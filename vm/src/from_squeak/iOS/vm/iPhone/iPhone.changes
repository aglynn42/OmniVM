'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 14 August 2011 at 7:19:23 pm'!

!AbstractHierarchicalList methodsFor: 'as yet unclassified' stamp: 'RAA 6/21/1999 15:22'!
genericMenu: aMenu

	aMenu add: 'no menu yet' target: self selector: #yourself.
	^aMenu! !

!AbstractHierarchicalList methodsFor: 'as yet unclassified' stamp: 'RAA 4/7/1999 16:44'!
getCurrentSelection

	^currentSelection! !

!AbstractHierarchicalList methodsFor: 'as yet unclassified' stamp: 'RAA 4/7/1999 16:46'!
noteNewSelection: x

	currentSelection _ x.
	self changed: #getCurrentSelection.
	currentSelection ifNil: [^self].
	currentSelection sendSettingMessageTo: self.
! !

!AbstractHierarchicalList methodsFor: 'as yet unclassified' stamp: 'RAA 4/7/1999 16:53'!
perform: selector orSendTo: otherTarget
	"Selector was just chosen from a menu by a user.  If can respond, then
perform it on myself. If not, send it to otherTarget, presumably the
editPane from which the menu was invoked."

	(self respondsTo: selector)
		ifTrue: [^ self perform: selector]
		ifFalse: [^ otherTarget perform: selector]! !

!AbstractHierarchicalList methodsFor: 'as yet unclassified' stamp: 'RAA 4/7/1999 16:47'!
update: aSymbol

	aSymbol == #hierarchicalList ifTrue: [
		^self changed: #getList
	].
	super update: aSymbol! !

!AbstractHierarchicalList methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:44'!
currentSelection
	"Answer the value of currentSelection"

	currentSelection isNil ifTrue:[self currentSelection: nil].
	^ currentSelection! !

!AbstractHierarchicalList methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:44'!
currentSelection: anObject
	"Set the value of currentSelection"

	currentSelection _ anObject! !

!AbstractHierarchicalList methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:44'!
myBrowser
	"Answer the value of myBrowser"

	myBrowser isNil ifTrue:[self myBrowser: nil].
	^ myBrowser! !

!AbstractHierarchicalList methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:44'!
myBrowser: anObject
	"Set the value of myBrowser"

	myBrowser _ anObject! !

!AbstractHierarchicalList commentStamp: '<historical>' prior: 0!
Contributed by Bob Arning as part of the ObjectExplorer package.
!
!AnimatedGIFReadWriter methodsFor: 'accessing' stamp: 'bf 2/25/2005 11:11'!
allImages
	| body colorTable |
	stream class == ReadWriteStream ifFalse: [
		stream binary.
		self on: (ReadWriteStream with: (stream contentsOfEntireFile))].
	localColorTable _ nil.
	forms _ OrderedCollection new.
	delays _ OrderedCollection new.
	comments _ OrderedCollection new.
	self readHeader.
	[(body _ self readBody) == nil]
		whileFalse: [colorTable _ localColorTable
						ifNil: [colorPalette].
			transparentIndex
				ifNotNil: [transparentIndex + 1 > colorTable size
						ifTrue: [colorTable _ colorTable forceTo: transparentIndex + 1 paddingWith: Color white].
					colorTable at: transparentIndex + 1 put: Color transparent].
			body colors: colorTable.
			forms add: body.
			delays add: delay].
	^ forms! !

!AnimatedGIFReadWriter methodsFor: 'accessing' stamp: 'mir 11/19/2003 14:16'!
delays
	^ delays! !

!AnimatedGIFReadWriter methodsFor: 'accessing' stamp: 'mir 11/19/2003 14:16'!
forms
	^ forms! !

!AnimatedGIFReadWriter methodsFor: 'private' stamp: 'mir 11/19/2003 12:25'!
comment: aString
	comments add: aString! !

!AnimatedGIFReadWriter methodsFor: 'private-decoding' stamp: 'mir 11/19/2003 12:21'!
readBitData
	| form |
	form := super readBitData.
	form offset: offset.
	^form! !

!AnimatedGIFReadWriter class methodsFor: 'image reading/writing' stamp: 'mir 11/18/2003 17:00'!
formsFromFileNamed: fileName 
	| stream |
	stream _ FileStream readOnlyFileNamed: fileName.
	^ self formsFromStream: stream! !

!AnimatedGIFReadWriter class methodsFor: 'image reading/writing' stamp: 'mir 11/18/2003 17:00'!
formsFromStream: stream 
	| reader |
	reader _ self new on: stream reset.
	Cursor read
		showWhile: [reader allImages.
			reader close].
	^reader! !

!AnimatedGIFReadWriter class methodsFor: 'image reading/writing' stamp: 'nk 6/12/2004 13:12'!
typicalFileExtensions
	"Answer a collection of file extensions (lowercase) which files that I can read might commonly have"
	^#('gif')! !

!AnimatedGIFReadWriter class methodsFor: 'image reading/writing' stamp: 'asm 12/11/2003 21:29'!
wantsToHandleGIFs
	^true! !

!ArchiveReader methodsFor: 'reading'!
close
	stream close! !

!ArchiveReader methodsFor: 'reading'!
next
	| anInteger |
	startPosition _ position.
	anInteger _ self read: Integer.
	^anInteger = 0
		ifTrue: [objectMap at: (self read: Integer)]
		ifFalse:
			[(classMap at: anInteger)
				dearchive: (classVersions at: anInteger)
				from: self]! !

!ArchiveReader methodsFor: 'reading'!
read: aClass
	"Ask aClass to read one of its objects from stream. aClass is typically Integer, Float, Symbol, etc.  Assume the object was put on the stream using ArchiveWriter>store:"

	| anObject |
	anObject _ aClass readFrom: stream.
	stream skipSeparators.
	position _ position + 1.
	^anObject! !

!ArchiveReader methodsFor: 'testing'!
isCopier
	"For compatibility with CopyReader (in case an object cares what type of Reader its using)."

	^false! !

!ArchiveReader methodsFor: 'private' stamp: 'ssa 10/25/2008 21:29'!
dearchive: version from: aStream
	"This is used before a class is read in for the first time... version is ignored here.  This method has this name only to avoid another case statement (see #next).  A better name for this method would be #dearchiveClassFrom:"

	| aClass anInteger |
	classMap add: (aClass _ Smalltalk at: (aStream read: Symbol)).
	classVersions add: (anInteger _ aStream read: Integer).
	^aClass dearchive: anInteger from: aStream! !

!ArchiveReader methodsFor: 'private'!
setStream: aStream
	stream _ aStream.
	objectMap _ IdentityDictionary new: 400.
	classMap _ OrderedCollection new: 30.
	classMap add: self.
	classVersions _ OrderedCollection with: 0.
	position _ 0! !

!ArchiveReader methodsFor: 'private'!
storeObject: anObject
	objectMap at: startPosition put: anObject! !

!ArchiveReader class methodsFor: 'instance creation' stamp: 'ssa 10/26/2008 08:08'!
dearchive: aString 
	"ArchiveReader dearchive: 'archive.test' "
	| aStream anObject |
	aStream _ self on: (self fastStreamOn: aString).
	anObject _ aStream next.
	aStream close.
	^anObject! !

!ArchiveReader class methodsFor: 'instance creation' stamp: 'ssa 10/25/2008 20:52'!
fastStreamOn: aFilename
	"Answer a stream which is appropriate for getting the data from aFilename as fast as possible.  The default version ignores lineEndConventions.  This is tightly coupled with ArchiveWriter>fastStreamOn:"

	^(FileStream oldFileNamed: aFilename) openReadOnly; yourself! !

!ArchiveReader class methodsFor: 'instance creation'!
on: aStream
	^self new setStream: aStream! !

!ArchiveWriter methodsFor: 'writing'!
canCopy: anObject
	"For archiving, I write out everything"

	^true! !

!ArchiveWriter methodsFor: 'writing'!
close
	stream close! !

!ArchiveWriter methodsFor: 'writing'!
nextPut: anObject
	| anInteger |
	anInteger _ objectMap
		at: anObject
		ifAbsent: [^anObject archiveOn: self].
	self
		store: 0;
		store: anInteger! !

!ArchiveWriter methodsFor: 'writing'!
store: anObject
	"Put anObject on the Stream, converting it to an ascii String.  anObject will typically be a Symbol, Number, etc.  This takes advantage of the storeOn:/readFrom: facility already in Smalltalk which works well for Basic Classes."
	"kwa -- 12 October 1989, replaced #space with: nextPut: Space (a TextConstant) for efficiency."

	stream store: anObject; nextPut: Space.
	position _ position + 1! !

!ArchiveWriter methodsFor: 'private' stamp: 'ssa 10/26/2008 20:44'!
setStream: aWriteStream
	stream _ aWriteStream.
	classMap _ IdentityDictionary new: 30.
	classMap at: self put: 1.
	objectMap _ IdentityDictionary new: 400.
	position _ 0! !

!ArchiveWriter methodsFor: 'private'!
storeClass: aClass
	self store: 
		(classMap at: aClass ifAbsent: 
			[self store: 1; store: aClass name; store: aClass archiveVersion.
			^classMap at: aClass put: classMap size + 1])! !

!ArchiveWriter methodsFor: 'private'!
storeObject: anObject
	objectMap at: anObject put: "stream" position! !

!ArchiveWriter methodsFor: 'testing'!
isCopier
	"For compatibility with CopyWriter (in case an object cares what type of Writer its using)."

	^false! !

!ArchiveWriter class methodsFor: 'instance creation' stamp: 'ssa 10/25/2008 21:17'!
archive: anObject to: aString 
	"ArchiveWriter archive: Array new to: 'archive.test'"
	"ArchiveWriter archive: 1 to: 'archive.test'"
	"ArchiveWriter archive: #(1 2 3) to: 'archive.test'"
	"ArchiveWriter archive: (Array with: #aSymbol with: 'aSymbol') to: 'archive.test'"

	| stream |
	 stream _ self fastStreamOn:  aString.
	(self on: stream)
		nextPut: anObject;
		close.! !

!ArchiveWriter class methodsFor: 'instance creation' stamp: 'ssa 10/25/2008 20:34'!
fastStreamOn: aFilename
	"Answer a stream which is appropriate for getting the data to aFilename as fast as possible.  The default version ignores lineEndConventions.  This is tightly coupled with ArchiveReader>fastStreamOn:"

	^FileStream newFileNamed: aFilename! !

!ArchiveWriter class methodsFor: 'instance creation'!
on: aWriteStream
	^self new setStream: aWriteStream! !

!Array methodsFor: 'converting' stamp: 'ssa 10/26/2008 15:00'!
asRunArray
	"Answer a RunArray of me"

	^RunArray newFrom: self! !

!Array methodsFor: 'testing' stamp: 'ssa 5/12/2010 19:26'!
isArray
	"Return true if the receiver is an Array"
	^true! !

!ArrayWithNilDetector methodsFor: 'accessing' stamp: 'ssa 11/24/2009 20:01'!
at: j put: obj

	obj ifNil:[self halt:'trying to add nil'].
	^super at: j put: obj! !

!ArrayWithNilDetector methodsFor: 'accessing' stamp: 'ssa 11/24/2009 20:39'!
species

	(self includes: nil) ifTrue:[self halt:'I found a nil!!!!'].
	^super species! !

!ArrayWithNilDetector class methodsFor: 'instance creation' stamp: 'ssa 11/24/2009 20:37'!
new: someSize

	someSize > 0 ifTrue:[self halt:'trying to create a an array with nil elements'].
	^super new: someSize! !

!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:25'!
mergeSortFrom: startIndex to: stopIndex by: aBlock
	"Sort the given range of indices using the mergesort algorithm.
	Mergesort is a worst-case O(N log N) sorting algorithm that usually
	does only half as many comparisons as heapsort or quicksort."

	"Details: recursively split the range to be sorted into two halves,
	mergesort each half, then merge the two halves together. An extra 
	copy of the data is used as temporary storage and successive merge 
	phases copy data back and forth between the receiver and this copy.
	The recursion is set up so that the final merge is performed into the
	receiver, resulting in the receiver being completely sorted."

	self size <= 1 ifTrue: [^ self].  "nothing to do"
	startIndex = stopIndex ifTrue: [^ self].
	self assert: [startIndex >= 1 and: [startIndex < stopIndex]]. "bad start index"
	self assert: [stopIndex <= self size]. "bad stop index"
	self
		mergeSortFrom: startIndex
		to: stopIndex 
		src: self clone 
		dst: self 
		by: aBlock! !

!ArrayedCollection methodsFor: '*Sly' stamp: 'dmu 9/17/2010 11:04'!
parallelCollect: aBlock
	"#(1 2 3 4 5) parallelCollect:[:e| e * 2]"
	| results task  barrier interlock result |
	"true ifTrue: [^ self collect: aBlock.]." "for debugging"
	self ifEmpty: [^ self].
	(Sly3 serializeForDebugging or: [self size = 1]) ifTrue: [^ self collect: aBlock].
	results _ self species new: self size.

	barrier _ RVMBarrier new signalsNeededToPass: self size.
	interlock _ Semaphore forMutualExclusion.
	1 to: self size do: [:i|
		task _ [
			result _ [aBlock copy fixTemps value:  (self at: i)] ifCurtailed: [barrier signal].
			interlock critical: [results at: i put: result].
			barrier signal
		]  asSlyMemberProcess.
		task resume
	].
	barrier wait.
	^results! !

!Association methodsFor: 'outlining' stamp: 'ssa 9/10/2009 16:01'!
outlineString

	^self key asString,'  ',self value printString! !

!BGBinaryTrees methodsFor: 'benchmarking' stamp: 'StefanMarr 5/15/2011 12:25'!
binarytrees: n to: output
   | minDepth maxDepth stretchDepth check longLivedTree iterations |
   minDepth := 4.
   maxDepth := minDepth + 2 max: n.
   stretchDepth := maxDepth + 1.

   check := (BGTreeNode bottomUpTree: 0 depth: stretchDepth) itemCheck.
   output
      nextPutAll: 'stretch tree of depth '; print: stretchDepth; tab;
      nextPutAll: ' check: '; print: check; cr.

   longLivedTree := BGTreeNode bottomUpTree: 0 depth: maxDepth.
   minDepth to: maxDepth by: 2 do: [:depth|
      iterations := 1 bitShift: maxDepth - depth + minDepth.

      check := 0.
      1 to: iterations do: [:i|
         check := check + (BGTreeNode bottomUpTree: i depth: depth) itemCheck.
         check := check + (BGTreeNode bottomUpTree: -1*i depth: depth) itemCheck
         ].
      output
         print:  (2*iterations); tab;
         nextPutAll: ' trees of depth '; print: depth; tab;
         nextPutAll: ' check: '; print: check; cr
      ].

	check := longLivedTree itemCheck.

   output
      nextPutAll: 'long lived tree of depth '; print: maxDepth; tab;
      nextPutAll: ' check: '; print: check; cr.
	
	^ check.! !

!BGBinaryTrees commentStamp: 'StefanMarr 1/16/2011 17:29' prior: 0!
This is an adaptation of a benchmark for testing GC. A whole tree is allocated before any nodes are GC'd.
The binary-trees benchmark is a simplistic adaptation of Hans Boehm's GCBench, which in turn was adapted from a benchmark by John Ellis and Pete Kovac.!
!BGBinaryTrees class methodsFor: 'defaults' stamp: 'StefanMarr 5/15/2011 23:25'!
defaultProblemSize
	^ 9! !

!BGBody methodsFor: 'nbody'!
addMomentumTo: anArray
   anArray at: 1 put: (anArray at: 1) + (vx * mass).
   anArray at: 2 put: (anArray at: 2) + (vy * mass).
   anArray at: 3 put: (anArray at: 3) + (vz * mass).
   ^anArray! !

!BGBody methodsFor: 'nbody'!
and: aBody velocityAfter: dt        
   | dx dy dz distance mag |
   dx := x - aBody x.
   dy := y - aBody y.
   dz := z - aBody z.
   
   distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.
   mag := dt / (distance * distance * distance).

   self decreaseVelocity: dx y: dy z: dz m: aBody mass * mag.   
   aBody increaseVelocity: dx y: dy z: dz m: mass * mag! !

!BGBody methodsFor: 'nbody'!
decreaseVelocity: dx y: dy z: dz m: m
   vx := vx - (dx * m).
   vy := vy - (dy * m).
   vz := vz - (dz * m)! !

!BGBody methodsFor: 'nbody'!
increaseVelocity: dx y: dy z: dz m: m
   vx := vx + (dx * m).
   vy := vy + (dy * m).
   vz := vz + (dz * m)! !

!BGBody methodsFor: 'nbody'!
kineticEnergy
   ^0.5d0 * mass * ((vx * vx) + (vy * vy) + (vz * vz))! !

!BGBody methodsFor: 'nbody'!
offsetMomentum: anArray 
   | m |
   m := self class solarMass.
   vx := (anArray at: 1) negated / m.
   vy := (anArray at: 2) negated / m.
   vz := (anArray at: 3) negated / m! !

!BGBody methodsFor: 'nbody'!
positionAfter: dt
   x := x + (dt * vx).
   y := y + (dt * vy).
   z := z + (dt * vz)! !

!BGBody methodsFor: 'nbody'!
potentialEnergy: aBody
   | dx dy dz distance |
   dx := x - aBody x.
   dy := y - aBody y.
   dz := z - aBody z.

   distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.
   ^mass * aBody mass / distance! !

!BGBody methodsFor: 'accessing'!
mass
   ^mass! !

!BGBody methodsFor: 'accessing'!
x
   ^x! !

!BGBody methodsFor: 'accessing'!
x: d1 y: d2 z: d3 vx: d4 vy: d5 vz: d6 mass: d7
   x := d1.
   y := d2. 
   z := d3. 
   vx := d4.
   vy := d5.
   vz := d6.
   mass := d7! !

!BGBody methodsFor: 'accessing'!
y
   ^y! !

!BGBody methodsFor: 'accessing'!
z
   ^z! !

!BGBody class methodsFor: 'constants'!
daysPerYear
   ^365.24d0! !

!BGBody class methodsFor: 'constants'!
jupiter
   ^self new
      x: 4.84143144246472090d0
      y: -1.16032004402742839d0
      z: -1.03622044471123109d-1
      vx: 1.66007664274403694d-3 * self daysPerYear
      vy: 7.69901118419740425d-3 * self daysPerYear
      vz: -6.90460016972063023d-5 * self daysPerYear
      mass: 9.54791938424326609d-4 * self solarMass! !

!BGBody class methodsFor: 'constants'!
neptune
   ^self new
      x: 1.53796971148509165d1
      y: -2.59193146099879641d1
      z: 1.79258772950371181d-1
      vx: 2.68067772490389322d-3 * self daysPerYear
      vy: 1.62824170038242295d-3 * self daysPerYear
      vz: -9.51592254519715870d-5 * self daysPerYear
      mass: 5.15138902046611451d-5 * self solarMass! !

!BGBody class methodsFor: 'constants'!
pi
   ^3.141592653589793d0! !

!BGBody class methodsFor: 'constants'!
saturn
   ^self new
      x: 8.34336671824457987d0
      y: 4.12479856412430479d0
      z: -4.03523417114321381d-1
      vx: -2.76742510726862411d-3 * self daysPerYear
      vy: 4.99852801234917238d-3 * self daysPerYear
      vz: 2.30417297573763929d-5 * self daysPerYear
      mass: 2.85885980666130812d-4 * self solarMass! !

!BGBody class methodsFor: 'constants'!
solarMass
   ^4.0d0 * self pi * self pi! !

!BGBody class methodsFor: 'constants'!
sun
   ^self new
      x: 0.0d0
      y: 0.0d0
      z: 0.0d0
      vx: 0.0d0
      vy: 0.0d0
      vz: 0.0d0
      mass: self solarMass! !

!BGBody class methodsFor: 'constants'!
uranus
   ^self new
      x: 1.28943695621391310d1
      y: -1.51111514016986312d1
      z: -2.23307578892655734d-1
      vx: 2.96460137564761618d-3 * self daysPerYear
      vy: 2.37847173959480950d-3 * self daysPerYear
      vz: -2.96589568540237556d-5 * self daysPerYear
      mass: 4.36624404335156298d-5 * self solarMass! !

!BGChameleon methodsFor: 'accessing'!
color
    ^color! !

!BGChameleon methodsFor: 'accessing'!
meetings
    ^meetings! !

!BGChameleon methodsFor: 'accessing'!
wait
    semaphore wait! !

!BGChameleon methodsFor: 'changing colours'!
color: c
    color := c! !

!BGChameleon methodsFor: 'changing colours'!
fade
    color := #faded.
    waitingForPair signal.
    semaphore signal! !

!BGChameleon methodsFor: 'changing colours'!
met: other
    | newColor |
    meetings := meetings + 1.
    color == #red ifTrue: [
    newColor := other == #yellow ifTrue: [ #blue ] ifFalse: [ #yellow ] ].
    color == #yellow ifTrue: [
    newColor := other == #red ifTrue: [ #blue ] ifFalse: [ #red ] ].
    color == #blue ifTrue: [
    newColor := other == #red ifTrue: [ #yellow ] ifFalse: [ #red ] ].
    color := newColor.
    waitingForPair signal! !

!BGChameleon methodsFor: 'running'!
fork: meetingPlace
    ^[ self run: meetingPlace ] fork! !

!BGChameleon methodsFor: 'running'!
run: meetingPlace
    [ color == #faded ] whileFalse: [
        meetingPlace reachedBy: self.
        waitingForPair wait ]! !

!BGChameleon methodsFor: 'initialize-release'!
initialize
    meetings := 0.
    waitingForPair := Semaphore new.
    semaphore := Semaphore new! !

!BGChameleon class methodsFor: 'instance creation'!
color: c
    ^self new
        initialize;
        color: c! !

!BGChameleons class methodsFor: 'benchmark scripts' stamp: 'StefanMarr 1/16/2011 12:12'!
chameneos
	" reports back the number of meetings "
	| out |
	^ self chameneos: 1000000! !

!BGChameleons class methodsFor: 'benchmarking' stamp: 'StefanMarr 5/15/2011 12:17'!
chameneos: n
    | c1 c2 c3 c4 mp |
    c1 := BGChameleon color: #blue.
    c2 := BGChameleon color: #red.
    c3 := BGChameleon color: #yellow.
    c4 := BGChameleon color: #blue.
    mp := BGMeetingPlace forMeetings: n.
    c1 fork: mp.
    c2 fork: mp.
    c3 fork: mp.
    c4 fork: mp.
    c1 wait.
    c2 wait.
    c3 wait.
    c4 wait.
    ^c1 meetings + c2 meetings + c3 meetings + c4 meetings! !

!BGChameleons class methodsFor: 'defaults' stamp: 'StefanMarr 5/15/2011 23:31'!
defaultProblemSize
	^ 10000! !

!BGChameneosColour methodsFor: 'accessing'!
color
   ^color! !

!BGChameneosColour methodsFor: 'accessing'!
color: aColor 
   color := aColor! !

!BGChameneosColour methodsFor: 'as yet unclassified'!
complementaryColourFor: aChameneosColour 
   "determine the complementary colour defined as..."

   self == aChameneosColour ifTrue: [^self].
   self isBlue 
      ifTrue: 
         [aChameneosColour isRed 
            ifTrue: [^self class yellow]
            ifFalse: [^self class red]].
   self isRed 
      ifTrue: 
         [aChameneosColour isBlue 
            ifTrue: [^self class yellow]
            ifFalse: [^self class blue]].
   aChameneosColour isBlue 
      ifTrue: [^self class red]
      ifFalse: [^self class blue]! !

!BGChameneosColour methodsFor: 'testing'!
hasSameColorAs: aChameneos 
   ^self color == aChameneos color! !

!BGChameneosColour methodsFor: 'testing'!
isBlue
   ^self == self class blue! !

!BGChameneosColour methodsFor: 'testing'!
isRed
   ^self == self class red! !

!BGChameneosColour methodsFor: 'testing'!
isYellow
   ^self == self class yellow! !

!BGChameneosColour methodsFor: 'printing'!
printOn: aStream 
   aStream nextPutAll: self color! !

!BGChameneosColour class methodsFor: 'accessing'!
blue
   ^Blue! !

!BGChameneosColour class methodsFor: 'accessing'!
blue: anObject
   Blue := anObject! !

!BGChameneosColour class methodsFor: 'accessing'!
red
   ^Red! !

!BGChameneosColour class methodsFor: 'accessing'!
red: anObject
   Red := anObject! !

!BGChameneosColour class methodsFor: 'accessing'!
yellow
   ^Yellow! !

!BGChameneosColour class methodsFor: 'accessing'!
yellow: anObject
   Yellow := anObject! !

!BGChameneosColour class methodsFor: 'initialize-release'!
createBlue
   "comment stating purpose of message"

   ^super new color: #blue! !

!BGChameneosColour class methodsFor: 'initialize-release'!
createRed
   "comment stating purpose of message"

   ^super new color: #red! !

!BGChameneosColour class methodsFor: 'initialize-release'!
createYellow
   "comment stating purpose of message"

   ^super new color: #yellow! !

!BGChameneosColour class methodsFor: 'initialize-release'!
initialize
   "self initialize"

   Red := self createRed.
   Blue := self createBlue.
   Yellow := self createYellow! !

!BGChameneosColour class methodsFor: 'printing' stamp: 'StefanMarr 1/16/2011 14:13'!
generateReportOfColoursOn: readOut 
   | colours |
   colours := Array 
            with: Blue
            with: Red
            with: Yellow.
   colours do: 
         [:aColour | 
         colours do: 
               [:anotherColour | 
               aColour printOn: readOut.
               readOut nextPutAll: ' + '.
               anotherColour printOn: readOut.
               readOut nextPutAll: ' -> '.
               (aColour complementaryColourFor: anotherColour) printOn: readOut.
               readOut cr]].
   ^readOut! !

!BGChameneosRedux class methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/15/2011 23:34'!
defaultProblemSize
	^ 6000! !

!BGChameneosRedux class methodsFor: 'benchmarking-scripts' stamp: 'StefanMarr 5/15/2011 12:27'!
chameneosredux2
	"ChameneosRedux chameneosredux2" 
	| report |
	report := TextStream with: String new.
	BGMall runBenchMark: 600 on: report.
	^report contents! !

!BGCreature methodsFor: 'accessing'!
colour
   ^colour! !

!BGCreature methodsFor: 'accessing'!
colour: anObject 
   colour := anObject! !

!BGCreature methodsFor: 'accessing'!
creaturesMet
   ^creaturesMet! !

!BGCreature methodsFor: 'accessing'!
creaturesMet: anObject 
   creaturesMet := anObject! !

!BGCreature methodsFor: 'accessing'!
name
   ^creatureName! !

!BGCreature methodsFor: 'accessing'!
name: anObject 
   creatureName := anObject! !

!BGCreature methodsFor: 'accessing'!
selfMet
   ^selfMet! !

!BGCreature methodsFor: 'accessing'!
selfMet: anObject 
   ^selfMet := anObject! !

!BGCreature methodsFor: 'initialize-release'!
initialize
   selfMet := 0.
   creaturesMet := 0! !

!BGCreature methodsFor: 'controlling'!
visitMall: mall 
   
   [| partner |
   partner := mall visitWith: self.
   partner ifNotNil: 
         [colour := colour complementaryColourFor: partner colour.
         self == partner ifTrue: [selfMet := selfMet + 1].
         creaturesMet := creaturesMet + 1].
   partner isNil] 
         whileFalse! !

!BGCreature class methodsFor: 'initialize-release' stamp: 'StefanMarr 5/15/2011 12:28'!
withName: aName colour: aColour 
   ^(BGCreature new initialize)
      name: aName;
      colour: aColour! !

!BGFannkuchRedux class methodsFor: 'defaults' stamp: 'StefanMarr 5/15/2011 23:35'!
defaultProblemSize
	^ 4! !

!BGFannkuchRedux class methodsFor: 'benchmarking' stamp: 'StefanMarr 5/15/2011 12:19'!
fannkuchRedux: n to: output
   ^(BGPermGeneratorRedux new: n) maxPfannkuchenTo: output! !

!BGFannkuchRedux class methodsFor: 'benchmark scripts' stamp: 'StefanMarr 5/16/2011 14:45'!
fannkuchredux
   | n f |
   n := 4.
   f := self fannkuchRedux: n to: (TextStream with: String new).
   ScriptConsole println: 'Pfannkuchen(', n printString, ') = ', f asString.
   ^''! !

!BGFasta class methodsFor: 'benchmark scripts' stamp: 'StefanMarr 5/15/2011 23:20'!
defaultProblemSize
	^ 1000! !

!BGFasta class methodsFor: 'benchmark scripts' stamp: 'StefanMarr 1/16/2011 18:56'!
fasta
	" self fasta"
  | out |
  out := TextStream with: String new.
  self fasta: 1000 to: out.
  ^out contents! !

!BGFasta class methodsFor: 'benchmarking' stamp: 'StefanMarr 5/15/2011 12:24'!
fasta: n to: out
   | r lineLength |
   lineLength := 60.
   self
      writeFasta: 'ONE Homo sapiens alu'
      from:
         ( BGRepeatStream
            to: n*2
            on:'GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG',
               'GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA',
               'CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT',
               'ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA',
               'GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG',
               'AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC',
               'AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA' )
      to: out
      lineLength: lineLength.

   r := BGRandomNumber to: 1. "Shared random sequence"

   self
      writeFasta: 'TWO IUB ambiguity codes'
      from:
         (( BGRandomStream
            to: n*3
            on: #(   #($a 0.27d0)
                  #($c 0.12d0)
                  #($g 0.12d0)
                  #($t 0.27d0)

                  #($B 0.02d0)
                  #($D 0.02d0)
                  #($H 0.02d0)
                  #($K 0.02d0)
                  #($M 0.02d0)
                  #($N 0.02d0)
                  #($R 0.02d0)
                  #($S 0.02d0)
                  #($V 0.02d0)
                  #($W 0.02d0)
                  #($Y 0.02d0)))
         random: r;
         yourself)
      to: out
      lineLength: lineLength.

   self
      writeFasta: 'THREE Homo sapiens frequency'
      from:
         (( BGRandomStream
            to: n*5
            on: #(   #($a 0.3029549426680d0)
                  #($c 0.1979883004921d0)
                  #($g 0.1975473066391d0)
                  #($t 0.3015094502008d0)))
            random: r;
            yourself)
      to: out
      lineLength: lineLength.

   out flush. ! !

!BGFasta class methodsFor: 'benchmarking' stamp: 'StefanMarr 6/14/2010 17:10'!
writeFasta: aString from: inStream to: outStream lineLength: lineLength
   | i |
   outStream nextPut: $>; nextPutAll: aString; cr.
   i := 0.
   [inStream atEnd] whileFalse:
      [i == lineLength ifTrue: [outStream cr. i := 0].
      outStream nextPut: inStream next.
      i := i + 1].
   outStream cr! !

!BGMall methodsFor: 'controlling'!
close
   open := false! !

!BGMall methodsFor: 'controlling'!
visitWith: aChameneos 
   | pair partner |
   pair := self obtainPair.
   pair me: aChameneos.
   queue nextPut: pair.
   pair wait.
   partner := pair partner.
   self releasePair: pair.
   ^partner! !

!BGMall methodsFor: 'initialize-release' stamp: 'StefanMarr 5/15/2011 12:27'!
initialize
   guard := Semaphore forMutualExclusion.
   queue := SharedQueue new.
   cache := OrderedCollection new.
   1 to: 10 do: [:x | cache add: BGPair new]! !

!BGMall methodsFor: 'initialize-release'!
run
   open := true.
   process ifNil: 
         [process := [self processVisitors] newProcess.
         process priority: Processor userBackgroundPriority -1 ].
   process resume! !

!BGMall methodsFor: 'accessing'!
maxRendezvous: max 
   maxRendezvous := max! !

!BGMall methodsFor: 'private'!
obtainPair
   ^cache removeFirst! !

!BGMall methodsFor: 'private'!
processVisitors
   [open] whileTrue: 
         [1 to: maxRendezvous
            do: 
               [:x | 
               | first second |
               first := queue next.
               second := queue next.
               self setPartnersOn: first and: second.
               first signal.
               second signal].
         [queue isEmpty] whileFalse: [queue next signal]].
   process terminate.
   process := nil! !

!BGMall methodsFor: 'private'!
releasePair: pair 
   pair release.
   cache addFirst: pair! !

!BGMall methodsFor: 'private'!
setPartnersOn: first and: second
   first partner: second me.
   second partner: first me.
! !

!BGMall methodsFor: 'private'!
shutdown
   [queue isEmpty] whileFalse: [queue next signal].
   process terminate.
   process := nil! !

!BGMall class methodsFor: 'initialize-release'!
createAllowing: maxRendezvous 
   "Private"

   ^self basicNew initialize maxRendezvous: maxRendezvous! !

!BGMall class methodsFor: 'initialize-release' stamp: 'StefanMarr 5/15/2011 12:29'!
createCreaturesWith: aCollectionOfColours 
   "Private"

   | aName |
   aName := 0.
   ^aCollectionOfColours collect: 
         [:aColour | 
         aName := aName + 1.
         BGCreature withName: aName colour: aColour]! !

!BGMall class methodsFor: 'initialize-release'!
initialize
   "self initialize"

   Units := #('zero' 'one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine')! !

!BGMall class methodsFor: 'initialize-release'!
new
   ^self shouldNotImplement! !

!BGMall class methodsFor: 'initialize-release'!
openMallWith: aCollectionOfColours forNumberOfMeets: aNumber 
   | mall creatures guard |
   mall := self createAllowing: aNumber.
   mall run.
   creatures := self createCreaturesWith: aCollectionOfColours.
   guard := Semaphore new.
   self 
      openMall: mall
      forCreatures: creatures
      usingGuard: guard.
   self 
      waitForClosingOfMall: mall
      withCreatures: creatures
      usingGuard: guard.
   ^creatures! !

!BGMall class methodsFor: 'printing' stamp: 'StefanMarr 1/16/2011 14:42'!
generateReportFor: creatures printOn: stream 
   | sum |
   sum := creatures inject: 0 into: [:accum :each | accum + each creaturesMet].
   creatures do: 
         [:aCreature | 
         aCreature creaturesMet printOn: stream.
         stream
            space;
            nextPutAll: (self units at: aCreature selfMet + 1);
            cr].
   stream space.
   sum printString 
      do: [:el | stream nextPutAll: (self units at: el digitValue + 1)]
      separatedBy: [stream space].
	lastSum := sum.
   ^stream! !

!BGMall class methodsFor: 'printing'!
generateReportForColours: colours printOn: stream 
   stream space.
   colours do: [:colour | colour printOn: stream] separatedBy: [stream space].
   ^stream! !

!BGMall class methodsFor: 'private'!
openMall: aMall forCreatures: creatures usingGuard: sema 
   | processes |
   processes := creatures 
            collect: [:aCreature | 
               [aCreature visitMall: aMall.
               sema signal] newProcess].
   processes do: 
         [:proc | 
         proc priority: Processor userBackgroundPriority.
         proc resume]! !

!BGMall class methodsFor: 'private'!
waitForClosingOfMall: aMall withCreatures: creatures usingGuard: guard 
   creatures size timesRepeat: [guard wait].
   aMall close! !

!BGMall class methodsFor: 'public' stamp: 'StefanMarr 5/15/2011 12:28'!
runBenchMark: number on: anOutputStream 
   "self runBenchMark: 60000 on: Transcript."

   | firstTestColours secondTestColours blue red yellow creatures |
   blue := BGChameneosColour blue.
   red := BGChameneosColour red.
   yellow := BGChameneosColour yellow.
   firstTestColours := Array 
            with: blue
            with: red
            with: yellow.
   secondTestColours := (OrderedCollection new)
            add: blue;
            add: red;
            add: yellow;
            add: red;
            add: yellow;
            add: blue;
            add: red;
            add: yellow;
            add: red;
            add: blue;
            yourself.
   (BGChameneosColour generateReportOfColoursOn: anOutputStream) cr.
   (self generateReportForColours: firstTestColours printOn: anOutputStream) 
      cr.
   creatures := BGMall openMallWith: firstTestColours forNumberOfMeets: number.
   (self generateReportFor: creatures printOn: anOutputStream)
      cr;
      cr.
   (self generateReportForColours: secondTestColours printOn: anOutputStream) 
      cr.
   creatures := BGMall openMallWith: secondTestColours forNumberOfMeets: number.
   (self generateReportFor: creatures printOn: anOutputStream)
      cr;
      cr.
	^ lastSum! !

!BGMall class methodsFor: 'accessing'!
units
   ^Units! !

!BGMeetingPlace methodsFor: 'initialize-release'!
initialize
    mutex := Semaphore forMutualExclusion.
    total := 0! !

!BGMeetingPlace methodsFor: 'running'!
max: maxMeetings
    max := maxMeetings! !

!BGMeetingPlace methodsFor: 'running'!
organizeMeetingWith: second
    total >= max
        ifTrue: [
            first fade.
            second fade ]
        ifFalse: [
            first met: second color.
            second met: first color ].
    total := total + 1! !

!BGMeetingPlace methodsFor: 'running'!
reachedBy: chameleon
    mutex critical: [
        first isNil
            ifTrue: [ first := chameleon ]
            ifFalse: [ self organizeMeetingWith: chameleon. first := nil ] ]! !

!BGMeetingPlace class methodsFor: 'instance creation'!
forMeetings: maxMeetings
    ^super new
        initialize;
        max: maxMeetings;
        yourself! !

!BGNBody class methodsFor: 'defaults' stamp: 'StefanMarr 5/15/2011 23:36'!
defaultProblemSize
	^ 1000! !

!BGNBody class methodsFor: 'benchmark scripts' stamp: 'sm 6/1/2011 14:09'!
nbody: times
	"self nbody: 1000"
   | bodies |
	self flag: 'Move the output that is currently in un-executed blocks into some reporter functionality'.

   bodies := BGNBodySystem new initialize.
   [ ScriptConsole print: bodies energy. ].
   times timesRepeat: [bodies after: 0.01d0].
   [ ScriptConsole print: bodies energy. ]. 
   ^ bodies energy! !

!BGNBodySystem methodsFor: 'nbody'!
after: dt
   1 to: bodies size do: [:i|
      i+1 to: bodies size do: [:j|                            
         (bodies at: i) and: (bodies at: j) velocityAfter: dt].
   ].   
   bodies do: [:each| each positionAfter: dt]! !

!BGNBodySystem methodsFor: 'nbody'!
energy
   | e |
   e := 0.0d0.
   1 to: bodies size do: [:i|       
      e := e + (bodies at: i) kineticEnergy.

      i+1 to: bodies size do: [:j| 
         e := e - ((bodies at: i) potentialEnergy: (bodies at: j))].
   ].
   ^e! !

!BGNBodySystem methodsFor: 'initialize-release' stamp: 'StefanMarr 5/15/2011 12:13'!
initialize
   bodies := OrderedCollection new
      add: BGBody sun; add: BGBody jupiter; add: BGBody saturn;
      add: BGBody uranus; add: BGBody neptune; yourself.

   bodies first offsetMomentum:
      (bodies inject: (Array with: 0.0d0 with: 0.0d0 with: 0.0d0)
         into: [:m :each | each addMomentumTo: m])! !

!BGPair methodsFor: 'initialize-release'!
initialize
   "Initialize a newly created instance. This method must answer the receiver."

   partner := nil.
   me := nil.
   sema := Semaphore new.
   ^self! !

!BGPair methodsFor: 'initialize-release'!
release
partner:=nil.! !

!BGPair methodsFor: 'initialize-release'!
signal
   sema signal! !

!BGPair methodsFor: 'initialize-release'!
wait
   sema wait! !

!BGPair methodsFor: 'accessing'!
me
   ^me! !

!BGPair methodsFor: 'accessing'!
me: anObject
   me := anObject! !

!BGPair methodsFor: 'accessing'!
partner
   ^partner! !

!BGPair methodsFor: 'accessing'!
partner: anObject
   partner := anObject! !

!BGPair class methodsFor: 'instance creation'!
new
   "Answer a newly created and initialized instance."
   ^super new initialize.! !

!BGPair class methodsFor: 'instance creation'!
with: me 
   "Answer a newly created and initialized instance."
self halt.
   ^super new initialize me: me! !

!BGPermGeneratorRedux methodsFor: 'accessing'!
atEnd
   ^atEnd! !

!BGPermGeneratorRedux methodsFor: 'accessing'!
next
   | result |
   result := perm copy.
   self makeNext.
   ^result! !

!BGPermGeneratorRedux methodsFor: 'initialize-release' stamp: 'StefanMarr 1/16/2011 22:01'!
initialize: size
   perm := (1 to: size) asArray.
   timesRotated := Array new: size withAll: 0.
   atEnd := false.! !

!BGPermGeneratorRedux methodsFor: 'initialize-release'!
makeNext
   | temp remainder |
   "* Generate the next permutation. *"
   2 to: perm size do: [ :r |
      "* Rotate the first r items to the left. *"
      temp := perm at: 1.
      1 to: r - 1 do: [ :i | perm at: i put: (perm at: i + 1) ].
      perm at: r put: temp.

      remainder := timesRotated at: r put: ((timesRotated at: r) + 1) \\ r.
      remainder = 0 ifFalse: [ ^self ].

      "* After r rotations, the first r items are in their original positions.
      Go on rotating the first r+1 items. *"
   ].

   "* We are past the final permutation. *"
   atEnd := true! !

!BGPermGeneratorRedux methodsFor: 'benchmarks' stamp: 'StefanMarr 6/15/2010 13:31'!
maxPfannkuchenTo: output
   | max permutation checksum permCount flipsCount |
   max := 0.
   permCount := 0.
   checksum := 0.
   [self atEnd] whileFalse:
      [permutation := self next.
      permCount := permCount + 1.
      (permCount = 1048576) ifTrue: [permCount := 0].
      flipsCount := self pfannkuchen: permutation.
      checksum := permCount odd ifTrue: [checksum+flipsCount] ifFalse: [checksum-flipsCount].
      max := max max: flipsCount].
   output print: checksum; cr.
   ^max! !

!BGPermGeneratorRedux methodsFor: 'benchmarks' stamp: 'StefanMarr 6/15/2010 13:30'!
pfannkuchen: anArray
   | first complement a b k |
   k := 0.
   [ (first := anArray at: 1) == 1 ] whileFalse: [
      k := k + 1.
      complement := first + 1.
      1 to: first // 2 do: [ :i |
         a := anArray at: i.
         b := anArray at: complement - i.
         anArray at: i put: b.
         anArray at: complement - i put: a.
      ]
   ].
   ^k! !

!BGPermGeneratorRedux class methodsFor: 'instance creation'!
new: size
   ^self new
      initialize: size;
      yourself! !

!BGRandomNumber methodsFor: 'accessing'!
next
   seed := (seed * Multiplier + Increment) \\ Modulus.
   ^(seed * scale) / FModulus! !

!BGRandomNumber methodsFor: 'private'!
to: anInteger
   seed := 42.
   scale := anInteger! !

!BGRandomNumber class methodsFor: 'class initialization'!
initialize
   FModulus := 139968.0d0.
   Increment := 29573.
   Modulus := 139968.
   Multiplier := 3877.! !

!BGRandomNumber class methodsFor: 'initialize-release'!
to: anInteger
   ^self basicNew to: anInteger! !

!BGRandomStream methodsFor: 'accessing'!
next
   | r |
   r := random next.
   repeatPtr := repeatPtr + 1.
   1 to: percentages size do: [:i|
      (r < (percentages at: i)) ifTrue: [^collection at: i]]! !

!BGRandomStream methodsFor: 'accessing'!
random: aRandomNumber
"* Share the random number generator so we can get the expected results. *"
   random := aRandomNumber! !

!BGRandomStream methodsFor: 'initialize-release' stamp: 'StefanMarr 5/15/2011 12:19'!
on: aCollection
   | size cp |
   repeatPtr := 0.
   random := BGRandomNumber to: 1.0d0.
   size := aCollection size.
   percentages := Array new: size.
   collection := Array new: size.
   cp := 0.0d0.
   1 to: size do: [:i|
      collection at: i put: (aCollection at: i) first.
      percentages at: i put: (cp := cp + (aCollection at: i) last).
   ]! !

!BGRepeatStream methodsFor: 'testing'!
atEnd
   ^repeatPtr >= repeatLimit! !

!BGRepeatStream methodsFor: 'accessing'!
next
   position >= readLimit ifTrue: [ self position: 0 ].
   repeatPtr := repeatPtr + 1.
   ^collection at: (position := position + 1)! !

!BGRepeatStream methodsFor: 'initialize-release'!
to: anInteger
   repeatPtr := 0.
   repeatLimit := anInteger! !

!BGRepeatStream class methodsFor: 'instance creation'!
to: anInteger on: aCollection
   ^(super on: aCollection) to: anInteger! !

!BGTests methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/15/2011 14:06'!
testBinaryTrees
	| bench output expected |
	bench := BGBinaryTrees new.
	output := (TextStream with: String new).

	self assert: -1 equals: (bench binarytrees: 10 to: output).
	
	expected := 'stretch tree of depth 11	 check: -1
2048	 trees of depth 4	 check: -2048
512	 trees of depth 6	 check: -512
128	 trees of depth 8	 check: -128
32	 trees of depth 10	 check: -32
long lived tree of depth 10	 check: -1
'.
	self assert: expected equals: output contents.! !

!BGTests methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/15/2011 14:08'!
testBinaryTreesResult
	| bench output |
	bench := BGBinaryTrees new.
				
	output := (TextStream with: String new).
	self assert: -1 equals: (bench binarytrees: 9 to: output).
	
	output := (TextStream with: String new).
	self assert: -1 equals: (bench binarytrees: 8 to: output).
	
	output := (TextStream with: String new).
	self assert: -1 equals: (bench binarytrees: 7 to: output).
	
	! !

!BGTests methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/15/2011 18:03'!
testChameleons
	self assert: (BGChameleons chameneos:     100) equals: 200. 
	self assert: (BGChameleons chameneos:   10000) equals: 20000.
	self assert: (BGChameleons chameneos: 1000000) equals: 2000000.! !

!BGTests methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/15/2011 18:03'!
testChameneosRedux
	| report result |
	
	report := TextStream with: String new.
	result := BGMall runBenchMark: 600 on: report.
	self assert: result equals: 1200.
	
	report := TextStream with: String new.
	result := BGMall runBenchMark: 555 on: report.
	self assert: result equals: (555 * 2).
	
	report := TextStream with: String new.
	result := BGMall runBenchMark: 121 on: report.
	self assert: result equals: (121 * 2).
	! !

!BGTests methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/15/2011 12:15'!
testFannkuchReduxResult
	 | f |
	f := BGFannkuchRedux fannkuchRedux: 7 to: (TextStream with: String new).
	self assert: f equals: 16! !

!BGTests methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/15/2011 18:07'!
testFasta
	| result |
	self flag: 'TODO: add proper verification'.
	self shouldnt: [result := BGFasta fasta] raise: Error.
	self assert: (result size > 0).
	self assert: (result isKindOf: String).
	! !

!BGTests methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/15/2011 18:04'!
testNBody
	self assert: (((BGNBody nbody: 1000) asString) beginsWith: '-0.169087605')! !

!BGTreeNode methodsFor: 'accessing'!
itemCheck
   ^left isNil 
      ifTrue: [item] ifFalse: [item + (left itemCheck - right itemCheck)]! !

!BGTreeNode methodsFor: 'initialize-release'!
left: leftChild right: rightChild item: anItem
   left := leftChild.
   right := rightChild.
   item := anItem! !

!BGTreeNode class methodsFor: 'instance creation'!
bottomUpTree: anItem depth: anInteger
   ^(anInteger > 0) 
      ifTrue: [
         self 
            left: (self bottomUpTree: 2*anItem - 1 depth: anInteger - 1) 
            right: (self bottomUpTree: 2*anItem depth: anInteger - 1)  
            item: anItem
         ]
      ifFalse: [self left: nil right: nil item: anItem]! !

!BGTreeNode class methodsFor: 'instance creation'!
left: leftChild right: rightChild item: anItem      
   ^(super new) left: leftChild right: rightChild item: anItem! !

!BMPReadWriter methodsFor: 'reading' stamp: 'ar 6/16/2002 15:36'!
nextImage
	| colors |
	stream binary.
	self readHeader.
	biBitCount = 24 ifTrue:[^self read24BmpFile].
	"read the color map"
	colors := self readColorMap.
	^self readIndexedBmpFile: colors! !

!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/25/2005 13:48'!
read24BmpFile
	"Read 24-bit pixel data from the given a BMP stream."
	| form formBits pixelLine bitsIndex bitBlt |
	form _ Form extent: biWidth@biHeight depth: 32.
	pixelLine := ByteArray new: (((24 * biWidth) + 31) // 32) * 4.
	bitsIndex := form height - 1 * biWidth + 1.
	formBits := form bits.
	1 to: biHeight do: [:i |
		pixelLine := stream nextInto: pixelLine.
		self read24BmpLine: pixelLine into: formBits startingAt: bitsIndex width: biWidth.
		bitsIndex := bitsIndex - biWidth.
	].
	bitBlt := BitBlt toForm: form.
	bitBlt combinationRule: 7 "bitOr:with:".
	bitBlt halftoneForm: (Bitmap with: 16rFF000000).
	bitBlt copyBits.
	^ form
! !

!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/25/2005 13:47'!
read24BmpLine: pixelLine into: formBits startingAt: formBitsIndex width: width
	| pixIndex rgb bitsIndex |
	pixIndex _ 0. "pre-increment"
	bitsIndex := formBitsIndex-1. "pre-increment"
	1 to: width do: [:j |
		rgb := 
			(pixelLine at: (pixIndex := pixIndex+1)) +
			((pixelLine at: (pixIndex := pixIndex+1)) bitShift: 8) +
			((pixelLine at: (pixIndex := pixIndex+1)) bitShift: 16).
		formBits at: (bitsIndex := bitsIndex+1) put: rgb.
	].
! !

!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/24/2005 20:57'!
readColorMap
	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."
	| colorCount colors maxLevel b g r ccStream |
	colorCount _ (bfOffBits - 54) // 4.
	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"
	biBitCount >= 16 ifTrue:[^nil].
	colorCount = 0 ifTrue: [ "this BMP file does not have a color map"
		"default monochrome color map"
		biBitCount = 1 ifTrue: [^ Array with: Color white with: Color black].
		"default gray-scale color map"
		maxLevel _ (2 raisedTo: biBitCount) - 1.
		^ (0 to: maxLevel) collect: [:level | Color gray: (level asFloat / maxLevel)]].
	ccStream := ReadStream on: (stream next: colorCount*4).
	colors _ Array new: colorCount.
	1 to: colorCount do: [:i |
		b _ ccStream next.
		g _ ccStream next.
		r _ ccStream next.
		ccStream next. "skip reserved"
		colors at: i put: (Color r: r g: g b: b range: 255)].
	^ colors
! !

!BMPReadWriter methodsFor: 'reading' stamp: 'ar 6/16/2002 15:20'!
readHeader
	| reserved |
	bfType _ stream nextLittleEndianNumber: 2.
	bfSize _ stream nextLittleEndianNumber: 4.
	reserved _ stream nextLittleEndianNumber: 4.
	bfOffBits _ stream nextLittleEndianNumber: 4.
	biSize _ stream nextLittleEndianNumber: 4.
	biWidth _ stream nextLittleEndianNumber: 4.
	biHeight _ stream nextLittleEndianNumber: 4.
	biPlanes _ stream nextLittleEndianNumber: 2.
	biBitCount _ stream nextLittleEndianNumber: 2.
	biCompression _ stream nextLittleEndianNumber: 4.
	biSizeImage _ stream nextLittleEndianNumber: 4.
	biXPelsPerMeter _ stream nextLittleEndianNumber: 4.
	biYPelsPerMeter _ stream nextLittleEndianNumber: 4.
	biClrUsed _ stream nextLittleEndianNumber: 4.
	biClrImportant _ stream nextLittleEndianNumber: 4.
! !

!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/25/2005 13:45'!
readIndexedBmpFile: colors
	"Read uncompressed pixel data of depth d from the given BMP stream, where d is 1, 4, 8, or 16"
	| form bytesPerRow pixelData pixelLine startIndex map bitBlt mask |
	colors 
		ifNil:[form _ Form extent: biWidth@biHeight depth: biBitCount]
		ifNotNil:[form _ ColorForm extent: biWidth@biHeight depth: biBitCount.
				form colors: colors].
	bytesPerRow _ (((biBitCount* biWidth) + 31) // 32) * 4.
	pixelData _ ByteArray new: bytesPerRow * biHeight.
	biHeight to: 1 by: -1 do: [:y |
		pixelLine _ stream next: bytesPerRow.
		startIndex _ ((y - 1) * bytesPerRow) + 1.
		pixelData 
			replaceFrom: startIndex 
			to: startIndex + bytesPerRow - 1 
			with: pixelLine 
			startingAt: 1].
	form bits copyFromByteArray: pixelData.
	biBitCount = 16 ifTrue:[
		map := ColorMap shifts: #(8 -8 0 0) masks: #(16rFF 16rFF00 0 0).
		mask := 16r80008000.
	].
	biBitCount = 32 ifTrue:[
		map := ColorMap shifts: #(24 8 -8 -24) masks: #(16rFF 16rFF00 16rFF0000 16rFF000000).
		mask := 16rFF000000.
	].
	map ifNotNil:[
		bitBlt := BitBlt toForm: form.
		bitBlt sourceForm: form.
		bitBlt colorMap: map.
		bitBlt combinationRule: Form over.
		bitBlt copyBits.
	].
	mask ifNotNil:[
		bitBlt := BitBlt toForm: form.
		bitBlt combinationRule: 7 "bitOr:with:".
		bitBlt halftoneForm: (Bitmap with: mask).
		bitBlt copyBits.
	].
	^ form
! !

!BMPReadWriter methodsFor: 'testing' stamp: 'ar 6/16/2002 15:27'!
understandsImageFormat
	stream size < 54 ifTrue:[^false]. "min size = BITMAPFILEHEADER+BITMAPINFOHEADER"
	self readHeader.
	bfType = 19778 "BM" ifFalse:[^false].
	biSize = 40 ifFalse:[^false].
	biPlanes = 1 ifFalse:[^false].
	bfSize <= stream size ifFalse:[^false].
	biCompression = 0 ifFalse:[^false].
	^true! !

!BMPReadWriter methodsFor: 'writing' stamp: 'yo 2/18/2004 17:57'!
nextPutImage: aForm
	| bhSize rowBytes rgb data colorValues depth image ppw scanLineLen |
	depth := aForm depth.
	[#(1 4 8 32) includes: depth] whileFalse:[depth := depth + 1 asLargerPowerOfTwo].
	image := aForm asFormOfDepth: depth.
	image unhibernate.
	bhSize _ 14.  "# bytes in file header"
	biSize _ 40.  "info header size in bytes"
	biWidth := image width.
	biHeight := image height.
	biClrUsed _ depth = 32 ifTrue: [0] ifFalse:[1 << depth].  "No. color table entries"
	bfOffBits _ biSize + bhSize + (4*biClrUsed).
	rowBytes _ ((depth min: 24) * biWidth + 31 // 32) * 4.
	biSizeImage _ biHeight * rowBytes.

	"Write the file header"
	stream position: 0.
	stream nextLittleEndianNumber: 2 put: 19778.  "bfType = BM"
	stream nextLittleEndianNumber: 4 put: bfOffBits + biSizeImage.  "Entire file size in bytes"
	stream nextLittleEndianNumber: 4 put: 0.  "bfReserved"
	stream nextLittleEndianNumber: 4 put: bfOffBits.  "Offset of bitmap data from start of hdr (and file)"

	"Write the bitmap info header"
	stream position: bhSize.
	stream nextLittleEndianNumber: 4 put: biSize.  "info header size in bytes"
	stream nextLittleEndianNumber: 4 put: image width.  "biWidth"
	stream nextLittleEndianNumber: 4 put: image height.  "biHeight"
	stream nextLittleEndianNumber: 2 put: 1.  "biPlanes"
	stream nextLittleEndianNumber: 2 put: (depth min: 24).  "biBitCount"
	stream nextLittleEndianNumber: 4 put: 0.  "biCompression"
	stream nextLittleEndianNumber: 4 put: biSizeImage.  "size of image section in bytes"
	stream nextLittleEndianNumber: 4 put: 2800.  "biXPelsPerMeter"
	stream nextLittleEndianNumber: 4 put: 2800.  "biYPelsPerMeter"
	stream nextLittleEndianNumber: 4 put: biClrUsed.
	stream nextLittleEndianNumber: 4 put: 0.  "biClrImportant"
	biClrUsed > 0 ifTrue: [
		"write color map; this works for ColorForms, too"
		colorValues _ image colormapIfNeededForDepth: 32.
		1 to: biClrUsed do: [:i |
			rgb _ colorValues at: i.
			0 to: 24 by: 8 do: [:j | stream nextPut: (rgb >> j bitAnd: 16rFF)]]].

	depth < 32 ifTrue: [
		"depth = 1, 4 or 8."
		data _ image bits asByteArray.
		ppw _ 32 // depth.
		scanLineLen _ biWidth + ppw - 1 // ppw * 4.  "# of bytes in line"
		1 to: biHeight do: [:i |
			stream next: scanLineLen putAll: data startingAt: (biHeight-i)*scanLineLen+1.
		].
	] ifFalse: [
		1 to: biHeight do:[:i |
			data _ (image copy: (0@(biHeight-i) extent: biWidth@1)) bits.
			1 to: data size do: [:j | stream nextLittleEndianNumber: 3 put: (data at: j)].
			1 to: (data size*3)+3//4*4-(data size*3) do: [:j | stream nextPut: 0 "pad to 32-bits"]
		].
	].
	stream position = (bfOffBits + biSizeImage) ifFalse: [self error:'Write failure'].
	stream close.! !

!BMPReadWriter class methodsFor: 'image reading/writing' stamp: 'nk 7/16/2003 17:56'!
typicalFileExtensions
	"Answer a collection of file extensions (lowercase) which files that I can read might commonly have"
	^#('bmp')! !

!BMPReadWriter class methodsFor: 'testing' stamp: 'ar 6/16/2002 18:55'!
displayAllFrom: fd
	"BMPReadWriter displayAllFrom: FileDirectory default"
	fd fileNames do:[:fName|
		(fName endsWith: '.bmp') ifTrue:[
			[(Form fromBinaryStream: (fd readOnlyFileNamed: fName)) display.
			Display forceDisplayUpdate] on: Error do:[:nix|].
		].
	].
	fd directoryNames do:[:fdName|
		self displayAllFrom: (fd directoryNamed: fdName)
	].! !

!BMPReadWriter class methodsFor: 'testing' stamp: 'ar 6/16/2002 18:56'!
readAllFrom: fd
	"MessageTally spyOn:[BMPReadWriter readAllFrom: FileDirectory default]"
	fd fileNames do:[:fName|
		(fName endsWith: '.bmp') ifTrue:[
			[Form fromBinaryStream: (fd readOnlyFileNamed: fName)] on: Error do:[:nix].
		].
	].
	fd directoryNames do:[:fdName|
		self readAllFrom: (fd directoryNamed: fdName)
	].! !

!BadEqualer methodsFor: 'comparing' stamp: 'mjr 8/20/2003 18:56'!
= other 
	self class = other class
		ifFalse: [^ false].
	^ 100 atRandom < 30 ! !

!BadEqualer commentStamp: 'mjr 8/20/2003 13:28' prior: 0!
I am an object that doesn't always report #= correctly.  Used for testing the EqualityTester.!
!BadHasher methodsFor: 'comparing' stamp: 'mjr 8/20/2003 18:56'!
hash
	"answer with a different hash some of the time"
	100 atRandom < 30
		ifTrue: [^ 1]. 
	^ 2! !

!BadHasher commentStamp: 'mjr 8/20/2003 13:28' prior: 0!
I am an object that doesn't always hash correctly.  I am used for testing the HashTester.!
!Behavior methodsFor: 'accessing' stamp: 'ssa 9/2/2009 17:59'!
setInstanceFormat: sizeAndFlags 
	"Set the format for the receiver (a Class)."

	format _ sizeAndFlags! !

!Behavior methodsFor: 'printing' stamp: 'ssa 10/25/2008 20:48'!
archiveVersion
	"This is the daefault version number for an archived instance of any class.
	Version 1 was back when each class was responsible for its own archiving.
	Version 2 uses the default archiving behavior in object (see Object>archiveOn: and Object class>dearchive:from:)."

	^1! !

!Behavior methodsFor: 'printing' stamp: 'ads 1/24/2011 13:02'!
longPrintOn: aStream
	"Append to the argument, aStream, the names and values of all of the receiver's instance variables.  But, not useful for a class with a method dictionary."

aStream nextPutAll: (RVMPrimitivesNeededForBootstrapping printPrefixFor: self).
	aStream nextPutAll: '<<too complex to show>>'; cr.! !

!Behavior methodsFor: 'compiling' stamp: 'ssa 9/3/2008 12:19'!
compile: code notifying: requestor trailer: trailingBytes
	"Compile the argument, code, as source code in the context of the 
	receiver and insEtall the result in the receiver's method dictionary. The 
	second argument, requestor, is to be notified if an error occurs. The 
	argument code is either a string or an object that converts to a string or 
	a PositionableStream. This method also saves the source code."
	
	| methodAndNode |
	methodAndNode  := self
		basicCompile: code "a Text"
		notifying: requestor
		trailer: trailingBytes
		ifFail: [^nil].
	methodAndNode method putSource: code fromParseNode: methodAndNode node inFile: 2
			withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Behavior method'; cr].
	self addSelector: methodAndNode selector withMethod: methodAndNode method notifying: requestor.
	^ methodAndNode selector! !

!Behavior methodsFor: 'accessing class hierarchy' stamp: 'ssa 10/8/2008 15:47'!
allSubclasses
	"Answer a Set of the receiver's and the receiver's descendent's subclasses. "

	| scan scanTop |
	scan _ OrderedCollection withAll: self subclasses.
	scanTop _ 1.
	[scanTop > scan size]
		whileFalse: [scan addAll: (scan at: scanTop) subclasses.
			scanTop _ scanTop + 1].
	^ scan "asSet"! !

!Behavior methodsFor: 'accessing class hierarchy' stamp: 'ssa 10/8/2008 16:02'!
withAllSubclasses
	"Answer a Set of the receiver, the receiver's descendent's, and the  
	receiver's descendent's subclasses."

	| subs |
	subs _ self allSubclasses.
	subs addFirst: self.
	^subs! !

!Behavior methodsFor: 'outlining' stamp: 'ssa 9/10/2009 13:46'!
subobjects

	^self subclasses! !

!Benchmark methodsFor: 'load and popStore'!
testLoadInstVar
	dummy _ 1.
	self test: [dummy == dummy. dummy == dummy.
			  dummy == dummy. dummy == dummy.
			  dummy == dummy. dummy == dummy.
			  dummy == dummy. dummy == dummy.
			  dummy == dummy. dummy == dummy. nil]
		labeled: 'load an instance variable, 20 times' repeated: 10000

	"Benchmark new testLoadInstVar"! !

!Benchmark methodsFor: 'load and popStore'!
testLoadLiteralIndirect
	self test: [Point == Point. Point == Point.
			  Point == Point. Point == Point.
			  Point == Point. Point == Point.
			  Point == Point. Point == Point.
			  Point == Point. Point == Point. nil]
		labeled: 'load literal indirect (overflow refct), 20 times' repeated: 10000

	"Benchmark new testLoadLiteralIndirect"! !

!Benchmark methodsFor: 'load and popStore'!
testLoadLiteralNRef
	self test: [3 == 3. 3 == 3. 3 == 3. 3 == 3. 3 == 3.
			  3 == 3. 3 == 3. 3 == 3. 3 == 3. 3 == 3. nil]
		labeled: 'load nonRefcounted literal, 20 times' repeated: 10000

	"Benchmark new testLoadLiteralNRef"! !

!Benchmark methodsFor: 'load and popStore'!
testLoadQuickConstant
	self test: [1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1.
			  1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1.
			  1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1.
			  1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1. nil]
		labeled: 'load 1, 40 times; send ==, 20 times' repeated: 10000

	"Benchmark new testLoadQuickConstant"! !

!Benchmark methodsFor: 'load and popStore'!
testLoadTempNRef
	| temp |
	temp _ 1.
	self test: [temp == temp. temp == temp.
			  temp == temp. temp == temp.
			  temp == temp. temp == temp.
			  temp == temp. temp == temp.
			  temp == temp. temp == temp. nil]
		labeled: 'load 1 as a temp, 20 times' repeated: 10000

	"Benchmark new testLoadTempNRef"! !

!Benchmark methodsFor: 'load and popStore'!
testLoadTempRef
	| temp |
	temp _ 0@0.
	self test: [temp == temp. temp == temp.
			  temp == temp. temp == temp.
			  temp == temp. temp == temp.
			  temp == temp. temp == temp.
			  temp == temp. temp == temp. nil]
		labeled: 'load 0@0, 20 times' repeated: 10000

	"Benchmark new testLoadTempRef"! !

!Benchmark methodsFor: 'load and popStore'!
testPopStoreInstVar
	self test: [dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1.
			  dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1.
			  dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1.
			  dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. dummy _ 1. nil]
		labeled: 'store into an instance variable, 20 times' repeated: 10000

	"Benchmark new testPopStoreInstVar"! !

!Benchmark methodsFor: 'load and popStore'!
testPopStoreTemp
	| temp |
	self test: [temp _ 1. temp _ 1. temp _ 1. temp _ 1. temp _ 1.
			  temp _ 1. temp _ 1. temp _ 1. temp _ 1. temp _ 1.
			  temp _ 1. temp _ 1. temp _ 1. temp _ 1. temp _ 1.
			  temp _ 1. temp _ 1. temp _ 1. temp _ 1. temp _ 1. nil]
		labeled: 'store into a temp, 20 times' repeated: 10000

	"Benchmark new testPopStoreTemp"! !

!Benchmark methodsFor: 'arithmetic'!
test16bitArith
	| twentyK |
	twentyK _ 20000.
	self test: [twentyK+twentyK. twentyK+twentyK.
			  twentyK+twentyK. twentyK+twentyK.
			  twentyK+twentyK. twentyK+twentyK.
			  twentyK+twentyK. twentyK+twentyK.
			  twentyK+twentyK. twentyK+twentyK. nil]
		labeled: 'add 20000 + 20000, 10 times' repeated: 1000

	"Benchmark new test16bitArith"! !

!Benchmark methodsFor: 'arithmetic'!
test3div4
	self test: [3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. nil]
		labeled: 'divide 3 by 4, 10 times' repeated: 1000

	"Benchmark new test3div4"! !

!Benchmark methodsFor: 'arithmetic'!
test3lessThan4
	self test: [3<4. 3<4. 3<4. 3<4. 3<4. 3<4. 3<4. 3<4. 3<4. 3<4. nil]
		labeled: 'test 3 < 4, 10 times' repeated: 10000

	"Benchmark new test3lessThan4"! !

!Benchmark methodsFor: 'arithmetic'!
test3plus4
	self test: [3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. nil]
		labeled: 'add 3 + 4, 10 times' repeated: 10000

	"Benchmark new test3plus4"! !

!Benchmark methodsFor: 'arithmetic'!
test3times4
	self test: [3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. nil]
		labeled: 'multiply 3 * 4, 10 times' repeated: 10000

	"Benchmark new test3times4"! !

!Benchmark methodsFor: 'arithmetic'!
testLargeIntArith
	| eightyK |
	eightyK _ 80000.
	self test: [eightyK+eightyK. eightyK+eightyK.
			  eightyK+eightyK. eightyK+eightyK.
			  eightyK+eightyK. eightyK+eightyK.
			  eightyK+eightyK. eightyK+eightyK.
			  eightyK+eightyK. eightyK+eightyK. nil]
		labeled: 'add 80000 + 80000, 10 times' repeated: 100

	"Benchmark new testLargeIntArith"! !

!Benchmark methodsFor: 'control'!
testActivationReturn
	self test:
			[self recur: 14]
		labeled: 'activate and return, 32K times' repeated: 1

	"Benchmark new testActivationReturn"! !

!Benchmark methodsFor: 'control'!
testShortBranch
	self test: [false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2].
			  false ifTrue: [1] ifFalse: [2]. nil]
		labeled: 'short branch on false, 10 times' repeated: 10000

	"Benchmark new testShortBranch"! !

!Benchmark methodsFor: 'control'!
testWhileLoop
	| temp |
	self test: [temp _ 10000.
			  [temp > 0] whileTrue: [temp _ temp - 1].
			  nil]
		labeled: 'simple whileLoop, 10000 times through' repeated: 10

	"Benchmark new testWhileLoop"! !

!Benchmark methodsFor: 'arrays and strings'!
testArrayAt
	| array index |
	array _ #(1 2 3 4 5 6).
	index _ 4.
	self test:
			[array at: index. array at: index. array at: index. array at: index.
			 array at: index. array at: index. array at: index. array at: index.
			 array at: index. array at: index. array at: index. array at: index.
			 array at: index. array at: index. array at: index. array at: index.
			 array at: index. array at: index. array at: index. array at: index. nil]
		labeled: 'send #at: 20 times (to an array)' repeated: 1000

	"Benchmark new testArrayAt"! !

!Benchmark methodsFor: 'arrays and strings'!
testArrayAtPut
	| array index element |
	array _ #(1 2 3 4 5 6).
	index _ 4.
	element _ 17.
	self test:
			[array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element.
			 array at: index put: element. array at: index put: element. nil]
		labeled: 'send #at:put: 20 times (to an array)' repeated: 1000

	"Benchmark new testArrayAtPut"! !

!Benchmark methodsFor: 'arrays and strings'!
testSize
	| string |
	string _ 'abcde'.
	self test:
			[string size. string size. string size. string size. string size.
			 string size. string size. string size. string size. string size.
			 string size. string size. string size. string size. string size.
			 string size. string size. string size. string size. string size. nil]
		labeled: 'send #size 20 times (to a string)' repeated: 1000

	"Benchmark new testSize"! !

!Benchmark methodsFor: 'arrays and strings'!
testStringAt
	| string index |
	string _ 'abcdefg'.
	index _ 4.
	self test:
			[string at: index. string at: index. string at: index. string at: index.
			 string at: index. string at: index. string at: index. string at: index.
			 string at: index. string at: index. string at: index. string at: index.
			 string at: index. string at: index. string at: index. string at: index.
			 string at: index. string at: index. string at: index. string at: index. nil]
		labeled: 'send #at: 20 times (to a string)' repeated: 1000

	"Benchmark new testStringAt"! !

!Benchmark methodsFor: 'arrays and strings'!
testStringAtPut
	| string index char |
	string _ 'abcdefg'.
	index _ 4.
	char _ $q.
	self test:
			[string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char.
			 string at: index put: char. string at: index put: char. nil]
		labeled: 'send #at:put: 20 times (to a string)' repeated: 1000

	"Benchmark new testStringAtPut"! !

!Benchmark methodsFor: 'primitive byte codes'!
testBlockCopy
	| tC |
	tC _ thisContext.
	self test: [tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0.
			  tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0.
			  tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0.
			  tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0.
			  tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. tC blockCopy: 0. nil]
		labeled: 'execute blockCopy: 0, 20 times' repeated: 1000

	"Benchmark new testBlockCopy"! !

!Benchmark methodsFor: 'primitive byte codes'!
testClass
	| pt |
	pt _ 0@0.
	self test:
			[pt class. pt class. pt class. pt class. pt class.
			 pt class. pt class. pt class. pt class. pt class.
			 pt class. pt class. pt class. pt class. pt class.
			 pt class. pt class. pt class. pt class. pt class. nil]
		labeled: 'send #class 20 times (to a point)' repeated: 1000

	"Benchmark new testClass"! !

!Benchmark methodsFor: 'primitive byte codes'!
testCreation
	self test:
			[Point new. Point new. Point new. Point new. Point new.
			  Point new. Point new. Point new. Point new. Point new.
			  Point new. Point new. Point new. Point new. Point new.
			  Point new. Point new. Point new. Point new. Point new. nil]
		labeled: 'create 20 uninitialized points' repeated: 1000

	"Benchmark new testCreation"! !

!Benchmark methodsFor: 'primitive byte codes'!
testEQ
	| temp |
	temp _ 1.
	self test: [temp == temp == temp == temp == temp ==
			  temp == temp == temp == temp == temp ==
			  temp == temp == temp == temp == temp ==
			  temp == temp == temp == temp == temp. nil]
		labeled: 'send ==, 20 times' repeated: 10000

	"Benchmark new testEQ"! !

!Benchmark methodsFor: 'primitive byte codes'!
testLoadThisContext
	self test: [thisContext == thisContext. thisContext == thisContext.
			  thisContext == thisContext. thisContext == thisContext.
			  thisContext == thisContext. thisContext == thisContext.
			  thisContext == thisContext. thisContext == thisContext.
			  thisContext == thisContext. thisContext == thisContext. nil]
		labeled: 'load thisContext, 20 times' repeated: 10000

	"Benchmark new testLoadThisContext"! !

!Benchmark methodsFor: 'primitive byte codes'!
testPointCreation
	self test: [3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. nil]
		labeled: 'create 3@4, 10 times' repeated: 1000

	"Benchmark new testPointCreation"! !

!Benchmark methodsFor: 'primitive byte codes'!
testPointX
	| pt |
	pt _ 0@0.
	self test: [pt x. pt x. pt x. pt x. pt x. pt x. pt x. pt x. pt x. pt x. nil]
		labeled: 'execute aPoint x, 10 times' repeated: 10000

	"Benchmark new testPointX"! !

!Benchmark methodsFor: 'primitive byte codes'!
testStreamNext
	| strm |
	strm _ ReadStream on: 'abcdefghijklmnopqrstuvwxyz'.
	self test: [strm position: 0.
			  strm next. strm next. strm next. strm next.
			  strm next. strm next. strm next. strm next.
			  strm next. strm next. strm next. strm next.
			  strm next. strm next. strm next. strm next.
			  strm next. strm next. strm next. strm next. nil]
		labeled: 'execute ReadStream next, 20 times' repeated: 1000

	"Benchmark new testStreamNext"! !

!Benchmark methodsFor: 'primitive byte codes'!
testStreamNextPut
	| strm ch |
	strm _ ReadWriteStream on: 'abcdefghijklmnopqrstuvwxyz'.
	ch _ $q.
	self test: [strm position: 0.
			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.
			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.
			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.
			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.
			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. nil]
		labeled: 'execute ReadWriteStream nextPut:, 20 times' repeated: 1000

	"Benchmark new testStreamNextPut"! !

!Benchmark methodsFor: 'primitive byte codes'!
testValue
	| block |
	block _ [3+4].
	self test: [block value. block value. block value. block value.
			  block value. block value. block value. block value.
			  block value. block value. block value. block value.
			  block value. block value. block value. block value.
			  block value. block value. block value. block value. nil]
		labeled: 'evaluate the block: (3+4), 20 times' repeated: 1000

	"Benchmark new testValue"! !

!Benchmark methodsFor: 'primitive methods'!
testAsFloat
	self test: [1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat.
			  1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat.
			  1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat.
			  1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. nil]
		labeled: 'convert 1 to floating point, 20 times' repeated: 100

	"Benchmark new testAsFloat"! !

!Benchmark methodsFor: 'primitive methods' stamp: 'ssa 8/19/2008 21:08'!
testBasicAt
	| coll index |
	coll _ Array new: 16.
	index _ 5.
	self test:
			[coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.
			 coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.
			 coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.
			 coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.
			 coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index. nil]
		labeled: 'send #basicAt: 20 times (to an array)' repeated: 1000

	"Benchmark new testBasicAt"! !

!Benchmark methodsFor: 'primitive methods' stamp: 'ssa 8/19/2008 21:09'!
testBasicAtPut
	| coll index element |
	coll _ Array new: 16.
	index _ 5.
	element _ 17.
	self test:
			[coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element.
			 coll basicAt: index put: element. coll basicAt: index put: element. nil]
		labeled: 'send #basicAtPut: 20 times (to a set)' repeated: 1000

	"Benchmark new testBasicAtPut"! !

!Benchmark methodsFor: 'primitive methods'!
testBitBLT
	| bLTer |
	bLTer _ self sampleBitBLT.
	self test:
			[bLTer copyBits. bLTer copyBits.
			 bLTer copyBits. bLTer copyBits.
			 bLTer copyBits. bLTer copyBits.
			 bLTer copyBits. bLTer copyBits.
			 bLTer copyBits. bLTer copyBits. nil]
		labeled: 'call bitBLT 10 times' repeated: 10

	"Benchmark new testBitBLT"! !

!Benchmark methodsFor: 'primitive methods'!
testFloatingPointAddition
	| a b |
	a _ 3.1.
	b _ 4.1.
	self test: [a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b.
			  a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. nil]
		labeled: 'add 3.1 plus 4.1, 20 times' repeated: 100

	"Benchmark new testFloatingPointAddition"! !

!Benchmark methodsFor: 'primitive methods'!
testPerform
	self test: [3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4.
			  3 perform: #+ with: 4. 3 perform: #+ with: 4. nil]
		labeled: '3 perform: #+ with: 4, 20 times' repeated: 1000

	"Benchmark new testPerform"! !

!Benchmark methodsFor: 'primitive methods'!
testStringReplace
	| source sink size |
	source _ self longishString copy.
	sink _ source copy.
	size _ sink size.
	self test:
			[sink replaceFrom: 1 to: size with: source startingAt: 1. nil]
		labeled: 'replace characters in a string' repeated: 100

	"Benchmark new testStringReplace"! !

!Benchmark methodsFor: 'primitive methods' stamp: 'ssa 8/19/2008 21:51'!
testTextScanning
	| clipRect para range scanner stops |
	"clipRect _ Display boundingBox.
	para _ Paragraph withText: 'Hi there, folks' asText.
	range _ 1 to: para numberOfLines.
	scanner _ DisplayScanner new.
	scanner displayLines: range in: para clippedBy: clipRect.
	stops _ scanner instVarAt: 17."
	self test:
		["scanner destX: 0.
		 scanner
			scanCharactersFrom: 1
			to: 16
			in: 'Hi there, folks!!'
			rightX: 400
			stopConditions: stops
			displaying: true"]
		labeled: 'DISABLED scan characters (primitive text display)' repeated: 100

	"Benchmark new testTextScanning"! !

!Benchmark methodsFor: 'macro operations' stamp: 'ssa 11/17/2008 22:54'!
testAllCallsOn
	self test:
			[SystemNavigation default  allCallsOn: #printStringBase:]
		labeled: 'find all calls on #printStringBase:' repeated: 3

	"Benchmark new testAllCallsOn"! !

!Benchmark methodsFor: 'macro operations' stamp: 'ssa 11/17/2008 22:51'!
testAllImplementors
	self test:
			[SystemNavigation default allImplementorsOf: #next]
		labeled: 'find all implementors of #next' repeated: 10

	"Benchmark new testAllImplementors"! !

!Benchmark methodsFor: 'macro operations'!
testClassOrganizer
	| class |
	class _ Benchmark.
	self test:
			[class organization changeFromString: class organization printString]
		labeled: 'read and write class organization' repeated: 1

	"Benchmark new testClassOrganizer"! !

!Benchmark methodsFor: 'macro operations' stamp: 'dmu 1/1/2009 04:42'!
testCompiler
	self test:
			[Benchmark compileBenchmark:
'dummy: aBlock repeated: nTimes | i emptyBlock emptyTime blockTime |
	nTimes > 1000 ifTrue: [^self time: aBlock repeatedK: nTimes // 1000].
	emptyBlock _ [].
	emptyTime _ Time millisecondsToRun:
					[i _ 0.
					 [(i _ i + 1) <= nTimes] whileTrue: [emptyBlock value]].
	blockTime _ Time millisecondsToRun:
					[i _ 0.
					 [(i _ i + 1) <= nTimes] whileTrue: [aBlock value]].
	^blockTime - emptyTime'
				notifying: nil ]
		labeled: 'compile dummy method' repeated: 5.
	Benchmark removeSelector: #dummy:repeated:

	"Benchmark new testCompiler"! !

!Benchmark methodsFor: 'macro operations'!
testDecompiler
	| class |
	class _ InputSensor.
	self
		test: [class selectors do:
				[:sel | (Decompiler new
						decompile: sel
						in: class
						method: (class compiledMethodAt: sel)) decompileString]]
		labeled: 'decompile class InputSensor' repeated: 1

	"Benchmark new testDecompiler"! !

!Benchmark methodsFor: 'macro operations' stamp: 'ssa 11/17/2008 22:57'!
testMandala
	self test:
			[Pen new mandala: 30 diameter: 400]
		labeled: 'testing Mandala' repeated: 2

	"Benchmark new testMandala"! !

!Benchmark methodsFor: 'macro operations'!
testPrintDefinition
	| class |
	class _ Compiler.
	self test:
			[class definition]
		labeled: 'print a class definition' repeated: 20

	"Benchmark new testPrintDefinition"! !

!Benchmark methodsFor: 'macro operations'!
testPrintHierarchy
	| class |
	class _ InstructionStream.
	self test:
			[class printHierarchy]
		labeled: 'print a class hierarchy' repeated: 10

	"Benchmark new testPrintHierarchy"! !

!Benchmark methodsFor: 'macro operations'!
testTextDisplay
	| para |
	para _ Paragraph withText: self textForDisplay.
	para displayAt: 200@200.
	self test: [para displayAt: 200@200]
		labeled: 'display text' repeated: 10

	"Benchmark new testTextDisplay"! !

!Benchmark methodsFor: 'macro operations'!
testTextEditing
	| aStringHolderView editor selectPoint |
	aStringHolderView _ self favoriteStringHolderView.
	editor _ aStringHolderView controller.
	selectPoint _ 0.
	self test:
			[editor selectAt: (selectPoint _ selectPoint + 5).
			 editor replaceSelectionWith: 'Now!! ' asText]
		labeled: 'text replacement and redisplay' repeated: 20.
	aStringHolderView release

	"Benchmark new testTextEditing"! !

!Benchmark methodsFor: 'macro operations'!
testTextFormatting
	| aString aView contents |
	aString _ self stringForDisplay.
	aView _ StringHolderView container: StringHolder new.
	aView window: Display boundingBox viewport: (100@100 extent: 200@200).
	self test:
			[aView editString: (aString asText makeSelectorBoldIn: Benchmark) asParagraph]
		labeled: 'format a bunch of text' repeated: 5.
	aView release

	"Benchmark new testTextFormatting"! !

!Benchmark methodsFor: 'testing'!
test: aBlock labeled: label repeated: nTimes 
	"This is the main message to a Benchmark. aBlock is repeated nTimes, and the
	results are reported."

	| time |
	time _ self time: aBlock repeated: nTimes.
	self
		report: label
		timedAt: time
		repeated: nTimes! !

!Benchmark methodsFor: 'testing' stamp: 'ssa 8/19/2008 21:56'!
testList: selectorList
	"This message allows you to test a series of benchmarks and record all the results on
	a file or stream."

	fromList _ true.
	self setOutputParameters.
	selectorList do:
		[:selector | self perform: selector].
	reporting ifTrue: [self closeOutput: reportStream].
	fromList _ false.

	"Benchmark new testList: #(testLoadInstVar testLoadLiteralIndirect testLoadLiteralNRef testLoadQuickConstant testLoadTempNRef)"! !

!Benchmark methodsFor: 'testing' stamp: 'ssa 8/19/2008 21:56'!
testList: selectorList toFile: aFileStream
	"This message allows you to test a series of benchmarks and record all the results on
	a file or stream."

	fromList _ true.
	self fileOutputParameters: aFileStream.
	selectorList do:
		[:selector | self perform: selector.
		 verboseTranscript ifTrue:
			[]].
	reporting ifTrue: [self closeOutput: reportStream].
	fromList _ false.

	"Benchmark new testList: #(testLoadInstVar testLoadLiteralIndirect testLoadLiteralNRef testLoadQuickConstant testLoadTempNRef) toFile: (FileStream fileNamed: 'Smalltalk.timing')"! !

!Benchmark methodsFor: 'testing'!
time: aBlock repeated10K: tenKTimes 
	| i emptyBlock emptyTime blockTime |
	tenKTimes > 10000 ifTrue: [^self error: 'one hundred million repetitions is my limit'].
	emptyBlock _ [].
	emptyTime _
			Time millisecondsToRun:
					[1 to: tenKTimes do: 
						[:j | 
						i _ 0.
						[(i _ i + 1) <= 10000]
							whileTrue: [emptyBlock value]]].
	blockTime _
			Time millisecondsToRun:
					[1 to: tenKTimes do: 
						[:j | 
						i _ 0.
						[(i _ i + 1) <= 10000]
							whileTrue: [aBlock value]]].
	^blockTime - emptyTime! !

!Benchmark methodsFor: 'testing'!
time: aBlock repeated: nTimes
	"Answer how many milliseconds it takes to repeat aBlock nTimes, corrected for the
	time to repeat an empty block."

	| i emptyBlock emptyTime blockTime iBox |
	nTimes > 10000 ifTrue: [^self time: aBlock repeated10K: nTimes // 10000].
	emptyBlock _ [].
	emptyTime _ Time millisecondsToRun: 
							[i _ 0.
							 [(i _ i + 1) <= nTimes] whileTrue: [emptyBlock value]].
	blockTime _ Time millisecondsToRun: 
							[i _ 0.
							 [(i _ i + 1) <= nTimes] whileTrue: [aBlock value]].
	^blockTime - emptyTime! !

!Benchmark methodsFor: 'output'!
clearOutputs
	"This allows you to get rid of your old accumulated output streams."

	Outputs _ nil

	"Benchmark new clearOutputs"! !

!Benchmark methodsFor: 'output'!
closeOutput: aStream
	self streamsRatherThanFiles 
		ifTrue: [aStream reset]
		ifFalse: [aStream close]! !

!Benchmark methodsFor: 'output' stamp: 'ssa 8/19/2008 22:12'!
compareOldTimes: oldName toNewTimes: newName outputTo: outName
	"Compare two sets of benchmark ouput reports."

	| oldDict newDict labels compareStream oldTime newTime |
	oldDict _ Dictionary new. newDict _ Dictionary new. labels _ OrderedCollection new.
	self readOutput: (self outputNamed: oldName) intoDict: oldDict andCollection: nil.
	self readOutput: (self outputNamed: newName) intoDict: newDict andCollection: labels.
	compareStream _ self makeOutputNamed: outName.
	labels do:
		[:label | (oldDict includesKey: label) ifTrue:
			[compareStream nextPutAll: label; cr; tab;
				nextPutAll: 'old time: ', (oldTime _ oldDict at: label) printString; tab;
				nextPutAll: 'new time: ', (newTime _ newDict at: label) printString; tab.
				oldTime = 0 ifTrue:[compareStream nextPutAll:'percent change: ERROR oldTime=0';cr;cr]
				ifFalse:[compareStream 
				nextPutAll: 'percent change: ', (newTime - oldTime * 100.0 / oldTime) printString; cr; cr]]].
	self closeOutput: compareStream

	"Benchmark new
		compareOldTimes: 'test1.timing'
		toNewTimes: 'test2.timing'
		outputTo: 'compare1-2.timing'"

	"Benchmark new displayOutputNamed: 'compare1-2.timing'"! !

!Benchmark methodsFor: 'output'!
displayOutputNamed: name
	"Create a window on the display to view the contents of the named output.
	Does not allow editing of the output file or stream."

	| output contents |
	output _ self outputNamed: name.
	contents _ self streamsRatherThanFiles
					ifTrue: [output contents]
					ifFalse: [output contentsOfEntireFile].
	StringHolderView
		open: (StringHolder new contents: contents)
		label: name! !

!Benchmark methodsFor: 'output'!
makeOutputNamed: name
	"Create a new output file or stream of the given name."

	self streamsRatherThanFiles
		ifTrue: [Outputs == nil ifTrue: [Outputs _ Dictionary new].
				Outputs at: name put:
					(ReadWriteStream on: (String new: 1000))].
	^self outputNamed: name! !

!Benchmark methodsFor: 'output' stamp: 'ssa 8/19/2008 22:06'!
outputNamed: name
	"Answer with the output file or stream of the given name."

	self streamsRatherThanFiles
		ifTrue: [^Outputs at: name]
		ifFalse: [^FileStream fileNamed: name]! !

!Benchmark methodsFor: 'output'!
readOutput: aStream intoDict: aDict andCollection: aColl
	"Parse the output file or stream, aStream, putting labels and times in aDict.
	If aColl is non-nil (but rather an ordered collection), also add the labels to it
	in order."

	| leftBracket rightBracket tab space label value |
	leftBracket _ $[.
	rightBracket _ $].
	tab _ $	.
	space _ $ .
	aStream upTo: leftBracket.
	[aStream atEnd] whileFalse:
		[label _ aStream upTo: rightBracket.
		 aColl notNil ifTrue: [aColl add: label].
		 aStream next: 2; upTo: tab.
		 value _ Number readFrom: (ReadStream on: (aStream upTo: space)).
		 aDict at: label put: value.
		 aStream upTo: leftBracket].
	self closeOutput: aStream! !

!Benchmark methodsFor: 'output'!
report: label timedAt: time repeated: numberOfTimes
	"Do all the reporting, both in the Transcript and on the output file or stream."

	| reportString |
	reportString _ self reportStringFor: label
						timedAt: time
						repeated: numberOfTimes.
	verboseTranscript
			ifTrue: [Transcript show: reportString]
			ifFalse: [Transcript show: '
[', label, ']'].
	reporting ifTrue:
		[reportStream nextPutAll: reportString.
		 fromList ifFalse: [self closeOutput: reportStream]]! !

!Benchmark methodsFor: 'output'!
reportStringFor: label timedAt: time repeated: numberOfTimes
	"Generate the parsible string to represent the measurement of a benchmark."

	| nTimes unitTime seconds aStream|
	aStream _ WriteStream on: (String new: 200).
	nTimes _ numberOfTimes <= 1000
				ifTrue: [numberOfTimes]
				ifFalse: [numberOfTimes // 1000 * 1000].
	seconds _ time asFloat / 1000.
	aStream cr; nextPutAll: 'Testing:  [' , label , ']'; cr.
	aStream tab; print: nTimes; nextPutAll: ' repetition(s) in'; cr;
		tab; print: seconds; nextPutAll: ' seconds'; cr.
	nTimes ~= 1
		ifTrue: 
			[unitTime _ (time * 1000) asFloat / nTimes.
			aStream tab; print: unitTime;
				nextPutAll: ' microseconds per repetition'; cr].
	^aStream contents! !

!Benchmark methodsFor: 'output' stamp: 'ssa 8/19/2008 22:05'!
streamsRatherThanFiles
	"Should the named outputs be (internal Smalltalk-80) streams rather than disk files?
	They should if there is no file system.
	Feel free to change this method if you have a file system but want streams anyway."

	^false! !

!Benchmark methodsFor: 'instance initialization'!
defaultOutputParameters
	reporting _ false.
	verboseTranscript _ true.
	fromList _ false! !

!Benchmark methodsFor: 'instance initialization'!
fileOutputParameters: aFileStream
	reporting _ true.
	reportStream _ aFileStream.
	verboseTranscript _ false! !

!Benchmark methodsFor: 'instance initialization' stamp: 'ssa 8/19/2008 22:24'!
setOutputParameters
	| answer |
	BinaryChoice 
		message: 'Would you like the transcript to just show labels, rather than full reports?'
		displayAt: Sensor mousePoint
		centered: true
		ifTrue: [verboseTranscript _ false]
		ifFalse: [verboseTranscript _ true].
	BinaryChoice
		message: 'Should the full reports to be output (saved on a file or stream)?'
		displayAt: Sensor mousePoint
		centered: true
		ifTrue: [reporting _ true]
		ifFalse: [reporting _ false].
	reporting ifTrue:
		[answer := FillInTheBlank
			request: 'Please supply desired output name' 
			initialAnswer: '.timing'
			centerAt: Sensor mousePoint.
			answer isEmpty ifFalse:[reportStream _ self makeOutputNamed: answer]
				ifTrue:[reporting := false]]! !

!Benchmark methodsFor: 'private'!
favoriteStringHolderView
	| aStringHolderView message |
	message _ self longishString.
	aStringHolderView _ StringHolderView container: (StringHolder new contents: message).
	aStringHolderView window: (0@0 extent: 300@200).
	aStringHolderView translateBy: 100@250.
	aStringHolderView display.
	^aStringHolderView! !

!Benchmark methodsFor: 'private'!
longishString
	^ 'Now is the time for all good people to come to the aid of the cause of world peace.  It is just fine, even desirable, to love your country, if that means wanting it to play a beneficial role in the course of world events and be the best possible example of a good society.  But if it means wanting dominion over the rest of the world, it is not love but defensiveness or self-glorification, and will lead only to oblivion.'! !

!Benchmark methodsFor: 'private'!
recur: exp 
	"Invokes a recursion involving ((2 raisedTo: exp+1) - 1) activations and 
	returns."

	exp = 0 ifTrue: [^self].
	self recur: exp - 1.
	^self recur: exp - 1! !

!Benchmark methodsFor: 'private' stamp: 'ssa 8/19/2008 21:11'!
sampleBitBLT
	^BitBlt 
		destForm: Display
		sourceForm: nil
		halftoneForm: Color black
		combinationRule: Form reverse
		destOrigin: 0@0
		sourceOrigin: 0@0
		extent: 400@400
		clipRect: Display boundingBox! !

!Benchmark methodsFor: 'private'!
stringForDisplay
	^'testTextDisplay
	| clipRect para range scanner |
	clipRect _ Display boundingBox.
	para _ Paragraph withText: self textForDisplay.
	range _ 1 to: para numberOfLines.
	scanner _ DisplayScanner new.
	self test: [scanner
				displayLines: range
				in: para
				clippedBy: clipRect]
		labeled: ''displaying text'' repeated: 10

	"Benchmark new testTextDisplay"'! !

!Benchmark methodsFor: 'private'!
textForDisplay
	^self stringForDisplay asText! !

!Benchmark commentStamp: 'ssa 8/19/2008 22:14' prior: 0!
Benchmark testStandardToFile: (FileStream fileNamed: 'test1.timing').
Benchmark testStandardToFile: (FileStream fileNamed: 'test2.timing').

Benchmark new
		compareOldTimes: 'test1.timing'
		toNewTimes: 'test2.timing'
		outputTo: 'compare1-2.timing'.

Benchmark new displayOutputNamed: 'compare1-2.timing'


--------------original comment follows-------------------------------

Class Benchmark contains facilities for timing the performance of your system and reporting the results.

There are built-in methods for timing certain activities that occur frequently in using Smalltalk-80.  There are also facilities for timing the execution of most byte codes.

It is intended that comparison of timing information between implementations and over time will allow implementors to discover where their systems could stand improvement and to gauge the value of intended performance enhancements.

The main interface to these facilities is through sending the messsage
	Benchmark new test: aBlock labeled: aLabel repeated: howManyTimes.
This will cause howManyTimes executions of aBlock and report the results, using aLabel for ease of identification.

The results can be reported in several different ways.  The default is to print a fairly verbose report in the Transcript.  But the reporting mode can be altered by sending the Benchmark which is going to perform a given test the message setOutputParameters.  This gives you the option of directing the report to a file or an internal stream and also of shortening the feedback in the Transcript.  The system automatically invites you to respecify the output parameters (e.g. naming a new output report file) whenever you test more than one thing at a time, using the message testList: (as in testStandardTests below).

Try an example.  To time your system's performance of simple addition, say
	Benchmark new test3plus4
or to time pushing an instance variable onto the stack, say
	Benchmark new testLoadInstVar.

If you had wished to print the results on a file or internal stream, you could have said
	Benchmark new setOutputParameters testLoadInstVar.

If you look at the code for these methods (e.g. testLoadInstVar), you will notice that it does a few things that you didn't want to time, such as sending the message ==, or popping things off the stack.  This is to make the compiler happy or to keep the stack from overflowing.  So you may want to subtract this stuff out.  (Use systems of equations.  Be clever!!)

The message category "macro operations" contains methods for timing more involved activities such as compiling, decompiling, editing text, formatting text, etc.

There is a message to class Benchmark which will invoke all the built-in benchmarks sequentially.  Say
	Benchmark testStandardTests.

There are also facilities for examining or automatically comparing the output files or streams generated by testing a bunch of benchmarks sequentially.  See the "output" category.  Be sure to read the comment to the streamsRatherThanFiles code.

Have fun and share your results with a friend.
!
!Benchmark class methodsFor: 'standard tests' stamp: 'ssa 8/19/2008 21:36'!
setStandardTests
	"These are all the built-in benchmarks.
	Feel free to change if you add more or think some of these are useless.
	To just execute a few, use testList: directly."

	StandardTests _
			#(testLoadInstVar testLoadTempNRef testLoadTempRef
			testLoadQuickConstant testLoadLiteralNRef testLoadLiteralIndirect
			testPopStoreInstVar testPopStoreTemp
			test3plus4 test3lessThan4 test3times4 test3div4 test16bitArith testLargeIntArith
			testActivationReturn testShortBranch testWhileLoop
			testArrayAt testArrayAtPut testStringAt testStringAtPut testSize
			testPointCreation testStreamNext testStreamNextPut testEQ testClass
			testBlockCopy testValue testCreation testPointX 
			testLoadThisContext
			testBasicAt testBasicAtPut testPerform testStringReplace
			testAsFloat testFloatingPointAddition testBitBLT testTextScanning
			testClassOrganizer testPrintDefinition testPrintHierarchy
 			testAllCallsOn testAllImplementors  
			testCompiler testDecompiler
			
			testTextDisplay testTextFormatting testTextEditing )! !

!Benchmark class methodsFor: 'standard tests'!
testStandardTests
	"This message allows you to test the default series of benchmarks and record all the
	results according to how you answer the interactive prompts."

	self setStandardTests.
	self new testList: StandardTests

	"Benchmark testStandardTests"! !

!Benchmark class methodsFor: 'standard tests'!
testStandardToFile: aFileStream
	"This message allows you to test the default series of benchmarks and record all the
	results on the specified file or stream."

	self setStandardTests.
	self new testList: StandardTests toFile: aFileStream

	"Benchmark testStandardToFile: (FileStream fileNamed: 'Smalltalk.timing')"! !

!Benchmark class methodsFor: 'instance creation'!
new
	^super new defaultOutputParameters

	"Benchmark new inspect"! !

!Benchmark class methodsFor: 'compiler benchmark support' stamp: 'dmu 1/1/2009 04:40'!
compileBenchmark: text classified: cat notifying: requestor
	| stamp |
	stamp _ self acceptsLoggingOfCompilation ifTrue: [Utilities changeStamp] ifFalse: [nil].
	^ self compileBenchmark: text classified: cat
		withStamp: stamp notifying: requestor

 ! !

!Benchmark class methodsFor: 'compiler benchmark support' stamp: 'dmu 1/1/2009 04:39'!
compileBenchmark: text classified: cat withStamp: changeStamp notifying: requestor
	^ self compile: text classified: cat withStamp: changeStamp notifying: requestor logSource: false! !

!Benchmark class methodsFor: 'compiler benchmark support' stamp: 'dmu 1/1/2009 04:41'!
compileBenchmark: code notifying: requestor 
	"Refer to the comment in Behavior|compile:notifying:." 

	^self compileBenchmark: code
		 classified: ClassOrganizer default
		 notifying: requestor! !

!BenchmarkGameSuite methodsFor: 'benchmarking' stamp: 'sm 5/31/2011 15:27'!
benchBinaryTrees
	| bench problemSize |
	bench := BGBinaryTrees new.
	problemSize := self problemSize ifNotNil: [ self problemSize asInteger ]
							  ifNil: [ BGBinaryTrees defaultProblemSize ].
	^ bench binarytrees: problemSize to: (TextStream with: String new).! !

!BenchmarkGameSuite methodsFor: 'benchmarking' stamp: 'sm 6/1/2011 14:01'!
benchChameleons
	| result problemSize |
	problemSize := self problemSize ifNotNil: [ self problemSize asInteger ]
								  ifNil: [ BGChameleons defaultProblemSize ].
	result := BGChameleons chameneos: problemSize.
	
	"Result should be 2*numberOfProcesses (as far as I understand the benchmark)"
	self flag: 'TODO adapt once verification is supported'.
	result = (2 * problemSize) ifFalse: [
		Error signal: (BGChameleons name, ' benchmark failed. Input: ', 
								 problemSize asString, ' Output: ', result asString).
	].! !

!BenchmarkGameSuite methodsFor: 'benchmarking' stamp: 'sm 6/1/2011 14:02'!
benchChameneosRedux
	| result report problemSize |
	problemSize := self problemSize ifNotNil: [ self problemSize asInteger ]
								  ifNil: [ BGChameneosRedux defaultProblemSize ].
	report := TextStream with: String new.
	result := BGMall runBenchMark: problemSize on: report.
	
	"Result should be 2*problemSize"
	self flag: 'TODO: adapt once verification is supported'.
	result = (2 * problemSize) ifFalse: [
		Error signal: self class name, ' benchmark failed. Input: ',
								 runner processes asString, ' Output: ', result asString  ].! !

!BenchmarkGameSuite methodsFor: 'benchmarking' stamp: 'sm 6/1/2011 14:02'!
benchFannkuchRedux
   | f problemSize |
	problemSize := self problemSize ifNotNil: [ self problemSize asInteger ]
								  ifNil: [ BGFannkuchRedux defaultProblemSize ].
   f := BGFannkuchRedux fannkuchRedux: problemSize to: (TextStream with: String new).
   
" the output should only be done by some reporter"
[ScriptConsole print: 'Pfannkuchen(', problemSize asString , ') = ', f asString.].
   ^f! !

!BenchmarkGameSuite methodsFor: 'benchmarking' stamp: 'sm 5/31/2011 15:28'!
benchFasta
	| out problemSize |
	out := TextStream with: String new.
	problemSize := self problemSize ifNotNil: [ self problemSize asInteger ]
								  ifNil: [ BGFasta defaultProblemSize ].  
	BGFasta fasta: problemSize to: out.! !

!BenchmarkGameSuite methodsFor: 'benchmarking' stamp: 'sm 5/31/2011 15:28'!
benchNBody
	| problemSize |
	problemSize := self problemSize ifNotNil: [ self problemSize asInteger ]
								  ifNil: [ BGNBody defaultProblemSize ].
	BGNBody nbody: problemSize.! !

!BenchmarkGameSuite methodsFor: 'license' stamp: 'StefanMarr 5/15/2011 12:31'!
license
	^
'Revised BSD license

This is a specific instance of the Open Source Initiative (OSI) BSD license
template http://www.opensource.org/licenses/bsd-license.php


Copyright 2008-2010 Isaac Gouy
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

   Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

   Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

   Neither the name of "The Computer Language Benchmarks Game" nor the name of
   "The Computer Language Shootout Benchmarks" nor the name "nanobench" nor
   the name "bencher" nor the names of its contributors may be used to endorse
   or promote products derived from this software without specific prior
   written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.'! !

!BinaryChoice class methodsFor: 'instance creation' stamp: 'ssa 8/19/2008 21:47'!
message: aString displayAt: aPoint centered: aBoolean ifTrue: trueBlock ifFalse: falseBlock
	"Mimic the old BinaryChoice protocol.  Canceling the menu by clicking outside executes false block"
	| answer |
	answer := PopUpMenu withCaption: aString chooseFrom: #( 'Yes' 'No').
	answer = 1 ifTrue: trueBlock ifFalse: falseBlock! !

!BitBlt methodsFor: 'accessing' stamp: 'dmu 4/4/2009 00:24'!
copyBitsOnMain
	"Primitive. Perform the movement of bits from the source form to the 
	destination form. Fail if any variables are not of the right type (Integer, 
	Float, or Form) or if the combination rule is not implemented. 
	In addition to the original 16 combination rules, this BitBlt supports
	16	fail (to simulate paint)
	17	fail (to simulate mask)
	18	sourceWord + destinationWord
	19	sourceWord - destinationWord
	20	rgbAdd: sourceWord with: destinationWord
	21	rgbSub: sourceWord with: destinationWord
	22	rgbDiff: sourceWord with: destinationWord
	23	tallyIntoMap: destinationWord
	24	alphaBlend: sourceWord with: destinationWord
	25	pixPaint: sourceWord with: destinationWord
	26	pixMask: sourceWord with: destinationWord
	27	rgbMax: sourceWord with: destinationWord
	28	rgbMin: sourceWord with: destinationWord
	29	rgbMin: sourceWord bitInvert32 with: destinationWord
"
	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>

	"Check for compressed source, destination or halftone forms"
	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:
		["No alpha specified -- re-run with alpha = 1.0"
		^ self copyBitsTranslucent: 255].
	((sourceForm isForm) and: [sourceForm unhibernate])
		ifTrue: [^ self copyBits].
	((destForm isForm) and: [destForm unhibernate])
		ifTrue: [^ self copyBits].
	((halftoneForm isForm) and: [halftoneForm unhibernate])
		ifTrue: [^ self copyBits].

	"Check for unimplmented rules"
	combinationRule = Form oldPaint ifTrue: [^ self paintBits].
	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].

	"Check if BitBlt doesn't support full color maps"
	(colorMap notNil and:[colorMap isColormap]) ifTrue:[
		colorMap _ colorMap colors.
		^self copyBits].
	"Check if clipping gots us way out of range"
	self clipRange ifTrue:[^self copyBits].

	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.
	"Convert all numeric parameters to integers and try again."
	destX _ destX asInteger.
	destY _ destY asInteger.
	width _ width asInteger.
	height _ height asInteger.
	sourceX _ sourceX asInteger.
	sourceY _ sourceY asInteger.
	clipX _ clipX asInteger.
	clipY _ clipY asInteger.
	clipWidth _ clipWidth asInteger.
	clipHeight _ clipHeight asInteger.
	^ self copyBitsAgain! !

!BitBlt methodsFor: 'copying' stamp: 'ssa 4/7/2009 13:44'!
OLDcopyBits
	"Primitive. Perform the movement of bits from the source form to the 
	destination form. Fail if any variables are not of the right type (Integer, 
	Float, or Form) or if the combination rule is not implemented. 
	In addition to the original 16 combination rules, this BitBlt supports
	16	fail (to simulate paint)
	17	fail (to simulate mask)
	18	sourceWord + destinationWord
	19	sourceWord - destinationWord
	20	rgbAdd: sourceWord with: destinationWord
	21	rgbSub: sourceWord with: destinationWord
	22	rgbDiff: sourceWord with: destinationWord
	23	tallyIntoMap: destinationWord
	24	alphaBlend: sourceWord with: destinationWord
	25	pixPaint: sourceWord with: destinationWord
	26	pixMask: sourceWord with: destinationWord
	27	rgbMax: sourceWord with: destinationWord
	28	rgbMin: sourceWord with: destinationWord
	29	rgbMin: sourceWord bitInvert32 with: destinationWord
"
	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>

	"Check for compressed source, destination or halftone forms"
	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:
		["No alpha specified -- re-run with alpha = 1.0"
		^ self copyBitsTranslucent: 255].
	((sourceForm isForm) and: [sourceForm unhibernate])
		ifTrue: [^ self copyBits].
	((destForm isForm) and: [destForm unhibernate])
		ifTrue: [^ self copyBits].
	((halftoneForm isForm) and: [halftoneForm unhibernate])
		ifTrue: [^ self copyBits].

	"Check for unimplmented rules"
	combinationRule = Form oldPaint ifTrue: [^ self paintBits].
	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].

	"Check if BitBlt doesn't support full color maps"
	(colorMap notNil and:[colorMap isColormap]) ifTrue:[
		colorMap _ colorMap colors.
		^self copyBits].
	"Check if clipping gots us way out of range"
	self clipRange ifTrue:[^self copyBits].

	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.
	"Convert all numeric parameters to integers and try again."
	destX _ destX asInteger.
	destY _ destY asInteger.
	width _ width asInteger.
	height _ height asInteger.
	sourceX _ sourceX asInteger.
	sourceY _ sourceY asInteger.
	clipX _ clipX asInteger.
	clipY _ clipY asInteger.
	clipWidth _ clipWidth asInteger.
	clipHeight _ clipHeight asInteger.
	^ self copyBitsAgain! !

!BitBlt methodsFor: 'copying' stamp: 'ads 1/24/2011 13:00'!
copyBits
	RVMPrimitivesNeededForBootstrapping isRVM ifFalse:[^self OLDcopyBits].
 	destForm == Display  ifTrue: [self copyBitsOnMain] ifFalse: [self copyBitsLocally]! !

!BitBlt methodsFor: 'copying' stamp: 'dmu 4/4/2009 00:20'!
copyBitsLocally
	"Primitive. Perform the movement of bits from the source form to the 
	destination form. Fail if any variables are not of the right type (Integer, 
	Float, or Form) or if the combination rule is not implemented. 
	In addition to the original 16 combination rules, this BitBlt supports
	16	fail (to simulate paint)
	17	fail (to simulate mask)
	18	sourceWord + destinationWord
	19	sourceWord - destinationWord
	20	rgbAdd: sourceWord with: destinationWord
	21	rgbSub: sourceWord with: destinationWord
	22	rgbDiff: sourceWord with: destinationWord
	23	tallyIntoMap: destinationWord
	24	alphaBlend: sourceWord with: destinationWord
	25	pixPaint: sourceWord with: destinationWord
	26	pixMask: sourceWord with: destinationWord
	27	rgbMax: sourceWord with: destinationWord
	28	rgbMin: sourceWord with: destinationWord
	29	rgbMin: sourceWord bitInvert32 with: destinationWord
"
	<primitive: 'primitiveCopyBitsLocally'>

	"Check for compressed source, destination or halftone forms"
	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:
		["No alpha specified -- re-run with alpha = 1.0"
		^ self copyBitsTranslucent: 255].
	((sourceForm isForm) and: [sourceForm unhibernate])
		ifTrue: [^ self copyBits].
	((destForm isForm) and: [destForm unhibernate])
		ifTrue: [^ self copyBits].
	((halftoneForm isForm) and: [halftoneForm unhibernate])
		ifTrue: [^ self copyBits].

	"Check for unimplmented rules"
	combinationRule = Form oldPaint ifTrue: [^ self paintBits].
	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].

	"Check if BitBlt doesn't support full color maps"
	(colorMap notNil and:[colorMap isColormap]) ifTrue:[
		colorMap _ colorMap colors.
		^self copyBits].
	"Check if clipping gots us way out of range"
	self clipRange ifTrue:[^self copyBits].

	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.
	"Convert all numeric parameters to integers and try again."
	destX _ destX asInteger.
	destY _ destY asInteger.
	width _ width asInteger.
	height _ height asInteger.
	sourceX _ sourceX asInteger.
	sourceY _ sourceY asInteger.
	clipX _ clipX asInteger.
	clipY _ clipY asInteger.
	clipWidth _ clipWidth asInteger.
	clipHeight _ clipHeight asInteger.
	^ self copyBitsAgain! !

!BitBlt methodsFor: 'line drawing' stamp: 'ads 1/24/2011 13:00'!
drawFrom: startPoint to: stopPoint withFirstPoint: drawFirstPoint
	"Draw a line whose end points are startPoint and stopPoint.
	The line is formed by repeatedly calling copyBits at every
	point along the line.  If drawFirstPoint is false, then omit
	the first point so as not to overstrike at line junctions."
	| offset point1 point2 forwards |
	"Always draw down, or at least left-to-right"
	forwards _ (startPoint y = stopPoint y and: [startPoint x < stopPoint x])
				or: [startPoint y < stopPoint y].
	forwards
		ifTrue: [point1 _ startPoint. point2 _ stopPoint]
		ifFalse: [point1 _ stopPoint. point2 _ startPoint].
	sourceForm == nil ifTrue:
		[destX _ point1 x.
		destY _ point1 y]
		ifFalse:
		[width _ sourceForm width.
		height _ sourceForm height.
		offset _ sourceForm offset.
		destX _ (point1 x + offset x) rounded.
		destY _ (point1 y + offset y) rounded].

	"Note that if not forwards, then the first point is the last and vice versa.
	We agree to always paint stopPoint, and to optionally paint startPoint."
	(drawFirstPoint or: [forwards == false  "ie this is stopPoint"])
		ifTrue: [self copyBits].
		(destForm == Display or:[RVMPrimitivesNeededForBootstrapping isRVM not]) ifTrue: [
	self drawLoopX: (point2 x - point1 x) rounded 
				  Y: (point2 y - point1 y) rounded]
			ifFalse: [self drawLoopLocallyX: (point2 x - point1 x) rounded 
				  Y: (point2 y - point1 y) rounded].
	(drawFirstPoint or: [forwards  "ie this is stopPoint"])
		ifTrue: [self copyBits].
! !

!BitBlt methodsFor: 'line drawing' stamp: 'dmu 4/3/2009 23:01'!
drawLoopLocallyX: xDelta Y: yDelta 
	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems
	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and
	maintains a potential, P. When P's sign changes, it is time to move in
	the minor direction as well. This particular version does not write the
	first and last points, so that these can be called for as needed in client code.
	Optional. See Object documentation whatIsAPrimitive."
	| |
	<primitive: 'primitiveDrawLoopLocally'>
self primitiveFailed! !

!BitBlt methodsFor: 'line drawing' stamp: 'ads 1/24/2011 13:01'!
drawLoopX: xDelta Y: yDelta 
	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems
	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and
	maintains a potential, P. When P's sign changes, it is time to move in
	the minor direction as well. This particular version does not write the
	first and last points, so that these can be called for as needed in client code.
	Optional. See Object documentation whatIsAPrimitive."
	
		^(destForm == Display  or:[RVMPrimitivesNeededForBootstrapping isRVM not])
			ifTrue:[self globalDrawLoopX:xDelta Y: yDelta ]
			ifFalse:[self localDrawLoopX:xDelta Y: yDelta ]! !

!BitBlt methodsFor: 'line drawing' stamp: 'ssa 4/3/2009 22:36'!
globalDrawLoopX: xDelta Y: yDelta 
	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems
	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and
	maintains a potential, P. When P's sign changes, it is time to move in
	the minor direction as well. This particular version does not write the
	first and last points, so that these can be called for as needed in client code.
	Optional. See Object documentation whatIsAPrimitive."
	| dx dy px py P |
	<primitive: 'primitiveDrawLoop' module: 'BitBltPlugin'>
	dx _ xDelta sign.
	dy _ yDelta sign.
	px _ yDelta abs.
	py _ xDelta abs.
	"self copyBits."
	py > px
		ifTrue: 
			["more horizontal"
			P _ py // 2.
			1 to: py do: 
				[:i |
				destX _ destX + dx.
				(P _ P - px) < 0 ifTrue: 
						[destY _ destY + dy.
						P _ P + py].
				i < py ifTrue: [self copyBits]]]
		ifFalse: 
			["more vertical"
			P _ px // 2.
			1 to: px do:
				[:i |
				destY _ destY + dy.
				(P _ P - py) < 0 ifTrue: 
						[destX _ destX + dx.
						P _ P + px].
				i < px ifTrue: [self copyBits]]]! !

!BitBlt methodsFor: 'line drawing' stamp: 'ssa 4/3/2009 22:52'!
localDrawLoopX: xDelta Y: yDelta 
	"Primitive"
	<primitive: 'primitiveDrawLoopLocally'>
	^self primitiveFailed! !

!BitBlt class methodsFor: 'examples' stamp: 'di 12/1/97 12:08'!
alphaBlendDemo
	"To run this demo, use...
		Display restoreAfter: [BitBlt alphaBlendDemo]	
	Displays 10 alphas, then lets you paint.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  

	"compute color maps if needed"
	Display depth <= 8 ifTrue: [
		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.
		map32toD _ Color cachedColormapFrom: 32 to: Display depth].

	"display 10 different alphas, across top of screen"
	buff _ Form extent: 500@50 depth: 32.
	dispToBuff _ BitBlt toForm: buff.
	dispToBuff colorMap: mapDto32.
	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.
	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)
						fillColor: (Color red alpha: i/10)
						rule: Form blend].
	buffToDisplay _ BitBlt toForm: Display.
	buffToDisplay colorMap: map32toD.
	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.

	"Create a brush with radially varying alpha"
	brush _ Form extent: 30@30 depth: 32.
	1 to: 5 do: 
		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)
				fillColor: (Color red alpha: 0.02 * i - 0.01)
				at: brush extent // 2].

	"Now paint with the brush using alpha blending."
	buffSize _ 100.
	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"
	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"
	dispToBuff colorMap: mapDto32.
	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"
	brushToBuff sourceForm: brush; sourceOrigin: 0@0.
	brushToBuff combinationRule: Form blend.
	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor yellowButtonPressed] whileFalse:
		[prevP _ nil.
		buffRect _ Sensor cursorPoint - (buffSize // 2) extent: buff extent.
		dispToBuff copyFrom: buffRect in: Display to: 0@0.
		[Sensor redButtonPressed] whileTrue:
			["Here is the painting loop"
			p _ Sensor cursorPoint - (brush extent // 2).
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP _ p].
				(p dist: prevP) > buffSize ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta _ (p-prevP) theta.
					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].
				brushRect _ p extent: brush extent.
				(buffRect containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta _ brushRect amountToTranslateWithin: buffRect.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta.
					newBuffRect _ buffRect translateBy: delta negated.
					(newBuffRect areasOutside: buffRect) do:
						[:r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin].
					buffRect _ newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP - buffRect origin
									to: p - buffRect origin
									withFirstPoint: false.

				"Update (only) the altered pixels of the destination"
				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.
				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.
				prevP _ p]]]! !

!BitBlt class methodsFor: 'examples' stamp: 'di 12/1/97 12:09'!
antiAliasDemo 
	"To run this demo, use...
		Display restoreAfter: [BitBlt antiAliasDemo]
	Goes immediately into on-screen paint mode.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"
	
	"This version also uses WarpBlt to paint into twice as large a buffer,
	and then use smoothing when reducing back down to the display.
	In fact this same routine will now work for 3x3 soothing as well.
	Remove the statements 'buff displayAt: 0@0' to hide the buffer. - di 3/19/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect scale p0 |  
	"compute color maps if needed"
	Display depth <= 8 ifTrue: [
		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.
		map32toD _ Color cachedColormapFrom: 32 to: Display depth].

	"Create a brush with radially varying alpha"
	brush _ Form extent: 3@3 depth: 32.
	brush fill: brush boundingBox fillColor: (Color red alpha: 0.05).
	brush fill: (1@1 extent: 1@1) fillColor: (Color red alpha: 0.2).

	scale _ 2.  "Actual drawing happens at this magnification"
	"Scale brush up for painting in magnified buffer"
	brush _ brush magnify: brush boundingBox by: scale.

	"Now paint with the brush using alpha blending."
	buffSize _ 100.
	buff _ Form extent: (brush extent + buffSize) * scale depth: 32.  "Travelling 32-bit buffer"
	dispToBuff _ (WarpBlt toForm: buff)  "From Display to buff - magnify by 2"
		sourceForm: Display;
		colorMap: mapDto32;
		combinationRule: Form over.
	brushToBuff _ (BitBlt toForm: buff)  "From brush to buff"
		sourceForm: brush;
		sourceOrigin: 0@0;
		combinationRule: Form blend.
	buffToDisplay _ (WarpBlt toForm: Display)  "From buff to Display - shrink by 2"
		sourceForm: buff;
		colorMap: map32toD;
		cellSize: scale;  "...and use smoothing"
		combinationRule: Form over.
	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor yellowButtonPressed] whileFalse:
		[prevP _ nil.
		buffRect _ Sensor cursorPoint - (buff extent // scale // 2) extent: buff extent // scale.
		p0 _ (buff extent // 2) - (buffRect extent // 2).
		dispToBuff copyQuad: buffRect innerCorners toRect: buff boundingBox.
buff displayAt: 0@0.  "** remove to hide sliding buffer **"
		[Sensor redButtonPressed] whileTrue:
			["Here is the painting loop"
			p _ Sensor cursorPoint - buffRect origin + p0.  "p, prevP are rel to buff origin"
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP _ p].
				(p dist: prevP) > (buffSize-1) ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta _ (p-prevP) theta.
					p _ ((theta cos@theta sin) * (buffSize-2) asFloat + prevP) truncated].
				brushRect _ p extent: brush extent.
				((buff boundingBox insetBy: scale) containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta _ (brushRect amountToTranslateWithin: (buff boundingBox insetBy: scale)) // scale.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta*scale.
					newBuffRect _ buffRect translateBy: delta negated.
					p _ p translateBy: delta*scale.
					prevP _ prevP translateBy: delta*scale.
					(newBuffRect areasOutside: buffRect) do:
						[:r | dispToBuff copyQuad: r innerCorners toRect: (r origin - newBuffRect origin*scale extent: r extent*scale)].
					buffRect _ newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP to: p withFirstPoint: false.
buff displayAt: 0@0.  "** remove to hide sliding buffer **"

				"Update (only) the altered pixels of the destination"
				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.
				updateRect _ updateRect origin // scale * scale
						corner: updateRect corner + scale // scale * scale.
				buffToDisplay copyQuad: updateRect innerCorners
							toRect: (updateRect origin // scale + buffRect origin
										extent: updateRect extent // scale).
				prevP _ p]]]! !

!BitBlt class methodsFor: 'examples' stamp: 'ssa 10/27/2008 16:38'!
exampleColorMap	"BitBlt exampleColorMap"
	"This example shows what one can do with the fixed part of a color map. The color map, as setup below, rotates the bits of a pixel all the way around. Thus you'll get a (sometime strange looking ;-) animation of colors which will end up exactly the way it looked at the beginning. The example is given to make you understand that the masks and shifts can be used for a lot more than simply color converting pixels. In this example, for instance, we use only two of the four independent shifters."
	| cc bb |
	cc _ ColorMap masks: {
		1 << (Display depth-1). "mask out high bit of color component"
		1 << (Display depth-1) - 1. "mask all other bits"
		0.
		0}
		shifts: {
			1 - Display depth. "shift right to bottom most position"
			1. "shift all other pixels one bit left"
			0.
			0}.
	bb _ BitBlt toForm: Display.
	bb 
		sourceForm: Display;
		combinationRule: 3;
		colorMap: cc.
	1 to: Display depth do:[:i|
		bb copyBits.
		Display forceDisplayUpdate.
		Sensor waitButton;waitNoButton
	].
! !

!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 4/24/2001 23:49'!
benchDiffsFrom: before to: afterwards
	"Given two outputs of BitBlt>>benchmark show the relative improvements."
	| old new log oldLine newLine oldVal newVal improvement |
	log _ WriteStream on: String new.
	old _ ReadStream on: before.
	new _ ReadStream on: afterwards.
	[old atEnd or:[new atEnd]] whileFalse:[
		oldLine _ old upTo: Character cr.
		newLine _ new upTo: Character cr.
		(oldLine includes: Character tab) ifTrue:[
			oldLine _ ReadStream on: oldLine.
			newLine _ ReadStream on: newLine.
			Transcript cr; show: (oldLine upTo: Character tab); tab.
			log cr; nextPutAll: (newLine upTo: Character tab); tab.

			[oldLine skipSeparators. newLine skipSeparators.
			oldLine atEnd] whileFalse:[
				oldVal _ Integer readFrom: oldLine.
				newVal _ Integer readFrom: newLine.
				improvement _ oldVal asFloat / newVal asFloat roundTo: 0.01.
				Transcript show: improvement printString; tab; tab.
				log print: improvement; tab; tab].
		] ifFalse:[
			Transcript cr; show: oldLine.
			log cr; nextPutAll: oldLine.
		].
	].
	^log contents! !

!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 5/14/2001 23:31'!
benchmark2		"BitBlt benchmark"
	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.
	Attention: *this*may*take*a*while*"
	| bb source dest destRect log t |
	log _ WriteStream on: String new.
	destRect _ 0@0 extent: 600@600.
	"Form paint/Form over - the most common rules"
	#( 25 3 ) do:[:rule|
		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.
		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.
		#(1 2 4 8 16 32) do:[:destDepth|
			dest _ nil.
			dest _ Form extent: destRect extent depth: destDepth.
			Transcript cr.
			log cr.
			#(1 2 4 8 16 32) do:[:sourceDepth|
				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.
				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.
				source _ nil. bb _ nil.
				source _ Form extent: destRect extent depth: sourceDepth.
				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.
				bb _ WarpBlt toForm: dest.
				bb sourceForm: source.
				bb sourceRect: source boundingBox.
				bb destRect: dest boundingBox.
				bb colorMap: (source colormapIfNeededFor: dest).
				bb combinationRule: rule.

				"Measure speed of copyBits"
				t _ Time millisecondsToRun:[1 to: 10 do:[:i| bb copyBits]].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				bb sourceForm: source destRect: source boundingBox.

				"Measure speed of 1x1 warpBits"
				bb cellSize: 1.
				t _ Time millisecondsToRun:[1 to: 4 do:[:i| bb warpBits]].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				"Measure speed of 2x2 warpBits"
				bb cellSize: 2.
				t _ Time millisecondsToRun:[bb warpBits].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				"Measure speed of 3x3 warpBits"
				bb cellSize: 3.
				t _ Time millisecondsToRun:[bb warpBits].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.
			].
		].
	].
	^log contents! !

!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 4/26/2001 21:04'!
benchmark3		"BitBlt benchmark"
	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.
	Attention: *this*may*take*a*while*"
	| bb source dest destRect log t |
	log _ WriteStream on: String new.
	destRect _ 0@0 extent: 600@600.
	"Form paint/Form over - the most common rules"
	#( 25 3 ) do:[:rule|
		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.
		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.
		#(1 2 4 8 16 32) do:[:destDepth|
			dest _ nil.
			dest _ Form extent: destRect extent depth: destDepth.
			Transcript cr.
			log cr.
			#(1 2 4 8 16 32) do:[:sourceDepth|
				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.
				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.
				source _ nil. bb _ nil.
				source _ Form extent: destRect extent depth: sourceDepth.
				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.
				bb _ WarpBlt toForm: dest.
				bb sourceForm: source.
				bb sourceRect: source boundingBox.
				bb destRect: dest boundingBox.
				bb colorMap: (source colormapIfNeededFor: dest).
				bb combinationRule: rule.

				"Measure speed of copyBits"
				t _ Time millisecondsToRun:[1 to: 10 do:[:i| bb copyBits]].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				bb sourceForm: source destRect: source boundingBox.

				"Measure speed of 1x1 warpBits"
				bb cellSize: 1.
				t _ Time millisecondsToRun:[1 to: 4 do:[:i| bb warpBits]].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				"Measure speed of 2x2 warpBits"
				bb cellSize: 2.
				t _ Time millisecondsToRun:[bb warpBits].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				"Measure speed of 3x3 warpBits"
				bb cellSize: 3.
				t _ Time millisecondsToRun:[bb warpBits].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.
			].
		].
	].
	^log contents! !

!BlockContext methodsFor: '*Sly3' stamp: 'dmu 9/17/2010 10:58'!
asSlyMemberProcess
	^ self copy fixTemps newProcess beSlyMemberProcess! !

!BlockContext methodsFor: 'controlling' stamp: 'ssa 8/24/2009 16:18'!
loopExit
	[self value: [^ self]] repeat! !

!BlockContext methodsFor: 'controlling' stamp: 'ssa 8/24/2009 16:43'!
untilFalse: aBlock

	[self value. aBlock value ifFalse: [^ self]] repeat

	! !

!BlockContext methodsFor: 'converting' stamp: 'ssa 9/7/2009 14:36'!
asContext

	^self! !

!BlockContext methodsFor: 'evaluating' stamp: 'dmu 8/17/2009 21:52'!
value: arg1 value: arg2 value: arg3 value: arg4  value: arg5
	"Primitive. Evaluate the block represented by the receiver. Fail if the 
	block expects other than three arguments or if the block is already being 
	executed. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 81>
	^self valueWithArguments: 
		(Array
			with: arg1
			with: arg2
			with: arg3
			with: arg4
			with: arg5)! !

!BlockContext methodsFor: 'printing' stamp: 'ssa 11/27/2009 16:55'!
asString

	| str |
	str _ (((self decompile ifNil: ['--source missing--']) printString
						replaceAll: Character cr with: Character space)
							replaceAll: Character tab with: Character space).
	^str copyFrom: 2 to: str size - 1! !

!BlockContext methodsFor: 'printing' stamp: 'ads 1/24/2011 13:02'!
printOn: aStream
	| blockString truncatedBlockString |
	aStream nextPutAll:(RVMPrimitivesNeededForBootstrapping printPrefixFor: self).
	home == nil ifTrue: [^aStream nextPutAll: 'a BlockContext with home=nil'].
	aStream nextPutAll: '[] in '.
	super printOn: aStream.
	aStream nextPutAll: ' '.
	blockString _ ((self decompile ifNil: ['--source missing--']) printString
						replaceAll: Character cr with: Character space)
							replaceAll: Character tab with: Character space.
	truncatedBlockString _ blockString truncateWithElipsisTo: 800.
	truncatedBlockString size < blockString size ifTrue:
		[truncatedBlockString _ truncatedBlockString, ']}'].
	aStream nextPutAll: truncatedBlockString.
! !

!BlockContext methodsFor: 'scheduling' stamp: 'dmu 4/7/2009 02:34'!
forkWith: anObject
	"Create and schedule a Process running the code in the receiver."

	^ (self newProcessWith: anObject) resume! !

!BlockContext methodsFor: 'scheduling' stamp: 'dmu 4/7/2009 02:33'!
newProcessWith: anObject
	"Answer a Process running the code in the receiver. The process is not 
	scheduled."
	<primitive: 19> "Simulation guard"
	^Process
		forContext: 
			[self value: anObject.
			Processor terminateActive]
		priority: Processor activePriority! !

!BlockContext methodsFor: 'private' stamp: 'dmu 11/25/2008 00:18'!
valueUnpreemptively
	"Evaluate the receiver (block), without the possibility of preemption by higher priority processes. Use this facility VERY sparingly!!"
	"Think about using Block>>valueUninterruptably first, and think about using Semaphore>>critical: before that, and think about redesigning your application even before that!! 
	After you've done all that thinking, go right ahead and use it..."
	| activeProcess oldPriority result |
	activeProcess _ Processor thisProcess.
	oldPriority _ activeProcess priority.
	activeProcess priority: Processor highestPriority.
	result _ self ensure: [activeProcess priority: oldPriority].
	"Yield after restoring priority to give the preempted processes a chance to run"
	Processor yield.
	^result! !

!BlockContext methodsFor: '*RVM' stamp: 'ads 1/30/2011 15:22'!
cyclesToRunMe
	| s delta correction result |
	s _ RVMOperations cycleCounter.
	self value.
	delta _  RVMOperations cycleCounter - s.
	^ delta < 0 ifTrue: [ 
		correction _ SmallInteger maxVal + 1. 
		result _ delta.
		[result < 0] whileTrue: [result _ result + correction].
		result
	] ifFalse: [delta]! !

!BlockContext methodsFor: '*RVM' stamp: 'dmu 4/7/2009 02:38'!
forkOn: aCore
	"Create and schedule a Process running the code in the receiver."

	^ self newProcess resumeOn: aCore! !

!BlockContext methodsFor: '*RVM' stamp: 'ssa 4/8/2009 20:09'!
forkOn: aCore with: anObject
	"Create and schedule a Process running the code in the receiver."

	^ (self newProcessWith: anObject) resumeOn: aCore! !

!BlockContext methodsFor: '*RVM' stamp: 'ssa 4/8/2009 20:08'!
forkOn: aCore with: anObject at: aPriority
	"Create and schedule a Process running the code in the receiver."

	| proc |
	proc _ self newProcessWith: anObject.
	proc priority: aPriority.
	^proc resumeOn: aCore! !

!BlockNode methodsFor: 'accessing' stamp: 'dmu 1/21/2010 15:22'!
returnSelfIfNoOther

	self returns
		ifFalse: 
			[statements last == NodeSelf ifFalse: [
				(statements isKindOf: Array) ifTrue: [statements _ statements asOrderedCollection].
				statements add: NodeSelf
			].
			self returnLast]! !

!BlockingSmallSet methodsFor: 'adding' stamp: 'max 9/29/2010 14:37'!
add: anObject 
	(self includes: anObject)
		ifFalse: [mutex critical: [super addLast: anObject]]! !

!BlockingSmallSet methodsFor: 'adding' stamp: 'max 9/15/2010 14:33'!
add: anObject after: anObject2 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'adding' stamp: 'max 9/15/2010 14:33'!
add: anObject afterIndex: anObject2 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'adding' stamp: 'max 9/15/2010 14:33'!
add: anObject before: anObject2 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'adding' stamp: 'max 9/15/2010 14:33'!
add: anObject beforeIndex: anObject2 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'adding' stamp: 'max 9/16/2010 13:13'!
addAll: aCollection 
	"Add each element of aCollection not already included in the reciever, at the end. 
	Use super's method to avoid needless nested blocking. Answer aCollection."

	mutex critical: 
		[aCollection do: [ :each | (array includes: each) ifFalse: [super addLast: each]]].
	^aCollection! !

!BlockingSmallSet methodsFor: 'adding' stamp: 'max 9/15/2010 14:33'!
addAllFirst: anObject 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'adding' stamp: 'max 9/15/2010 14:33'!
addAllFirstUnlessAlreadyPresent: anObject 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'adding' stamp: 'max 9/16/2010 13:04'!
addAllLast: aCollection 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'adding' stamp: 'max 9/15/2010 14:33'!
addFirst: anObject 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'adding' stamp: 'max 9/16/2010 13:07'!
addLast: anObject 
	self add: anObject! !

!BlockingSmallSet methodsFor: 'adding' stamp: 'max 9/15/2010 14:33'!
at: anObject ifAbsentPut: anObject2 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'accessing' stamp: 'max 9/15/2010 14:33'!
at: anObject put: anObject2 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'enumerating' stamp: 'max 9/16/2010 12:38'!
collect: aBlock from: fromIndex to: toIndex
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'enumerating' stamp: 'max 9/15/2010 14:33'!
with: anObject collect: anObject2 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'enumerating' stamp: 'max 9/15/2010 14:33'!
withIndexCollect: anObject 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'copying' stamp: 'max 9/15/2010 14:33'!
copyFrom: anObject to: anObject2 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'copying' stamp: 'max 9/15/2010 14:33'!
copyReplaceFrom: anObject to: anObject2 with: anObject3 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'copying' stamp: 'max 9/15/2010 14:33'!
copyWith: anObject 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'copying' stamp: 'max 9/15/2010 14:33'!
reversed
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'removing' stamp: 'max 9/15/2010 15:15'!
remove: anObject
	self remove: anObject ifAbsent: []! !

!BlockingSmallSet methodsFor: 'removing' stamp: 'max 9/15/2010 15:13'!
remove: anObject ifAbsent: absentBlock 
	mutex critical: [super remove: anObject ifAbsent: absentBlock]! !

!BlockingSmallSet methodsFor: 'removing' stamp: 'dmu 9/23/2010 14:28'!
removeAll
	mutex critical: [super setCollection: (Array new: array size)]! !

!BlockingSmallSet methodsFor: 'removing' stamp: 'max 9/17/2010 13:31'!
removeAll: aCollection
	"Remove each element of aCollection, using super's method to avoid needless nested blocking. Answer aCollection."

	mutex critical: 
		[aCollection do: [ :each | super remove: each ifAbsent: []]].
	^aCollection! !

!BlockingSmallSet methodsFor: 'removing' stamp: 'max 9/16/2010 12:24'!
removeAllSuchThat: aBlock 
	mutex critical:
		[ super removeAllSuchThat: aBlock ]! !

!BlockingSmallSet methodsFor: 'removing' stamp: 'max 9/15/2010 14:33'!
removeAt: anObject 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'removing' stamp: 'max 9/15/2010 14:33'!
removeFirst
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'removing' stamp: 'max 9/15/2010 14:33'!
removeFirst: anObject 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'removing' stamp: 'max 9/15/2010 14:33'!
removeLast
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'removing' stamp: 'max 9/15/2010 14:33'!
removeLast: anObject 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'sorting' stamp: 'max 9/15/2010 14:33'!
sort
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'sorting' stamp: 'max 9/15/2010 14:33'!
sort: anObject 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'sorting' stamp: 'max 9/15/2010 14:33'!
sorted: anObject 
	self shouldNotImplement! !

!BlockingSmallSet methodsFor: 'initialize-release' stamp: 'max 9/29/2010 14:38'!
initialize
	super initialize.
	mutex := Semaphore forMutualExclusion! !

!BlockingSmallSet commentStamp: 'max 9/17/2010 12:48' prior: 0!
A BlockingSmallSet is an unindexed collection which behaves like a set, allowing no duplicate elements. It uses a semaphore to ensure that adding and removing operations are atomic and thus thread-safe. It wraps an OrderedCollection, which is simpler than Set's hash-based implementation and may be more efficient for small numbers of elements.

BlockingSmallSets block on recieving any of (#add: #remove: #addAll: #removeAll:). They also respond to: #intersection:, #union:, and all the standard enumeration messages. However, care should be taken when using any #do:-based enumerator which may affect the state of the reciever: while each individual successive #add: or #remove: is atomic, the overall enumeration is not.!
!BlockingSmallSet class methodsFor: 'as yet unclassified' stamp: 'max 9/15/2010 17:55'!
new
	| bss |
	bss := super new.
	bss initialize.
	^ bss! !

!Boolean methodsFor: 'debugging' stamp: 'ssa 3/11/2010 11:54'!
haltIfFalse

	! !

!Boolean methodsFor: 'debugging' stamp: 'ssa 3/11/2010 11:54'!
haltIfTrue

! !

!Boolean methodsFor: 'testing' stamp: 'ssa 6/1/2010 16:46'!
mustBeBoolean
	^false! !

!Boolean methodsFor: 'testing' stamp: 'ssa 6/1/2010 16:47'!
mustBeBooleanIn: aContext
	^true! !

!Boolean methodsFor: '*Sly' stamp: 'ssa 5/27/2010 10:41'!
isBoolean
	"Return true if the receiver is true or false.
	Note: Do not override in any class except Boolean."
	^true! !

!Browser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 09:01'!
classOrganizer
	"Answer the value of classOrganizer"

	classOrganizer isNil ifTrue:[self classOrganizer: nil].
	^ classOrganizer! !

!Browser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 09:01'!
classOrganizer: anObject
	"Set the value of classOrganizer"

	classOrganizer _ anObject! !

!Browser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 09:40'!
lastClassSelected
	"Answer the value of lastClassSelected"

	lastClassSelected isNil ifTrue:[self lastClassSelected: self selectedClassOrMetaClass].
	^ lastClassSelected! !

!Browser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 09:01'!
lastClassSelected: anObject
	"Set the value of lastClassSelected"

	lastClassSelected _ anObject! !

!Browser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 09:01'!
metaClassOrganizer
	"Answer the value of metaClassOrganizer"

	metaClassOrganizer isNil ifTrue:[self metaClassOrganizer: nil].
	^ metaClassOrganizer! !

!Browser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 09:01'!
metaClassOrganizer: anObject
	"Set the value of metaClassOrganizer"

	metaClassOrganizer _ anObject! !

!Browser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 09:01'!
systemOrganizer
	"Answer the value of systemOrganizer"

	systemOrganizer isNil ifTrue:[self systemOrganizer: nil].
	^ systemOrganizer! !

!Browser methodsFor: 'class functions' stamp: 'ssa 8/27/2009 05:09'!
createInstVarAccessors
	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"

	| aClass newMessage setter |
	(aClass _ self selectedClassOrMetaClass) ifNotNil:
		[aClass instVarNames do: 
			[:aName |
				(aClass canUnderstand: aName asSymbol)
					ifFalse:
						[newMessage _ aName, '
	"Answer the value of ', aName, '"

	',aName,' isNil ifTrue:[self ',aName,': nil].
	^ ', aName.
						aClass compile: newMessage classified: 'accessing' notifying: nil].
				(aClass canUnderstand: (setter _ aName, ':') asSymbol)
					ifFalse:
						[newMessage _ setter, ' anObject
	"Set the value of ', aName, '"

	', aName, ' _ anObject'.
						aClass compile: newMessage classified: 'accessing' notifying: nil]]].
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self contentsChanged.
	self selectMessageCategoryNamed:'accessing'! !

!Browser methodsFor: 'class list' stamp: 'ssa 9/9/2009 09:03'!
classListIndex: anInteger 
	"Set anInteger to be the index of the current class selection."

	| className |

	classListIndex _ anInteger.
	self lastClassSelected: self selectedClassOrMetaClass.
	self setClassOrganizer.
	messageCategoryListIndex _ 0.
	messageListIndex _ 0.
	self classCommentIndicated
		ifTrue: []
		ifFalse: [self editSelection: (anInteger = 0
					ifTrue: [metaClassIndicated | (systemCategoryListIndex == 0)
						ifTrue: [#none]
						ifFalse: [#newClass]]
					ifFalse: [#editClass])].
	contents _ nil.
	self selectedClass isNil
		ifFalse: [className _ self selectedClass name.
					(RecentClasses includes: className)
				ifTrue: [RecentClasses remove: className].
			RecentClasses addFirst: className.
			RecentClasses size > 16
				ifTrue: [RecentClasses removeLast]].
	self changed: #classSelectionChanged.
	self changed: #classCommentText.
	self changed: #classListIndex.	"update my selection"
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self contentsChanged! !

!Browser methodsFor: 'initialize-release' stamp: 'ssa 9/10/2009 13:32'!
setClass: aBehavior selector: aSymbol 
	"Set the state of a new, uninitialized Browser."

	| isMeta aClass messageCatIndex |
	aBehavior ifNil: [^ self].
	(aBehavior isKindOf: Metaclass)
		ifTrue: [
			isMeta _ true.
			aClass _ aBehavior soleInstance]
		ifFalse: [
			isMeta _ false.
			aClass _ aBehavior].
	self selectCategoryForClass: aClass.
	self classListIndex: (
		(SystemOrganization listAtCategoryNamed: self selectedSystemCategoryName)
			indexOf: aClass name).
	self metaClassIndicated: isMeta.
	aSymbol ifNil: [^ self].
	messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.
	self messageCategoryListIndex: (messageCatIndex > 0
		ifTrue: [messageCatIndex + 1]
		ifFalse: [0]).
	messageCatIndex = 0 ifTrue: [^ self].
	self messageListIndex: (
		(aBehavior organization listAtCategoryNumber: messageCatIndex)
			indexOf: aSymbol).! !

!Browser methodsFor: 'message functions' stamp: 'ssa 9/9/2009 09:05'!
defineMessage: aString notifying: aController 
	"Compile the expressions in aString. Notify aController if a syntax error 
	occurs. Install the compiled method in the selected class classified under 
	the currently selected message category name. Answer true if 
	compilation succeeds, false otherwise."
	| selectedMessageName selector category oldMessageList |
	selectedMessageName _ self selectedMessageName.
	oldMessageList _ self messageList.
	contents _ nil.
	selector _ self lastClassSelected "selectedClassOrMetaClass"
				compile: aString
				classified: (category _ self selectedMessageCategoryName)
				notifying: aController.
	selector == nil ifTrue: [^ false].
	contents _ aString copy.
	selector ~~ selectedMessageName
		ifTrue: 
			[category = ClassOrganizer nullCategory
				ifTrue: [self changed: #classSelectionChanged.
						self changed: #classList.
						self messageCategoryListIndex: 1].
			self setClassOrganizer.  "In case organization not cached"
			(oldMessageList includes: selector)
				ifFalse: [self changed: #messageList].
			self messageListIndex: (self messageList indexOf: selector)].
	^ true! !

!Browser methodsFor: 'message functions' stamp: 'ssa 9/9/2009 09:06'!
defineMessageFrom: aString notifying: aController
	"Compile the expressions in aString. Notify aController if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."
	| selectedMessageName selector category oldMessageList |
	selectedMessageName _ self selectedMessageName.
	oldMessageList _ self messageList.
	contents _ nil.
	selector _ (Parser new parseSelector: aString).
	(self metaClassIndicated
		and: [(self lastClassSelected "selectedClassOrMetaClass" includesSelector: selector) not
		and: [Metaclass isScarySelector: selector]])
		ifTrue: ["A frist-time definition overlaps the protocol of Metaclasses"
				(self confirm: ((selector , ' is used in the existing class system.
Overriding it could cause serious problems.
Is this really what you want to do?') asText makeBoldFrom: 1 to: selector size))
				ifFalse: [^nil]].
	selector _ self lastClassSelected "selectedClassOrMetaClass"
				compile: aString
				classified: (category _ self selectedMessageCategoryName)
				notifying: aController.
	selector == nil ifTrue: [^ nil].
	contents _ aString copy.
	selector ~~ selectedMessageName
		ifTrue: 
			[category = ClassOrganizer nullCategory
				ifTrue: [self changed: #classSelectionChanged.
						self changed: #classList.
						self messageCategoryListIndex: 1].
			self setClassOrganizer.  "In case organization not cached"
			(oldMessageList includes: selector)
				ifFalse: [self changed: #messageList].
			self messageListIndex: (self messageList indexOf: selector)].
	^ selector! !

!Browser methodsFor: 'metaclass' stamp: 'ssa 9/10/2009 08:45'!
metaClassIndicated: trueOrFalse 
	"Indicate whether browsing instance or class messages."

	metaClassIndicated _ trueOrFalse.
	self setClassOrganizer.
	systemCategoryListIndex > 0 ifTrue:
		[self editSelection: (classListIndex = 0
			ifTrue: [metaClassIndicated
				ifTrue: [#none]
				ifFalse: [#newClass]]
			ifFalse: [#editClass])].
	messageCategoryListIndex _ 0.
	messageListIndex _ 0.
	contents _ nil.
	self changed: #classSelectionChanged.
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #contents.
	self changed: #annotation.
	self decorateButtons.
	self lastClassSelected: self selectedClassOrMetaClass.
! !

!CPUWatcher methodsFor: 'process operations' stamp: 'dmu 11/25/2008 00:18'!
debugProcess: aProcess
	| uiPriority oldPriority |
	uiPriority _ Processor thisProcess priority.
	aProcess priority >= uiPriority ifTrue: [
		oldPriority _ ProcessBrowser setProcess: aProcess toPriority: uiPriority - 1
	].
	ProcessBrowser debugProcess: aProcess.! !

!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'sm 2/24/2011 16:39'!
startMonitoringPeriod: pd rate: rt threshold: th
	"CPUWatcher startMonitoring"

	CurrentCPUWatcher ifNotNil: [ ^CurrentCPUWatcher startMonitoring. ].
	CurrentCPUWatcher _ (self new)
		monitorProcessPeriod: pd sampleRate: rt;
		threshold: th;
		name: 'CurrentCPUWatcher';
		yourself.
	^CurrentCPUWatcher
! !

!Categorizer methodsFor: '*transporter' stamp: 'ads 12/1/2010 11:49'!
classifyAllFrom: srcCat under: dstCat
	self classifyAll: (self listAtCategoryNamed: srcCat) under: dstCat.
	self removeCategory: srcCat.! !

!Categorizer methodsFor: '*transporter' stamp: 'ads 12/8/2010 14:00'!
removeCategoryIfEmpty: cat
	(self listAtCategoryNamed: cat) isEmpty ifTrue: [self removeCategory: cat].! !

!ChangeList methodsFor: 'scanning' stamp: 'ssa 1/5/2010 15:55'!
scanRecords: someRecords
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	listIndex _ 0.
	someRecords do:[:each|
		each type = #doIt ifTrue:[self addItem: each text: 'do it: ' , (each string contractTo: 50)].
		each type = #preamble ifTrue:[self addItem: each text: 'preamble: ' , (each string contractTo: 50)].
		each type = #classComment ifTrue:[self addItem: each text: 'class comment for ', each methodClassName].
		each type = #method ifTrue:[self addItem: each text:  'method: ',each methodClassName,(each isMetaClassChange ifTrue: [' class '] ifFalse: [' ']),each methodSelector,' ', each stamp]].
	listSelections _ Array new: list size withAll: false! !

!ChangeList methodsFor: 'menu actions' stamp: 'ssa 1/5/2010 12:19'!
changeListMenu: aMenu
	"Fill aMenu up so that it comprises the primary changelist-browser menu"

	aMenu addList: #(

	('fileIn selections'							fileInSelections						'import the selected items into the image')
	('fileOut selections...	'						fileOutSelections						'create a new file containing the selected items')
	-
	('compare to current'						compareToCurrentVersion			'open a separate window which shows the text differences between the on-file version and the in-image version.' )
	('toggle diffing (D)'							toggleDiffing						'start or stop showing diffs in the code pane.')
	-
	('select conflicts with any changeset'		selectAllConflicts					'select methods in the file which also occur in any change-set in the system')
	('select conflicts with current changeset'	selectConflicts						'select methods in the file which also occur in the current change-set')
	('select conflicts with...'						selectConflictsWith					'allows you to designate a file or change-set against which to check for code conflicts.')
	-
	('select changes matching...'					selectChangesMatching				'select changes in the file that match a user-supplied pattern')
	('spawn changes matching...'					spawnChangesMatching				'spawn changes in the file that match a user-supplied pattern into a new change list view')
	('select changes such that...'					selectSuchThat				'select changes in the file that evaluate to true to a user-supplied code fragment')
	('spawn changes such that...'					spawnSuchThat				'spawn changes in the file that evaluate to true to a user-supplied code fragment')
	-
	('select unchanged methods'					selectUnchangedMethods				'select methods in the file whose in-image versions are the same as their in-file counterparts' )
	('select new methods'						selectNewMethods					'select methods in the file that do not current occur in the image')
	('select methods for this class'				selectMethodsForThisClass			'select all methods in the file that belong to the currently-selected class')

	-
	('select all (a)'								selectAll								'select all the items in the list')
	('deselect all'								deselectAll							'deselect all the items in the list')
	('invert selections'							invertSelections						'select every item that is not currently selected, and deselect every item that *is* currently selected')
	('spawn selections'							spawnSelections						'spawn all selected changes into a new change list view')
	-
	('browse current versions of selections'		browseCurrentVersionsOfSelections	'open a message-list browser showing the current (in-image) counterparts of the selected methods')
	('destroy current methods of selections'		destroyCurrentCodeOfSelections		'remove (*destroy*) the in-image counterparts of all selected methods')
	-
	('remove doIts'								removeDoIts							'remove all items that are doIts rather than methods')
	('remove older versions'						removeOlderMethodVersions			'remove all but the most recent versions of methods in the list')
	('remove up-to-date versions'				removeExistingMethodVersions		'remove all items whose code is the same as the counterpart in-image code')
	('remove selected items'						removeSelections					'remove the selected items from the change-list')
	('remove unselected items'					removeNonSelections					'remove all the items not currently selected from the change-list')).

	^ aMenu

! !

!ChangeList methodsFor: 'menu actions' stamp: 'ssa 1/5/2010 14:16'!
selectChangesMatching
	"query the user for a pattern then select all changes matching that pattern"
	| pattern |
	pattern _ FillInTheBlank request: 'Enter a pattern to match to select changes:
# = single character wildcard
* = many character wildcard'. ''
.

	pattern isEmpty ifTrue: [^ self ].

	self selectSuchThat: [:aChangeRecord |  aChangeRecord match: pattern]! !

!ChangeList methodsFor: 'menu actions' stamp: 'ssa 1/5/2010 15:07'!
selectSuchThat
	"query the user for a selection criterio.  By Lex Spoon.  NB: the UI for invoking this from a changelist browser is currently commented out; to reenfranchise it, you'll need to mild editing to ChangeList method #changeListMenu:"
	| code block |
	code _ FillInTheBlank request: 'selection criteria for a change named aChangeRecord?
For instance, 
aChangeRecord category = ''System-Network''
aChangeRecord type = "one of #(#method #doIt #classComment #preamble )"
aChangeRecord text = ''whole change text'' 
aChangeRecord string includesSubString: ''change text substring'' 
aChangeRecord string includesSubString: ''change text substring'' 
''*fooba#'' match: aChangeRecord string  
 ''*fooba#''  match: aChangeRecord methodSelectorSafe
 ''*fooba#'' match: aChangeRecord methodSelectorSafe 
' initialAnswer: 'aChangeRecord match:''*anything#anyChar'''.

	code isEmpty ifTrue: [^ self ].

	block _ Compiler evaluate: '[:aChangeRecord | ', code, ']'.

	self selectSuchThat: block! !

!ChangeList methodsFor: 'menu actions' stamp: 'ssa 1/5/2010 14:46'!
spawnChangesMatching
	"query the user for a pattern then select all changes matching that pattern"
	| pattern |
	pattern _ FillInTheBlank request: 'Enter a pattern to match to select changes:
# = single character wildcard
* = many character wildcard'. ''
.

	pattern isEmpty ifTrue: [^ self ].

	self spawnSuchThat: [:aChangeRecord |  aChangeRecord match: pattern] titled:'Changes matching ',pattern! !

!ChangeList methodsFor: 'menu actions' stamp: 'ssa 1/5/2010 14:55'!
spawnSelections
	"spawn a new changelist view for the selections"
	
	self class browseRecords: self selectedChanges titled:'Selected Changes'! !

!ChangeList methodsFor: 'menu actions' stamp: 'ssa 1/5/2010 15:07'!
spawnSuchThat
	"query the user for a selection criterion block and then spawn"
	| code block |
	code _ FillInTheBlank request: 'selection criteria for a change named aChangeRecord?
For instance, 
aChangeRecord category = ''System-Network''
aChangeRecord type = "one of #(#method #doIt #classComment #preamble )"
aChangeRecord text = ''whole change text'' 
aChangeRecord string includesSubString: ''change text substring'' 
''*foo*ba#'' match: aChangeRecord string  
 ''*foo*ba#''  match: aChangeRecord methodSelectorSafe
 ''*foo*ba#'' match: aChangeRecord methodSelectorSafe 
' initialAnswer: 'aChangeRecord match:''*anything#anyChar'''.


	code isEmpty ifTrue: [^ self ].

	block _ Compiler evaluate: '[:aChangeRecord | ', code, ']'.

	self spawnSuchThat: block titled: 'Changes such that ''',code,'''' ! !

!ChangeList methodsFor: 'menu actions' stamp: 'ssa 1/5/2010 14:58'!
spawnSuchThat: aBlock titled: aString
	"spawn changes passing aBlock"

	| changes |
	changes _ changeList select: [ :change | aBlock value: change ].
	self class browseRecords: changes titled: aString! !

!ChangeList methodsFor: 'viewing access' stamp: 'ssa 1/1/1970 00:15'!
togglePrimaryListIndex: newListIndex 
	listIndex = newListIndex
		ifTrue: [listSelections at: listIndex put: false.
			listIndex := 0]
		ifFalse: [newListIndex ~= 0
				ifTrue: [listSelections at: newListIndex put: true.
					listIndex := newListIndex]].
	self changed: #listIndex.
	self contentsChanged! !

!ChangeList methodsFor: 'accessing' stamp: 'ssa 1/5/2010 13:56'!
changeList: aCollection
	changeList _ aCollection! !

!ChangeList methodsFor: 'accessing' stamp: 'ssa 1/5/2010 14:56'!
selectedChanges

	| sels |
	sels _ OrderedCollection new.
	listSelections with: changeList do: 
		[:selected :item | selected ifTrue: [sels add: item]].
	^sels! !

!ChangeList class methodsFor: 'public access' stamp: 'ssa 1/5/2010 14:45'!
browseRecords: someChangeRecords
	"Opens a changeList on a collection of change records"
	self browseRecords: someChangeRecords titled: 'Some changes'! !

!ChangeList class methodsFor: 'public access' stamp: 'ssa 1/5/2010 14:45'!
browseRecords: someChangeRecords titled: aString
	"Opens a changeList on a collection of change records"
	| changeList |
	changeList _ self new scanRecords: someChangeRecords.
	self open: changeList name: aString multiSelect: true! !

!ChangeList class methodsFor: 'public access' stamp: 'dmu 9/7/2010 14:16'!
getRecentLocatorWithPrompt: aPrompt
	"Prompt with a menu of how far back to go.  Return nil if user backs out.  Otherwise return the number of characters back from the end of the .changes file the user wishes to include"
	 "ChangeList getRecentPosition"
	| end changesFile banners positions pos chunk i |
	changesFile _ (SourceFiles at: 2) readOnlyCopy.
	banners _ OrderedCollection new.
	positions _ OrderedCollection new.
	changesFile safelyDo: [
		end _ changesFile size.
		pos _ SmalltalkImage current lastQuitLogPosition.
		[pos = 0 or: [banners size > 20]] whileFalse:
			[
			changesFile position: pos.
			chunk _ changesFile nextChunk.
			i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.
			i > 0 ifTrue: [positions addLast: pos.
						banners addLast: (chunk copyFrom: 5 to: i-2).
						pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]
				ifFalse: [pos _ 0]].
		changesFile close.
		pos _ (SelectionMenu labelList: banners selections: positions)
					startUpWithCaption: aPrompt.
		pos == nil ifTrue: [^ nil].
		^ end - pos
	]! !

!ChangeList class methodsFor: 'instance creation' stamp: 'ssa 8/21/2009 15:32'!
open: aChangeList name: aString multiSelect: multiSelect
	"Create a standard system view for the messageSet, whose label is aString.
	The listView may be either single or multiple selection type"

	| topView listHeight annoHeight optButtonHeight codeHeight aListView underPane annotationPane buttonsView aBrowserCodeView |
	
	listHeight _ 70.
	annoHeight _ 10.
	optButtonHeight _ aChangeList optionalButtonHeight.
	codeHeight _ 110.

	topView _ (StandardSystemView new)
		model: aChangeList;
		label: aString;
		minimumSize: 200 @ 120;
		borderWidth: 1.

	aListView _ (multiSelect
			ifTrue: [PluggableListViewOfMany
						on: aChangeList
						list: #list
						primarySelection: #listIndex
						changePrimarySelection: #togglePrimaryListIndex:
						listSelection: #listSelectionAt:
						changeListSelection: #listSelectionAt:put:
						menu: (aChangeList showsVersions
								ifTrue: [#versionsMenu:]
								ifFalse: [#changeListMenu:])]
			ifFalse: [PluggableListView
						on: aChangeList
						list: #list
						selected: #listIndex
						changeSelected: #toggleListIndex:
						menu: (aChangeList showsVersions
								ifTrue: [#versionsMenu:]
								ifFalse: [#changeListMenu:])]).
	aListView  window: (0 @ 0 extent: 200 @ listHeight).
	topView addSubView: aListView .

	underPane _ aListView.
	aChangeList wantsAnnotationPane
		ifTrue:
			[annotationPane _ PluggableTextView
				on: aChangeList
				text: #annotation
				accept: nil
				readSelection: nil
				menu: nil.
			annotationPane window: (0 @ 0 extent: 200 @ 10).
			topView addSubView: annotationPane below: underPane.
			underPane _ annotationPane .
			codeHeight _ codeHeight - annoHeight].

	aChangeList wantsOptionalButtons
		ifTrue:
			[buttonsView _ aChangeList optionalButtonsView.
			buttonsView borderWidth: 1.
			topView addSubView: buttonsView  below: underPane.
			underPane _ buttonsView.
			codeHeight _ codeHeight - optButtonHeight].

	aBrowserCodeView _ PluggableTextView
			on: aChangeList
			text: #contents
			accept: #contents:
			readSelection: #contentsSelection
			menu: #codePaneMenu:shifted:.
	aBrowserCodeView scrollingView
			controller: ReadOnlyTextController new.
	aBrowserCodeView
			window: (0 @ 0 extent: 200 @ codeHeight).
	topView addSubView: aBrowserCodeView below: underPane.

	topView controller open.! !

!ChangeList class methodsFor: 'fileIn/Out' stamp: 'ssa 9/3/2008 10:49'!
fileReaderServicesForFile: fullName suffix: suffix
	| services |
	services _ OrderedCollection new.
	(FileStream isSourceFileSuffix: suffix) | (suffix = '*')
		ifTrue: [ services add: self serviceBrowseChangeFile ].
	(suffix = 'changes') | (suffix = '*')
		ifTrue: [ services add: self serviceBrowseDotChangesFile ].
	^services! !

!ChangeList class methodsFor: 'fileIn/Out' stamp: 'ssa 9/3/2008 10:49'!
services
	"Answer potential file services associated with this class"

	^ { self serviceBrowseChangeFile. 
		self serviceBrowseDotChangesFile.
		 }! !

!ChangeRecord methodsFor: 'testing' stamp: 'ssa 1/5/2010 14:12'!
match: aPatternString
	"Answer true is any of my text matches aPatternString"
	
	(aPatternString match: self string) ifTrue:[^true].
	(aPatternString match: self methodClassNameSafe) ifTrue:[^true].
	^false! !

!ChangeRecord methodsFor: 'access' stamp: 'ssa 1/5/2010 14:04'!
methodClassNameSafe
	^class isNil ifTrue:['']ifFalse:[class]! !

!ChangeRecord methodsFor: 'access' stamp: 'ssa 1/5/2010 14:03'!
methodSelectorSafe
	"Answer a string in any case"
	type == #method ifFalse: [^ ''].
	^ Parser new parseSelector: self string! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 1/5/2010 21:02'!
changeRecords
	"Answer the value of changeRecords"

	changeRecords isNil ifTrue:[self changeRecords: nil].
	^ changeRecords! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 1/5/2010 21:02'!
changeRecords: anObject
	"Set the value of changeRecords"

	changeRecords _ anObject! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 9/3/2008 11:02'!
editPostscript
	"edit the receiver's postscript, in a separate window.  "

	| deps found |
	self assurePostscriptExists.
	deps _ postscript dependents select:
		[:m | m isKindOf: StandardSystemView].
	deps size > 0 ifTrue:
		[Smalltalk isMorphic
			ifTrue:
				[]
			ifFalse:
				[found _ deps detect: [:obj | (obj isKindOf: StandardSystemView) and: [ScheduledControllers scheduledControllers includes: obj controller]] ifNone: [nil].
				found ifNotNil: [^ ScheduledControllers activateController: found controller]].
.
		self inform:
'Caution -- there', (deps size isOrAreStringWith: 'other window'), '
already open on this postscript elsewhere'].

	postscript openLabel: 'Postscript for ChangeSet named ', name! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 1/5/2010 21:02'!
isolatedProject: anObject
	"Set the value of isolatedProject"

	isolatedProject _ anObject! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 1/5/2010 21:02'!
isolationSet
	"Answer the value of isolationSet"

	isolationSet isNil ifTrue:[self isolationSet: nil].
	^ isolationSet! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 1/5/2010 21:02'!
postscript
	"Answer the value of postscript"

	postscript isNil ifTrue:[self postscript: nil].
	^ postscript! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 1/5/2010 21:02'!
postscript: anObject
	"Set the value of postscript"

	postscript _ anObject! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 1/5/2010 21:02'!
preamble
	"Answer the value of preamble"

	preamble isNil ifTrue:[self preamble: nil].
	^ preamble! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 1/5/2010 21:02'!
preamble: anObject
	"Set the value of preamble"

	preamble _ anObject! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 1/5/2010 21:02'!
revertable
	"Answer the value of revertable"

	revertable isNil ifTrue:[self revertable: nil].
	^ revertable! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 1/5/2010 21:02'!
revertable: anObject
	"Set the value of revertable"

	revertable _ anObject! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 1/5/2010 21:02'!
structures: anObject
	"Set the value of structures"

	structures _ anObject! !

!ChangeSet methodsFor: 'accessing' stamp: 'ssa 1/5/2010 21:02'!
superclasses: anObject
	"Set the value of superclasses"

	superclasses _ anObject! !

!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ssa 9/3/2008 10:51'!
checkForConversionMethods
	"See if any conversion methods are needed"
	| oldStruct newStruct tell choice list need
sel renamed rec nn |

	Preferences conversionMethodsAtFileOut ifFalse: [^ self].	"Check preference"
	structures ifNil: [^ self].

	list _ OrderedCollection new.
	renamed _ OrderedCollection new.
	self changedClasses do: [:class |
		need _ (self atClass: class includes: #new) not.
		need ifTrue: ["Renamed classes."
			(self atClass: class includes: #rename) ifTrue: [
				rec _ changeRecords at: class name.
				rec priorName ifNotNil: [
					(structures includesKey: rec priorName) ifTrue: [
						renamed add: class.  need _ false]]]].
		need ifTrue: [need _ (self atClass: class includes: #change)].
		need ifTrue: [oldStruct _ structures at: class name 
									ifAbsent: [need _ false.  #()]].
		need ifTrue: [
			newStruct _ (Array with: class classVersion), (class allInstVarNames).
			need _ (oldStruct ~= newStruct)].
		need ifTrue: [sel _ #convertToCurrentVersion:refStream:.
			(#(add change) includes: (self atSelector: sel class: class)) ifFalse: [
				list add: class]].
		].

	list isEmpty & renamed isEmpty ifTrue: [^ self].
	"Ask user if want to do this"
	tell _ 'If there might be instances of ', (list asArray, renamed asArray) printString,
		'\in a project (.pr file) on someone''s disk, \please ask to write a conversion method.\'
			withCRs,
		'After you edit the conversion method, you''ll need to fileOut again.\' withCRs,
		'The preference conversionMethodsAtFileOut in category "fileout" controls this feature.'.
	choice _ (PopUpMenu labels: 
'Write a conversion method by editing a prototype
These classes are not used in any object file.  fileOut my changes now.
I''m too busy.  fileOut my changes now.
Don''t ever ask again.  fileOut my changes now.') startUpWithCaption: tell. 
	choice = 4 ifTrue: [Preferences disable: #conversionMethodsAtFileOut].
	choice = 2 ifTrue: ["Don't consider this class again in the changeSet"
			list do: [:cls | structures removeKey: cls name ifAbsent: []].
			renamed do: [:cls | 
				nn _ (changeRecords at: cls name) priorName.
				structures removeKey: nn ifAbsent: []]].
	choice ~= 1 ifTrue: [^ self].	"exit if choice 2,3,4"

	self error:'No support for writing conversion methods in this stripped image'! !

!ChangeSet methodsFor: 'private' stamp: 'ssa 9/3/2008 10:28'!
fileOutClassDefinition: class on: stream 
	"Write out class definition for the given class on the given stream, if the class definition was added or changed."

	(self atClass: class includes: #rename) ifTrue:
		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].

	(self atClass: class includes: #change) ifTrue: [ "fat definition only needed for changes"
		stream command: 'H3'; nextChunkPut: (self fatDefForClass: class); cr; command: '/H3'.
		
	] ifFalse: [
		(self atClass: class includes: #add) ifTrue: [ "use current definition for add"
			stream command: 'H3'; nextChunkPut: class definition; cr; command: '/H3'.
		
		].
	].

	(self atClass: class includes: #comment) ifTrue:
		[class theNonMetaClass organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: class theNonMetaClass.
		stream cr].

! !

!ChangeSet methodsFor: '*transporter' stamp: 'ads 1/26/2011 14:23'!
changedPackages
	| changedPackages nonCategoryBasedPackages |
	nonCategoryBasedPackages := Transporter nonCategoryBasedPackages.
	changedPackages := Set new.
	self changedMessageList do: [:m |
		changedPackages add: (PackageInfo named: m topLevelPackageName).
		changedPackages addAll: (nonCategoryBasedPackages select: [:p | p includesMethod: m methodSymbol ofClass: m actualClass]).
	].
	self changedClasses do: [:c |
		(self changeRecords at: c name) hasTheClassItselfChanged ifTrue: [
			changedPackages add: (PackageInfo named: c topLevelPackageName).
			changedPackages addAll: (nonCategoryBasedPackages select: [:p | p includesClass: c]).
		].
	].
	^ changedPackages! !

!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 7/17/2002 11:37'!
changeSetListKey: aChar from: view
	"Respond to a Command key.  I am a model with a listView that has a list of changeSets."

	aChar == $b ifTrue: [^ self browseChangeSet].
	aChar == $B ifTrue: [^ self openChangeSetBrowser].
	aChar == $c ifTrue: [^ self copyAllToOther].
	aChar == $D ifTrue: [^ self toggleDiffing]. 
	aChar == $f ifTrue: [^ self findCngSet].
	aChar == $m ifTrue: [^ self newCurrent].
	aChar == $n ifTrue: [^ self newSet].
	aChar == $o ifTrue: [^ self fileOut].
	aChar == $p ifTrue: [^ self addPreamble].
	aChar == $r ifTrue: [^ self rename].
	aChar == $s ifTrue: [^ self chooseChangeSetCategory].
	aChar == $x ifTrue: [^ self remove].
	aChar == $- ifTrue: [^ self subtractOtherSide].

	^ self messageListKey: aChar from: view! !

!ChangeSorter methodsFor: 'changeSet menu' stamp: 'BG 10/29/2003 08:09'!
changeSetMenu: aMenu shifted: isShifted 
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	isShifted ifTrue: [^ self shiftedChangeSetMenu: aMenu].
	Smalltalk isMorphic
		ifTrue:
			[]
		ifFalse:
			[aMenu title: 'Change Set:
' , myChangeSet name].

	aMenu add: 'make changes go to me (m)' action: #newCurrent.
	aMenu addLine.
	aMenu add: 'new change set... (n)' action: #newSet.
	aMenu add: 'find...(f)' action: #findCngSet.
	aMenu add: 'show category... (s)' action:  #chooseChangeSetCategory.
	aMenu balloonTextForLastItem:
'Lets you choose which change sets should be listed in this change sorter'.
	aMenu add: 'select change set...' action: #chooseCngSet.
	aMenu addLine.
	aMenu add: 'rename change set (r)' action: #rename.
	aMenu add: 'file out (o)' action: #fileOut.
"	aMenu add: 'mail to list' action: #mailOut. "
	aMenu add: 'browse methods (b)' action: #browseChangeSet.
	aMenu add: 'browse change set (B)' action: #openChangeSetBrowser.
	aMenu addLine.
	parent
		ifNotNil: 
			[aMenu add: 'copy all to other side (c)' action: #copyAllToOther.
			aMenu add: 'submerge into other side' action: #submergeIntoOtherSide.
			aMenu add: 'subtract other side (-)' action: #subtractOtherSide.
			aMenu addLine].
	myChangeSet hasPreamble
		ifTrue: 
			[aMenu add: 'edit preamble (p)' action: #addPreamble.
			aMenu add: 'remove preamble' action: #removePreamble]
		ifFalse: [aMenu add: 'add preamble (p)' action: #addPreamble].
	myChangeSet hasPostscript
		ifTrue: 
			[aMenu add: 'edit postscript...' action: #editPostscript.
			aMenu add: 'remove postscript' action: #removePostscript]
		ifFalse: [aMenu add: 'add postscript...' action: #editPostscript].
	aMenu addLine.

	aMenu add: 'category functions...' action: #offerCategorySubmenu.
	aMenu balloonTextForLastItem:
'Various commands relating to change-set-categories'.
	aMenu addLine.


	aMenu add: 'destroy change set (x)' action: #remove.
	aMenu addLine.
	aMenu add: 'more...' action: #offerShiftedChangeSetMenu.
	^ aMenu! !

!ChangeSorter methodsFor: 'class list' stamp: 'ssa 1/5/2010 21:28'!
classListKey: aChar from: view
	"Respond to a Command key in the class-list pane."

	aChar == $x ifTrue: [^ self removeClass].
	aChar == $d ifTrue: [^ self forgetClass]. 
	aChar == $m ifTrue: [^ self moveClassToOther]. 

	^ self messageListKey: aChar from: view "picks up b,h,p"! !

!ChangeSorter methodsFor: 'class list' stamp: 'ssa 1/5/2010 21:24'!
classListMenu: aMenu shifted: shifted
	"Fill aMenu with items appropriate for the class list"

	aMenu title: 'class list'.
	(parent notNil and: [shifted not])
		ifTrue: [aMenu addList: #( "These two only apply to dual change sorters"
			('copy class chgs to other side'			copyClassToOther)	
			('move class chgs to other side (m)'			moveClassToOther)
			('copy  chgs to other side from classes matching...'			copyClassesToOtherMatching)	
			('move  chgs to other side from classes matching...'			moveClassesToOtherMatching)	
			)].

	aMenu addList: (shifted
		ifFalse: [#(
			-
			('delete class from change set (d)'		forgetClass)
			('remove class from system (x)'			removeClass)
			-
			('browse full (b)'						browseMethodFull)
			('browse hierarchy (h)'					spawnHierarchy)
			('browse protocol (p)'					browseFullProtocol)
			-
			('printOut'								printOutClass)
			('fileOut'								fileOutClass)
			-
			('inst var refs...'						browseInstVarRefs)
			('inst var defs...'						browseInstVarDefs)
			('class var refs...'						browseClassVarRefs)
			('class vars'								browseClassVariables)
			('class refs (N)'							browseClassRefs)
			-
			('more...'								offerShiftedClassListMenu))]

		ifTrue: [#(
			-
			('unsent methods'						browseUnusedMethods)
			('unreferenced inst vars'				showUnreferencedInstVars)
			('unreferenced class vars'				showUnreferencedClassVars)
			-
			('sample instance'						makeSampleInstance)
			('inspect instances'						inspectInstances)
			('inspect subinstances'					inspectSubInstances)
			-
			('more...'								offerUnshiftedClassListMenu ))]).
	^ aMenu! !

!ChangeSorter methodsFor: 'class list' stamp: 'ssa 1/5/2010 21:13'!
copyClassesToOtherMatching
	"Adsk the user for a pattern.  Copy matching changes from this changeset in the other changeSet"

	| otherSorter otherChangeSet pattern classNamesToCopy |
	self checkThatSidesDiffer: [^ self halt].
	self okToChange ifFalse: [^ self halt].
	otherSorter _ parent other: self.
	otherChangeSet _ otherSorter changeSet.

	pattern _ FillInTheBlank request: 'Enter a pattern to match to the class to copy changes:
# = single character wildcard
* = many character wildcard'. ''.

	pattern isEmpty ifTrue: [^ self ].

	classNamesToCopy _ OrderedCollection new.
	self changeSet changedClassNames   do: [:nm | (pattern match: nm) ifTrue:[classNamesToCopy add: nm]].
	classNamesToCopy  do:[:clsnm|
		otherChangeSet absorbClass: clsnm from: myChangeSet].
	otherSorter showChangeSet: otherChangeSet.! !

!ChangeSorter methodsFor: 'class list' stamp: 'ssa 1/5/2010 21:22'!
moveClassesToOtherMatching
	"Adsk the user for a pattern.  Move matching changes from this changeset in the other changeSet"

	| otherSorter otherChangeSet pattern classNamesToCopy |
	self checkThatSidesDiffer: [^ self halt].
	self okToChange ifFalse: [^ self halt].
	otherSorter _ parent other: self.
	otherChangeSet _ otherSorter changeSet.

	pattern _ FillInTheBlank request: 'Enter a pattern to match to the class to copy changes:
# = single character wildcard
* = many character wildcard'. ''.

	pattern isEmpty ifTrue: [^ self ].

	classNamesToCopy _ OrderedCollection new.
	self changeSet changedClassNames   do: [:nm | (pattern match: nm) ifTrue:[classNamesToCopy add: nm]].
	classNamesToCopy  do:[:clsnm|
		otherChangeSet absorbClass: clsnm from: myChangeSet.
		 myChangeSet removeClassChanges: clsnm].
	currentClassName _ nil.
		currentSelector _ nil.
		self showChangeSet: myChangeSet.
	otherSorter showChangeSet: otherChangeSet.! !

!ChangeSorter class methodsFor: 'adding' stamp: 'sm 3/11/2011 11:29'!
basicNewChangeSet: newName
	| newSet |
	newName ifNil: [^ nil].
	(self changeSetNamed: newName) ifNotNil:
		[self inform: 'Sorry that name is already used: ', newName.
		^ nil].
	newSet _ ChangeSet basicNewNamed: newName.
	AllChangeSets add: newSet.
	^ newSet! !

!ChangeSorter class methodsFor: 'fileIn/Out' stamp: 'ssa 9/3/2008 10:33'!
fileIntoNewChangeSet: fullName
	"File in all of the contents of the currently selected file, if any, into a new change set." 

	| fn ff |
	fullName ifNil: [^ Beeper beep].
	ff _ FileStream readOnlyFileNamed: (fn _  fullName).
	((FileDirectory extensionFor: fn) sameAs: 'html') ifTrue: [ff _ ff asHtml].
	self newChangesFromStream: ff named: (FileDirectory localNameFor: fn)! !

!ChangedMethodFinder methodsFor: 'as yet unclassified' stamp: 'dmu 8/25/2010 16:17'!
changedMethods
	"ChangedMethodFinder new changedMethods"
	| result |
	result _ OrderedCollection new.
	Smalltalk allClassesDo: [:cls| 
		{cls. cls class.} do: [:clsHalf|
			clsHalf methodDict associationsDo: [:a | 
				(self isMethodChanged: a value) ifTrue: [
					result add: { cls category. cls name. clsHalf name.  clsHalf organization categoryOfElement: a key. a key}
				]
			]
		]
	].
^ result! !

!ChangedMethodFinder methodsFor: 'as yet unclassified' stamp: 'dmu 8/25/2010 16:19'!
changedMethodsInStandardClasses
	"ChangedMethodFinder new  changedMethodsInStandardClasses"
	| changedMethods standardClassNames result |
	changedMethods _ self changedMethods.
	standardClassNames _ self standardClassNames.
	result _ changedMethods select: [:e| standardClassNames includes: (e at: 2)].
	^ result! !

!ChangedMethodFinder methodsFor: 'as yet unclassified' stamp: 'dmu 8/25/2010 15:56'!
isMethodChanged: aMethod
	^ (SourceFiles at: 1) ~= aMethod sourceFileStream! !

!ChangedMethodFinder methodsFor: 'as yet unclassified' stamp: 'dmu 8/25/2010 16:17'!
standardClassNames
	"ChangedMethodFinder new standardClassNames"
	| result |
	result _ Set new.
	Smalltalk allClassesDo: [:cls| 
		{cls. cls class.} do: [:clsHalf|
			clsHalf methodDict associationsDo: [:a | 
				(self isMethodChanged: a value) ifFalse: [result add: cls name]
			]
		]
	].
^ result! !

!Character methodsFor: 'testing' stamp: 'ssa 8/11/2009 12:37'!
isCharacter
	^true! !

!Character methodsFor: '*Ly' stamp: 'ssa 8/18/2009 12:29'!
at: index

	index > 1 ifTrue:[^super at: index].
	^self! !

!Character methodsFor: '*Ly' stamp: 'ssa 8/18/2009 12:25'!
doesNotUnderstand: aMessage
	"Hack DNU to make chars act like strings"
	
	^self asString perform: aMessage selector withArguments: aMessage arguments! !

!Character methodsFor: '*Ly' stamp: 'ssa 8/18/2009 12:28'!
size

	^1! !

!Character methodsFor: '*packageinfo-base' stamp: 'ab 5/31/2003 17:15'!
escapeEntities
	#($< '&lt;' $> '&gt;' $& '&amp;') pairsDo:
		[:k :v |
		self = k ifTrue: [^ v]].
	^ String with: self! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:20'!
arrowDown
	^ self value: 31! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:20'!
arrowLeft
	^ self value: 28! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:20'!
arrowRight
	^ self value: 29! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:20'!
arrowUp
	^ self value: 30! !

!Character class methodsFor: 'accessing untypeable characters'!
backspace
	"Answer the Character representing a backspace."

	^self value: 8! !

!Character class methodsFor: 'accessing untypeable characters'!
cr
	"Answer the Character representing a carriage return."

	^self value: 13! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:19'!
delete
	^ self value: 127! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:21'!
end
	^ self value: 4! !

!Character class methodsFor: 'accessing untypeable characters'!
enter
	"Answer the Character representing enter."

	^self value: 3! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'ls 9/2/1999 08:06'!
escape
	"Answer the ASCII ESC character"

	^self value: 27! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'sma 3/15/2000 22:33'!
euro
	"The Euro currency sign, that E with two dashes. The key code is a wild guess"

	^ Character value: 219! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:21'!
home
	^ self value: 1! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:19'!
insert
	^ self value: 5! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'ls 9/8/1998 22:15'!
lf
	"Answer the Character representing a linefeed."

	^self value: 10! !

!Character class methodsFor: 'accessing untypeable characters'!
linefeed
	"Answer the Character representing a linefeed."

	^self value: 10! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'wiz 4/9/2006 20:30'!
nbsp
	"non-breakable space. Latin1 encoding common usage."

	^ Character value: 160! !

!Character class methodsFor: 'accessing untypeable characters'!
newPage
	"Answer the Character representing a form feed."

	^self value: 12! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:20'!
pageDown
	^ self value: 12! !

!Character class methodsFor: 'accessing untypeable characters' stamp: 'NS 7/11/2000 09:21'!
pageUp
	^ self value: 11! !

!Character class methodsFor: 'accessing untypeable characters'!
space
	"Answer the Character representing a space."

	^self value: 32! !

!Character class methodsFor: 'accessing untypeable characters'!
tab
	"Answer the Character representing a tab."

	^self value: 9! !

!CharacterScanner methodsFor: 'scanning' stamp: 'ssa 8/19/2008 21:22'!
scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops displaying: foo

	^ self scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: 0! !

!CharacterScanner methodsFor: 'accessing' stamp: 'ssa 8/19/2008 21:15'!
destX: x

	destX := x! !

!CharacterSet methodsFor: '*Ly' stamp: 'ssa 8/18/2009 12:50'!
addAll: aCollection
	
	aCollection do:[:char| self add: char]! !

!CharacterSet methodsFor: '*Ly' stamp: 'ssa 8/18/2009 12:52'!
removeAll: aCollection
	
	aCollection do:[:char| self remove: char]! !

!Class methodsFor: '*transporter' stamp: 'ads 12/14/2010 10:27'!
fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex  filteringCategoriesBy: catFilterBlock
	"File a description of the receiver on aFileStream. If the boolean argument,
	moveSource, is true, then set the trailing bytes to the position of aFileStream and
	to fileIndex in order to indicate where to find the source code."
	^self fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex filteringCategoriesBy: catFilterBlock initializing: true! !

!Class methodsFor: '*transporter' stamp: 'ads 12/14/2010 10:29'!
fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex filteringCategoriesBy: catFilterBlock initializing: aBool
	"File a description of the receiver on aFileStream. If the boolean argument,
	moveSource, is true, then set the trailing bytes to the position of aFileStream and
	to fileIndex in order to indicate where to find the source code."

	Transcript cr; show: name.
	super
		fileOutOn: aFileStream
		moveSource: moveSource
		toFile: fileIndex
		filteringCategoriesBy: catFilterBlock.
	self class nonTrivial
		ifTrue:
			[aFileStream cr; nextPutAll: '"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!!'; cr; cr.
			self class
				fileOutOn: aFileStream
				moveSource: moveSource
				toFile: fileIndex
				filteringCategoriesBy: catFilterBlock
				initializing: aBool]! !

!Class methodsFor: '*SUnit-initialize-release' stamp: 'sm 5/25/2011 00:57'!
removeFromChanges
	"References to the receiver, a class, and its metaclass should no longer be included in the system ChangeSet.
	7/18/96 sw: call removeClassAndMetaClassChanges:"

	ChangeSet current removeClassAndMetaClassChanges: self! !

!Class methodsFor: '*SUnit-initialize-release' stamp: 'sm 5/25/2011 00:59'!
removeFromSystemUnlogged
	"Forget the receiver from the Smalltalk global dictionary. Any existing instances will refer to an obsolete version of the receiver.  Do not log the removal either to the current change set nor to the system changes log"
	^self removeFromSystem: false! !

!ClassAndMethodSaver methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 14:01'!
save
	self createRoot.
	self saveAllClasses.! !

!ClassAndMethodSaver methodsFor: 'root directory' stamp: 'dmu 8/23/2010 14:41'!
createRoot
	self rootDirectory: ( self createDir: self rootName in: FileDirectory default mustBeNew: false )! !

!ClassAndMethodSaver methodsFor: 'root directory' stamp: 'dmu 8/23/2010 14:04'!
rootDirectory
	"Answer the value of rootDirectory"

	rootDirectory isNil ifTrue:[self rootDirectory: nil].
	^ rootDirectory! !

!ClassAndMethodSaver methodsFor: 'root directory' stamp: 'dmu 8/23/2010 14:04'!
rootDirectory: anObject
	"Set the value of rootDirectory"

	rootDirectory _ anObject! !

!ClassAndMethodSaver methodsFor: 'root directory' stamp: 'dmu 8/23/2010 14:00'!
rootName
	"Answer the value of rootName"

	rootName isNil ifTrue:[self rootName: 'root'].
	^ rootName! !

!ClassAndMethodSaver methodsFor: 'root directory' stamp: 'dmu 8/23/2010 14:00'!
rootName: anObject
	"Set the value of rootName"

	rootName _ anObject! !

!ClassAndMethodSaver methodsFor: 'directories' stamp: 'dmu 8/23/2010 14:35'!
classCategoryDirFor: cat
	^ self createDir: cat in: self rootDirectory mustBeNew: false! !

!ClassAndMethodSaver methodsFor: 'directories' stamp: 'dmu 8/23/2010 14:34'!
createDir: leafName in: parentDir mustBeNew: mustBeNew
	| p d |
	p _ parentDir pathName, parentDir pathNameDelimiter, leafName.
	d _ FileDirectory on: p.
	(mustBeNew and: [d exists]) ifTrue: [self error: p, ' already exists'].
	d exists ifFalse: [d assureExistence].
	^ d
! !

!ClassAndMethodSaver methodsFor: 'directories' stamp: 'dmu 8/23/2010 14:38'!
createDirectoriesFor: cls

	| catDir |
	catDir _ self classCategoryDirFor: cls category.
	classDir _ self createDir: cls name in: catDir mustBeNew: false.
	baseDir _ self createDir: 'base' in: classDir mustBeNew: false.
	metaDir _ self createDir: 'meta' in: classDir mustBeNew: false.! !

!ClassAndMethodSaver methodsFor: 'saving methods' stamp: 'dmu 10/1/2010 22:58'!
methodSourceFor: sel in: clsHalf 
	| method |
	method _ clsHalf methodDict at: sel ifAbsent: [^ sel printString, 'CORRUPTED'].
	^ (method getSourceFor: sel in: clsHalf) asString! !

!ClassAndMethodSaver methodsFor: 'saving methods' stamp: 'dmu 10/1/2010 22:59'!
saveMethodNamed: sel inCategory: cat of: clsHalf in: catDir
	| src fs selOrFoo |
	src _ self methodSourceFor: sel in: clsHalf.
	selOrFoo _ (sel isKindOf: String) ifTrue: [sel] ifFalse: [sel printString].
	fs _ self fileStreamIn: catDir named: selOrFoo, '.txt'.
	fs nextPutAll: src.
	fs close
	! !

!ClassAndMethodSaver methodsFor: 'saving classes' stamp: 'dmu 8/23/2010 14:46'!
fileStreamIn: dir named: n
	| fs |
	fs _ FileStream fileNamed: dir pathName, dir pathNameDelimiter, n.
	^ fs! !

!ClassAndMethodSaver methodsFor: 'saving classes' stamp: 'dmu 8/23/2010 14:01'!
saveAllClasses
	Smalltalk allClassesDo: [:cls| self saveClass: cls]! !

!ClassAndMethodSaver methodsFor: 'saving classes' stamp: 'dmu 8/23/2010 15:00'!
saveCategory: cat of: clsHalf in: dir
	| selectors catDir |
	catDir _ self createDir: cat in: dir mustBeNew: false.
	selectors := (cat asString = ClassOrganizer allCategory)
				ifTrue: [ clsHalf organization allMethodSelectors ]
				ifFalse: [ clsHalf organization listAtCategoryNamed: cat ].
	selectors do: [:sel| self saveMethodNamed: sel inCategory: cat of: clsHalf in: catDir]! !

!ClassAndMethodSaver methodsFor: 'saving classes' stamp: 'dmu 8/23/2010 14:39'!
saveClass: cls
	self createDirectoriesFor: cls.
	self saveClassHalf: cls in:  baseDir.
	self saveClassHalf: cls class in:  metaDir! !

!ClassAndMethodSaver methodsFor: 'saving classes' stamp: 'dmu 8/23/2010 14:52'!
saveClassHalf: clsHalf in: dir
	self saveClassHalfDefinition: clsHalf in: dir.
	self saveClassHalfComment: clsHalf in: dir.
	self saveClassHalfCategories: clsHalf in: dir! !

!ClassAndMethodSaver methodsFor: 'saving classes' stamp: 'dmu 8/23/2010 14:53'!
saveClassHalfCategories: clsHalf in: dir
	clsHalf organization categories do: [:cat | self saveCategory: cat of: clsHalf in: dir]! !

!ClassAndMethodSaver methodsFor: 'saving classes' stamp: 'dmu 8/23/2010 15:15'!
saveClassHalfComment: clsHalf in: dir
	| fs |
	fs _ self fileStreamIn: dir named: 'comment.txt'.
	fs nextPutAll: clsHalf organization classComment asString.
	fs close.! !

!ClassAndMethodSaver methodsFor: 'saving classes' stamp: 'dmu 8/23/2010 14:48'!
saveClassHalfDefinition: clsHalf in: dir
	| fs |
	fs _ self fileStreamIn: dir named: 'definition.txt'.
	fs nextPutAll: clsHalf definition.
	fs close.! !

!ClassAndMethodSaver commentStamp: 'dmu 8/23/2010 13:56' prior: 0!
Save all class definitions and method definitions to a directory tree so I can use FileMerge!
!ClassAndMethodSaver class methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 16:32'!
save
	"ClassAndMethodSaver save"
	^self saveIn: 'root'! !

!ClassAndMethodSaver class methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 13:59'!
saveIn: rootName
	(self new rootName: rootName) save! !

!ClassChangeRecord methodsFor: '*transporter' stamp: 'ads 1/26/2011 14:08'!
hasTheClassItselfChanged
	"Or have there only been method changes?"
	^ self allChangeTypes isEmpty not! !

!ClassCommentVersionsBrowser methodsFor: 'basic function' stamp: 'dmu 9/7/2010 14:16'!
scanVersionsOf: class 
	"Scan for all past versions of the class comment of the given class"

	| oldCommentRemoteStr sourceFilesCopy position prevPos stamp preamble tokens prevFileIndex |

	classOfMethod _ class.
	oldCommentRemoteStr _ class  organization commentRemoteStr.
	currentCompiledMethod _ oldCommentRemoteStr.
	selectorOfMethod _ #Comment.
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	listIndex _ 0.
	oldCommentRemoteStr ifNil:[^ nil] ifNotNil: [oldCommentRemoteStr sourcePointer].

	sourceFilesCopy _ SourceFiles collect:
		[:x | x isNil ifTrue: [ nil ]
				ifFalse: [x readOnlyCopy]].
	position _ oldCommentRemoteStr position.
	file _ sourceFilesCopy at: oldCommentRemoteStr sourceFileNumber.
	[position notNil & file notNil]
		whileTrue: [
		file position: (0 max: position-150).  " Skip back to before the preamble"
		[file position < (position-1)]  "then pick it up from the front"
			whileTrue: [preamble _ file nextChunk].

		prevPos _ nil.
		stamp _ ''.
		(preamble findString: 'commentStamp:' startingAt: 1) > 0
			ifTrue: [tokens _ Scanner new scanTokens: preamble.
				(tokens at: tokens size-3) = #commentStamp:
				ifTrue: ["New format gives change stamp and unified prior pointer"
						stamp _ tokens at: tokens size-2.
						prevPos _ tokens last.
						prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: prevPos.
						prevPos _ sourceFilesCopy filePositionFromSourcePointer: prevPos]]
			ifFalse: ["The stamp get lost, maybe after a condenseChanges"
					stamp _ '<historical>'].
 		self addItem:
				(ChangeRecord new file: file position: position type: #classComment
						class: class name category: nil meta: class stamp: stamp)
			text: stamp , ' ' , class name , ' class comment'. 
		prevPos = 0 ifTrue:[prevPos _ nil].
		position _ prevPos.
		prevPos notNil 
					ifTrue:[file _ sourceFilesCopy at: prevFileIndex]].
	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].
	listSelections _ Array new: list size withAll: false! !

!ClassDescription methodsFor: 'printing' stamp: 'dmu 9/6/2010 16:21'!
instanceVariablesString
	"Answer a string of my instance variable names separated by spaces."

	^String streamContents: [ :stream |
		(self instVarNames isKindOf: Number) ifTrue: [stream nextPutAll: 'EEK'] ifFalse: [
			self instVarNames
			do: [ :each | stream nextPutAll: each ]
			separatedBy: [ stream space ] ]]! !

!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'ssa 10/8/2008 19:00'!
allMethodsInCategory: aName 
	"Answer a list of all the method categories of the receiver and all its 
	superclasses "
	| aColl |
	aColl _ OrderedCollection new.
	self withAllSuperclasses
		do: [:aClass | aColl
				addAll: (aName = ClassOrganizer allCategory
						ifTrue: [aClass organization allMethodSelectors]
						ifFalse: [aClass organization listAtCategoryNamed: aName])].
	^ aColl asSet asSortedArray! !

!ClassDescription methodsFor: 'fileIn/Out' stamp: 'dmu 9/7/2010 14:17'!
classComment: aString stamp: aStamp
	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."

	| ptr header file oldCommentRemoteStr |
	(aString isKindOf: RemoteString) ifTrue:
		[SystemChangeNotifier uniqueInstance classCommented: self.
		^ self organization classComment: aString stamp: aStamp].

	oldCommentRemoteStr _ self organization commentRemoteStr.
	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ self organization classComment: nil].
		"never had a class comment, no need to write empty string out"

	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].
	SourceFiles ifNotNil: [(file _ SourceFiles at: 2) ifNotNil: [
		file safelyDo: [
			file setToEnd; cr; nextPut: $!!.	"directly"
			"Should be saying (file command: 'H3') for HTML, but ignoring it here"
			header _ String streamContents: [:strm | strm nextPutAll: self name;
				nextPutAll: ' commentStamp: '.
				aStamp storeOn: strm.
				strm nextPutAll: ' prior: '; nextPutAll: ptr printString].
			file nextChunkPut: header]]].
	self organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp.
	SystemChangeNotifier uniqueInstance classCommented: self.
! !

!ClassDescription methodsFor: 'fileIn/Out' stamp: 'dmu 9/7/2010 14:22'!
printMethodChunk: selector withPreamble: doPreamble on: outStream
		moveSource: moveSource toFile: fileIndex
	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."
	| preamble method oldPos newPos sourceFile endPos |
	doPreamble 
		ifTrue: [preamble _ self name , ' methodsFor: ' ,
					(self organization categoryOfElement: selector) asString printString]
		ifFalse: [preamble _ ''].
	method _ self methodDict at: selector.
	((method fileIndex = 0
		or: [(SourceFiles at: method fileIndex) == nil])
		or: [(oldPos _ method filePosition) = 0])
		ifTrue:
		["The source code is not accessible.  We must decompile..."
		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].
		outStream nextChunkPut: (self decompilerClass new decompile: selector
											in: self method: method) decompileString]
		ifFalse:
		[sourceFile _ SourceFiles at: method fileIndex.
		sourceFile safelyDo: [
			sourceFile position: oldPos.
			preamble size > 0 ifTrue:    "Copy the preamble"
				[outStream copyPreamble: preamble from: sourceFile].
			"Copy the method chunk"
			newPos _ outStream position.
			outStream copyMethodChunkFrom: sourceFile.
			sourceFile skipSeparators.      "[" "The following chunk may have ]style[" "]"
			sourceFile peek == "[" $] ifTrue: [
				outStream cr; copyMethodChunkFrom: sourceFile].
			moveSource ifTrue:    "Set the new method source pointer"
				[endPos _ outStream position.
				method checkOKToAdd: endPos - newPos at: newPos.
				method setSourcePosition: newPos inFile: fileIndex]]].
	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].
	^ outStream cr! !

!ClassDescription methodsFor: '*transporter' stamp: 'StefanMarr 3/12/2011 10:14'!
fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex filteringCategoriesBy: catFilterBlock 
	"File a description of the receiver on aFileStream. If the boolean 
	argument, moveSource, is true, then set the trailing bytes to the position 
	of aFileStream and to fileIndex in order to indicate where to find the 
	source code."

	aFileStream nextChunkPut: self definition.

	self organization
		putCommentOnFile: aFileStream
		numbered: fileIndex
		moveSource: moveSource
		forClass: self.
	self organization categories do: 
		[:heading |
		(catFilterBlock value: heading value: self) ifTrue: [
			self fileOutCategory: heading
				on: aFileStream
				moveSource: moveSource
				toFile: fileIndex]]! !

!ClassDescription methodsFor: '*transporter' stamp: 'ads 12/5/2010 23:14'!
methodNamed: aSymbol
	^ MethodReference new setStandardClass: self methodSymbol: aSymbol! !

!ClassDescription methodsFor: '*transporter' stamp: 'ads 1/26/2011 13:35'!
topLevelPackageName
	^ self theNonMetaClass category asString copyUpTo: $-! !

!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'Noury 10/26/2008 14:21'!
createdClassNames
	^self createdClasses collect: [:class| class name]! !

!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'Noury 10/26/2008 13:59'!
createdClasses
	^createdClasses! !

!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'Noury 10/26/2008 14:01'!
createdClasses: classes
	createdClasses := classes asIdentitySet ! !

!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'Noury 10/26/2008 16:37'!
defaultCategory
	^ (self packageName , '-', self defaultCategoryPostfix) asSymbol! !

!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'Noury 10/26/2008 16:23'!
defaultCategoryPostfix
	^ #Default! !

!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/18/2010 18:46'!
defaultSuperclass 
	^Object! !

!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'Noury 10/26/2008 16:20'!
packageName
	^#CategoryForTestToBeDeleted! !

!ClassFactoryForTestCase methodsFor: 'cleaning' stamp: 'Noury 10/26/2008 16:26'!
cleanUp
	| createdClassNames |
	createdClassNames := self createdClassNames.
	self deleteClasses.
	self deletePackage.
	self cleanUpChangeSetForClassNames: createdClassNames! !

!ClassFactoryForTestCase methodsFor: 'cleaning' stamp: 'Noury 10/26/2008 14:20'!
cleanUpChangeSetForClassNames: classeNames
	| changeSet |
	changeSet := ChangeSet current.
	classeNames do: [:name|
		changeSet 
			removeClassChanges: name;
			removeClassChanges: name, ' class'].	! !

!ClassFactoryForTestCase methodsFor: 'cleaning' stamp: 'Noury 10/26/2008 12:47'!
delete: aClass
	aClass isObsolete ifTrue: [^self].
	aClass removeFromChanges.
	aClass removeFromSystemUnlogged
! !

!ClassFactoryForTestCase methodsFor: 'cleaning' stamp: 'Noury 10/26/2008 12:46'!
deleteClasses
	self createdClasses do: [:class|
		self delete: class]! !

!ClassFactoryForTestCase methodsFor: 'cleaning' stamp: 'Noury 10/26/2008 16:33'!
deletePackage
	| categoriesMatchString |
	categoriesMatchString := self packageName, '-*'.
	SystemOrganization removeCategoriesMatching: categoriesMatchString! !

!ClassFactoryForTestCase methodsFor: 'cleaning' stamp: 'Noury 10/26/2008 14:01'!
initialize
	super initialize.
	self createdClasses: IdentitySet new! !

!ClassFactoryForTestCase methodsFor: 'creating' stamp: 'NouryBouraqadi 12/18/2010 18:46'!
newClass
	^self newSubclassOf: self defaultSuperclass instanceVariableNames: '' classVariableNames: ''! !

!ClassFactoryForTestCase methodsFor: 'creating' stamp: 'NouryBouraqadi 12/18/2010 18:48'!
newClassInCategory: category
	^self newSubclassOf: self defaultSuperclass instanceVariableNames: '' classVariableNames: '' category: category! !

!ClassFactoryForTestCase methodsFor: 'creating' stamp: 'Noury 11/12/2009 17:53'!
newName
	| postFix |
	postFix := (self createdClasses size + 1) printString.
	^(#ClassForTestToBeDeleted, postFix) asSymbol! !

!ClassFactoryForTestCase methodsFor: 'creating' stamp: 'Noury 10/26/2008 16:25'!
newSubclassOf: aClass instanceVariableNames: ivNamesString classVariableNames:  classVarsString 
	^self 
		newSubclassOf: aClass 
		instanceVariableNames: ivNamesString 
		classVariableNames: classVarsString 
		category: self defaultCategoryPostfix! !

!ClassFactoryForTestCase methodsFor: 'creating' stamp: 'Noury 10/26/2008 16:36'!
newSubclassOf: aClass instanceVariableNames: ivNamesString classVariableNames:  classVarsString category: category
	| newClass |
	newClass := aClass 
		subclass: self newName 
		instanceVariableNames: ivNamesString 
		classVariableNames: classVarsString 
		poolDictionaries: '' 
		category: (self packageName, '-', category) asSymbol.
	self createdClasses add: newClass.
	^newClass! !

!ClassFactoryForTestCase commentStamp: 'LaurentLaffont 4/15/2011 20:20' prior: 0!
I'm useful when classes needs to be created during the execution of the test. This avoid polluting your unit tests with dummy and mock classes.
A typical usage of it is:

TestCase subclass: #YourTest
       instanceVariableNames: 'classFactory'

YourTest>>setUp
       classFactory := ClassFactoryForTestCase new

YourTest>>tearDown
       classFactory deleteClasses.

YourTest>>testIsBehavior
       | cls |
       cls := classFactory newClass.
       self assert: cls isBehavior
!
!ClassFactoryForTestCaseTest methodsFor: 'setUp-tearDown' stamp: 'Noury 10/26/2008 12:19'!
setUp
	super setUp.
	factory := ClassFactoryForTestCase new! !

!ClassFactoryForTestCaseTest methodsFor: 'setUp-tearDown' stamp: 'Noury 10/26/2008 14:53'!
tearDown
	super tearDown.
	factory cleanUp! !

!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:43'!
testClassCreationInDifferentCategories
	| firstThreeClasses lastTwoClasses |
	3 timesRepeat: [
		factory newSubclassOf: Object instanceVariableNames: '' classVariableNames: '' category: #One].
	firstThreeClasses := factory createdClasses copy.
	2 timesRepeat: [
		factory newSubclassOf: Object instanceVariableNames: '' classVariableNames: '' category: #Two].
	lastTwoClasses := factory createdClasses copyWithoutAll: firstThreeClasses.
	self assert: (firstThreeClasses allSatisfy: [:class| class category = (factory packageName, '-', #One) asSymbol]).
	self assert: (lastTwoClasses allSatisfy: [:class| class category = (factory packageName, '-', #Two) asSymbol]).! !

!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:42'!
testClassFastCreationInDifferentCategories
	| firstThreeClasses lastTwoClasses |
	3 timesRepeat: [
		factory newClassInCategory: #One].
	firstThreeClasses := factory createdClasses copy.
	2 timesRepeat: [
		factory newClassInCategory: #Two].
	lastTwoClasses := factory createdClasses copyWithoutAll: firstThreeClasses.
	self assert: (firstThreeClasses allSatisfy: [:class| class category = (factory packageName, '-', #One) asSymbol]).
	self assert: (lastTwoClasses allSatisfy: [:class| class category = (factory packageName, '-', #Two) asSymbol]).! !

!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:44'!
testDefaultCategoryCleanUp
	| createdClassNames allClasses |
	3 timesRepeat: [
		factory newClass].
	createdClassNames := factory createdClassNames.
	factory cleanUp.	
	self assert: (factory createdClasses allSatisfy: [:class| class isObsolete]). 
	allClasses := SystemNavigation new allClasses.
	self assert: (factory createdClasses noneSatisfy: [:class| allClasses includes: class]).
	self deny: (SystemOrganization categories includes: factory defaultCategory). 
	self deny: (ChangeSet current changedClassNames includesAnyOf: createdClassNames)
! !

!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:38'!
testMultipleClassCreation
	5 timesRepeat: [
		factory newClass].
	self assert: (SystemNavigation new allClasses includesAllOf: factory createdClasses).
	self assert: factory createdClassNames asSet size = 5.
	self assert: (SystemOrganization listAtCategoryNamed: factory defaultCategory) asSet = factory createdClassNames asSet! !

!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:47'!
testPackageCleanUp
	| createdClassNames allClasses |
	3 timesRepeat: [
		factory newClassInCategory: #One].
	2 timesRepeat: [
		factory newClassInCategory: #Two].
	createdClassNames := factory createdClassNames.
	factory cleanUp.	
	self assert: (factory createdClasses allSatisfy: [:class| class isObsolete]). 
	allClasses := SystemNavigation new allClasses.
	self assert: (factory createdClasses noneSatisfy: [:class| allClasses includes: class]).
	self assert: (SystemOrganization categoriesMatching: factory packageName, '*') isEmpty. 
	self deny: (ChangeSet current changedClassNames includesAnyOf: createdClassNames)
! !

!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'nice 12/3/2009 23:47'!
testSingleClassCreation
	|class elementsInCategoryForTest |
	class := factory 
		newSubclassOf: Object 
		instanceVariableNames: 'a b c' 
		classVariableNames: 'X Y'.
	self assert: (SystemNavigation new allClasses includes: class).
	elementsInCategoryForTest := SystemOrganization listAtCategoryNamed: factory defaultCategory. 
	self assert: elementsInCategoryForTest = {class name}.
	self assert: class instVarNames = #(a b c).
	self assert: class classPool keys asSet = #(X Y) asSet! !

!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:37'!
testSingleClassFastCreation
	|class elementsInCategoryForTest |
	class := factory newClass.
	self assert: (SystemNavigation new allClasses includes: class).
	elementsInCategoryForTest := SystemOrganization listAtCategoryNamed: factory defaultCategory. 
	self assert: elementsInCategoryForTest = {class name}.
	self assert: class instVarNames isEmpty.
	self assert: class classPool isEmpty! !

!ClassFactoryForTestCaseTest class methodsFor: 'history' stamp: 'simon.denier 11/22/2008 22:13'!
lastStoredRun
	^ ((Dictionary new) add: (#passed->((Set new) add: #testDefaultCategoryCleanUp; add: #testPackageCleanUp; add: #testSingleClassCreation; add: #testClassCreationInDifferentCategories; add: #testClassFastCreationInDifferentCategories; add: #testMultipleClassCreation; add: #testSingleClassFastCreation; yourself)); add: (#timeStamp->'22 November 2008 10:11:35 pm'); add: (#failures->((Set new))); add: (#errors->((Set new))); yourself)! !

!ClassFactoryWithOrganization methodsFor: 'accessing' stamp: 'LucFabresse 10/24/2010 20:31'!
organization
	^organization! !

!ClassFactoryWithOrganization methodsFor: 'accessing' stamp: 'LucFabresse 10/24/2010 20:31'!
organization: aSystemOrganizer
	organization := aSystemOrganizer! !

!ClassFactoryWithOrganization methodsFor: 'cleaning' stamp: 'LucFabresse 10/24/2010 22:01'!
deletePackage
	| categoriesMatchString |
	categoriesMatchString := self packageName, '-*'.
	self organization removeCategoriesMatching: categoriesMatchString ; 
		removeEmptyCategories
	! !

!ClassFactoryWithOrganization methodsFor: 'creating' stamp: 'LucFabresse 10/29/2010 08:04'!
newClassNamed: aString subclassOf: aClass instanceVariableNames: ivNamesString classVariableNames:  classVarsString 
	^self 
		newClassNamed: aString
		subclassOf: aClass 
		instanceVariableNames: ivNamesString 
		classVariableNames: classVarsString 
		category:  (self packageName, '-', self defaultCategoryPostfix) asSymbol.! !

!ClassFactoryWithOrganization methodsFor: 'creating' stamp: 'LucFabresse 10/29/2010 08:03'!
newClassNamed: aString subclassOf: aClass instanceVariableNames: ivNamesString classVariableNames:  classVarsString category: category
	| newClass |
	newClass := (ClassBuilder new)
		name: aString 
		inEnvironment: self organization environment
		subclassOf: aClass
		type: aClass typeOfClass
		instanceVariableNames: ivNamesString
		classVariableNames: classVarsString
		poolDictionaries: ''
		category: category asSymbol.
	self createdClasses add: newClass.
	^newClass! !

!ClassFactoryWithOrganization methodsFor: 'creating' stamp: 'LucFabresse 10/24/2010 21:41'!
newSubclassOf: aClass instanceVariableNames: ivNamesString classVariableNames:  classVarsString 
	^self 
		newSubclassOf: aClass 
		instanceVariableNames: ivNamesString 
		classVariableNames: classVarsString 
		category:  (self packageName, '-', self defaultCategoryPostfix) asSymbol.! !

!ClassFactoryWithOrganization methodsFor: 'creating' stamp: 'LucFabresse 10/24/2010 21:35'!
newSubclassOf: aClass instanceVariableNames: ivNamesString classVariableNames:  classVarsString category: category

	| newClass |
	newClass := (ClassBuilder new)
		name: self newName 
		inEnvironment: self organization environment
		subclassOf: aClass
		type: aClass typeOfClass
		instanceVariableNames: ivNamesString
		classVariableNames: classVarsString
		poolDictionaries: ''
		category: category asSymbol.
	self createdClasses add: newClass.
	^newClass! !

!ClassFactoryWithOrganization commentStamp: 'LaurentLaffont 5/4/2011 21:25' prior: 0!
I'm a class to create classes with a category. I'm only used by Tests.

I am similar to ClassFactoryForTestCase (i.e., I can be used in place of a ClassFactoryForTestCase), expect that classes may be created on a specific class category.!
!ClassFactoryWithOrganization class methodsFor: 'instance creation' stamp: 'LucFabresse 10/24/2010 20:33'!
newWithOrganization: aSystemOrganizer
	^self new
		organization: aSystemOrganizer;
		yourself! !

!ClassFactoryWithOrganizationTest methodsFor: 'accessing' stamp: 'LucFabresse 10/24/2010 19:57'!
testedEnvironment
	^self testedOrganization environment! !

!ClassFactoryWithOrganizationTest methodsFor: 'accessing' stamp: 'LucFabresse 10/24/2010 20:31'!
testedOrganization
	^factory organization! !

!ClassFactoryWithOrganizationTest methodsFor: 'setUp-tearDown' stamp: 'LucFabresse 12/19/2010 12:42'!
setUp
	| environment |
	super setUp.
	environment := SystemDictionary withOrganizer: SystemOrganizer new.
	factory := ClassFactoryWithOrganization newWithOrganization: environment organization.
	! !

!ClassFactoryWithOrganizationTest methodsFor: 'testing' stamp: 'LucFabresse 10/24/2010 19:48'!
assertEnvironmentOf: aBehavior
	self assert: aBehavior environment = self testedEnvironment! !

!ClassFactoryWithOrganizationTest methodsFor: 'testing' stamp: 'sm 5/25/2011 01:15'!
expectedFailures
	^ self class allTestSelectors! !

!ClassFactoryWithOrganizationTest methodsFor: 'testing' stamp: 'LucFabresse 10/29/2010 09:09'!
testClassCreationInDifferentCategories
	| firstThreeClasses lastTwoClasses |
	3 timesRepeat: [
		factory newSubclassOf: Object instanceVariableNames: '' classVariableNames: '' category: #One].
	firstThreeClasses := factory createdClasses copy.
	2 timesRepeat: [
		factory newSubclassOf: Object instanceVariableNames: '' classVariableNames: '' category: #Two].
	lastTwoClasses := factory createdClasses copyWithoutAll: firstThreeClasses.
	self assert: (firstThreeClasses allSatisfy: [:class| class category = #One]).
	self assert: (lastTwoClasses allSatisfy: [:class| class category = #Two]).
	factory createdClasses do: [ :aClass |
		self assertEnvironmentOf: aClass ]! !

!ClassFactoryWithOrganizationTest methodsFor: 'testing' stamp: 'LucFabresse 10/29/2010 09:14'!
testClassFastCreationInDifferentCategories
	| firstThreeClasses lastTwoClasses |
	3 timesRepeat: [
		factory newClassInCategory: #One].
	firstThreeClasses := factory createdClasses copy.
	2 timesRepeat: [
		factory newClassInCategory: #Two].
	lastTwoClasses := factory createdClasses copyWithoutAll: firstThreeClasses.
	self assert: (firstThreeClasses allSatisfy: [:class| class category =  #One]).
	self assert: (lastTwoClasses allSatisfy: [:class| class category = #Two]).
	factory createdClasses do: [ :aClass |
		self assertEnvironmentOf: aClass ]! !

!ClassFactoryWithOrganizationTest methodsFor: 'testing' stamp: 'LucFabresse 10/24/2010 19:41'!
testDefaultCategoryCleanUp
	| createdClassNames allClasses |
	3 timesRepeat: [
		factory newClass].
	createdClassNames := factory createdClassNames.
	factory cleanUp.	
	self assert: (factory createdClasses allSatisfy: [:class| class isObsolete]). 
	allClasses := self testedEnvironment allClasses.
	self assert: (factory createdClasses noneSatisfy: [:class| allClasses includes: class]).
	self deny: (self testedOrganization categories includes: factory defaultCategory). 
	self deny: (ChangeSet current changedClassNames includesAnyOf: createdClassNames)
! !

!ClassFactoryWithOrganizationTest methodsFor: 'testing' stamp: 'LucFabresse 10/24/2010 19:50'!
testMultipleClassCreation
	5 timesRepeat: [
		factory newClass].
	self assert: (self testedEnvironment allClasses includesAllOf: factory createdClasses).
	self assert: factory createdClassNames asSet size = 5.
	self assert: (self testedOrganization listAtCategoryNamed: factory defaultCategory) asSet = factory createdClassNames asSet.
	factory createdClasses do: [ :aClass |
		self assertEnvironmentOf: aClass ]! !

!ClassFactoryWithOrganizationTest methodsFor: 'testing' stamp: 'LucFabresse 10/24/2010 19:50'!
testPackageCleanUp
	| createdClassNames allClasses |
	3 timesRepeat: [
		factory newClassInCategory: #One].
	2 timesRepeat: [
		factory newClassInCategory: #Two].
	createdClassNames := factory createdClassNames.
	factory cleanUp.	
	self assert: (factory createdClasses allSatisfy: [:class| class isObsolete]). 
	allClasses := self testedEnvironment allClasses.
	self assert: (factory createdClasses noneSatisfy: [:class| allClasses includes: class]).
	self assert: (self testedOrganization categoriesMatching: factory packageName, '*') isEmpty. 
	self deny: (ChangeSet current changedClassNames includesAnyOf: createdClassNames).
! !

!ClassFactoryWithOrganizationTest methodsFor: 'testing' stamp: 'LucFabresse 10/24/2010 19:51'!
testSingleClassCreation
	|class elementsInCategoryForTest |
	class := factory 
		newSubclassOf: Object 
		instanceVariableNames: 'a b c' 
		classVariableNames: 'X Y'.
	self assert: (self testedEnvironment allClasses includes: class).
	factory createdClasses do: [ :aClass |
		self assertEnvironmentOf: aClass ].
	elementsInCategoryForTest := self testedOrganization listAtCategoryNamed: factory defaultCategory. 
	self assert: elementsInCategoryForTest = {class name}.
	self assert: class instVarNames = #(a b c).
	self assert: class classPool keys asSet = #(X Y) asSet! !

!ClassFactoryWithOrganizationTest methodsFor: 'testing' stamp: 'LucFabresse 10/24/2010 19:51'!
testSingleClassFastCreation
	|class elementsInCategoryForTest |
	class := factory newClass.
	self assert: (self testedEnvironment allClasses includes: class).
	elementsInCategoryForTest := self testedOrganization listAtCategoryNamed: factory defaultCategory. 
	factory createdClasses do: [ :aClass |
		self assertEnvironmentOf: aClass ].
	self assert: elementsInCategoryForTest = {class name}.
	self assert: class instVarNames isEmpty.
	self assert: class classPool isEmpty! !

!ClassHierarchyExplorer methodsFor: 'accessing' stamp: 'ssa 3/1/2010 11:52'!
centralClass
	"Answer the value of centralClass"

	centralClass isNil ifTrue:[self centralClass: nil].
	^ centralClass! !

!ClassHierarchyExplorer methodsFor: 'accessing' stamp: 'ssa 3/1/2010 11:52'!
centralClass: anObject
	"Set the value of centralClass"

	centralClass _ anObject! !

!ClassHierarchyExplorer methodsFor: 'accessing' stamp: 'ssa 3/1/2010 11:52'!
getCentralItem
	^Array with: (ClassHierarchyExplorerWrapper with: self centralClass name: self centralClass name model: self)
! !

!ClassHierarchyExplorer methodsFor: 'accessing' stamp: 'ssa 3/1/2010 12:22'!
getList

	| classList prev |
	classList _ OrderedCollection new.
	self centralClass allSuperclasses reverseDo:  [:aClass | classList add: aClass].
	classList add: self centralClass.
	self centralClass subclassesDo: [:aClass| classList add: aClass].
	prev _nil.
	^(classList collect:[:cls| prev _ ClassHierarchyExplorerWrapper with: cls name: cls name model: self parent: prev]) asArray! !

!ClassHierarchyExplorer methodsFor: 'user interface' stamp: 'ssa 3/1/2010 12:01'!
explorerFor: anObject withLabel: label 
	|  topView listView |
	self centralClass: anObject.
	topView := StandardSystemView new
				label: label; 
				model: self;
				yourself.
	topView addSubView:(listView := ExplorerListView
						on: self
						list: #list
						selected: #getCurrentSelection
						changeSelected: #noteNewSelection:
						menu: #genericMenu:
						keystroke: #explorerKey:from:)
		in: (0 @ 0 corner: 1 @ 1)
		borderWidth:1.
	listView autoDeselect: false.
	^ topView! !

!ClassHierarchyExplorerWrapper methodsFor: 'testing' stamp: 'ssa 3/1/2010 12:06'!
hasContents

	^self item subclasses notEmpty ! !

!ClassHierarchyExplorerWrapper methodsFor: 'accessing' stamp: 'ssa 3/1/2010 12:07'!
asString

	^self itemName! !

!ClassHierarchyExplorerWrapper methodsFor: 'accessing' stamp: 'ssa 3/1/2010 12:04'!
contents
	^ self item subclasses
		collect: [:ea| self class with: ea name: ea name model: item parent: self]! !

!ClassHierarchyExplorerWrapper methodsFor: 'printing' stamp: 'ssa 3/1/2010 12:19'!
printOn: aStream

	aStream nextPutAll:self class name,' on: ',self item printString! !

!ClassTestCase methodsFor: 'coverage' stamp: 'brp 7/27/2003 12:39'!
classToBeTested
	
	self subclassResponsibility! !

!ClassTestCase methodsFor: 'coverage' stamp: 'brp 7/26/2003 16:35'!
selectorsNotTested

	^ self selectorsToBeTested difference: self selectorsTested.
! !

!ClassTestCase methodsFor: 'coverage'!
selectorsTested
	| literals |
	literals := Set new.
	self class
		selectorsAndMethodsDo: [ :s :m | (s beginsWith: 'test')
			ifTrue: [ literals addAll: (m messages)] ].
	^ literals asArray sort! !

!ClassTestCase methodsFor: 'coverage' stamp: 'brp 7/26/2003 17:22'!
selectorsToBeIgnored
	^ #(#DoIt #DoItIn:)! !

!ClassTestCase methodsFor: 'coverage' stamp: 'brp 7/27/2003 12:40'!
selectorsToBeTested

	^ ( { self classToBeTested. self classToBeTested class } gather: [:c | c selectors]) 
			difference: self selectorsToBeIgnored! !

!ClassTestCase methodsFor: 'tests'!
testClassComment
	self should: [self targetClass organization hasComment].! !

!ClassTestCase methodsFor: 'tests' stamp: 'brp 12/14/2003 15:51'!
testCoverage

	| untested | 
	self class mustTestCoverage ifTrue:
		[ untested := self selectorsNotTested.
		self assert: untested isEmpty 
		description: untested size asString, ' selectors are not covered' ]! !

!ClassTestCase methodsFor: 'tests' stamp: 'md 3/25/2003 23:07'!
testNew
	self shouldnt: [self targetClass new] raise: Error.! !

!ClassTestCase methodsFor: 'tests' stamp: 'md 3/26/2003 17:24'!
testUnCategorizedMethods
	| categories slips  |
	categories := self categoriesForClass: self targetClass.
	slips := categories select: [:each | each = #'as yet unclassified'].
	self should: [slips isEmpty].	! !

!ClassTestCase methodsFor: 'private' stamp: 'md 1/28/2004 11:32'!
categoriesForClass: aClass

 ^ aClass organization allMethodSelectors collect: 
			[:each |  aClass organization categoryOfElement: each].
! !

!ClassTestCase methodsFor: 'private' stamp: 'lr 3/14/2010 21:13'!
targetClass
	[ ^ self classToBeTested ]
		on: Error
		do: [ 
			| className |
			className := self class name asText copyFrom: 0 to: self class name size - 4.
			^ Smalltalk globals at: className asString asSymbol ]! !

!ClassTestCase commentStamp: 'brp 7/26/2003 16:57' prior: 0!
This class is intended for unit tests of individual classes and their metaclasses.

It provides methods to determine the coverage of the unit tests.

Subclasses are expected to re-implement #classesToBeTested and #selectorsToBeIgnored.

They should also implement to confirm that all methods have been tested.

#testCoverage

	super testCoverage.

!
!ClassTestCase class methodsFor: 'testing' stamp: 'md 2/22/2006 14:21'!
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self name = #ClassTestCase
			! !

!ClassTestCase class methodsFor: 'testing' stamp: 'brp 12/14/2003 15:50'!
mustTestCoverage

	^ false! !

!CodeHolder methodsFor: 'what to show' stamp: 'ssa 9/3/2008 11:02'!
addContentsTogglesTo: aMenu 
	"Add updating menu toggles governing contents to aMenu."
	self contentsSymbolQuints
		do: [:aQuint | aQuint == #-
				ifTrue: [aMenu addLine]
				ifFalse: [Smalltalk isMorphic
						ifTrue: []
						ifFalse: [aMenu
								add: (('<yes>*' match: (self perform: aQuint third)) ifTrue: ['*'] ifFalse: ['']), aQuint fourth
								target: self
								selector: #contentsSymbol: 
								argumentList: { aQuint first } ]]]! !

!CodeHolder methodsFor: 'what to show' stamp: 'ssa 9/3/2008 10:29'!
offerWhatToShowMenu
	"Offer a menu governing what to show"
	| aMenu |
	Smalltalk isMorphic
		ifTrue: []
		ifFalse: [aMenu := CustomMenu new.
			self addContentsTogglesTo: aMenu.
			aMenu title: 'What to show' translated.
			aMenu invokeOn: self.
			self changed: #contents ]! !

!CodeHolder methodsFor: 'tiles' stamp: 'ssa 9/3/2008 11:03'!
addModelItemsToWindowMenu: aMenu
	"Add model-related item to the window menu"

	super addModelItemsToWindowMenu: aMenu. 
! !

!Collection methodsFor: 'accessing' stamp: 'ssa 3/12/2010 17:57'!
atRandom
	"Answer a random element of the receiver.  Uses a shared random 
	number generator owned by class Collection.  If you use this a lot, 
	define your own instance of Random and use #atRandom:.  Causes 
	an error if self has no elements."

	^ self atRandom: self class randomForPicking 

"Examples:
	#('one' 'or' 'the' 'other') atRandom
	(1 to: 10) atRandom
	'Just pick one of these letters at random' atRandom
	#(3 7 4 9 21) asSet atRandom		(just to show it also works for Sets)
"! !

!Collection methodsFor: 'converting'!
asString: aBlock withDelimiter: aDelimiter
	"kwa -- 30 November 1988, Answer a string with each of the objects in the receiver (converted to strings by aBlock) separated by aDelimiter."
	"KSC Extension"

	| aStream |
	self isEmpty ifTrue: [^''].
	aStream _ WriteStream on: (String new: 64).
	self do: [:each |
		aStream nextPutAll: (aBlock value: each).
		aStream nextPutAll: aDelimiter].
	aStream skip: aDelimiter size negated.
	^aStream contents

	"#(13 2 3) asString: [:each | (each * 2) printString] withDelimiter: ', '"! !

!Collection methodsFor: 'converting'!
asStringWithDelimiter: aDelimiter
	"kwa -- 13 May 1988, Answer a string of from the objects in the receiver separated by aDelimiter."
	"KSC Extension"

	| aStream |
	self isEmpty ifTrue: [^''].
	aStream _ WriteStream on: (String new: 64).
	self do: [:each |
		(each isKindOf: String) 
			ifTrue: [aStream nextPutAll: each asString]
			ifFalse: [each printOn: aStream].
		aStream nextPutAll: aDelimiter].
	aStream skip: aDelimiter size negated.
	^aStream contents

	"#(a b 2 3) asStringWithDelimiter: ', '"! !

!Collection methodsFor: 'converting'!
asText: aBlock withDelimiter: aDelimiter
	"kwa -- 30 November 1988, Answer a text with each of the objects in the receiver (converted to texts by aBlock) separated by aDelimiter."
	"KSC Extension"

	| aDelimiterText first text |
	self isEmpty ifTrue: [^'' asText].
	aDelimiterText _ aDelimiter asText.
	first _ true.
	self do: [:each |
		first 
			ifTrue: 
				[text _ (aBlock value: each) asText.
				first _ false]
			ifFalse:
				[text _ text, aDelimiterText, (aBlock value: each) asText]].
	^text

	"(#(13 2 3) asText: [:each | (each * 2) printString asText allBold] withDelimiter: ', ') asDisplayText displayAt: Sensor cursorPoint"! !

!Collection methodsFor: 'enumerating'!
collect: aBlock if: aQualifyingBlock
	"kwa -- 1 February 1989,
	Evaluate aQualifyingBlock with each of the values of the receiver as the argument.  If the result is true, collect the resulting values of aBlock (using the same value as the argument) into a collection that is like the receiver.  Answer the new collection."
	"KSC Extension"

	| newCollection |
	newCollection _ self species new.
	self do: [:each | 
		(aQualifyingBlock value: each)
			ifTrue: [newCollection add: (aBlock value: each)]].
	^newCollection! !

!Collection methodsFor: '*Sly3' stamp: 'dmu 9/16/2010 23:41'!
asEnsembleOfElements
	^ Sly3Ensemble withMembersFrom: self! !

!Collection methodsFor: '*Sly' stamp: 'ssa 7/7/2010 19:50'!
deactivateEnsembleSendsDuring: aBlock
	"disable messaging dispatching to members and just send it to myself during aBlock"
	
	0 primitiveSetExtraPreheaderWord:  self.
	aBlock value.
	self  primitiveSetExtraPreheaderWord:  self. 
! !

!Collection methodsFor: '*Sly' stamp: 'dmu 9/17/2010 11:04'!
parallelCollect: aBlock
	"#(1 2 3 4 5) asOrderedCollection parallelCollect:[:e| e * 2]"
	| results task  barrier result interlock |
	"true ifTrue: [^ self collect: aBlock.]." "for debugging"
	self ifEmpty: [^ self].
	(Sly3 serializeForDebugging or: [self size = 1]) ifTrue: [^ self collect: aBlock].
	results _ self species new.
	barrier _ RVMBarrier new signalsNeededToPass: self size.
	interlock _ Semaphore forMutualExclusion.
	self do:[:each|
		task _ [
			result _ ([aBlock copy fixTemps value: each] ifCurtailed: [barrier signal.
				"Tasks do:[:eachTask| eachTask terminate].
				Tasks _ OrderedCollection new."
				 "self error: 'Yipes!! An ensemble is NLRing back.'." ] ).
			interlock critical: [results add: result].
			barrier signal] asSlyMemberProcess.
		task resume].
	barrier wait.
	^results! !

!Collection methodsFor: '*Sly' stamp: 'dmu 9/1/2010 15:17'!
product
	| r |
	r _ 1.
	self do: [:e| r _ r * e].
	^ r! !

!Collection methodsFor: '*Sly' stamp: 'dmu 9/8/2010 21:58'!
sentToEnsemble: aMessage
	| r |
	r _ Sly3EnsembleMessageDispatcher dispatch: (Sly3UnprocessedEnsembleMessage fromMessage: aMessage members: self).
	^ r! !

!Collection methodsFor: 'removing' stamp: 'ssa 9/9/2009 12:16'!
removeAll: aCollection ifAbsent:aBlock
	"Remove each element of aCollection from the receiver. If successful for 
	each, answer aCollection. Otherwise create an error notification.
	ArrayedCollections cannot respond to this message."

	aCollection do: [:each | self remove: each ifAbsent: aBlock].
	^ aCollection! !

!Collection methodsFor: 'outlining' stamp: 'ssa 9/10/2009 13:47'!
subobjects

	^self! !

!Collection methodsFor: '*RVM-converting' stamp: 'dmu 9/16/2010 23:43'!
doInParallel: aBlock
	self parallelCollect: aBlock! !

!Collection methodsFor: '*packageinfo-base' stamp: 'ab 9/30/2002 19:26'!
gather: aBlock
	^ Array streamContents:
		[:stream |
		self do: [:ea | stream nextPutAll: (aBlock value: ea)]]! !

!Color class methodsFor: 'other' stamp: 'ssa 9/13/2008 16:04'!
colorChart

	^ColorChart! !

!Color class methodsFor: 'other' stamp: 'ssa 9/13/2008 16:04'!
colorChart: aChart

	ColorChart _ aChart! !

!Color class methodsFor: 'color from user' stamp: 'ssa 9/13/2008 15:52'!
fromUser
	"Displays a color palette of colors, waits for a mouse click, and returns the selected color. Any pixel on the Display can be chosen, not just those in the color palette."
	"Note: Since the color chart is cached, you may need to do 'ColorChart _ nil' after changing the oldColorPaletteForDepth:extent: method."
	"Color fromUser"

	| d startPt save tr oldColor c here s |
	d _ Display depth.
	((ColorChart == nil) or: [ColorChart depth ~= Display depth]) 
		ifTrue: [ColorChart _ self oldColorPaletteForDepth: d extent: (2 * 144)@80].
	startPt _ Sensor cursorPoint "y < Display center y 
		ifTrue: [startPt _ 0@(Display boundingBox bottom - ColorChart height)]
		ifFalse: [startPt _ 0@0]".

	save _ Form fromDisplay: (startPt extent: ColorChart extent).
	ColorChart displayAt: startPt.
	tr _ ColorChart extent - (50@19) corner: ColorChart extent.
	tr _ tr translateBy: startPt.

	oldColor _ nil.
	[Sensor anyButtonPressed] whileFalse: [
		c _ Display colorAt: (here _ Sensor cursorPoint).
		(tr containsPoint: here)
			ifFalse: [Display fill: (0@61+startPt extent: 20@19) fillColor: c]
			ifTrue: [
				c _ Color transparent.
				Display fill: (0@61+startPt extent: 20@19) fillColor: Color white].
		c = oldColor ifFalse: [
			Display fillWhite: (20@61 + startPt extent: 135@19).
			c isTransparent
				ifTrue: [s _ 'transparent']
				ifFalse: [s _ c shortPrintString.
						s _ s copyFrom: 7 to: s size - 1].
			s displayAt: 20@61 + startPt.
			oldColor _ c]].
	save displayAt: startPt.
	Sensor waitNoButton.
	^ c
! !

!ColorForm methodsFor: 'private' stamp: 'ssa 11/26/2009 22:44'!
setExtent: extent depth: bitsPerPixel
	"Create a virtual bit map with the given extent and bitsPerPixel."

	| bpp |
	bpp _ bitsPerPixel.
	bpp > 8 ifTrue: [self error: 'ColorForms only support depths up to 8 bits, proceed for 8 bits'.
		bpp _ 8].
	super setExtent: extent depth: bpp.
! !

!ColorMap class methodsFor: 'instance creation' stamp: 'ar 5/27/2000 20:08'!
mappingToARGB: srcBitMasks
	"Return a ColorMap mapping from srcBitMasks into canonical ARGB space"
	^self mappingFrom: srcBitMasks to: #(16rFF0000 16rFF00 16rFF 16rFF000000)! !

!ColorMap class methodsFor: 'instance creation' stamp: 'ar 5/4/2001 15:59'!
masks: maskArray shifts: shiftArray
	^self shifts: shiftArray masks: maskArray colors: nil.! !

!CompiledMethod methodsFor: 'printing' stamp: 'ads 1/24/2011 13:02'!
longPrintOn: aStream indent: tabs
	"List of all the byte codes in a method with a short description of each" 

aStream nextPutAll: (RVMPrimitivesNeededForBootstrapping printPrefixFor: self).
	self isQuick ifTrue: 
		[self isReturnSpecial ifTrue:
			[^ aStream tab: tabs; nextPutAll: 'Quick return ' , 
				(#('self' 'true' 'false' 'nil' '-1' '0' '1' '2') at: self primitive - 255)].
		^ aStream nextPutAll: 'Quick return field ' , self returnField printString , ' (0-based)'].

	self primitive = 0 ifFalse: [
		aStream tab: tabs.
		self printPrimitiveOn: aStream.
	].
	(InstructionPrinter on: self) indent: tabs; printInstructionsOn: aStream.
! !

!CompiledMethod methodsFor: 'printing' stamp: 'ssa 10/3/2008 18:13'!
symbolic
	"Answer a String that contains a list of all the byte codes in a method 
	with a short description of each."

	| aStream |
	aStream _ WriteStream on: (String new: 1000).
	self longPrintOn: aStream.
	^aStream contents! !

!CompiledMethod methodsFor: 'printing' stamp: 'dmu 9/7/2010 14:23'!
timeStamp
	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."

	"(CompiledMethod compiledMethodAt: #timeStamp) timeStamp"

	| position file preamble stamp tokens tokenCount |
	self fileIndex == 0 ifTrue: [^ String new].  "no source pointer for this method"
	position _ self filePosition.
	file _ SourceFiles at: self fileIndex.
	file ifNil: [^ String new].  "sources file not available"
	"file does not exist happens in secure mode"
	file _ [file readOnlyCopy] on: FileDoesNotExistException do:[:ex| nil].

	file ifNil: [^ String new].
	file position: (0 max: position - 150).  "Skip back to before the preamble"
		[file position < (position - 1)]  "then pick it up from the front"
			whileTrue: [preamble _ file nextChunk].
		stamp _ String new.
		tokens _ (preamble findString: 'methodsFor:' startingAt: 1) > 0
			ifTrue: [Scanner new scanTokens: preamble]
			ifFalse: [Array new  "ie cant be back ref"].
		(((tokenCount _ tokens size) between: 7 and: 8) and: [(tokens at: tokenCount - 5) = #methodsFor:])
			ifTrue:
				[(tokens at: tokenCount - 3) = #stamp:
					ifTrue: ["New format gives change stamp and unified prior pointer"
							stamp _ tokens at: tokenCount - 2]].
		((tokenCount between: 5 and: 6) and: [(tokens at: tokenCount - 3) = #methodsFor:])
			ifTrue:
				[(tokens at: tokenCount  - 1) = #stamp:
					ifTrue: ["New format gives change stamp and unified prior pointer"
						stamp _ tokens at: tokenCount]].
	file close.
	^ stamp
! !

!CompiledMethod methodsFor: 'source code management' stamp: 'dmu 9/7/2010 14:23'!
putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock
  "Store the source code for the receiver on an external file.
  If no sources are available, i.e., SourceFile is nil, then store
  temp names for decompilation at the end of the method.
  If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,
  in each case, storing a 4-byte source code pointer at the method end."

  | file remoteString  st80str |
  (SourceFiles == nil or: [(file _ SourceFiles at: fileIndex) == nil]) ifTrue:
    [^ self become: (
      (self class methodDictionary includesKey: #copyWithTempsFromMethodNode:) 
        ifTrue: [self copyWithTempsFromMethodNode: methodNode]
        ifFalse: [self copyWithTempNames: methodNode tempNames]
    )].

  SmalltalkImage current assureStartupStampLogged.
  file safelyDo: [
    file setToEnd.

    preambleBlock value: file.  "Write the preamble"
    (DialectMethodNode notNil and: [methodNode isKindOf: DialectMethodNode])
      ifTrue:
        ["This source was parsed from an alternate syntax.
        We must convert to ST80 before logging it."
        st80str _ (DialectStream dialect: #ST80 contents: [:strm | methodNode printOn: strm])
        asString.
        remoteString _ RemoteString newString: st80str
        onFileNumber: fileIndex toFile: file]
      ifFalse:
        [remoteString _ RemoteString newString: sourceStr
        onFileNumber: fileIndex toFile: file].

    file nextChunkPut: ' '.
    InMidstOfFileinNotification signal ifFalse: [file flush].
    self checkOKToAdd: sourceStr size at: remoteString position.
    self setSourcePosition: remoteString position inFile: fileIndex
    ]! !

!CompositePackageInfo methodsFor: 'accessing' stamp: 'ads 12/10/2010 12:03'!
name
	^ name! !

!CompositePackageInfo methodsFor: 'accessing' stamp: 'ads 12/10/2010 12:02'!
name: aString
	name := aString.! !

!CompositePackageInfo methodsFor: 'accessing' stamp: 'ads 12/10/2010 12:03'!
packageNames: aCollection
	"Just a shortcut for setting my packages."
	self packages: (aCollection collect: [:n | PackageInfo named: n]).! !

!CompositePackageInfo methodsFor: 'accessing' stamp: 'ads 12/2/2010 14:46'!
packages
	^ packages! !

!CompositePackageInfo methodsFor: 'accessing' stamp: 'ads 12/2/2010 14:45'!
packages: aCollection
	packages := aCollection.! !

!CompositePackageInfo methodsFor: 'classes' stamp: 'ads 12/2/2010 14:44'!
classes
	^ packages
		ifNil: [Smalltalk allClasses]
		ifNotNil: [packages gather: [:p | p classes]]! !

!CompositePackageInfo methodsFor: 'classes' stamp: 'ads 12/5/2010 22:59'!
systemCategories
	^ packages
		ifNil: [SystemOrganization categories]
		ifNotNil: [packages gather: [:p | p systemCategories]]! !

!CompositePackageInfo methodsFor: 'extension methods' stamp: 'ads 12/3/2010 11:20'!
extensionCategoriesForClass: cls
	^ packages
		ifNil: [{}]
		ifNotNil: [packages gather: [:p | p extensionCategoriesForClass: cls]]! !

!CompositePackageInfo methodsFor: 'extension methods' stamp: 'ads 1/13/2011 13:31'!
extensionClasses
	^ packages
		ifNil: [{}]
		ifNotNil: [((packages gather: [:p | p extensionClasses]) asSet asSortedCollection: [:a :b | a name < b name]) asArray]! !

!CompositePackageInfo methodsFor: 'extension methods' stamp: 'ads 12/2/2010 14:44'!
extensionMethods
	^ packages
		ifNil: [{}]
		ifNotNil: [packages gather: [:p | p extensionMethods]]! !

!CompositePackageInfo methodsFor: 'extension methods' stamp: 'ads 12/6/2010 01:02'!
isYourClassExtension: categoryName
	^ packages
		ifNil: [false]
		ifNotNil: [packages anySatisfy: [:p | p isYourClassExtension: categoryName]]! !

!CompositePackageInfo methodsFor: 'testing' stamp: 'ads 12/14/2010 10:16'!
includesClass: aClass
	^ self includesSystemCategory: aClass theNonMetaClass category! !

!CompositePackageInfo methodsFor: 'testing' stamp: 'ads 12/14/2010 10:15'!
includesMethod: aSymbol ofClass: aClass
	aClass ifNil: [^ false].
	^ self
		includesMethodCategory: ((aClass organization categoryOfElement: aSymbol)
										ifNil: [' '])
		ofClass: aClass! !

!CompositePackageInfo methodsFor: 'testing' stamp: 'ads 12/14/2010 10:15'!
includesMethodCategory: categoryName ofClass: aClass
	^ (self isYourClassExtension: categoryName)
		or: [(self includesClass: aClass)
				and: [(self isForeignClassExtension: categoryName) not]]! !

!CompositePackageInfo methodsFor: 'testing' stamp: 'ads 12/14/2010 10:17'!
includesSystemCategory: categoryName
	^ packages ifNil: [true] ifNotNil: [packages anySatisfy: [:p | p includesSystemCategory: categoryName]]! !

!CompositePackageInfo methodsFor: 'testing' stamp: 'ads 12/14/2010 10:18'!
isForeignClassExtension: categoryName
	^ categoryName first = $* and: [(self isYourClassExtension: categoryName) not]! !

!CompositePackageInfo methodsFor: 'comparing' stamp: 'ads 1/26/2011 13:05'!
= other
	^ self species = other species and: [self name = other name and: [self packages = other packages]]! !

!CompositePackageInfo methodsFor: 'comparing' stamp: 'ads 1/26/2011 13:06'!
hash
	^ self name hash bitXor: self packages hash! !

!CompositePackageInfo methodsFor: 'reverting' stamp: 'ads 1/26/2011 16:16'!
revertToVersionBeforeTeam: team
	self extensionMethods do: [:m | team revertToOldVersionOrRemove: m].
	self classes do: [:cls | cls removeFromSystem].
	self systemCategories do: [:cat | SystemOrganization removeCategoryIfEmpty: cat].
! !

!CompositePackageInfo methodsFor: 'composing' stamp: 'ads 12/5/2010 23:38'!
, p
	^ self class new
		packages: {self. p};
		yourself! !

!CompositePackageInfo methodsFor: 'composing' stamp: 'ads 1/26/2011 14:15'!
includesPackage: p
	^ self = p or: [self packages anySatisfy: [:myPackage | myPackage includesPackage: p]]! !

!CompositePackageInfo commentStamp: 'ads 12/14/2010 09:16' prior: 0!
Contains multiple packages (see the PackageInfo class).

To specify that you want a CompositePackageInfo containing all classes in the entire image, leave the collection of packages as nil.

Doesn't support the entire PackageInfo protocol yet; just the stuff we needed to save code out to text files.!
!CompositePackageInfo class methodsFor: 'as yet unclassified' stamp: 'ads 12/10/2010 11:58'!
forEntireImage
	^ self new
		name: 'EntireImage';
		yourself ! !

!CompositePackageInfo class methodsFor: 'as yet unclassified' stamp: 'ads 12/10/2010 11:58'!
forRVMBootstrapping
	^ self new
		name: 'RVMBootstrapping';
		packageNames: {'RVMBootstrap'. 'SlyBootstrap'. 'Sly3Bootstrap'};
		yourself
! !

!ConfigurationOfBenchmarking methodsFor: 'baselines' stamp: 'StefanMarr 7/8/2011 22:34'!
baseline01: spec
	"<version: '0.1-baseline'>"

	spec for: #'common' do: [
		spec blessing: #'baseline'.
		spec repository: 'http://www.squeaksource.com/SMark'.
		self class subPackages do: [:pkg | spec package:  pkg ].
	].

	spec for: #pharo do: [
		spec project: 'OSProcess'
			with:
				[ spec
					className: 'ConfigurationOfOSProcess';
					file: 'ConfigurationOfOSProcess';
					repository: 'http://www.squeaksource.com/MetacelloRepository' ]
		]! !

!ConfigurationOfBenchmarking methodsFor: 'symbolic versions' stamp: 'StefanMarr 7/8/2011 22:34'!
development: spec
	"<symbolicVersion: #'development'>"

	spec for: #'common' version: '0.1'.
! !

!ConfigurationOfBenchmarking methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 12:19'!
project

	^ project ifNil: [ | constructor |
		"Bootstrap Metacello if it is not already loaded"
		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.
		"Construct Metacello project"
		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.
		project := constructor project.
		project loadType: #linear. "change to #atomic if desired"
		project ]! !

!ConfigurationOfBenchmarking methodsFor: 'versions' stamp: 'StefanMarr 7/8/2011 22:34'!
version01: spec
	"<version: '0.1' imports: #('0.1-baseline' )>"

	spec for: #'common' do: [
		spec blessing: #'development'.
		spec description: ''.
		spec author: 'StefanMarr'.
		spec timestamp: '5/14/2011 12:19'.
	].! !

!ConfigurationOfBenchmarking class methodsFor: 'development support' stamp: 'StefanMarr 7/8/2011 22:34'!
DevelopmentSupport

"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."
	"<apiDocumentation>"
! !

!ConfigurationOfBenchmarking class methodsFor: 'development support' stamp: 'StefanMarr 7/8/2011 22:35'!
validate
	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 
	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 
	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.
	Warnings identify specification issues that are technically correct, but are worth take a look at."

	"self validate"

	"<apiDocumentation>"
	self ensureMetacello.
	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !

!ConfigurationOfBenchmarking class methodsFor: 'private' stamp: 'StefanMarr 5/14/2011 12:19'!
baseConfigurationClassIfAbsent: aBlock

	^Smalltalk
		at: #MetacelloBaseConfiguration
		ifAbsent: [ 
			self ensureMetacelloBaseConfiguration.
			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].
! !

!ConfigurationOfBenchmarking class methodsFor: 'private' stamp: 'StefanMarr 5/14/2011 12:19'!
ensureMetacello

	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !

!ConfigurationOfBenchmarking class methodsFor: 'private' stamp: 'StefanMarr 5/14/2011 12:19'!
ensureMetacelloBaseConfiguration

	Smalltalk
		at: #MetacelloBaseConfiguration
		ifAbsent: [ 
			| repository version |
			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.
			repository
				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'
				do: [ :reader | 
					version := reader version.
					version load.
					version workingCopy repositoryGroup addRepository: repository ] ]! !

!ConfigurationOfBenchmarking class methodsFor: 'metacello tool support' stamp: 'StefanMarr 5/14/2011 12:19'!
isMetacelloConfig
	"Answer true and the Metacello tools will operate on you"
	
	^true! !

!ConfigurationOfBenchmarking class methodsFor: 'loading' stamp: 'StefanMarr 7/8/2011 22:35'!
load
	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."

	"self load"

	"<apiDocumentation>"
	^(self project version: #stable) load! !

!ConfigurationOfBenchmarking class methodsFor: 'loading' stamp: 'StefanMarr 7/8/2011 22:35'!
loadBleedingEdge
	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."

	"self loadBleedingEdge"

	"<apiDocumentation>"
	^(self project version: #bleedingEdge) load! !

!ConfigurationOfBenchmarking class methodsFor: 'loading' stamp: 'StefanMarr 7/8/2011 22:35'!
loadDevelopment
	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."

	"self loadDevelopment"

	"<apiDocumentation>"
	^(self project version: #development) load! !

!ConfigurationOfBenchmarking class methodsFor: 'transporter' stamp: 'StefanMarr 5/25/2011 11:49'!
saveWithTransporter
	"Will save the package in file-out format using the Transporter infrastructure"
	self transporters
		ifNotNilDo: [:transporters | 
			transporters do: [:t | t saveNoPopup ]].! !

!ConfigurationOfBenchmarking class methodsFor: 'transporter' stamp: 'StefanMarr 7/8/2011 22:27'!
subPackages
	"Specifies the names of all logical subpackages of the Benchmarking package."
	"TODO: have a versioning for this, to better comply with the Metacello approach."
	^ {	'SMark'.
		'NPB'.
		'CL-Benchmarks-Game'.
	}! !

!ConfigurationOfBenchmarking class methodsFor: 'transporter' stamp: 'sm 7/8/2011 22:39'!
transporters
	"Returns the transporters that define how to file out the different packages for versioning with Git."
	Smalltalk at: #Transporter ifPresent: [ :tpCls |
		| package packages |
		package := CompositePackageInfo new.
		package name: 'Benchmarking'.
		
		packages := { PackageInfo named: 'ConfigurationOfBenchmarking' }.
		packages := packages, (self subPackages collect: [:pkg | PackageInfo named: pkg ]).
				
		package packages: packages.		
		^ {Transporter forPackage: package}.
	].
	^ nil.! !

!ConfigurationOfBenchmarking class methodsFor: 'transporter' stamp: 'StefanMarr 5/25/2011 11:48'!
transportersForFileOutMenu
	^ self transporters! !

!ConfigurationOfBenchmarking class methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 12:19'!
project

	^self new project! !

!ContextPart methodsFor: 'debugger access' stamp: 'ads 1/24/2011 13:02'!
tempsAndValues
	"Return a string of the temporary variabls and their current values"
	| aStream |
	aStream _ WriteStream on: (String new: 100).
	self tempNames
		doWithIndex: [:title :index |
			aStream nextPutAll: title; nextPut: $:; space; tab.
			aStream nextPutAll:(RVMPrimitivesNeededForBootstrapping printPrefixFor:(self tempAt: index)).
			(self tempAt: index) printOn: aStream.
			aStream cr].
	^aStream contents! !

!ContextPart methodsFor: 'system simulation' stamp: 'ssa 9/7/2009 14:34'!
runSimulated: aBlock contextAtEachStep: block2
	"Simulate the execution of the argument, aBlock, until it ends. aBlock 
	MUST NOT contain an '^'. Evaluate block2 with the current context 
	prior to each instruction executed. Answer the simulated value of aBlock."

	| current |
	(aBlock isBlock and: [aBlock hasMethodReturn])
		ifTrue: [self error: 'simulation of blocks with ^ can run loose'].
	current _ aBlock asContext.
	current privSender: self.
	[current == self]
		whileFalse:
			[block2 value: current.
			current _ current step].
	^ self pop! !

!ContextPart methodsFor: 'private-exceptions' stamp: 'ssa 1/21/2010 16:20'!
unwindTo: aContext

	| ctx unwindBlock |
	ctx := self.
	[(ctx _ ctx findNextUnwindContextUpTo: aContext) isNil] whileFalse: [
		unwindBlock := ctx tempAt: 1.
		unwindBlock == nil ifFalse: [
			ctx tempAt: 1 put: nil.
			unwindBlock value]
	].
! !

!ContextPart methodsFor: 'as yet unclassified' stamp: 'ssa 9/3/2008 11:42'!
errorReportOn: foo! !

!ContextPart methodsFor: '*RVMBootstrap' stamp: 'dmu 9/22/2010 22:18'!
contextStackIn: aProcess
	"Answer an Array of the contexts on the receiver's sender chain."

	^self stackOfSize: 100000 in: aProcess! !

!ContextPart methodsFor: '*RVMBootstrap' stamp: 'dmu 9/22/2010 22:38'!
senderOrSlyInvokerAndProcessIn: aProcess
	"Answer the context that sent the message that created the receiver."
	"Follow up the process parent chain to the invoking ensemble process."
	^sender ifNotNil: [sender->aProcess] ifNil: [ aProcess parent ifNil: [nil] ifNotNil: [aProcess parent suspendedContext->aProcess parent]]! !

!ContextPart methodsFor: '*RVMBootstrap' stamp: 'dmu 9/22/2010 22:29'!
senderOrSlyInvokerIn: aProcess
	"Answer the context that sent the message that created the receiver."
	"Follow up the process parent chain to the invoking ensemble process."

	^sender ifNotNil: [sender] ifNil: [self halt. aProcess parent ifNil: [nil] ifNotNil: [aProcess parent suspendedContext]]! !

!ContextPart methodsFor: '*RVMBootstrap' stamp: 'dmu 9/22/2010 22:38'!
stackOfSize: limit  in: aProcess
	"Answer an OrderedCollection of the top 'limit' contexts
		on the receiver's sender chain."

	| a stack cachedStackTop newLimit p assoc |
	stack _ OrderedCollection new.
	stack addLast: (a _ self).
	p _ aProcess.
	"Ugh!! I ought to clean this up. -- dmu"
	[ (assoc _ a senderOrSlyInvokerAndProcessIn: p) ~~ nil and: [stack size < limit]]
		whileTrue:
			[
			a _ assoc key.
			p _ assoc value.
			a hideFromDebugger ifFalse: [stack addLast: a].
			a cachesStack ifTrue: [cachedStackTop := a cachedStackTop]].
	^cachedStackTop == nil 
		ifTrue: [stack]
		ifFalse:
			[newLimit := limit - stack size.
			newLimit > 0
				ifTrue: [stack addAllLast: (cachedStackTop stackOfSize: newLimit); yourself]
				ifFalse: [stack]]! !

!ControlManager methodsFor: 'accessing' stamp: 'ssa 3/25/2010 16:14'!
activeControllerNoTerminate: aController andProcess: aProcess
	"Set aController to be the currently active controller and aProcess to be 
	the the process that handles controller scheduling activities in the 
	system. This message differs from activeController:andProcess: in that it 
	does not send controlTerminate to the currently active controller."

	self inActiveControllerProcess
		ifTrue: 
			[aController~~nil
				ifTrue: [(scheduledControllers includes: aController)
							ifTrue: [self promote: aController]
							ifFalse: [self error: 'Old controller not scheduled']].
			activeController _ aController.
			activeController == nil
				ifFalse: [activeController controlInitialize].
			activeControllerProcess _ aProcess.
			activeControllerProcess resume]
		ifFalse: 
			['New active controller process must be set from old one, resetting...' print.
			self reset.
			] ! !

!ControlManager methodsFor: 'scheduling' stamp: 'dmu 11/25/2008 00:19'!
inActiveControllerProcess
	"Answer whether the active scheduling process is the actual active 
	process in the system."

	^activeControllerProcess == Processor thisProcess! !

!ControlManager methodsFor: 'scheduling' stamp: 'ssa 3/2/2010 14:12'!
interruptName: labelString
	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."
	| suspendingList newActiveController |
	(suspendingList _ activeControllerProcess suspendingList) == nil
		ifTrue: [activeControllerProcess == Processor thisProcess
					ifTrue: [activeControllerProcess suspend]]
		ifFalse: [suspendingList remove: activeControllerProcess ifAbsent:[].
				activeControllerProcess offList].

	activeController ~~ nil ifTrue: [
		"Carefully de-emphasis the current window."
		activeController view topView deEmphasizeForDebugger].

	newActiveController _
		(Debugger
			openInterrupt: labelString 
			onProcess: activeControllerProcess) controller.
	newActiveController centerCursorInView.
	self activeController: newActiveController.
! !

!ControlManager methodsFor: 'scheduling' stamp: 'ssa 3/25/2010 16:17'!
reset
	"ssa - reset the window controller process"
	| newProcess |
	newProcess := [ScheduledControllers resetActiveController.
			ScheduledControllers searchForActiveController] fixTemps newProcess priority: Processor userSchedulingPriority.
	newProcess resume.
	"lose the current process"
	"Processor terminateActive"! !

!ControlManager methodsFor: 'scheduling' stamp: 'dmu 11/25/2008 00:19'!
resetActiveController
	"When saving a morphic project whose parent is mvc, we need to set this up first"

	activeController _ nil.
	activeControllerProcess _ Processor thisProcess.
! !

!ControlManager methodsFor: 'scheduling' stamp: 'dmu 11/25/2008 00:20'!
scheduleActiveNoTerminate: aController 
	"Make aController be the active controller. Presumably the process that 
	requested the new active controller wants to keep control to do more 
	activites before the new controller can take control. Therefore, do not 
	terminate the currently active process."

	self schedulePassive: aController.
	self scheduled: aController
		from: Processor thisProcess! !

!ControlManager methodsFor: 'scheduling' stamp: 'dmu 11/25/2008 00:20'!
searchForActiveController
	"Find a scheduled controller that wants control and give control to it. If 
	none wants control, then see if the System Menu has been requested."
	| aController |
	activeController _ nil.
	activeControllerProcess _ Processor thisProcess.
	self activeController: self nextActiveController.
	Processor terminateActive! !

!ControlManager methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:48'!
restore 
	"Clear the screen to gray and then redisplay all the scheduled views.  Try to be a bit intelligent about the view that wants control and not display it twice if possible."

	scheduledControllers first view uncacheBits.  "assure refresh"
	self unschedule: screenController; scheduleOnBottom: screenController.
	screenController view window: Display boundingBox; displayDeEmphasized.
	self scheduledWindowControllers reverseDo:
		[:aController | aController view resetDisplayInterlock; displayDeEmphasized].
! !

!ControlManager methodsFor: 'displaying' stamp: 'ssa 8/26/2008 08:55'!
restore: aRectangle below: index without: aView
	"Restore all windows visible in aRectangle, but without aView"
	| view | 
	view := (scheduledControllers at: index) view.
	view == aView ifTrue: 
		[index >= scheduledControllers size ifTrue: [^ self].
		^ self restore: aRectangle below: index+1 without: aView].
	view isNil ifTrue:[^self].
	view displayOn: ((BitBlt current toForm: Display) clipRect: aRectangle).
	index >= scheduledControllers size ifTrue: [^ self].
	(aRectangle areasOutside: view windowBox) do:
		[:rect | self restore: rect below: index + 1 without: aView]! !

!Controller methodsFor: 'initialize-release'!
initialize
	"Initialize the state of the receiver. Subclasses should include 'super 
	initialize' when redefining this message to insure proper initialization."

	sensor _ InputSensor default! !

!Controller methodsFor: 'basic control sequence' stamp: 'sm 2/24/2011 18:49'!
controlLoop 
	"Sent by Controller|startUp as part of the standard control sequence. 
	Controller|controlLoop sends the message Controller|isControlActive to test 
	for loop termination. As long as true is returned, the loop continues. 
	When false is returned, the loop ends. Each time through the loop, the 
	message Controller|controlActivity is sent."
	| oldName |
	oldName := Processor thisProcess name.
	
	" as long as the process is executing the control loop it will be named according to its class "
	Processor thisProcess name:  self class name, '(Controller)>>controlLoop'.
	
	[self isControlActive] whileTrue: ["self killExtraUIProcesses."
		self interActivityPause. self controlActivity. Processor yield].
	
	" restore old name "
	Processor thisProcess name: oldName.
	
	self lastProcessRunningMe: nil! !

!Controller methodsFor: 'basic control sequence' stamp: 'ads 1/24/2011 13:01'!
interActivityPause
	"if we are looping quickly, insert a short delay.  Thus if we are just doing UI stuff, we won't take up much CPU"
	| currentTime wait |
	[RVMPrimitivesNeededForBootstrapping isRVM ifTrue: [Processor yield. ^ self].].
	MinActivityLapse ifNotNil: [
		lastActivityTime ifNotNil: [ 
			currentTime _ Time millisecondClockValue.
			wait _ lastActivityTime + MinActivityLapse - currentTime.
			wait > 0 ifTrue: [ 
				wait <= MinActivityLapse  "big waits happen after a snapshot"
					ifTrue: [DisplayScreen checkForNewScreenSize.
							"(Delay forMilliseconds: wait) wait "]. ]. ]. ].

	lastActivityTime _ Time millisecondClockValue.! !

!Controller methodsFor: '*Ly' stamp: 'dmu 3/29/2010 00:21'!
killExtraUIProcesses
		| p lp |
	p _ Processor thisProcess.
		lp _ self lastProcessRunningMe.
		p == lp ifTrue: [self killCounter: 0. ^ self].
		lp isRunning ifTrue: [
			self killCounter < 5  ifTrue: [
				self killCounter: self killCounter + 1.
				^ self.
			].
			self killCounter: 0.
			Transcript cr;show:'Controller>>killExtraUIProcesses working, killing process hash=',p identityHash printString.
			p terminate
		]
		
	"1 foo"
	"2 timesRepeat:[[self halt]fork]"! !

!Controller methodsFor: 'accessing' stamp: 'ssa 3/2/2010 17:18'!
lastActivityTime
	"Answer the value of lastActivityTime"

	lastActivityTime isNil ifTrue:[self lastActivityTime: nil].
	^ lastActivityTime! !

!Controller methodsFor: 'accessing' stamp: 'ssa 3/2/2010 17:18'!
lastActivityTime: anObject
	"Set the value of lastActivityTime"

	lastActivityTime _ anObject! !

!Controller methodsFor: '*RVMBootstrap' stamp: 'dmu 3/26/2010 14:59'!
killCounter
	"Answer the value of killCounter"

	killCounter isNil ifTrue:[self killCounter: 0].
	^ killCounter! !

!Controller methodsFor: '*RVMBootstrap' stamp: 'dmu 3/26/2010 14:59'!
killCounter: anObject
	"Set the value of killCounter"

	killCounter _ anObject! !

!Controller methodsFor: '*RVMBootstrap' stamp: 'ssa 3/2/2010 17:28'!
lastProcessRunningMe
	"Answer the value of lastProcessRunningMe"

	lastProcessRunningMe isNil ifTrue:[self lastProcessRunningMe: Processor thisProcess].
	^ lastProcessRunningMe! !

!Controller methodsFor: '*RVMBootstrap' stamp: 'ssa 3/2/2010 17:18'!
lastProcessRunningMe: anObject
	"Set the value of lastProcessRunningMe"

	lastProcessRunningMe _ anObject! !

!Controller class methodsFor: 'initialization' stamp: 'ssa 8/15/2008 09:40'!
initialize
	"Controller initialize"
	self MinActivityLapse: 50.! !

!CopyReader methodsFor: 'reading'!
read: aClass
	"Ignore aClass and grab the object directly from the stream. aClass is typically Integer, Float, Symbol, etc.  Assume the object was put on the stream using CopyWriter>store: (look there for more info)."

	| anObject |
	anObject _ stream next.
	position _ position + 1.
	^anObject! !

!CopyReader methodsFor: 'testing'!
isCopier

	^true! !

!CopyWriter methodsFor: 'testing'!
isCopier

	^true! !

!CopyWriter methodsFor: 'writing'!
canCopy: anObject
	"Answer true only if anObject is in the copySet (or if there is no copySet).  This can be used by objects which are connected to objects which are not to be copied."

	^copySet == nil
		ifTrue:[true]
		ifFalse:[copySet includes: anObject]! !

!CopyWriter methodsFor: 'writing'!
copySet: aCollection
	"Set the set of objects that should be copied."

	copySet _ aCollection! !

!CopyWriter methodsFor: 'writing'!
store: anObject
	"Put anObject directly on the Stream... don't convert it to an ascii String since it's not going to a file.  anObject will typically be a Symbol, Number, etc."

	stream nextPut: anObject.
	position _ position + 1! !

!CopyWriter class methodsFor: 'instance creation'!
copy: anObject
	| aStream |
	aStream _ ReadWriteStream on: (Array new: 100).
	(self on: aStream) nextPut: anObject.
	aStream reset.
	^(CopyReader on: aStream) next! !

!Cursor class methodsFor: 'class initialization' stamp: 'ssa 1/1/1970 00:31'!
initialize
	"Create all the standard cursors..."
		self initOrigin.
		self initRightArrow.
		self initLeftArrow.
		self initMenu.
		self initCorner.
		self initRead.
		self initWrite.
		self initWait.
		BlankCursor _ Cursor new.
		self initXeq.
		self initSquare.
		self initNormalWithMask.
		self initCrossHair.
		self initMarker.
		self initUp.
		self initDown.
		self initMove.
		self initBottomLeft.
		self initBottomRight.
		self initAction.
		self initResizeLeft.
		self initResizeTop.
		self initResizeTopLeft.
		self initResizeTopRight.
		self initTopLeft.
		self initTopRight.
		self makeCursorsWithMask.

		"Cursor initialize"
! !

!Cursor class methodsFor: '*RVM' stamp: 'ssa 9/19/2008 12:03'!
action
	"Answer the instance of me that indicates a mouse action is available"

	^ActionCursor! !

!Cursor class methodsFor: '*RVM' stamp: 'ssa 1/1/1970 00:21'!
initAction
	"Cursor initAction"
	ActionCursor _    
		(Cursor
			extent: 16@16
			fromArray: #(
		2r0000000000000000
		2r0000000100000000
		2r0010000100001000
		2r0001000100010000
		2r0000100100100000
		2r0000010001000000
		2r0000000000000000
		2r1111100100111110
		2r0000000000000000
		2r0000100001000000
		2r0001000100100000
		2r0010000100010000
		2r0100000100001000
		2r0000000100000000
		2r0000000000000000
		2r0)
			offset: -7 @ -7).
	
	! !

!Cursor class methodsFor: '*RVM' stamp: 'ssa 9/19/2008 11:39'!
initLeftArrow 

	LeftArrowCursor  _
		      (Cursor
	extent: 16@16
	fromArray: #(
		2r0000100000000000
		2r0011100000000000
		2r1111111110000000
		2r0011100000000000
		2r0000100000000000
		2r0
		2r0
		2r0
		2r0
		2r0
		2r0
		2r0
		2r0
		2r0
		2r0
		2r0)
	offset: -8@0).
	
	"Cursor initLeftArrow"! !

!Cursor class methodsFor: '*RVM' stamp: 'ssa 9/19/2008 11:24'!
leftArrow 
	"Answer the instance of me that is the shape of an arrow pointing to the left."

	^LeftArrowCursor! !

!CustomMenu methodsFor: 'invocation' stamp: 'ssa 12/17/2009 10:10'!
invokeOn: targetObject orSendTo: anObject
	"Pop up this menu and return the result of sending to the target object the selector corresponding to the menu item selected by the user. Return  nil if no item is selected.  If the chosen selector has arguments, obtain appropriately.  If the recipient does not respond to the resulting message, send it to the alternate object provided"

	| aSelector anIndex recipient |
	^ (aSelector _ self startUp) ifNotNil:
		[anIndex _ self selection.
		recipient _ (self targets isEmpty or: [anIndex > self targets size])
			ifTrue:
				[targetObject]
			ifFalse:
				[self targets at: anIndex].
		aSelector numArgs == 0
			ifTrue:
				[recipient perform: aSelector orSendTo: anObject]
			ifFalse:
				[recipient perform: aSelector withArguments: (self arguments at: 1)]]! !

!CustomMenu methodsFor: 'invocation' stamp: 'ssa 1/1/1970 00:42'!
startUp: initialSelection withCaption: caption at: aPoint
	"Build and invoke this menu with the given initial selection and caption. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."

	self build.
	(initialSelection notNil) ifTrue: [self preSelect: initialSelection].
	^ super startUpWithCaption: caption at: aPoint! !

!CustomMenu methodsFor: 'accessing' stamp: 'ssa 6/20/2008 14:29'!
arguments

	arguments isNil ifTrue:[arguments := OrderedCollection new].
	^arguments! !

!CustomMenu methodsFor: 'accessing' stamp: 'ssa 6/20/2008 14:29'!
selections

	selections isNil ifTrue:[selections := OrderedCollection new].
	^selections! !

!CustomMenu methodsFor: 'accessing' stamp: 'ssa 6/20/2008 14:29'!
targets

	targets isNil ifTrue:[targets := OrderedCollection new].
	^targets! !

!Debugger methodsFor: '*Ly' stamp: 'smu 3/4/2010 10:26'!
setContextStackIndexFromLyIndex: anIndex

	| ctx n |
	ctx _ contextStackTop.
	n _ 1.
	[ 
		ctx _ ctx firstContextContainingLyActivation. 
		ctx ifNil: [
			Transcript show: 'setContextStackIndexFromLyIndex: missing activation'; cr. 
			^ self
		].
		n >= anIndex ifTrue: [
			self fullStack.
			self toggleContextStackIndex: (self contextStack indexOf: ctx).
			^ self
		].
		n _ n + 1.
		ctx _ ctx sender.
	] repeat! !

!Debugger methodsFor: '*Ly' stamp: 'ssa 3/3/2010 20:25'!
setContextStackIndexFromOtherIndex: anIndex otherTopContext: ctx
	self setContextStackIndexFromLyIndex: anIndex! !

!Debugger methodsFor: 'initialize' stamp: 'ssa 3/3/2010 23:00'!
buildMVCDebuggerViewLabel: aString minSize: aPoint
	"Build an MVC debugger view around the receiver, and return the StandardSystemView thus created."

	| topView stackListView stackCodeView rcvrVarView rcvrValView ctxtVarView ctxtValView deltaY underPane annotationPane buttonsView oldContextStackIndex |

	oldContextStackIndex _ contextStackIndex.
	self expandStack. "Sets contextStackIndex to zero."
	contextStackIndex _ oldContextStackIndex.
	self contextVariablesInspector object: self selectedContext.
	self receiverInspector object: self receiver.
	
	topView _ StandardSystemView new model: self.
	topView borderWidth: 1.
	stackListView _ PluggableListView on: self
			list: #contextStackList
			selected: #contextStackIndex
			changeSelected: #toggleContextStackIndex:
			menu: #contextStackMenu:shifted:
			keystroke: #contextStackKey:from:.
		self installListFontInto: stackListView.
		stackListView menuTitleSelector: #messageListSelectorTitle.
		stackListView window: (0 @ 0 extent: 150 @ 50).
		topView addSubView: stackListView.
	deltaY _ 0.
	 self wantsAnnotationPane
		ifTrue:
			[annotationPane _ PluggableTextView on: self
				text: #annotation accept: nil readSelection: nil menu: nil.
			annotationPane window: (0@0 extent: 150@self optionalAnnotationHeight).
			topView addSubView: annotationPane below: stackListView.
			deltaY _ deltaY + self optionalAnnotationHeight.
			underPane _ annotationPane]
		ifFalse:
			[underPane _ stackListView].
	self wantsOptionalButtons
		ifTrue:
			[buttonsView _ self buildMVCOptionalButtonsButtonsView.
			buttonsView borderWidth: 1.
			topView addSubView: buttonsView below: underPane.
			underPane _ buttonsView.
			deltaY _ deltaY + self optionalButtonHeight].
	stackCodeView _ self codeView.
		stackCodeView window: (0 @ 0 extent: 150 @ (75 - deltaY)).
		topView addSubView: stackCodeView below: underPane.
	rcvrVarView _ PluggableListView on: self receiverInspector
			list: #fieldList
			selected: #selectionIndex
			changeSelected: #toggleIndex:
			menu: #fieldListMenu:
			keystroke: #inspectorKey:from:.
		self installListFontInto: rcvrVarView.
		rcvrVarView window: (0 @ 0 extent: 25 @ (50 - deltaY)).
		topView addSubView: rcvrVarView below: stackCodeView.
	rcvrValView _ PluggableTextView on: self receiverInspector
			text: #contents accept: #accept:
			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.
		rcvrValView window: (0 @ 0 extent: 50 @ (50 - deltaY)).
		topView addSubView: rcvrValView toRightOf: rcvrVarView.
	ctxtVarView _ PluggableListView on: self contextVariablesInspector
			list: #fieldList
			selected: #selectionIndex
			changeSelected: #toggleIndex:
			menu: #fieldListMenu:
			keystroke: #inspectorKey:from:.
		self installListFontInto: ctxtVarView.
		ctxtVarView window: (0 @ 0 extent: 25 @ (50 - deltaY)).
		topView addSubView: ctxtVarView toRightOf: rcvrValView.
	ctxtValView _ PluggableTextView on: self contextVariablesInspector
			text: #contents accept: #accept:
			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.
		ctxtValView window: (0 @ 0 extent: 50 @ (50 - deltaY)).
		topView addSubView: ctxtValView toRightOf: ctxtVarView.
	topView label: aString.
	topView minimumSize: aPoint.
	^ topView ! !

!Debugger methodsFor: 'initialize' stamp: 'ssa 3/3/2010 22:55'!
buildMVCNotifierViewLabel: aString message: messageString minSize: aPoint

	| topView notifyView buttonView x y bHeight |
	self expandStack.
	topView _ StandardSystemView new model: self.
	topView borderWidth: 1.
	buttonView _ self buildMVCNotifierButtonView.
	topView addSubView: buttonView.
	notifyView _ PluggableListView on: self
		list: #contextStackList
		selected: #contextStackIndex
		changeSelected: #debugAt:
		menu: nil
		keystroke: nil.
	self installListFontInto: notifyView.
	x _ 350 max: (aPoint x).
	y _ ((4 * 15) + 16) max: (aPoint y - 16 - self optionalButtonHeight).
	bHeight _ self optionalButtonHeight.
	y _ y - bHeight.
	notifyView window: (0@0 extent: x@y).
	topView
		addSubView: notifyView below: buttonView;
		label: aString;
		minimumSize: aPoint.
	^ topView! !

!Debugger methodsFor: 'initialize' stamp: 'ssa 3/3/2010 21:35'!
codeView
	"Answer the code editing view for me"
	^PluggableTextView on: self
			text: #contents accept: #contents:notifying:
			readSelection: #contentsSelection menu: #codePaneMenu:shifted:! !

!Debugger methodsFor: 'initialize' stamp: 'dmu 3/10/2010 18:15'!
customButtonSpecs
	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."

	| list |
	list _ #(('Proceed'	proceed				'close the debugger and proceed.')
		('Restart'		restart				'reset this context to its start.')
		('Into'			send				'step Into message sends')
		('Over'			doStep				'step Over message sends')
		('Through'		stepIntoBlock		'step into a block')
		('Full Stack'		fullStack			'show full stack')
		('Where'		where				'select current pc range')
		('Meta'		halt					'go meta & debug the debugger')).
	list _ list, self otherButtonSpecs.
	Preferences restartAlsoProceeds ifTrue:
		[list _ list collect: [:each |
			each second == #restart
				ifTrue: [each copy at: 3 put: 'proceed from the beginning of this context.'; yourself]
				ifFalse: [each]]].
	^ list! !

!Debugger methodsFor: 'initialize' stamp: 'ssa 9/9/2009 17:35'!
debugAt: anInteger
	self toggleContextStackIndex: anInteger. 
	 ^ self debug.! !

!Debugger methodsFor: 'initialize' stamp: 'ssa 9/10/2009 15:56'!
openFullNoSuspendLabel: aString
	"Create and schedule a full debugger with the given label. Do not terminate the current active process."

	| topView oldContextStackIndex |

	Smalltalk isMorphic ifTrue: [
    oldContextStackIndex := contextStackIndex.
    self expandStack. "Sets contextStackIndex to zero."
    ToolBuilder open: self label: aString.
    self toggleContextStackIndex: oldContextStackIndex.
    ^ self
  ].
	topView _ self buildMVCDebuggerViewLabel: aString minSize: 300@200.
	topView controller openNoTerminate.
	^ topView
! !

!Debugger methodsFor: 'initialize' stamp: 'ssa 9/15/2009 14:11'!
openNotifierContents: msgString label: label
	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."
	| msg topView p |
	Sensor flushKeyboard.
	savedCursor _ Sensor currentCursor.
	Sensor currentCursor: Cursor normal.
	(label beginsWith: 'Space is low')
		ifTrue: [msg _ self lowSpaceChoices, (msgString ifNil: [''])]
		ifFalse: [msg _ msgString].
	isolationHead ifNotNil:
		["We have already revoked the isolation layer -- now jump to the parent project."
		msg _ self isolationRecoveryAdvice, msgString.
		failedProject _ Project current.
		isolationHead parent enterForEmergencyRecovery].


  Smalltalk isMorphic ifTrue: [
    builder := ToolBuilder default.
    spec := self buildNotifierWith: builder label: label message: msg.
    self expandStack.
    builder open: spec.
    errorWasInUIProcess := Project spawnNewProcessIfThisIsUI: interruptedProcess.
    ^ self
  ].


	Display fullScreen.
	topView _ self 
		buildMVCNotifierViewLabel: label , Time dateAndTimeNow  printString
		message: thisContext sender sender shortStack 
		minSize:600@((14 * 20) + 16 + self optionalButtonHeight).
	ScheduledControllers activeController
		ifNil: [p _ Display boundingBox center]
		ifNotNil: [p _ ScheduledControllers activeController view displayBox center].
	topView controller openNoTerminateDisplayAt: (p adhereTo:(Display boundingBox insetBy: topView minimumSize)).
	^ topView! !

!Debugger methodsFor: 'initialize' stamp: 'ssa 9/3/2008 15:34'!
optionalButtonPairs
	"Actually, return triples.  In mvc (until someone deals with this) only the custom debugger-specific buttons are shown, but in morphic, the standard code-tool buttons are provided in addition to the custom buttons"

	^ Smalltalk isMorphic
		ifFalse:
			[self customButtonSpecs]
		ifTrue:
			[]! !

!Debugger methodsFor: 'initialize' stamp: 'ssa 7/7/2010 10:48'!
otherButtonSpecs
	| r |
	r _ OrderedCollection new.
	(Smalltalk includesKey:#Ly) ifTrue:[
		contextStackTop hasLyActivation 
			ifTrue:[r add: #('Debug in Ly'	debugInLy				'launch a Ly execution debugger on this stack')]].
	^ r asArray! !

!Debugger methodsFor: 'initialize' stamp: 'ssa 3/3/2010 20:55'!
release
	self windowIsClosing.
	super release.
! !

!Debugger methodsFor: 'initialize' stamp: 'ssa 3/3/2010 20:58'!
terminateInterruptedProcessIfSoleOwner

	| otherOwners |
	otherOwners _ Smalltalk pointersTo: interruptedProcess except:{self}.
	otherOwners detect:[:each| each isKindOf: Debugger] ifNone:[
		Transcript show: 'Debugger>>terminateInterruptedProcessIfSoleOwner: ', interruptedProcess identityHash printString; cr.
		interruptedProcess terminate].
	
! !

!Debugger methodsFor: 'initialize' stamp: 'ssa 4/20/2010 11:05'!
windowIsClosing
	"My window is being closed; clean up. Restart the low space watcher."

	interruptedProcess == nil ifTrue: [^ self].
	interruptedProcess terminate.
	"self terminateInterruptedProcessIfSoleOwner."
	interruptedProcess _ nil.
	interruptedController _ nil.
	contextStack _ nil.
	contextStackTop _ nil.
	receiverInspector _ nil.
	contextVariablesInspector _ nil.
	Smalltalk installLowSpaceWatcher.  "restart low space handler"
! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
contextStack
	"Answer the value of contextStack"

	contextStack isNil ifTrue:[self contextStack: nil].
	^ contextStack! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
contextStack: anObject
	"Set the value of contextStack"

	contextStack _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
contextStackIndex: anObject
	"Set the value of contextStackIndex"

	contextStackIndex _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
contextStackList: anObject
	"Set the value of contextStackList"

	contextStackList _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
contextStackTop
	"Answer the value of contextStackTop"

	contextStackTop isNil ifTrue:[self contextStackTop: nil].
	^ contextStackTop! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
contextStackTop: anObject
	"Set the value of contextStackTop"

	contextStackTop _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 3/3/2010 22:24'!
contextVariablesInspector
	"Answer the instance of Inspector that is providing a view of the 
	variables of the selected context."

	contextVariablesInspector isNil ifTrue:[self contextVariablesInspector: self defaultContextVariablesInspector].
	^contextVariablesInspector! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
contextVariablesInspector: anObject
	"Set the value of contextVariablesInspector"

	contextVariablesInspector _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 3/3/2010 22:22'!
defaultContextVariablesInspector

	^ContextVariablesInspector inspect: nil! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 3/3/2010 22:15'!
defaultReceiverInspector

	^Inspector inspect: nil! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
errorWasInUIProcess
	"Answer the value of errorWasInUIProcess"

	errorWasInUIProcess isNil ifTrue:[self errorWasInUIProcess: nil].
	^ errorWasInUIProcess! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
errorWasInUIProcess: anObject
	"Set the value of errorWasInUIProcess"

	errorWasInUIProcess _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
externalInterrupt
	"Answer the value of externalInterrupt"

	externalInterrupt isNil ifTrue:[self externalInterrupt: nil].
	^ externalInterrupt! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
failedProject
	"Answer the value of failedProject"

	failedProject isNil ifTrue:[self failedProject: nil].
	^ failedProject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
failedProject: anObject
	"Set the value of failedProject"

	failedProject _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
interruptedController
	"Answer the value of interruptedController"

	interruptedController isNil ifTrue:[self interruptedController: nil].
	^ interruptedController! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
interruptedController: anObject
	"Set the value of interruptedController"

	interruptedController _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
interruptedProcess
	"Answer the value of interruptedProcess"

	interruptedProcess isNil ifTrue:[self interruptedProcess: nil].
	^ interruptedProcess! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
interruptedProcess: anObject
	"Set the value of interruptedProcess"

	interruptedProcess _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
isolationHead
	"Answer the value of isolationHead"

	isolationHead isNil ifTrue:[self isolationHead: nil].
	^ isolationHead! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
isolationHead: anObject
	"Set the value of isolationHead"

	isolationHead _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
proceedValue
	"Answer the value of proceedValue"

	proceedValue isNil ifTrue:[self proceedValue: nil].
	^ proceedValue! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 3/3/2010 22:15'!
receiverInspector
	"Answer the instance of Inspector that is providing a view of the 
	variables of the selected context's receiver."

	receiverInspector isNil ifTrue:[self receiverInspector: self defaultReceiverInspector].
	^receiverInspector! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
receiverInspector: anObject
	"Set the value of receiverInspector"

	receiverInspector _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
savedCursor
	"Answer the value of savedCursor"

	savedCursor isNil ifTrue:[self savedCursor: nil].
	^ savedCursor! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
savedCursor: anObject
	"Set the value of savedCursor"

	savedCursor _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:16'!
selectingPC
	"Answer the value of selectingPC"

	selectingPC isNil ifTrue:[self selectingPC: false].
	^ selectingPC! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
selectingPC: anObject
	"Set the value of selectingPC"

	selectingPC _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
sourceMap
	"Answer the value of sourceMap"

	sourceMap isNil ifTrue:[self sourceMap: nil].
	^ sourceMap! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
sourceMap: anObject
	"Set the value of sourceMap"

	sourceMap _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
tempNames
	"Answer the value of tempNames"

	tempNames isNil ifTrue:[self tempNames: nil].
	^ tempNames! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
tempNames: anObject
	"Set the value of tempNames"

	tempNames _ anObject! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
theMethodNode
	"Answer the value of theMethodNode"

	theMethodNode isNil ifTrue:[self theMethodNode: nil].
	^ theMethodNode! !

!Debugger methodsFor: 'accessing' stamp: 'ssa 9/15/2009 10:15'!
theMethodNode: anObject
	"Set the value of theMethodNode"

	theMethodNode _ anObject! !

!Debugger methodsFor: 'notifier menu' stamp: 'ssa 3/2/2010 18:08'!
debug
	"Open a full DebuggerView."
	| topView |
  Smalltalk isMorphic
    ifTrue: [
      "hack for Squeak4.1 image -- dmu"
      topView := self topView.
      topView model: nil.  "so close won't release me."
      self breakDependents.
      ToolBuilder default close: topView.
      ^ self openFullNoSuspendLabel: topView label].

  topView _ self  topView.
	topView isNil ifTrue:[topView _ self buildMVCDebuggerViewLabel: self labelString minSize: 200@200].
	topView model: nil.  "so close won't release me."
	

	topView controller controlTerminate.
	topView deEmphasize; erase.

	"a few hacks to get the scroll selection artifacts out when we got here by clicking in the list"
	topView subViewWantingControl ifNotNil: [
		topView subViewWantingControl controller controlTerminate
	].
	topView controller status: #closed.

	self openFullNoSuspendLabel: topView label.
	topView controller closeAndUnscheduleNoErase.
	Transcript show: 'in debug: ', Processor thisProcess identityHash printString; cr.
	Processor terminateActive.
! !

!Debugger methodsFor: 'context stack (message list)' stamp: 'ssa 3/10/2010 09:17'!
contextStackIndex
	"Answer the index of the selected context."

	contextStackIndex isNil ifTrue:[self contextStackIndex: 0].
	^contextStackIndex! !

!Debugger methodsFor: 'context stack (message list)' stamp: 'ssa 3/3/2010 22:23'!
expandStack
	"A Notifier is being turned into a full debugger.  Show a substantial amount of stack in the context pane."

	self newStack: (contextStackTop stackOfSize: 20).
	contextStackIndex _ 0.
	receiverInspector _ self defaultReceiverInspector.
	contextVariablesInspector _ self defaultContextVariablesInspector.
	proceedValue _ nil! !

!Debugger methodsFor: 'context stack (message list)' stamp: 'dmu 9/22/2010 22:17'!
fullyExpandStack
	"Expand the stack to include all of it, rather than the first four or five
	contexts."

	self okToChange ifFalse: [^ self].
	self newStack: ( contextStackTop contextStackIn: interruptedProcess).
	self changed: #contextStackList! !

!Debugger methodsFor: 'context stack (message list)' stamp: 'ssa 3/2/2010 16:17'!
labelForContext: ctxt

	^ctxt printString! !

!Debugger methodsFor: 'context stack (message list)' stamp: 'ssa 9/15/2009 10:14'!
toggleContextStackIndex: anInteger 
	"If anInteger is the same as the index of the selected context, deselect it. 
	Otherwise, the context whose index is anInteger becomes the selected 
	context."

	self contextStackIndex: 
		(contextStackIndex = anInteger
			ifTrue: [0]
			ifFalse: [anInteger])
		oldContextWas:
		((contextStackIndex = 0 or:[contextStackIndex isNil])
			ifTrue: [nil]
			ifFalse: [contextStack at: contextStackIndex])! !

!Debugger methodsFor: 'context stack menu' stamp: 'ssa 9/3/2008 11:23'!
contextStackMenu: aMenu shifted: shifted
	"Set up the menu appropriately for the context-stack-list, either shifted or unshifted as per the parameter provided"

	^ shifted ifFalse: 
		[self selectedContext selector = #doesNotUnderstand: ifTrue:
			[aMenu 
				add: 'implement in...' 
				subMenu: (self populateImplementInMenu: (Smalltalk isMorphic ifTrue: [] ifFalse: [CustomMenu new]))
				target: nil 
				selector: nil 
				argumentList: #(nil)].
		aMenu labels: 
'fullStack (f)
restart (r)
proceed (p)
step (t)
step through (T)
send (e)
where (w)
peel to first like this
senders of... (n)
implementors of... (m)
inheritance (i)
versions (v)
inst var refs...
inst var defs...
class var refs...
class variables
class refs (N)
browse full (b)
file out 
more...'
		lines: #(8 12 14 17 20)
		selections: #(fullStack restart proceed doStep stepIntoBlock send where peelToFirst
browseSendersOfMessages browseMessages methodHierarchy browseVersions
browseInstVarRefs browseInstVarDefs
browseClassVarRefs browseClassVariables browseClassRefs
browseMethodFull fileOutMessage 
shiftedYellowButtonActivity)]

	ifTrue: [aMenu labels: 
'browse class hierarchy
browse class
browse method (O)
implementors of sent messages
change sets with this method
inspect instances
inspect subinstances
revert to previous version
remove from current change set
revert & remove from changes
more...' 
	lines: #(5 7 10)
	selections: #(classHierarchy browseClass 
		openSingleMessageBrowser browseAllMessages findMethodInChangeSets 
		inspectInstances inspectSubInstances
		revertToPreviousVersion 
		removeFromCurrentChanges revertAndForget
		unshiftedYellowButtonActivity)]

! !

!Debugger methodsFor: 'code pane' stamp: 'ssa 9/15/2009 10:16'!
pcRange
	"Answer the indices in the source code for the method corresponding to 
	the selected context's program counter value."

	| i pc end |
	(self selectingPC and: [contextStackIndex ~= 0])
		ifFalse: [^1 to: 0].
	sourceMap ifNil:
		[theMethodNode isNil ifTrue:[^1 to: 0].
		sourceMap _ theMethodNode sourceMap.
		tempNames _ theMethodNode tempNames.
		self selectedContext method cacheTempNames: tempNames].
	(sourceMap size = 0 or: [ self selectedContext isDead ]) ifTrue: [^1 to: 0].
	Smalltalk at: #RBProgramNode ifPresent:[:nodeClass|
		(theMethodNode isKindOf: nodeClass) ifTrue: [
			pc _ contextStackIndex = 1
				ifTrue: [self selectedContext pc]
				ifFalse: [self selectedContext previousPc].
			i _ sourceMap findLast:[:pcRange | pcRange key <= pc].
			i = 0 ifTrue:[^ 1 to: 0].
			^ (sourceMap at: i) value
		].
	].
	pc_ self selectedContext pc -
		(("externalInterrupt" true and: [contextStackIndex=1])
			ifTrue: [1]
			ifFalse: [2]).
	i _ sourceMap indexForInserting: (Association key: pc value: nil).
	i < 1 ifTrue: [^1 to: 0].
	i > sourceMap size
		ifTrue:
			[end _ sourceMap inject: 0 into:
				[:prev :this | prev max: this value last].
			^ end+1 to: end].
	^(sourceMap at: i) value! !

!Debugger methodsFor: 'dependents access' stamp: 'ssa 3/3/2010 22:18'!
step 
	"Update the inspectors."

	self receiverInspector ifNotNil: [self receiverInspector step].
	self contextVariablesInspector ifNotNil: [self contextVariablesInspector step].
! !

!Debugger methodsFor: 'dependents access' stamp: 'ssa 3/3/2010 22:19'!
updateInspectors 
	"Update the inspectors on the receiver's variables."

	self receiverInspector == nil ifFalse: [self receiverInspector update].
	self contextVariablesInspector == nil ifFalse: [self contextVariablesInspector update]! !

!Debugger methodsFor: 'private' stamp: 'ssa 3/3/2010 21:46'!
contextStackIndex: anInteger oldContextWas: oldContext 
	"Change the context stack index to anInteger, perhaps in response to user selection."

	| newMethod |
	contextStackIndex := anInteger.
	anInteger = 0
		ifTrue: [currentCompiledMethod := theMethodNode := tempNames := sourceMap := contents := nil.
			self changed: #contextStackIndex.
			self decorateButtons.
			self contentsChanged.
			contextVariablesInspector object: nil.
			self updateInspectorToObject: self receiver.
			^ self].
	(newMethod := oldContext == nil
					or: [oldContext method ~~ (currentCompiledMethod := self selectedContext method)])
		ifTrue: [tempNames := sourceMap := nil.
			theMethodNode := Preferences browseWithPrettyPrint
				ifTrue: [ 	self selectedContext methodNodeFormattedAndDecorated: Preferences colorWhenPrettyPrinting ]
				ifFalse: [	self selectedContext methodNode ].
			contents := self selectedMessage.
			self contentsChanged.
			self pcRange
			"will compute tempNamesunless noFrills"].
	self changed: #contextStackIndex.
	self decorateButtons.
	tempNames == nil
		ifTrue: [tempNames := self selectedClassOrMetaClass parserClass new parseArgsAndTemps: contents notifying: nil].
	contextVariablesInspector object: self selectedContext.
	self updateInspectorToObject: self receiver.
	newMethod
		ifFalse: [self changed: #contentsSelection]! !

!Debugger methodsFor: 'private' stamp: 'ssa 3/2/2010 16:16'!
newStack: stack
	| oldStack diff |

	contextStackTop _ stack first.
	oldStack _ contextStack.
	contextStack _ stack.
	(oldStack == nil or: [oldStack last ~~ stack last])
		ifTrue: [contextStackList _ contextStack collect: [:ctx | self labelForContext: ctx ].
				^ self].
	"May be able to re-use some of previous list"
	diff _ stack size - oldStack size.
	contextStackList _ diff <= 0
		ifTrue: [contextStackList copyFrom: 1-diff to: oldStack size]
		ifFalse: [diff > 1
				ifTrue: [contextStack collect: [:ctx | self labelForContext: ctx ]]
				ifFalse: [(Array with: (self labelForContext:stack first)) , contextStackList]]! !

!Debugger methodsFor: 'private' stamp: 'ssa 9/15/2009 14:25'!
process: aProcess controller: aController context: aContext isolationHead: projectOrNil

	super initialize.
	Smalltalk at: #MessageTally ifPresentAndInMemory: [:c | c new close].
	contents _ nil. 
	interruptedProcess _ aProcess.
	interruptedController _ aController.
	contextStackTop _ aContext.
	self newStack: (contextStackTop stackOfSize: 1).
	contextStackIndex _ 1.
	externalInterrupt _ false.
	selectingPC _ true.
	isolationHead _ projectOrNil.
! !

!Debugger methodsFor: 'private' stamp: 'dmu 3/10/2010 17:52'!
resetContext: aContext 
	"Used when a new context becomes top-of-stack, for instance when the
	method of the selected context is re-compiled, or the simulator steps or
	returns to a new method. There is room for much optimization here, first
	to save recomputing the whole stack list (and text), and secondly to avoid
	recomposing all that text (by editing the paragraph instead of recreating it)."

	| oldContext |
	oldContext _ self selectedContext.
	contextStackTop _ aContext.
	self newStack: (contextStackTop ifNil:  [^ self release] ifNotNil: [contextStackTop contextStack]).
	self changed: #contextStackList.
	self contextStackIndex: 1 oldContextWas: oldContext.
	self changed: #content.! !

!Debugger methodsFor: 'private' stamp: 'ssa 3/25/2010 16:02'!
resumeProcess: aTopView 
	| c |
	aTopView erase.
	savedCursor
		ifNotNil: [Sensor currentCursor: savedCursor].
	isolationHead
		ifNotNil: [failedProject enterForEmergencyRecovery.
			isolationHead invoke.
			isolationHead _ nil].
	(interruptedProcess isNil or:[interruptedProcess isTerminated]) ifFalse: [
		c _ interruptedController ifNil:[ScheduledControllers scheduledControllers last] ifNotNil:[interruptedController].
		ScheduledControllers activeControllerNoTerminate: c  andProcess: interruptedProcess].
	"if old process was terminated, just terminate current one"
	interruptedProcess _ nil.
	"Before delete, so release doesn't terminate it"
	aTopView controller closeAndUnscheduleNoErase.
	Smalltalk installLowSpaceWatcher.
	"restart low space handler"
	errorWasInUIProcess == false
		ifFalse: [Processor terminateActive]! !

!Debugger methodsFor: 'private' stamp: 'ssa 3/10/2010 09:17'!
selectedContext

	self contextStackIndex = 0
		ifTrue: [^self contextStackTop]
		ifFalse: [^self contextStack at: contextStackIndex]! !

!Debugger methodsFor: 'private' stamp: 'ssa 3/3/2010 21:48'!
updateInspectorToObject: obj

	self receiverInspector object: obj! !

!Debugger methodsFor: '*RVMBootstrap' stamp: 'ssa 3/3/2010 22:53'!
installListFontInto: aListView

	"do nothing by default"! !

!Debugger class methodsFor: 'class initialization' stamp: 'sm 5/25/2011 20:27'!
openContext: aContext label: aString contents: contentsStringOrNil
	| isolationHead |
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	<primitive: 19> "Simulation guard"
	"When we are running headless, we just print the stuff and quit."
	RVMOperations isHeadless ifTrue: [
		Smalltalk logError: aString inContext: aContext onConsoleAndQuitWithSaving: false.
	].
	
	ErrorRecursion not & Preferences logDebuggerStackToFile ifTrue:
		[Smalltalk logError: aString inContext: aContext to: 'SqueakDebug.log'].
	ErrorRecursion ifTrue:
		[ErrorRecursion _ false.
		"(isolationHead _ CurrentProjectRefactoring currentIsolationHead)
			ifNil: [self primitiveError: aString]
			ifNotNil: [isolationHead revoke]"].
	ErrorRecursion _ true.
	self informExistingDebugger: aContext label: aString.
	(Debugger context: aContext isolationHead: nil)
		openNotifierContents: contentsStringOrNil
		label: aString.
	ErrorRecursion _ false.
	Processor thisProcess suspend.
! !

!Debugger class methodsFor: 'instance creation' stamp: 'dmu 11/25/2008 00:20'!
context: aContext isolationHead: isolationHead
	"Answer an instance of me for debugging the active process starting with the given context."

	^ self new
		process: Processor thisProcess
		controller:
			((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])
				ifTrue: [ScheduledControllers activeController]
				ifFalse: [nil])
		context: aContext
		isolationHead: isolationHead
! !

!Debugger class methodsFor: 'opening' stamp: 'dmu 9/17/2010 12:00'!
openInterrupt: aString onProcess: interruptedProcess
	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."
	| debugger |
	<primitive: 19> "Simulation guard"
	debugger _ self new.
	interruptedProcess suspend.
	debugger
		process: interruptedProcess
		controller: ((Smalltalk isMorphic not
					and: [ScheduledControllers activeControllerProcess == interruptedProcess])
						ifTrue: [ScheduledControllers activeController])
		context: interruptedProcess suspendedContextWaitingIfNecessary.
	debugger externalInterrupt: true.

Preferences logDebuggerStackToFile ifTrue:
	[(aString includesSubString: 'Space') & 
		(aString includesSubString: 'low') ifTrue: [
			Smalltalk logError: aString inContext: debugger interruptedContext to:'LowSpaceDebug.log']].

	^ debugger
		openNotifierContents: nil
		label: aString
! !

!Debugger class methodsFor: 'opening' stamp: 'sm 5/25/2011 20:35'!
openNoForkSuspendOn: process context: context label: title contents: contentsStringOrNil fullView: bool selectingOtherIndex: anIndex
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	| controller |
	
	"When we are running headless, we just print the stuff and quit."
	RVMOperations isHeadless ifTrue: [
		Smalltalk logError: (title, 'Contents: ', contentsStringOrNil asString) inContext: context onConsoleAndQuitWithSaving: false.
	].
	
	controller _ ScheduledControllers activeControllerProcess == process
				ifTrue: [ScheduledControllers activeController].
	 [
		[	| debugger |
			debugger _ self new process: process controller: controller context: context.
			bool ifTrue: [debugger openFullNoSuspendLabel: title]
				ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].
			debugger setContextStackIndexFromOtherIndex: anIndex otherTopContext: context.
			Preferences logDebuggerStackToFile ifTrue: [
				Smalltalk logError: title inContext: context to: 'SqueakDebug.log'].
			Smalltalk isMorphic
				ifFalse: [ScheduledControllers searchForActiveController "needed since openNoTerminate (see debugger #open...) does not set up activeControllerProcess if activeProcess (this fork) is not the current activeControllerProcess (see #scheduled:from:)"].
		] on: Error do: [:ex |
			self primitiveError: 
				'Orginal error: ', 
				title asString, '.
	Debugger error: ', 
				([ex description] on: Error do: ['a ', ex class printString]), ':'
		]
	] value! !

!Debugger class methodsFor: 'opening' stamp: 'sm 5/25/2011 20:35'!
openNoSuspendOn: process context: context label: title contents: contentsStringOrNil fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	| controller |
	
	"When we are running headless, we just print the stuff and quit."
	RVMOperations isHeadless ifTrue: [
		Smalltalk logError: (title, 'Contents: ', contentsStringOrNil asString) inContext: context onConsoleAndQuitWithSaving: false.
	].
	
	Smalltalk isMorphic
		ifTrue: []
		ifFalse: [controller _ ScheduledControllers activeControllerProcess == process
				ifTrue: [ScheduledControllers activeController]].
	[
		[	| debugger |
			debugger _ self new process: process controller: controller context: context.
			bool ifTrue: [debugger openFullNoSuspendLabel: title]
				ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].
			Preferences logDebuggerStackToFile ifTrue: [
				Smalltalk logError: title inContext: context to: 'SqueakDebug.log'].
			Smalltalk isMorphic
				ifFalse: [ScheduledControllers searchForActiveController "needed since openNoTerminate (see debugger #open...) does not set up activeControllerProcess if activeProcess (this fork) is not the current activeControllerProcess (see #scheduled:from:)"].
		] on: Error do: [:ex |
			self primitiveError: 
				'Orginal error: ', 
				title asString, '.
	Debugger error: ', 
				([ex description] on: Error do: ['a ', ex class printString]), ':'
		]
	] fork! !

!Debugger class methodsFor: 'opening' stamp: 'dmu 3/25/2010 10:23'!
openOn: process context: context label: title contents: contentsStringOrNil fullView: bool
    self openNoSuspendOn: process context: context label: title contents: contentsStringOrNil fullView: bool.
   process suspend.
! !

!Delay methodsFor: '*RVM' stamp: 'dmu 2/6/2011 21:25'!
spinWait
	| t |
	t _ Time millisecondClockValue + delayDuration.
	[t > Time millisecondClockValue] whileTrue: [Processor yield]! !

!Delay class methodsFor: 'snapshotting' stamp: 'dmu 5/25/2010 11:02'!
startUp
	"Restart active delay, if any, when resuming a snapshot."

	self restoreResumptionTimes.
	ActiveDelay == nil ifFalse: [ActiveDelay activate].
	AccessProtect _ Semaphore forMutualExclusion
! !

!Delay class methodsFor: 'timer process' stamp: 'sm 2/24/2011 16:38'!
startTimerInterruptWatcher
	"Reset the class variables that keep track of active Delays and re-start the timer interrupt watcher process. Any currently scheduled delays are forgotten."
	"Delay startTimerInterruptWatcher"

	| p |
	self primSignal: nil atMilliseconds: 0.
	TimingSemaphore == nil
		ifFalse: [TimingSemaphore terminateProcess].
	TimingSemaphore _ Semaphore new.
	AccessProtect _ Semaphore forMutualExclusion.
	SuspendedDelays _ 
		SortedCollection sortBlock: 
			[:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].
	ActiveDelay _ nil.
	p _ [self timerInterruptWatcher] newProcess.
	p priority: Processor timingPriority.
	p name: 'TimerInterruptWatcher'.
	p resume.
! !

!Dictionary methodsFor: 'outlining' stamp: 'ssa 9/10/2009 14:30'!
subobjects

	^self associations asOrderedCollection! !

!Dictionary methodsFor: '*RVM-Archiving'!
archiveOn: aStream
	aStream
		storeObject: self;
		storeClass: self class;
		store: self size.
	self associationsDo:
		[:each | aStream nextPut: each]! !

!Dictionary methodsFor: '*Ly-Explorer' stamp: 'hg 10/3/2001 20:47'!
explorerContents

	| contents |
	
	contents := OrderedCollection new.
	self keysSortedSafely do: [:key |
		contents add: (ObjectExplorerWrapper
			with: (self at: key)
			name: (key printString contractTo: 32)
			model: self)].
	^contents
! !

!DictionaryInspector methodsFor: 'menu' stamp: 'ssa 1/6/2010 20:24'!
dictionaryMenu: aMenu
	"Set up the key-list menu for a dictionary inspector"

	aMenu title: 'Dictionary key'.
	^ aMenu addList: #(
		('inspect'						inspectSelection)
		('explore'						exploreSelection)
		('copy name'					copyName)
		('references'					selectionReferences)
		('objects pointing to this value'	objectReferencesToSelection)
		('senders of this key'			sendersOfSelectedKey)
		-
		('refresh view'					calculateKeyArray)
		-
		('add key'						addEntry)
		('rename key'					renameEntry)
		('remove'						removeSelection)
		-
		('basic inspect'					inspectBasic))! !

!DisplayMedium methodsFor: 'bordering' stamp: 'ssa 11/30/2009 13:50'!
border: aRectangle width: borderWidth fillColor: aHalfTone  clippingBox: clipRect
	"Paint a border whose rectangular area is defined by aRectangle. The 
	width of the border of each side is borderWidth. Uses aHalfTone for 
	drawing the border."

	self border: aRectangle
		widthRectangle: 
			(Rectangle
				left: borderWidth
				right: borderWidth
				top: borderWidth
				bottom: borderWidth)
		rule: Form over
		fillColor: aHalfTone
		 clippingBox: clipRect! !

!DisplayMedium methodsFor: 'bordering' stamp: 'ssa 11/30/2009 13:50'!
border: aRectangle width: borderWidth rule: combinationRule fillColor: aHalfTone  clippingBox: clipRect
	"Paint a border whose rectangular area is defined by aRectangle. The 
	width of the border of each side is borderWidth. Uses aHalfTone for 
	drawing the border."

	self border: aRectangle
		widthRectangle: 
			(Rectangle
				left: borderWidth
				right: borderWidth
				top: borderWidth
				bottom: borderWidth)
		rule: combinationRule
		fillColor: aHalfTone
		 clippingBox: clipRect! !

!DisplayMedium methodsFor: 'bordering' stamp: 'ssa 11/30/2009 13:42'!
border: aRectangle widthRectangle: insets rule: combinationRule fillColor: aHalfTone clippingBox: clipRect
	"Paint a border whose rectangular area is defined by aRectangle. The 
	width of each edge of the border is determined by the four coordinates 
	of insets. Uses aHalfTone and combinationRule for drawing the border."

	(aRectangle areasOutside: (aRectangle insetBy: insets)) do:
		[:edgeStrip | self fill: edgeStrip rule: combinationRule fillColor: aHalfTone  clippingBox: clipRect]! !

!DisplayMedium methodsFor: 'bordering' stamp: 'ssa 12/18/2009 06:38'!
outlined

	self border: self boundingBox width: 1! !

!DisplayObject methodsFor: 'displaying-generic' stamp: 'ssa 9/4/2009 10:47'!
displayOn: aDisplayMedium at: aDisplayPoint 
	"Display the receiver located at aDisplayPoint with default settings for 
	rule and halftone."

	self displayOn: aDisplayMedium
		at: aDisplayPoint
		clippingBox: aDisplayMedium boundingBox
		rule: Form paint
		fillColor: nil! !

!DisplayObject methodsFor: 'displaying-generic' stamp: 'ssa 12/17/2009 16:54'!
followCursor
	"Just show the Form following the mouse. 6/21/96 tk"
	Cursor blank showWhile:
		[self follow: [Sensor cursorPoint] while: [Sensor noButtonPressed]].
	Sensor waitNoButton
! !

!DisplayScreen methodsFor: 'displaying' stamp: 'ssa 8/23/2009 15:06'!
outline: rectBlock do: effectBlock while: durationBlock width: borderWidth halftone: halftone
	"Display an evolving rectangle dynamically.
	rectBlock supplies a rectangle, durationBlock supplies true, then false to terminate.
	effectBlock is executed at each iteration." 

	| oldRect edges rect | 
	oldRect _ rectBlock value rounded.
	edges _ oldRect areasOutside: (oldRect insetBy: borderWidth).
	edges do: [:edge | self fill: edge rule: Form reverse fillColor: halftone].
	[durationBlock value] whileTrue:
		[rect _ rectBlock value rounded.
		rect = oldRect
			ifFalse:
				[edges do: [:edge | self fill: edge rule: Form reverse fillColor: halftone].
				effectBlock value.
				edges _ rect areasOutside: (rect insetBy: borderWidth).
				edges do: [:edge | self fill: edge rule: Form reverse fillColor: halftone].
				oldRect _ rect]].
	edges do: [:edge | self fill: edge rule: Form reverse fillColor: halftone].
	^ oldRect! !

!DisplayScreen methodsFor: 'displaying' stamp: 'ssa 8/23/2009 15:05'!
outline: rectBlock while: durationBlock width: borderWidth halftone: halftone
	"Display an evolving rectangle dynamically.
	rectBlock supplies a rectangle, durationBlock supplies true, then false to 
terminate." 

	^self outline: rectBlock do: [] while: durationBlock width: borderWidth halftone: halftone! !

!DisplayScreen methodsFor: 'other' stamp: 'ssa 8/24/2009 10:14'!
boundingBox
	clippingBox == nil
		ifTrue: [self clippingBox: super boundingBox].
	^ clippingBox copy! !

!DisplayScreen methodsFor: 'other' stamp: 'ssa 8/24/2009 09:59'!
clippingTo: aRect do: aBlock
	"Display clippingTo: Rectangle fromUser do:
	[ScheduledControllers restore: Display fullBoundingBox]"
	| saveClip |
	saveClip _ clippingBox.
	self clippingBox: aRect.
	aBlock value.
	self clippingBox: saveClip! !

!DisplayScreen methodsFor: 'other' stamp: 'ssa 8/24/2009 09:59'!
fullScreen   "Display fullScreen"

	ScreenSave notNil ifTrue: [Display _ ScreenSave].
	self clippingBox: super boundingBox! !

!DisplayScreen methodsFor: 'private' stamp: 'ssa 8/24/2009 10:00'!
copyFrom: aForm
	"Take on all state of aForm, with complete sharing"

	super copyFrom: aForm.
	self clippingBox: super boundingBox! !

!DisplayScreen methodsFor: 'private' stamp: 'ssa 8/24/2009 10:00'!
setExtent: aPoint depth: bitsPerPixel  "DisplayScreen startUp"
	"This method is critical.  If the setExtent fails, there will be no
	proper display on which to show the error condition..."
	"ar 5/1/1999: ... and that is exactly why we check for the available display depths first."

	"RAA 27 Nov 99 - if depth and extent are the same and acceptable, why go through this.
	also - record when we change so worlds can tell if it is time to repaint"

	(depth == bitsPerPixel and: [aPoint = self extent and: 
					[self supportsDisplayDepth: bitsPerPixel]]) ifFalse: [
		bits _ nil.  "Free up old bitmap in case space is low"
		DisplayChangeSignature _ (DisplayChangeSignature ifNil: [0]) + 1.
		(self supportsDisplayDepth: bitsPerPixel)
			ifTrue:[super setExtent: aPoint depth: bitsPerPixel]
			ifFalse:["Search for a suitable depth"
					super setExtent: aPoint depth: self findAnyDisplayDepth].
	].
	self clippingBox: super boundingBox! !

!DisplayScreen methodsFor: 'accessing' stamp: 'ssa 8/24/2009 10:10'!
clippingBox: aRect
	clippingBox _ aRect
	! !

!DisplayScreen methodsFor: '*RVM' stamp: 'dmu 1/25/2010 11:25'!
drawDot5At: point1
	"Display drawDot5At: 100@100"
	Dot5 ifNil: [Dot5 _ Form dotOfSize:5].
	Dot5 displayAt: point1! !

!DisplayScreen methodsFor: '*RVM' stamp: 'aau 1/13/2011 19:54'!
drawDot5At: point1 color: c
	|ColorDot5|
	"Display drawDot5At: 100@100 color: Color red"
	ColorDot5 _ ColorForm dotOfSize:5 color: c.
	ColorDot5 displayAt: point1! !

!DisplayScreen methodsFor: '*RVM' stamp: 'dmu 3/23/2010 00:02'!
drawLineFrom: point1 to: point2 color: aColor
	"Display drawLineFrom: Point fromUser to: Point fromUser color: Color fromUser"
	"Display drawLineFrom: 0@0 to: 200@200 color: Color black"
	"Display drawLineFrom: 0@0 to: 200@200 color: Color white"
	Dot1 ifNil: [Dot1 _ Form dotOfSize:1].
	self drawLine: Dot1 from: point1 to: point2 clippingBox: self boundingBox rule: Form paint fillColor: aColor ! !

!DisplayScreen methodsFor: '*RVM' stamp: 'dmu 1/25/2010 11:27'!
eraseDot5At: point1
	"Display eraseDot5At: 100@100"
	Blank5 ifNil: [Blank5 _ (Form dotOfSize:5) fillWhite].
	Blank5 displayAt: point1! !

!DisplayScreen methodsFor: '*RVM' stamp: 'dmu 3/23/2010 00:03'!
eraseLineFrom: point1 to: point2 color: aColor
	"Display eraseLineFrom: Point fromUser to: Point fromUser color: Color fromUser"
	"Display eraseLineFrom: 0@0 to: 200@200 color: Color black"
	"Display eraseLineFrom: 0@0 to: 200@200 color: Color white"
	Dot1 ifNil: [Dot1 _ Form dotOfSize:1].
	self drawLine: Dot1 from: point1 to: point2 clippingBox: self boundingBox rule: Form erase fillColor: aColor ! !

!DisplayText methodsFor: 'accessing' stamp: 'ssa 8/27/2009 11:17'!
numberOfLines 
	"Answer the number of lines of text in the receiver."

	^self text lineCount! !

!DisplayText methodsFor: 'converting' stamp: 'ssa 1/20/2010 10:34'!
asParagraphWithStyle: aTextStyle
	"Answer a Paragraph whose text  is  identical to that of the 
	receiver."
	| para |
	para _ Paragraph withText: text style: aTextStyle.
	para foregroundColor: foreColor backgroundColor: backColor.
	backColor isTransparent ifTrue: [para rule: Form paint].
	^ para! !

!DisplayText methodsFor: 'testing' stamp: 'ssa 1/20/2010 11:00'!
isEmpty

	^self text isEmpty! !

!DisplayTextView class methodsFor: 'examples' stamp: 'ssa 9/4/1998 17:29'!
example2	
	"Create a standarad system view with two parts, one editable, the other not."
	"Modified to support Windoze - ssa"
	| topView aDisplayTextView |
	topView _ StandardSystemView new.
	topView label: 'Text Editor'.
	aDisplayTextView _ MSWScrollBarView on: (self new model: 'test string label' asDisplayText).
	aDisplayTextView scrollingView controller: NoController new.
	aDisplayTextView window: (0 @ 0 extent: 100 @ 100).
	aDisplayTextView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.
	topView addSubView: aDisplayTextView.

	aDisplayTextView _ MSWScrollBarView on: (self new model: 'test string' asDisplayText).
	aDisplayTextView window: (0 @ 0 extent: 100 @ 100).
	aDisplayTextView borderWidth: 2.
	topView
		addSubView: aDisplayTextView
		align: aDisplayTextView viewport topLeft
		with: topView lastSubView viewport topRight.
	topView controller open

	"DisplayTextView example2"! !

!DisplayTextView class methodsFor: 'examples'!
open: textOrString label: aLabel
        "Create a system view with a paragraph editor in it.  6/2/96 sw"
        "VIVA LA JUNTA!!  Modified to use MSWScrollBarViews - ssa 12/11/97 12:00"

        | topView aDisplayTextView |
        aDisplayTextView _ MSWScrollBarView on: (DisplayTextView new model: textOrString asDisplayText).
        aDisplayTextView borderWidth: 2.
        topView _ StandardSystemView new.
        topView label: aLabel.
        topView addSubView: aDisplayTextView.
        topView controller open

        "DisplayTextView open: 'Great green gobs' label: 'Gopher Guts'"! !

!DualChangeSorter methodsFor: 'initialization' stamp: 'ssa 9/3/2008 11:07'!
open
	| topView |

	leftCngSorter _ ChangeSorter new myChangeSet: ChangeSet current.
	leftCngSorter parent: self.
	rightCngSorter _ ChangeSorter new myChangeSet: 
			ChangeSorter secondaryChangeSet.
	rightCngSorter parent: self.

	topView _ (StandardSystemView new) model: self; borderWidth: 1.
	topView label: leftCngSorter label.
	topView minimumSize: 300 @ 200.
	leftCngSorter openView: topView offsetBy: 0@0.
	rightCngSorter openView: topView offsetBy: 360@0.
	topView controller open.
! !

!EnsembleNode methodsFor: 'printing' stamp: 'ssa 4/19/2010 20:44'!
printOn: aStream indent: level

	aStream nextPut: $%;nextPut: ${.
	1 to: elements size do: 
		[:i | (elements at: i) printOn: aStream indent: level.
		i < elements size ifTrue: [aStream nextPutAll: '. ']].
	aStream nextPut: $}! !

!EnsembleNode methodsFor: 'code generation' stamp: 'ssa 4/19/2010 22:35'!
emitForValue: stack on: aStream

	^ emitNode emitForValue: stack on: aStream! !

!EnsembleNode methodsFor: 'code generation' stamp: 'dmu 9/16/2010 23:44'!
sizeForValue: encoder
	emitNode _ "Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray;asEnsembleOfElements"
				CascadeNode new
					receiver: (MessageNode new
								receiver: (encoder encodeVariable: #Array)
								selector: #braceStream:
								arguments: (Array with: (encoder encodeLiteral: elements size))
								precedence: 3 from: encoder)
					messages: (((elements collect: [:elt | MessageNode new receiver: nil
														selector: #nextPut:
														arguments: (Array with: elt)
														precedence: 3 from: encoder])
								copyWith: (MessageNode new receiver: nil
														selector: #braceArray
														arguments: (Array new)
														precedence: 1 from: encoder))copyWith: (MessageNode new receiver: nil
														selector: #asEnsembleOfElements
														arguments: (Array new)
														precedence: 1 from: encoder)).
	^ emitNode sizeForValue: encoder! !

!EqualityTester methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!
resultFor: runs 
	"Test that equality is the same over runs and answer the result"
	1
		to: runs
		do: [:i | self prototype = self prototype
				ifFalse: [^ false]]. 
	^ true! !

!EqualityTester commentStamp: 'mjr 8/20/2003 13:04' prior: 0!
I provide a simple way to test the equality properties of any object.!
!Error methodsFor: '*SUnit'!
sunitAnnounce: aTestCase toResult: aTestResult
	aTestResult addError: aTestCase.
	self sunitExitWith: false.! !

!EventSensor methodsFor: 'accessing' stamp: 'ar 7/23/2000 14:37'!
eventQueue
	"Return the current event queue"
	^eventQueue! !

!EventSensor methodsFor: 'accessing' stamp: 'nk 4/12/2004 19:36'!
eventTicklerProcess
	"Answer my event tickler process, if any"
	^EventTicklerProcess! !

!EventSensor methodsFor: 'accessing' stamp: 'ssa 12/17/2009 13:19'!
flushAllButDandDEvents
	| newQueue oldQueue  |
	
	newQueue _ SharedQueue new.
	self eventQueue ifNil: 
		[eventQueue := newQueue.
		^self].
	oldQueue _ self eventQueue.
	[oldQueue size > 0] whileTrue: 
		[| item type | 
		item _ oldQueue next.
		type _ item at: 1.
		type = EventTypeDragDropFiles ifTrue: [ newQueue nextPut: item]].
	eventQueue := newQueue.
! !

!EventSensor methodsFor: 'accessing' stamp: 'ar 2/7/2001 17:13'!
flushEvents
	eventQueue ifNotNil:[eventQueue flush].! !

!EventSensor methodsFor: 'accessing' stamp: 'ssa 12/17/2009 12:30'!
nextEvent
	"Return the next event from the receiver."
	eventQueue == nil 
		ifTrue:[^self nextEventSynthesized]
		ifFalse:[^self nextEventFromQueue]
! !

!EventSensor methodsFor: 'accessing' stamp: 'JMM 11/7/2005 14:38'!
peekButtons
	self wait2ms.
	self fetchMoreEvents.
	^mouseButtons! !

!EventSensor methodsFor: 'accessing' stamp: 'ar 2/6/2004 14:51'!
peekEvent
	"Look ahead at the next event."
	eventQueue ifNil:[^nil].
	self fetchMoreEvents.
	^eventQueue peek! !

!EventSensor methodsFor: 'accessing' stamp: 'tpr 1/5/2005 17:34'!
peekKeyboardEvent
	"Return the next keyboard char event from the receiver or nil if none available"
	^eventQueue nextOrNilSuchThat: 
					[:buf | 
					buf first = EventTypeKeyboard and: [(buf fourth) = EventKeyChar]]! !

!EventSensor methodsFor: 'accessing' stamp: 'ar 2/8/2001 21:45'!
peekMousePt
	^mousePosition! !

!EventSensor methodsFor: 'accessing' stamp: 'JMM 11/7/2005 14:38'!
peekPosition
	self wait2ms.
	self fetchMoreEvents.
	^mousePosition! !

!EventSensor methodsFor: 'initialize' stamp: 'nk 4/12/2004 19:21'!
initialize
	"Initialize the receiver"
	mouseButtons := 0.
	mousePosition := 0 @ 0.
	keyboardBuffer := SharedQueue new.
	self setInterruptKey: (interruptKey ifNil: [$. asciiValue bitOr: 16r0800 ]). 	"cmd-."
	interruptSemaphore := (Smalltalk specialObjectsArray at: 31) ifNil: [Semaphore new].
	self flushAllButDandDEvents.
	inputSemaphore := Semaphore new.
	hasInputSemaphore := false.! !

!EventSensor methodsFor: 'initialize' stamp: 'nk 4/12/2004 20:13'!
shutDown
	super shutDown.
	EventTicklerProcess ifNotNil: [
		EventTicklerProcess terminate.
		EventTicklerProcess _ nil. ].
	inputSemaphore ifNotNil:[Smalltalk unregisterExternalObject: inputSemaphore].
! !

!EventSensor methodsFor: 'initialize' stamp: 'nk 6/21/2004 10:42'!
startUp
	"Run the I/O process"
	self initialize.
	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).
	super startUp.
	self installEventTickler.
	Smalltalk isMorphic ifTrue:[self flushAllButDandDEvents].

	"Attempt to discover whether the input semaphore is actually being signaled."
	hasInputSemaphore := false.
	inputSemaphore initSignals.
! !

!EventSensor methodsFor: 'mouse' stamp: 'ar 5/18/2003 18:27'!
createMouseEvent
	"create and return a new mouse event from the current mouse 
	position; this is useful for restarting normal event queue 
	processing after manual polling"

	| buttons modifiers pos mapped eventBuffer |
	eventBuffer _ Array new: 8.
	buttons _ self primMouseButtons.
	pos _ self primMousePt.
	modifiers _ buttons bitShift: -3.
	buttons _ buttons bitAnd: 7.
	mapped _ self mapButtons: buttons modifiers: modifiers.
	eventBuffer
		at: 1
		put: EventTypeMouse;
		 at: 2 put: Time millisecondClockValue;
		 at: 3 put: pos x;
		 at: 4 put: pos y;
		 at: 5 put: mapped;
		 at: 6 put: modifiers.
	^ eventBuffer! !

!EventSensor methodsFor: 'private' stamp: 'nk 4/12/2004 20:16'!
eventTickler
	"Poll infrequently to make sure that the UI process is not been stuck. 
	If it has been stuck, then spin the event loop so that I can detect the 
	interrupt key."
	| delay |
	delay := Delay forMilliseconds: self class eventPollPeriod.
	self lastEventPoll.	"ensure not nil."
	[| delta | 
	[ delay wait.
	delta := Time millisecondClockValue - lastEventPoll.
	(delta < 0
			or: [delta > self class eventPollPeriod])
		ifTrue: ["force check on rollover"
			self fetchMoreEvents]] on: Error do: [:ex | ].
	true ] whileTrue.! !

!EventSensor methodsFor: 'private' stamp: 'ssa 12/17/2009 14:18'!
flushNonKbdEvents
	eventQueue ifNil: [^ self].
	[^self]value.   "don't flush so we don't lose events"
	eventQueue flushAllSuchThat:
		[:buf | (self isKbdEvent: buf) not]
! !

!EventSensor methodsFor: 'private' stamp: 'sm 2/24/2011 16:42'!
installEventTickler
	"Initialize the interrupt watcher process. Terminate the old process if any."
	"Sensor installEventTickler"

	EventTicklerProcess ifNotNil: [EventTicklerProcess terminate].
	EventTicklerProcess _ [self eventTickler] forkAt: Processor lowIOPriority.
	EventTicklerProcess name: 'EventTicklerProcess'.
! !

!EventSensor methodsFor: 'private' stamp: 'di 10/1/2001 20:51'!
isKbdEvent: buf
	^ (buf at: 1) = EventTypeKeyboard and: [(buf at: 4) = EventKeyChar]! !

!EventSensor methodsFor: 'private' stamp: 'nk 3/18/2004 13:21'!
lastEventPoll
	"Answer the last clock value at which fetchMoreEvents was called."
	^lastEventPoll ifNil: [ lastEventPoll _ Time millisecondClockValue ]! !

!EventSensor methodsFor: 'private' stamp: 'ar 2/6/2004 14:42'!
nextEventFromQueue
	"Return the next event from the receiver."
	eventQueue isEmpty ifTrue:[self fetchMoreEvents].
	eventQueue isEmpty
		ifTrue:[^nil]
		ifFalse:[^eventQueue next]! !

!EventSensor methodsFor: 'private' stamp: 'nk 3/17/2004 07:09'!
nextEventSynthesized
	"Return a synthesized event. This method is called if an event driven client wants to receive events but the primary user interface is not event-driven (e.g., the receiver does not have an event queue but only updates its state). This can, for instance, happen if a Morphic World is run in an MVC window. To simplify the clients work this method will always return all available keyboard events first, and then (repeatedly) the mouse events. Since mouse events come last, the client can assume that after one mouse event has been received there are no more to come. Note that it is impossible for EventSensor to determine if a mouse event has been issued before so the client must be aware of the possible problem of getting repeatedly the same mouse events. See HandMorph>>processEvents for an example on how to deal with this."
	| kbd array buttons pos modifiers mapped |
	"First check for keyboard"
	array _ Array new: 8.
	kbd _ self primKbdNext.
	kbd ifNotNil:
		["simulate keyboard event"
		array at: 1 put: EventTypeKeyboard. "evt type"
		array at: 2 put: Time millisecondClockValue. "time stamp"
		array at: 3 put: (kbd bitAnd: 255). "char code"
		array at: 4 put: EventKeyChar. "key press/release"
		array at: 5 put: (kbd bitShift: -8). "modifier keys"
		^ array].

	"Then check for mouse"
	pos _ self primMousePt.
	buttons _ mouseButtons.
	modifiers _ buttons bitShift: -3.
	buttons _ buttons bitAnd: 7.
	mapped _ self mapButtons: buttons modifiers: modifiers.
	array 
		at: 1 put: EventTypeMouse;
		at: 2 put: Time millisecondClockValue;
		at: 3 put: pos x;
		at: 4 put: pos y;
		at: 5 put: mapped;
		at: 6 put: modifiers.
	^ array

! !

!EventSensor methodsFor: 'private' stamp: 'ar 7/23/2000 00:34'!
primInterruptSemaphore: aSemaphore 
	"Primitive. Install the argument as the semaphore to be signalled whenever the user presses the interrupt key. The semaphore will be signaled once each time the interrupt key is pressed."
	interruptSemaphore _ aSemaphore.
	"backward compatibility: use the old primitive which is obsolete now"
	super primInterruptSemaphore: aSemaphore! !

!EventSensor methodsFor: 'private' stamp: 'ssa 12/16/2009 13:26'!
primKbdNext
	"Allows for use of old Sensor protocol to get at the keyboard,
	as when running kbdTest or the InterpreterSimulator in Morphic"
	| evtBuf |
	self fetchMoreEvents.
	keyboardBuffer isEmpty ifFalse:[^ keyboardBuffer next].
	eventQueue ifNotNil:
		[evtBuf _ eventQueue nextOrNilSuchThat: [:buf | self isKbdEvent: buf].
		self flushNonKbdEvents].
	^ evtBuf ifNotNil: [evtBuf at: 3]
! !

!EventSensor methodsFor: 'private' stamp: 'ssa 12/16/2009 13:26'!
primKbdPeek
	"Allows for use of old Sensor protocol to get at the keyboard,
	as when running kbdTest or the InterpreterSimulator in Morphic"
	| char |

	self fetchMoreEvents.
	keyboardBuffer isEmpty ifFalse: [^ keyboardBuffer peek].
	char _ nil.
	eventQueue ifNotNil:
		[eventQueue nextOrNilSuchThat:  "NOTE: must not return out of this block, so loop to end"
			[:buf | (self isKbdEvent: buf) ifTrue: [char ifNil: [char _ buf at: 3]].
			false  "NOTE: block value must be false so Queue won't advance"]].
	^ char
! !

!EventSensor methodsFor: 'private' stamp: 'ssa 12/16/2009 13:26'!
primMouseButtons

	self fetchMoreEvents.
	self flushNonKbdEvents.
	^ mouseButtons
! !

!EventSensor methodsFor: 'private' stamp: 'ssa 12/16/2009 13:26'!
primMousePt

	self fetchMoreEvents.
	self flushNonKbdEvents.
	^ mousePosition
! !

!EventSensor methodsFor: 'private' stamp: 'ls 10/23/2000 14:14'!
primSetInterruptKey: anInteger
	"Primitive. Register the given keycode as the user interrupt key. The low byte of the keycode is the ISO character and its next four bits are the Smalltalk modifer bits <cmd><opt><ctrl><shift>."
	interruptKey _ anInteger.
	"backward compatibility: use the old primitive which is obsolete now"
	super primSetInterruptKey: anInteger! !

!EventSensor methodsFor: 'private' stamp: 'JMM 11/7/2005 14:37'!
wait2ms
	(Delay forMilliseconds: 2) wait.! !

!EventSensor methodsFor: 'private-I/O' stamp: 'ssa 12/17/2009 13:21'!
fetchMoreEvents
	"Fetch more events from the VM"
	| eventBuffer type |

	"Reset input semaphore so clients can wait for the next events after this one."
	inputSemaphore isSignaled
		ifTrue: [ hasInputSemaphore _ true.
			inputSemaphore initSignals ].

	"Remember the last time that I checked for events."
	lastEventPoll := Time millisecondClockValue.

	eventBuffer := Array new: 8.
	[self primGetNextEvent: eventBuffer.
	type := eventBuffer at: 1.
	type = EventTypeNone]
		whileFalse: [self processEvent: eventBuffer ].
! !

!EventSensor methodsFor: 'private-I/O' stamp: 'ar 7/30/2000 18:12'!
mapButtons: buttons modifiers: modifiers
	"Map the buttons to yellow or blue based on the given modifiers.
	If only the red button is pressed, then map
		Ctrl-RedButton -> BlueButton.
		Cmd-RedButton -> YellowButton.
	"
	(buttons = RedButtonBit)
		ifFalse:[^buttons].
	(modifiers allMask: CtrlKeyBit) 
		ifTrue:[^BlueButtonBit].
	(modifiers allMask: CommandKeyBit) 
		ifTrue:[^YellowButtonBit].
	^buttons! !

!EventSensor methodsFor: 'private-I/O' stamp: 'ssa 12/17/2009 13:30'!
primGetNextEvent: array
	"Store the next OS event available into the provided array.
	Essential. If the VM is not event driven the ST code will fall
	back to the old-style mechanism and use the state based
	primitives instead."
	| kbd buttons modifiers pos mapped |
	<primitive: 94>

	"Simulate the events"
	array at: 1 put: EventTypeNone. "assume no more events"

	"First check for keyboard"
	kbd _ super primKbdNext.
	kbd = nil ifFalse:[
		"simulate keyboard event"
		array at: 1 put: EventTypeKeyboard. "evt type"
		array at: 2 put: Time millisecondClockValue. "time stamp"
		array at: 3 put: (kbd bitAnd: 255). "char code"
		array at: 4 put: EventKeyChar. "key press/release"
		array at: 5 put: (kbd bitShift: -8). "modifier keys"
		^self].

	"Then check for mouse"
	buttons _ super primMouseButtons.
	pos _ super primMousePt.
	modifiers _ buttons bitShift: -3.
	buttons _ buttons bitAnd: 7.
	mapped _ self mapButtons: buttons modifiers: modifiers.
	(pos = mousePosition and:[(mapped bitOr: (modifiers bitShift: 3)) = mouseButtons])
		ifTrue:[^self].
	array 
		at: 1 put: EventTypeMouse;
		at: 2 put: Time millisecondClockValue;
		at: 3 put: pos x;
		at: 4 put: pos y;
		at: 5 put: mapped;
		at: 6 put: modifiers.
! !

!EventSensor methodsFor: 'private-I/O' stamp: 'ar 7/30/2000 18:16'!
primSetInputSemaphore: semaIndex
	"Set the input semaphore the VM should use for asynchronously signaling the availability of events. Primitive. Optional."
	<primitive: 93>
	^nil! !

!EventSensor methodsFor: 'private-I/O' stamp: 'ssa 12/17/2009 12:46'!
processEvent: evt 
	"Process a single event. This method is run at high priority."
	| type |
	type := evt at: 1.
	"Tackle mouse events first"
	type = EventTypeMouse
		ifTrue: [evt
				at: 5
				put: (ButtonDecodeTable at: (evt at: 5)
							+ 1). 
				self queueEvent: evt.
				self processMouseEvent: evt . 
				^self].
	
	"Store the event in the queue if there's any"
	type = EventTypeKeyboard
		ifTrue: [ "Check if the event is a user interrupt"
			((evt at: 4) = 0
				and: [((evt at: 3)
						bitOr: (((evt at: 5)
							bitAnd: 8)
							bitShift: 8))
							= interruptKey])
					ifTrue: ["interrupt key is meta - not reported as event"
							^ interruptSemaphore signal].
			"Else swap ctrl/alt keys if neeeded.wi"
			KeyDecodeTable
				at: {evt at: 3. evt at: 5}
				ifPresent: [:a | evt at: 3 put: a first;
						 at: 5 put: a second]. 
			self queueEvent: evt. 
			self processKeyboardEvent: evt . 
			^self ].
				
	"Handle all events other than Keyborad or Mouse."
	self queueEvent: evt.
	! !

!EventSensor methodsFor: 'private-I/O' stamp: 'ssa 12/16/2009 13:12'!
processKeyboardEvent: evt
	"process a keyboard event, updating InputSensor state"
	| charCode pressCode |
	"Never update keyboardBuffer if we have an eventQueue active"
	mouseButtons _ (mouseButtons bitAnd: 7) bitOr: ((evt at: 5) bitShift: 3).
	eventQueue ifNotNil:[^self]. 
	charCode _ evt at: 3.
	charCode = nil ifTrue:[^self]. "extra characters not handled in MVC"
	pressCode _ evt at: 4.
	pressCode = EventKeyChar ifFalse:[^self]. "key down/up not handled in MVC"
	"mix in modifiers"
	charCode _ charCode bitOr: ((evt at: 5) bitShift: 8).
	keyboardBuffer nextPut: charCode .! !

!EventSensor methodsFor: 'private-I/O' stamp: 'ar 8/16/2000 22:07'!
processMouseEvent: evt
	"process a mouse event, updating InputSensor state"
	| modifiers buttons mapped |
	mousePosition _ (evt at: 3) @ (evt at: 4).
	buttons _ evt at: 5.
	modifiers _ evt at: 6.
	mapped _ self mapButtons: buttons modifiers: modifiers.
	mouseButtons _ mapped bitOr: (modifiers bitShift: 3).! !

!EventSensor methodsFor: 'private-I/O' stamp: 'ssa 12/17/2009 14:17'!
queueEvent: evt
	"Queue the given event in the event queue (if any).
	Note that the event buffer must be copied since it
	will be reused later on."
	eventQueue ifNil:[^self].
	eventQueue nextPut: evt clone.! !

!EventSensor commentStamp: 'nk 4/13/2004 11:18' prior: 0!
EventSensor is a replacement for InputSensor based on a set of (optional) event primitives. An EventSensor updates its state when events are received so that all state based users of Sensor (e.g., Sensor keyboard, Sensor leftShiftDown, Sensor mouseButtons) will work exactly as before, by moving the current VM mechanisms into EventSensor itself. An optional input semaphore is part of the new design.

For platforms that support true asynchronous event notification, the semaphore will be signaled to indicate pending events.
On platforms that do not support asynchronous notifications about events, the UI will have to poll EventSensor periodically to read events from the VM.

Instance variables:
	mouseButtons <Integer>	- mouse button state as replacement for primMouseButtons
	mousePosition <Point>	- mouse position as replacement for primMousePt
	keyboardBuffer <SharedQueue>	- keyboard input buffer
	interruptKey <Integer>			- currently defined interrupt key
	interruptSemaphore <Semaphore>	- the semaphore signaled when the interruptKey is detected
	eventQueue <SharedQueue>	- an optional event queue for event driven applications
	inputSemaphore <Semaphore>- the semaphore signaled by the VM if asynchronous event notification is supported
	lastEventPoll <Integer>		- the last millisecondClockValue at which we called fetchMoreEvents
	hasInputSemaphore <Boolean>	- true if my inputSemaphore has actually been signaled at least once.

Class variables:
	EventPollPeriod <Integer>	- the number of milliseconds to wait between polling for more events in the userInterruptHandler.
	EventTicklerProcess <Process>	- the process that makes sure that events are polled for often enough (at least every EventPollPeriod milliseconds).

Event format:
The current event format is very simple. Each event is recorded into an 8 element array. All events must provide some SmallInteger ID (the first field in the event buffer) and a time stamp (the second field in the event buffer), so that the difference between the time stamp of an event and the current time can be reported.

Currently, the following events are defined:

Null event
=============
The Null event is returned when the ST side asks for more events but no more events are available.
Structure:
[1]		- event type 0
[2-8]	- unused

Mouse event structure
==========================
Mouse events are generated when mouse input is detected.
Structure:
[1]	- event type 1
[2]	- time stamp
[3]	- mouse x position
[4]	- mouse y position
[5]	- button state; bitfield with the following entries:
		1	-	yellow (e.g., right) button
		2	-	blue (e.g., middle) button
		4	-	red (e.g., left) button
		[all other bits are currently undefined]
[6]	- modifier keys; bitfield with the following entries:
		1	-	shift key
		2	-	ctrl key
		4	-	(Mac specific) option key
		8	-	Cmd/Alt key
		[all other bits are currently undefined]
[7]	- reserved.
[8]	- reserved.

Keyboard events
====================
Keyboard events are generated when keyboard input is detected.
[1]	- event type 2
[2]	- time stamp
[3]	- character code
		For now the character code is in Mac Roman encoding.
[4]	- press state; integer with the following meaning
		0	-	character
		1	-	key press (down)
		2	- 	key release (up)
[5]	- modifier keys (same as in mouse events)
[6]	- reserved.
[7]	- reserved.
[8]	- reserved.
!
!EventSensor class methodsFor: 'class initialization' stamp: 'nk 4/12/2004 18:55'!
eventPollPeriod
	^EventPollPeriod ifNil: [ EventPollPeriod _ 500 ].! !

!EventSensor class methodsFor: 'class initialization' stamp: 'nk 4/12/2004 18:55'!
eventPollPeriod: msec
	"Set the number of milliseconds between checking for events to msec."

	EventPollPeriod _ msec max: 10.! !

!EventSensor class methodsFor: 'class initialization' stamp: 'ar 7/23/2000 15:06'!
install	"EventSensor install"
	"Install an EventSensor in place of the current Sensor."
	| newSensor |
	Sensor shutDown.
	newSensor _ self new.
	newSensor startUp.
	"Note: We must use #become: here to replace all references to the old sensor with the new one, since Sensor is referenced from all the existing controllers."
	Sensor becomeForward: newSensor. "done"! !

!ExampleSetTest methodsFor: 'running' stamp: 'BaseSystem 8/30/2009 09:40'!
setUp
	empty := Set new.
	full := Set with: 5 with: #abc! !

!ExampleSetTest methodsFor: 'testing' stamp: 'BaseSystem 8/30/2009 09:40'!
testAdd
	empty add: 5.
	self assert: (empty includes: 5)! !

!ExampleSetTest methodsFor: 'testing' stamp: 'BaseSystem 8/30/2009 09:40'!
testGrow
	empty addAll: (1 to: 100).
	self assert: empty size = 100! !

!ExampleSetTest methodsFor: 'testing' stamp: 'BaseSystem 8/30/2009 09:40'!
testIllegal
	self 
		should: [empty at: 5] 
		raise: TestResult error.
	self 
		should: [empty at: 5 put: #abc] 
		raise: TestResult error! !

!ExampleSetTest methodsFor: 'testing' stamp: 'BaseSystem 8/30/2009 09:40'!
testIncludes
	self assert: (full includes: 5).
	self assert: (full includes: #abc)! !

!ExampleSetTest methodsFor: 'testing' stamp: 'BaseSystem 8/30/2009 09:40'!
testOccurrences
	self assert: (empty occurrencesOf: 0) = 0.
	self assert: (full occurrencesOf: 5) = 1.
	full add: 5.
	self assert: (full occurrencesOf: 5) = 1! !

!ExampleSetTest methodsFor: 'testing' stamp: 'BaseSystem 8/30/2009 09:40'!
testRemove
	full remove: 5.
	self assert: (full includes: #abc).
	self deny: (full includes: 5)! !

!Exception methodsFor: '*SUnit' stamp: 'jp 3/17/2003 10:03'!
sunitExitWith: aValue
 
        self return: aValue! !

!ExplorerListView methodsFor: 'accessing' stamp: 'ssa 3/9/2010 16:15'!
indentFor: anItem

	| aStream lev |
	(anItem isKindOf: String) ifTrue:[^''].
	aStream _ WriteStream on:''.
	(lev _ self levelOf: anItem) .
	lev  timesRepeat:[aStream nextPutAll:'   '].
	^aStream contents,'  '! !

!ExplorerListView methodsFor: 'accessing' stamp: 'ssa 3/1/2010 12:33'!
levelOf: anItem

	^anItem depth! !

!ExplorerListView methodsFor: 'displaying' stamp: 'ssa 2/8/2010 16:17'!
displayTwisties

	| box twisty to firstIndex |
	firstIndex _ self firstShown.
	firstIndex  to: ((self list numberOfLines -2)min:(firstIndex + self numSelectionsInView )) do:[:index|
		(self objects at: index) hasContents ifTrue:[ 
			box _ self indentBoxFor: index.
			twisty _(self objects at: index) isOpen ifTrue:[self openedTwistyIcon]ifFalse:[self closedTwistyIcon].
			twisty
				displayOn: Display
				at: (to_box topRight- (twisty width@0))
				clippingBox: (box intersect: self clippingBox)
				rule: Form paint
				fillColor: nil.
			self twistyTargets at:(to extent: twisty extent) put: index]].! !

!ExplorerListView methodsFor: 'displaying' stamp: 'ssa 6/17/2010 16:32'!
labelForItem: anItem
	"Subclasses may want to override"

	^(self indentFor: anItem),' ',anItem asString ! !

!FailingTestResourceTestCase methodsFor: 'utility' stamp: 'BaseSystem 8/30/2009 09:40'!
clearOuterResourceStateDuring: aBlock
	"Make the resource impossible to make available, then ensure that every test raises a failure but not an error (which its setUp would do if it reached it and the resource were nil)."

	^super clearOuterResourceStateDuring:
		[SimpleTestResource preventAvailabilityDuring:
			[self should: aBlock raise: TestResult failure]]! !

!False methodsFor: 'debugging' stamp: 'ssa 3/11/2010 11:53'!
haltIfFalse

	self halt

	! !

!False class methodsFor: 'instance creation'!
dearchiveFrom: aStream

	aStream storeObject: false.
	^false! !

!Field methodsFor: 'accessing' stamp: 'dmu 9/23/2010 14:25'!
add: aParticle 
	particles  add: aParticle.
	
	simulation running
		ifTrue: [aParticle go]! !

!Field methodsFor: 'accessing'!
area
	^ area! !

!Field methodsFor: 'accessing'!
extent
	^ area extent! !

!Field methodsFor: 'accessing'!
neighborE
	^ neighborE! !

!Field methodsFor: 'accessing'!
neighborN
	^ neighborN! !

!Field methodsFor: 'accessing'!
neighborNE
	^ neighborNE! !

!Field methodsFor: 'accessing'!
neighborNW
	^ neighborNW! !

!Field methodsFor: 'accessing'!
neighborS
	^ neighborS! !

!Field methodsFor: 'accessing'!
neighborSE
	^ neighborSE! !

!Field methodsFor: 'accessing'!
neighborSW
	^ neighborSW! !

!Field methodsFor: 'accessing'!
neighborW
	^ neighborW! !

!Field methodsFor: 'accessing'!
origin
	^ self area origin! !

!Field methodsFor: 'accessing'!
particles
	^ particles! !

!Field methodsFor: 'accessing' stamp: 'dmu 10/6/2010 14:10'!
remove: aParticle 
	particles  members remove: aParticle ifAbsent: []! !

!Field methodsFor: 'accessing'!
simulation
	^ simulation! !

!Field methodsFor: 'motion'!
go
	particles
		do: [:t1 | t1 go]! !

!Field methodsFor: 'motion' stamp: 'max 9/29/2010 12:59'!
hand: aParticle to: neighborField
	neighborField isNil ifTrue: [aParticle bounce. ^ self].
	(neighborField = self) ifFalse: [aParticle moveTo: neighborField].
	^ self! !

!Field methodsFor: 'motion' stamp: 'max 9/17/2010 23:58'!
localFieldsUnderParticleAt: aLocation size: particleSize
	| pX pY bounds |
	pX _ aLocation x. pY _ aLocation y.
	bounds _ area insetBy: (particleSize // 2).
	
	(pX < bounds left) ifTrue:
		[(pY < bounds top) ifTrue:
			[^ {neighborNW . neighborN . neighborW . self}].
		 (pY >= bounds bottom) ifTrue:
			[^ {neighborSW . neighborS . neighborW . self}].
		^ {neighborW . self}].
	
	(pX >= bounds right) ifTrue:
		[(pY < bounds top) ifTrue:
			[^ {neighborNE . neighborN. neighborE . self}].
		 (pY >= bounds bottom) ifTrue:
			[^ {neighborSE . neighborS. neighborE . self}].
		^ {neighborE . self}].
	
	(pY < bounds top) ifTrue:
			[^ {neighborN . self}].
	(pY >= bounds bottom) ifTrue:
			[^ {neighborS . self}].
	
	^ {self}! !

!Field methodsFor: 'motion' stamp: 'max 9/29/2010 12:48'!
particle: aParticle ofSize: itsSize movedTo: aLocation 
	| fields |
	fields := self localFieldsUnderParticleAt: aLocation size: itsSize.
	self hand: aParticle to: (fields first).
	fields do: [:fld | fld ifNotNil: [fld particles do: [:p | p particle: aParticle
								ofSize: itsSize
								movedTo: aLocation]]]
	! !

!Field methodsFor: 'motion' stamp: 'max 9/16/2010 16:30'!
step
	particles do: [:each | each step]! !

!Field methodsFor: 'motion' stamp: 'max 9/16/2010 16:30'!
stop
	particles do: [:each | each stop]! !

!Field methodsFor: 'displaying'!
defaultLabelForInspector
	| t1 |
	t1 := WriteStream with: ''.
	self printOn: t1.
	^ t1 contents! !

!Field methodsFor: 'displaying' stamp: 'max 9/16/2010 16:31'!
displayOn: aDisplaySurface 
	particles do: [:each | each displayOn: aDisplaySurface]! !

!Field methodsFor: 'displaying' stamp: 'max 9/16/2010 16:32'!
printOn: aStream 
	super printOn: aStream.
	aStream nextPut: $(.
	self origin printOn: aStream.
	aStream nextPut: $)! !

!Field methodsFor: 'private'!
setArea: t1 
	area := t1! !

!Field methodsFor: 'private'!
setNeighborE: t1 
	neighborE := t1! !

!Field methodsFor: 'private'!
setNeighborN: t1 
	neighborN := t1! !

!Field methodsFor: 'private'!
setNeighborNE: t1 
	neighborNE := t1! !

!Field methodsFor: 'private'!
setNeighborNW: t1 
	neighborNW := t1! !

!Field methodsFor: 'private'!
setNeighborS: t1 
	neighborS := t1! !

!Field methodsFor: 'private'!
setNeighborSE: t1 
	neighborSE := t1! !

!Field methodsFor: 'private'!
setNeighborSW: t1 
	neighborSW := t1! !

!Field methodsFor: 'private'!
setNeighborW: t1 
	neighborW := t1! !

!Field methodsFor: 'private'!
setSimulation: t1 
	simulation := t1! !

!Field methodsFor: 'initialize-release' stamp: 'max 9/17/2010 10:38'!
initialize
	particles := BlockingSmallSet new! !

!Field class methodsFor: 'instance creation' stamp: 'dmu 9/23/2010 14:07'!
null
	^ NullField new! !

!Field class methodsFor: 'instance creation'!
origin: t1 extent: t2 
	^ self new
		setArea: (t1 extent: t2)! !

!FileDirectory methodsFor: '*transporter' stamp: 'ads 12/13/2010 15:32'!
deleteLocalFiles
	"Took this method from Squeak 3.7; not sure why it wasn't already here. -- Adam"

	"Delete the local files in this directory."

	self fileNames do:[:fn| self deleteFileNamed: fn ifAbsent: [(CannotDeleteFileException new
			messageText: 'Could not delete the old version of file ' , (self fullNameFor: fn)) signal]]
! !

!FileDirectory methodsFor: '*transporter' stamp: 'ads 12/13/2010 15:32'!
recursiveDelete
	"Took this method from Squeak 3.7; not sure why it wasn't already here. -- Adam"
	
	"Delete the this directory, recursing down its tree."
	self directoryNames
		do: [:dn | (self directoryNamed: dn) recursiveDelete].
	self deleteLocalFiles.
	"should really be some exception handling for directory deletion, but no 
	support for it yet"
	self containingDirectory deleteDirectory: self localName! !

!FileDirectory class methodsFor: 'name utilities' stamp: 'ssa 9/3/2008 11:25'!
startUp
	"Establish the platform-specific FileDirectory subclass. Do any platform-specific startup."
	self setDefaultDirectoryClass.

	self setDefaultDirectory: (self dirPathFor: SmalltalkImage current imageName).

	Preferences startInUntrustedDirectory 
		ifTrue:[
				DefaultDirectory assureExistence].
	SmalltalkImage current openSourceFiles.
! !

!FileList methodsFor: 'file list menu' stamp: 'ssa 8/28/2009 19:44'!
fileContentsMenu: aMenu shifted: shifted
	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"

	| shiftMenu services maybeLine extraLines |
	shifted ifTrue:
		[shiftMenu _ ParagraphEditor shiftedYellowButtonMenu.
		^ aMenu 
			labels: shiftMenu labelString 
			lines: shiftMenu lineArray
			selections: shiftMenu selections].
	fileName ifNotNil:
		[services _ OrderedCollection new.
		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue:
			[services add: self serviceGet].
		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse:
			[services add: self serviceGetHex].
		maybeLine _ services size.
		(#('st' 'cs') includes: self suffixOfSelectedFile) ifTrue:
			[services addAll:
				(self servicesFromSelectorSpecs:
					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].
		(#('gif' 'jpg' 'bmp') includes: self suffixOfSelectedFile) ifTrue:
			[services halt addAll:
				(self servicesFromSelectorSpecs:
					#(importGraphic))].

		extraLines _ OrderedCollection new.
		maybeLine > 0 ifTrue: [extraLines add: maybeLine].
		services size > maybeLine ifTrue: [extraLines add: services size].
		aMenu 
			addServices: services
			for: self fullName
			extraLines: extraLines].

	aMenu addList: {
			{'find...(f)' translated.		#find}.
			{'find again (g)' translated.		#findAgain}.
			{'set search string (h)' translated.	#setSearchString}.
			#-.
			{'do again (j)' translated.		#again}.
			{'undo (z)' translated.			#undo}.
			#-.
			{'copy (c)' translated.			#copySelection}.
			{'cut (x)' translated.			#cut}.
			{'paste (v)' translated.		#paste}.
			{'paste...' translated.			#pasteRecent}.
			#-.
			{'do it (d)' translated.		#doIt}.
			{'print it (p)' translated.		#printIt}.
			{'inspect it (i)' translated.		#inspectIt}.
			{'fileIn selection (G)' translated.	#fileItIn}.
			#-.
			{'accept (s)' translated.		#accept}.
			{'cancel (l)' translated.		#cancel}.
			#-.
			{'more...' translated.			#shiftedYellowButtonActivity}}.


	^ aMenu
! !

!FileList methodsFor: 'file list menu' stamp: 'ssa 8/28/2009 19:14'!
fileSelectedMenu: aMenu

	| firstItems secondItems thirdItems n1 n2 n3 services |
	firstItems _ self itemsForFile: self fullName.
	secondItems _ self itemsForAnyFile.
	thirdItems _ self itemsForNoFile.
	n1 _ firstItems size.
	n2 _ n1 + secondItems size.
	n3 _ n2 + thirdItems size.
	services _ firstItems, secondItems, thirdItems, self serviceAllFileOptions.
	services do: [ :svc | svc addDependent: self ].
	^ aMenu 
		addServices2: services 
		for: self
		extraLines: (Array with: n1 with: n2 with: n3)
! !

!FileList methodsFor: 'file list menu' stamp: 'ssa 9/3/2008 11:18'!
fullFileListMenu: aMenu shifted: aBoolean
	"Fill the menu with all possible items for the file list pane, regardless of selection."

	| services servicesPlus extraLines linePointer |
	aMenu title: 'all possible file operations'.
	servicesPlus := self servicesFromSelectorSpecs:  #(
		fromFileName: openFromFile:  
		-
		openOn: fileIntoNewChangeSet: fileIn: browseChangesFile: browseRecentLogOnPath:
		-
		viewContents: saveContents: openOn:
		-
		
		removeLineFeeds: ).
	extraLines _ OrderedCollection new.
	linePointer _ 1.
	services _ OrderedCollection new.
	servicesPlus doWithIndex:
		[:svc :ind |
			svc == #-
				ifTrue:
					[extraLines add: linePointer - 1]
				ifFalse:
					[services add: svc.
					linePointer _ linePointer + 1]].
	aMenu 
		addServices: services 
		for: self fullName
		extraLines: extraLines! !

!FileList methodsFor: 'file list menu' stamp: 'BG 11/2/2003 21:04'!
myServicesForFile: fullName suffix: suffix

	^(FileStream isSourceFileSuffix: suffix)
		ifTrue: [ #() ]
		ifFalse: [ #() ]! !

!FileList class methodsFor: 'instance creation' stamp: 'ssa 8/22/2009 14:57'!
open
	"Open a view of an instance of me on the default directory."
	"Added scrollingView to support Windoze - ssa"
	"FileList open"
	| dir aFileList topView volListView templateView fileListView fileContentsView |
	World ifNotNil: [^ self openAsMorph].

	dir _ FileDirectory default.
	aFileList _ self new directory: dir.
	topView _ StandardSystemView new.
	topView
		model: aFileList;
		label: dir pathName;
		minimumSize: 200@200.
	topView borderWidth: 1.

	volListView _ PluggableListView on: aFileList
		list: #volumeList
		selected: #volumeListIndex
		changeSelected: #volumeListIndex:
		menu: #volumeMenu:.
	volListView autoDeselect: false.
	volListView window: (0@0 extent: 80@45).
	topView addSubView: volListView.

	templateView _ PluggableTextView on: aFileList
		text: #pattern
		accept: #pattern:.
	templateView scrollingView askBeforeDiscardingEdits: false.
	templateView window: (0@0 extent: 80@15).
	topView addSubView: templateView below: volListView.

	fileListView _ PluggableListView on: aFileList
		list: #fileList
		selected: #fileListIndex
		changeSelected: #fileListIndex:
		menu: #fileListMenu:.
	fileListView window: (0@0 extent: 120@60).
	topView addSubView: fileListView toRightOf: volListView.
	"fileListView scrollingView controller terminateDuringSelect: true. " "Pane to left may change under scrollbar"

	fileContentsView _ PluggableTextView on: aFileList
		text: #contents accept: #put:
		readSelection: #contentsSelection menu: #fileContentsMenu:shifted:.
	fileContentsView window: (0@0 extent: 200@140).
	topView addSubView: fileContentsView below: templateView.

	topView controller open.
! !

!FileStream class methodsFor: 'concrete classes' stamp: 'ads 1/12/2011 16:27'!
concreteStream
	"Who should we really direct class queries to?  "
	^ CrLfFileStream  "may change this to StandardFileStream"! !

!FileStream class methodsFor: 'file reader services' stamp: 'ssa 9/3/2008 10:33'!
fileIn: fullName
	"File in the entire contents of the file specified by the name provided"

	| fn ff |
	fullName ifNil: [^ Beeper beep].
	ff _ self readOnlyFileNamed: (fn _ fullName).
	((FileDirectory extensionFor: fn) sameAs: 'html') ifTrue: [ff _ ff asHtml].
	ff fileIn! !

!Float methodsFor: 'printing' stamp: 'ssa 1/1/1970 00:24'!
absPrintOn: aStream base: base digitCount: digitCount 
	"Print me in the given base, using digitCount significant figures."
	"Float pi absPrintOn: Transcript base: 10 digitCount: 4. Transcript cr;flush" 

	| fuzz x exp q fBase scale logScale xi |
	self isInf ifTrue: [^ aStream nextPutAll: 'Inf'].
	fBase _ base asFloat.
	"x is myself normalized to [1.0, fBase), exp is my exponent"
	exp _ 
		self < 1.0
			ifTrue: [self reciprocalFloorLog: fBase]
			ifFalse: [self floorLog: fBase].
	scale _ 1.0.
	logScale _ 0.
	[(x _ fBase raisedTo: (exp + logScale)) = 0]
		whileTrue:
			[scale _ scale * fBase.
			logScale _ logScale + 1].
	x _ self * scale / x.
	fuzz _ fBase raisedTo: 1 - digitCount.
	"round the last digit to be printed"
	x _ 0.5 * fuzz + x.
	x >= fBase
		ifTrue: 
			["check if rounding has unnormalized x"
			x _ x / fBase.
			exp _ exp + 1].
	(exp < 6 and: [exp > -4])
		ifTrue: 
			["decimal notation"
			q _ 0.
			exp < 0 ifTrue: [1 to: 1 - exp do: [:i | aStream nextPut: ('0.0000'
at: i)]]]
		ifFalse: 
			["scientific notation"
			q _ exp.
			exp _ 0].
	[x >= fuzz]
		whileTrue: 
			["use fuzz to track significance"
			xi _ x asInteger.
			aStream nextPut: (Character digitValue: xi).
			x _ x - xi asFloat * fBase.
			fuzz _ fuzz * fBase.
			exp _ exp - 1.
			exp = -1 ifTrue: [aStream nextPut: $.]].
	[exp >= -1]
		whileTrue: 
			[aStream nextPut: $0.
			exp _ exp - 1.
			exp = -1 ifTrue: [aStream nextPut: $.]].
	q ~= 0
		ifTrue: 
			[aStream nextPut: $e.
			q printOn: aStream]! !

!Form methodsFor: 'accessing' stamp: 'ssa 11/27/2009 00:23'!
bottomCenter

	^self width//2@self height ! !

!Form methodsFor: 'accessing' stamp: 'ssa 11/27/2009 00:21'!
bottomLeft

	^0@self height! !

!Form methodsFor: 'accessing' stamp: 'ssa 11/27/2009 00:21'!
bottomRight

	^self extent! !

!Form methodsFor: 'accessing' stamp: 'ssa 8/25/2009 13:22'!
displayBox 

	^Rectangle origin: self offset extent: width @ height! !

!Form methodsFor: 'accessing' stamp: 'ssa 11/27/2009 00:22'!
leftCenter

	^0@(self height//2)! !

!Form methodsFor: 'accessing' stamp: 'ssa 11/27/2009 00:22'!
rightCenter

	^self width @ (self height//2)! !

!Form methodsFor: 'accessing' stamp: 'ssa 11/27/2009 00:23'!
topCenter

	^self width//2@0 ! !

!Form methodsFor: 'accessing' stamp: 'ssa 11/27/2009 00:21'!
topLeft

	^0@0! !

!Form methodsFor: 'accessing' stamp: 'ssa 11/27/2009 00:21'!
topRight

	^self width@0! !

!Form methodsFor: 'converting' stamp: 'ssa 8/28/2009 16:18'!
asOpaqueForm

	^OpaqueForm figure: self shape: self! !

!Form methodsFor: 'converting' stamp: 'ssa 8/28/2009 11:32'!
wrapAround: aPoint
	"Answer a new form which contains the image of the receiver, but 
	translated by deltaPoint, with wrap-around.  Used for realigning 
	halftone masks.  Assumes the receiver is 32x32 with zero offset."

	"[Sensor anyButtonPressed] whileFalse:
		[((Cursor normal wrapAround: Sensor cursorPoint)
			magnifyBy: 8) displayAt: 100@100]"

	| newForm delta |
	newForm _ Form extent: (width@height) depth: 1..
	delta _ (aPoint x\\32)@(aPoint y\\32).
	delta = (0@0) ifTrue: [^self].
	self displayOn: newForm at: delta-(32@32) clippingBox: newForm boundingBox rule: Form paint fillColor: nil.
	self displayOn: newForm at: delta-(32@0) clippingBox: newForm boundingBox rule: Form paint fillColor: nil.
	self displayOn: newForm at: delta-(0@32) clippingBox: newForm boundingBox rule: Form paint fillColor: nil.
	self displayOn: newForm at: delta clippingBox: newForm boundingBox rule: Form paint fillColor: nil.
	^newForm! !

!Form methodsFor: 'displaying' stamp: 'ssa 9/4/2009 09:59'!
displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: rule fillColor: aForm

	aDisplayMedium copyBits: self boundingBox
		from: self
		at: aDisplayPoint + self offset
		clippingBox: clipRectangle 
		rule: rule
		fillColor: aForm
		map: (self colormapIfNeededFor: aDisplayMedium).
! !

!Form methodsFor: 'displaying' stamp: 'ssa 9/4/2009 15:45'!
displayTranslucentOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle
	((aDisplayMedium isKindOf:Form) ifTrue:[aDisplayMedium]ifFalse:[aDisplayMedium displayMedium])
		paintBits: self  at: aDisplayPoint + self offset clippingBox: clipRectangle translucent: 0.3! !

!Form methodsFor: 'displaying' stamp: 'ssa 9/4/2009 15:32'!
paintBits: sourceForm at: destOrigin clippingBox: aRect translucent: factor
	"Make up a BitBlt table and copy the bits with the given colorMap."
	(BitBlt current destForm: self
		sourceForm: sourceForm
		halftoneForm: nil
		combinationRule: 31
		destOrigin: destOrigin
		sourceOrigin: 0@0
		extent: sourceForm extent
		clipRect: aRect)
		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)
"
 | f f2 f3 | f _ Form fromUser. f replaceColor:  (Color r: 0.8 g: 1.0 b: 0.599) withColor: Color transparent.
f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.
0.0 to: 1.0 by: 1.0/32 do:
	[:t | f3 _ f2 deepCopy. f3 paintBits: f at: 0@0 translucent: t.
	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait].
"! !

!Form methodsFor: 'filling' stamp: 'ssa 11/30/2009 13:30'!
fill: aRectangle rule: anInteger fillColor: aForm  clippingBox: clipRect
	"Replace a rectangular area of the receiver with the pattern described by aForm 
	according to the rule anInteger."
	
	"Display fill: (300@300 extent: 300@100) rule: Form paint fillColor: Color red.
	Display fill: (300@300 extent: 300@100) rule: Form paint fillColor: Color green clippingBox: (300@300 extent: 150@100)"
	
	| bb |
	bb _ BitBlt current toForm: self.
	bb clipRect: clipRect.
	bb
		copy: aRectangle
		from: 0@0 in: nil
		fillColor: aForm rule: anInteger! !

!Form methodsFor: 'image manipulation' stamp: 'ssa 12/17/2009 16:16'!
erase

	self eraseInside: self boundingBox! !

!Form methodsFor: 'image manipulation' stamp: 'ssa 12/17/2009 16:26'!
eraseInside: aRect
	"Erase a transparent rectangular 'hole' in me"
	
	"  | form|
	form _ Form extent:100@100 depth: Display depth.
	form fillColor: Color blue.
	form eraseInside: (20@20 extent:60@60).
	form followCursor"
	
	| eraser |
	eraser _ Form extent: self extent depth:1.
	eraser fill: aRect fillColor: Color black.
	self eraseShape: eraser! !

!Form methodsFor: 'image manipulation' stamp: 'ssa 4/10/2009 23:42'!
nextLifeGeneration
    "Compute next generation by computing neighbor counts.
    These are tallied in nbr1, nbr2, nbr4."
    | all delta nbr1 nbr2 nbr4 carry2 carry4 |
    all _ 0@0 extent: self extent.
nbr1 _ Form extent: self extent.
nbr2 _ Form extent: self extent.
nbr4 _ Form extent: self extent.
carry2 _ Form extent: self extent.
carry4 _ Form extent: self extent.

    nbr1 fillWhite.  nbr2 fillWhite.  nbr4 fillWhite.
    1 to: 8 do:                   "Three-bit add for each shift of self"
        [:i | delta _ (i+4\\9//3 - 1)@(i+4\\3 - 1).  "8 neighbor deltas"
        carry2 copy: all from: nbr1 to: 0@0 rule: Form over.
        carry2 copy: all from: self to: delta rule: Form and. "carry 2"
        nbr1 copy: all from: self to: delta rule: Form reverse.   "sum 1" "(reverse is xor)"
        carry4 copy: all from: nbr2 to: 0@0 rule: Form over.
        carry4 copy: all from: carry2 to: 0@0 rule: Form and.  "carry 4"
        nbr2 copy: all from: carry2 to: 0@0 rule: Form reverse.    "sum 2"
        nbr4 copy: all from: carry4 to: 0@0 rule: Form reverse].    "sum 4"
    "Next gen = ((2s AND self) OR (2s AND 1s)) AND (NOT 4s)"
    self copy: all from: nbr2 to: 0@0 rule: Form and.
    nbr1 copy: all from: nbr2 to: 0@0 rule: Form and.
    self copy: all from: nbr1 to: 0@0 rule: Form under.
    self copy: all from: nbr4 to: 0@0 rule: Form erase.
    self borderWidth: 1 fillColor: Color white.  "trim edges"! !

!Form methodsFor: 'image manipulation' stamp: 'ssa 4/10/2009 23:39'!
nextLifeGenerationBlueBook
	"|f| f_Form fromUser.
	100 timesRepeat:[f nextLifeGeneration display]"
	| nbr1 nbr2 nbr4 carry2 carry4 all delta |
	nbr1 := Form extent: self extent.
	nbr2 := Form extent: self extent.
	nbr4 := Form extent: self extent.
	carry2 := Form extent: self extent.
	carry4 := Form extent: self extent.
	all := self boundingBox.
	1 to: 8
		do: [:i | 
			"delta is the offset of the eight neighboring cells"
			delta := (#(-1 0 1 1 1 0 1 -1 ) at: i)
						@ (#(1 -1 -1 0 1 1 1 0 ) at: i).
			carry2
				copy: all
				from: 0 @ 0
				in: nbr1
				rule: 3.
			carry2
				copy: all
				from: delta
				in: self
				rule: 1.
			"AND for carry into 2"
			nbr1
				copy: all
				from: delta
				in: self
				rule: 6.
			"XOR for sum 1"
			carry4
				copy: all
				from: 0 @ 0
				in: nbr2
				rule: 3.
			carry4
				copy: all
				from: 0 @ 0
				in: carry2
				rule: 1.
			"AND for carry into 4"
			nbr2
				copy: all
				from: 0 @ 0
				in: carry2
				rule: 6.
			"XOR for sum 2"
			nbr4
				copy: all
				from: 0 @ 0
				in: carry4
				rule: 6].
	"XOR for sum 4 (ignore carry into 8)"
	self
		copy: all
		from: 0 @ 0
		in: nbr2
		rule: 1.
	nbr1
		copy: all
		from: 0 @ 0
		in: nbr2
		rule: 1.
	self
		copy: all
		from: 0 @ 0
		in: nbr1
		rule: 7.
	self
		copy: all
		from: 0 @ 0
		in: nbr4
		rule: 4
	"compute next generation"! !

!Form methodsFor: 'scaling, rotation' stamp: 'ssa 8/31/2009 13:43'!
rotateBy: deg smoothing: cellSize
	"Rotate the receiver by the indicated number of degrees."
	"rot is the destination form, big enough for any angle."
	| side rot warp r1 pts p center dim |
	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.
	(#(0 90 180 270 360) includes: deg abs) ifTrue:[dim _ self extent]ifFalse:[dim _ side@side].
	rot _ Form extent: dim depth: self depth.
	center _ rot extent // 2.

	"Now compute the sin and cos constants for the rotation angle." 
	warp _ (WarpBlt current toForm: rot)
		sourceForm: self;
		colorMap: (self colormapIfNeededFor: rot);
		cellSize: cellSize;  "installs a new colormap if cellSize > 1"
		combinationRule: Form over.
	r1 _ rot boundingBox align: center with: self boundingBox center.

	pts _ r1 innerCorners collect:
		[:pt | p _ pt - r1 center.
		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @
		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].
	warp copyQuad: pts toRect: rot boundingBox.
	^ rot
"
 | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.
[Sensor anyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))
		rotateBy: (a _ a+5) smoothing: 2) display].
f display
"! !

!Form methodsFor: 'scaling, rotation' stamp: 'ssa 11/30/2009 12:57'!
scaledToSize: newExtent

	| scale |

	newExtent = self extent ifTrue: [^self].
	scale _ (newExtent x / self width) @ (newExtent y / self height).
	^self magnify: self boundingBox by: scale smoothing: 2.
! !

!Form methodsFor: '*RVM-Archiving'!
archiveOn: anArchiver
	"Always use #storeOn: and #readFrom:"
	
"	anArchiver isCopier
		ifFalse: [^super archiveOn: anArchiver]."
	anArchiver
		storeObject: self;
		storeClass: self class;
		store: self.! !

!Form class methodsFor: 'instance creation' stamp: 'ssa 11/17/2008 13:50'!
dotOfSize: diameter color: aColor
	"Create a form which contains a round colored dot with transparent background."
	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |
	radius _ diameter//2.
	form _ self extent: diameter@diameter depth: Display depth.
	form offset: (0@0) - (radius@radius).	
	bb _ (BitBlt current toForm: form)
		sourceX: 0; sourceY: 0;
		combinationRule: Form over;
		fillColor: aColor.
	rect _ form boundingBox.
	centerX _ rect center x.
	centerY _ rect center y.
	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].
	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].
	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.
	xOverY _ rect width asFloat / rect height asFloat.
	maxy _ rect height - 1 // 2.

	"First do the inner fill, and collect x values"
	0 to: maxy do:
		[:dy |
		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.
		bb	destX: centerX - centerXBias - dx
			destY: centerY - centerYBias - dy
			width: dx + dx + centerXBias + 1
			height: 1;
			copyBits.
		bb	destY: centerY + dy;
			copyBits].
	form mapColor: Color white to: Color transparent.
	^ form
"
Time millisecondsToRun:
	[1 to: 30 do: [:i | (Form dotOfSize: i color: Color random) displayAt: (i*30)@(i*30)]]
"! !

!Form class methodsFor: 'instance creation' stamp: 'ssa 8/28/2009 19:30'!
fromBinaryStream: aBinaryStream
	"Read a Form or ColorForm from given file, using the first byte of the file to guess its format. Currently handles: GIF, uncompressed BMP, and both old and new DisplayObject writeOn: formats, JPEG, and PCX. Return nil if the file could not be read or was of an unrecognized format."

	| firstByte |
	aBinaryStream binary.
	firstByte _ aBinaryStream next.
	firstByte = 1 ifTrue: [
		"old Squeakform format"
		^ self new readFromOldFormat: aBinaryStream].
	firstByte = 2 ifTrue: [
		"new Squeak form format"
		^ self new readFrom: aBinaryStream].

	"Try for JPG, GIF, or PCX..."
	"Note: The following call closes the stream."
	^ ImageReadWriter formFromStream: aBinaryStream 
! !

!Form class methodsFor: '*RVM-Archiving'!
archiveVersion
	"universal 2.3, 2.4 format."

	^3! !

!Form class methodsFor: '*RVM-Archiving'!
dearchive2From: anArchiver
	"If the archiver is a copier, just get a deepCopy directly from it."
	
	| anObject |
	anArchiver isCopier
		ifFalse: [^super dearchiveFrom: anArchiver].
	anObject _ (anArchiver read: self) deepCopy.
	anArchiver storeObject: anObject.
	^anObject! !

!Form class methodsFor: '*RVM-Archiving'!
dearchive: versionNumber from: aStream
	"Override this method when implementing new archive versions for a class."

	^versionNumber == self archiveVersion
		ifTrue: [self dearchiveFrom: aStream]
		ifFalse: 
			[versionNumber == 2
				ifTrue: [self dearchive2From: aStream]
				ifFalse: [self error: 'Can''t dearchive this version.']]! !

!Form class methodsFor: '*RVM-Archiving'!
dearchiveFrom: anArchiver
	"Always use store: and read:."
	
	| anObject |
	anObject _ anArchiver read: self.
	anArchiver isCopier
		ifTrue: [anObject _ anObject deepCopy].
	anArchiver storeObject: anObject.
	^anObject! !

!FormView methodsFor: 'controller access' stamp: 'ssa 10/8/2008 13:14'!
defaultControllerClass  ^ NoController! !

!FormView methodsFor: 'displaying' stamp: 'ssa 11/26/2009 22:52'!
displayView 
	"Refer to the comment in View|displayView."

	| oldOffset |
	super displayView.
	insideColor == nil ifFalse: [Display fill: self insetDisplayBox fillColor: insideColor].
	oldOffset _ model offset.
	model offset: "borderWidth origin" 0@0.
	model
		displayOn: Display
		at: self insetDisplayBox origin
		clippingBox: self insetDisplayBox
		rule: Form paint
		fillColor: nil.
	model offset: oldOffset! !

!FormView methodsFor: 'private' stamp: 'ssa 11/26/2009 22:42'!
defaultRule 
	"The default display rule is 3=over or storing."

	^Form paint! !

!FormView class methodsFor: 'examples' stamp: 'ssa 11/26/2009 22:47'!
open: aForm named: aString
	"FormView open: ((ColorForm fromUser) borderWidth: 1) named: 'Squeak' "
	"Open a window whose model is aForm and whose label is aString."
	| topView aView |
	topView _ StandardSystemView new.
	topView model: aForm.
	topView label: aString.
	topView minimumSize: aForm extent+2";
	          maximumSize: aForm extent + 2".
	aView _ FormView new.
	aView model: aForm.
	"aView window: (aForm boundingBox expandBy: 2)."
	aView borderWidthLeft: 1 right: 1 top: 2 bottom: 1.
	topView addSubView: aView.
	topView controller open! !

!GIFReadWriter methodsFor: 'accessing' stamp: 'bf 5/29/2003 01:43'!
delay: aNumberOrNil
	"Set delay for next image in hundredth (1/100) of seconds"
	delay := aNumberOrNil! !

!GIFReadWriter methodsFor: 'accessing' stamp: 'bf 5/29/2003 01:39'!
loopCount: aNumber
	"Set looping. This must be done before any image is written!!"
	loopCount := aNumber! !

!GIFReadWriter methodsFor: 'accessing' stamp: 'sd 1/30/2004 15:18'!
nextImage
	"Read in the next GIF image from the stream. Read it all into
memory first for speed."

	| f thisImageColorTable |
	stream class == ReadWriteStream ifFalse: [
		stream binary.
		self on: (ReadWriteStream with: (stream contentsOfEntireFile))].

	localColorTable _ nil.
	self readHeader.
	f _ self readBody.
	self close.
	f == nil ifTrue: [^ self error: 'corrupt GIF file'].

	thisImageColorTable _ localColorTable ifNil: [colorPalette].
	transparentIndex ifNotNil: [
		transparentIndex + 1 > thisImageColorTable size ifTrue: [
			thisImageColorTable _ thisImageColorTable 
				forceTo: transparentIndex + 1 
				paddingWith: Color white
		].
		thisImageColorTable at: transparentIndex + 1 put: Color transparent
	].
	f colors: thisImageColorTable.
	^ f
! !

!GIFReadWriter methodsFor: 'accessing' stamp: 'ar 10/24/2005 22:52'!
nextPutImage: aForm

	| reduced tempForm |
	aForm unhibernate.
	aForm depth > 8 ifTrue:[
		reduced := aForm colorReduced.  "minimize depth"
		reduced depth > 8 ifTrue: [
			"Not enough color space; do it the hard way."
			reduced := reduced asFormOfDepth: 8].
	] ifFalse:[reduced := aForm].
	reduced depth < 8 ifTrue: [
		"writeBitData: expects depth of 8"
		tempForm := reduced class extent: reduced extent depth: 8.
		(reduced isColorForm) ifTrue:[
			tempForm
				copyBits: reduced boundingBox
				from: reduced at: 0@0
				clippingBox: reduced boundingBox
				rule: Form over
				fillColor: nil
				map: nil.
			tempForm colors: reduced colors.
		] ifFalse: [reduced displayOn: tempForm].
		reduced := tempForm.
	].
	(reduced isColorForm) ifTrue:[
		(reduced colorsUsed includes: Color transparent) ifTrue: [
			transparentIndex := (reduced colors indexOf: Color transparent) - 1.
		]
	] ifFalse: [transparentIndex := nil].
	width := reduced width.
	height := reduced height.
	bitsPerPixel := reduced depth.
	colorPalette := reduced colormapIfNeededForDepth: 32.
	interlace := false.
	self writeHeader.
	self writeBitData: reduced bits.
! !

!GIFReadWriter methodsFor: 'accessing' stamp: '6/18/97 13:18 '!
setStream: aStream
	"Feed it in from an existing source"
	stream _ aStream! !

!GIFReadWriter methodsFor: 'accessing' stamp: 'di 9/15/1998 09:53'!
understandsImageFormat
	^('abc' collect: [:x | stream next asCharacter]) = 'GIF'! !

!GIFReadWriter methodsFor: 'private-encoding'!
flushCode
	self flushBits! !

!GIFReadWriter methodsFor: 'private-encoding' stamp: 'tk 9/14/97 16:25'!
readPixelFrom: bits
	"Since bits is a Bitmap with 32 bit values, watch out for the
padding at the end of each row.  But, GIF format already wants padding to
32 bit boundary!!  OK as is.  tk 9/14/97"

	| pixel |
	ypos >= height ifTrue: [^nil].
	pixel _ bits byteAt: (ypos * rowByteSize + xpos + 1).
	self updatePixelPosition.
	^pixel! !

!GIFReadWriter methodsFor: 'private-encoding' stamp: 'bf 5/29/2003 01:21'!
writeBitData: bits
	"using modified Lempel-Ziv Welch algorithm."

	| maxBits maxMaxCode tSize initCodeSize ent tShift fCode pixel index disp nomatch |
	pass _ 0.
	xpos _ 0.
	ypos _ 0.
	rowByteSize _ width * 8 + 31 // 32 * 4.
	remainBitCount _ 0.
	bufByte _ 0.
	bufStream _ WriteStream on: (ByteArray new: 256).

	maxBits _ 12.
	maxMaxCode _ 1 bitShift: maxBits.
	tSize _ 5003.
	prefixTable _ Array new: tSize.
	suffixTable _ Array new: tSize.

	initCodeSize _ bitsPerPixel <= 1 ifTrue: [2] ifFalse: [bitsPerPixel].
	self nextPut: initCodeSize.
	self setParameters: initCodeSize.

	tShift _ 0.
	fCode _ tSize.
	[fCode < 65536] whileTrue:
		[tShift _ tShift + 1.
		fCode _ fCode * 2].
	tShift _ 8 - tShift.
	1 to: tSize do: [:i | suffixTable at: i put: -1].

	self writeCodeAndCheckCodeSize: clearCode.
	ent _ self readPixelFrom: bits.
	[(pixel _ self readPixelFrom: bits) == nil] whileFalse:
		[
		fCode _ (pixel bitShift: maxBits) + ent.
		index _ ((pixel bitShift: tShift) bitXor: ent) + 1.
		(suffixTable at: index) = fCode
			ifTrue: [ent _ prefixTable at: index]
			ifFalse:
				[nomatch _ true.
				(suffixTable at: index) >= 0
					ifTrue:
						[disp _ tSize - index + 1.
						index = 1 ifTrue: [disp _ 1].
						"probe"
						[(index _ index - disp) < 1 ifTrue: [index _ index + tSize].
						(suffixTable at: index) = fCode
							ifTrue:
								[ent _ prefixTable at: index.
								nomatch _ false.
								"continue whileFalse:"].
						nomatch and: [(suffixTable at: index) > 0]]
							whileTrue: ["probe"]].
				"nomatch"
				nomatch ifTrue:
					[self writeCodeAndCheckCodeSize: ent.
					ent _ pixel.
					freeCode < maxMaxCode
						ifTrue:
							[prefixTable at: index put: freeCode.
							suffixTable at: index put: fCode.
							freeCode _ freeCode + 1]
						ifFalse:
							[self writeCodeAndCheckCodeSize: clearCode.
							1 to: tSize do: [:i | suffixTable at: i put: -1].
							self setParameters: initCodeSize]]]].
	prefixTable _ suffixTable _ nil.
	self writeCodeAndCheckCodeSize: ent.
	self writeCodeAndCheckCodeSize: eoiCode.
	self flushCode.

	self nextPut: 0.	"zero-length packet"
! !

!GIFReadWriter methodsFor: 'private-encoding'!
writeCode: aCode
	self nextBitsPut: aCode! !

!GIFReadWriter methodsFor: 'private-encoding'!
writeCodeAndCheckCodeSize: aCode
	self writeCode: aCode.
	self checkCodeSize! !

!GIFReadWriter methodsFor: 'private-encoding' stamp: 'bf 5/29/2003 01:38'!
writeHeader

	| byte |
	stream position = 0 ifTrue: [
		"For first image only"
		self nextPutAll: 'GIF89a' asByteArray.
		self writeWord: width.	"Screen Width"
		self writeWord: height.	"Screen Height"
		byte _ 16r80.  "has color map"
		byte _ byte bitOr: ((bitsPerPixel - 1) bitShift: 5).  "color resolution"
		byte _ byte bitOr: bitsPerPixel - 1.  "bits per pixel"
		self nextPut: byte.
		self nextPut: 0.		"background color."
		self nextPut: 0.		"reserved"
		colorPalette do: [:pixelValue |
			self	nextPut: ((pixelValue bitShift: -16) bitAnd: 255);
				nextPut: ((pixelValue bitShift: -8) bitAnd: 255);
				nextPut: (pixelValue bitAnd: 255)].
		loopCount notNil ifTrue: [
			"Write a Netscape loop chunk"
			self nextPut: Extension.
			self nextPutAll: #(255 11 78 69 84 83 67 65 80 69 50 46 48 3 1) asByteArray.
			self writeWord: loopCount.
			self nextPut: 0]].

	delay notNil | transparentIndex notNil ifTrue: [
		self nextPut: Extension;
			nextPutAll: #(16rF9 4) asByteArray;
			nextPut: (transparentIndex isNil ifTrue: [0] ifFalse: [9]);
			writeWord: (delay isNil ifTrue: [0] ifFalse: [delay]);
			nextPut: (transparentIndex isNil ifTrue: [0] ifFalse: [transparentIndex]);
			nextPut: 0].

	self nextPut: ImageSeparator.
	self writeWord: 0.		"Image Left"
	self writeWord: 0.		"Image Top"
	self writeWord: width.	"Image Width"
	self writeWord: height.	"Image Height"
	byte _ interlace ifTrue: [16r40] ifFalse: [0].
	self nextPut: byte.
! !

!GIFReadWriter methodsFor: 'private-encoding'!
writeWord: aWord
	self nextPut: (aWord bitAnd: 255).
	self nextPut: ((aWord bitShift: -8) bitAnd: 255).
	^aWord! !

!GIFReadWriter methodsFor: 'private-decoding' stamp: 'mir 11/19/2003 12:19'!
readBitData
	"using modified Lempel-Ziv Welch algorithm."

	| outCodes outCount bitMask initCodeSize code curCode oldCode inCode finChar i bytes f c packedBits hasLocalColor localColorSize maxOutCodes |

	maxOutCodes _ 4096.
	offset := self readWord@self readWord. "Image Left@Image Top"
	width _ self readWord.
	height _ self readWord.

	"---
	Local Color Table Flag        1 Bit
	Interlace Flag                1 Bit
	Sort Flag                     1 Bit
	Reserved                      2 Bits
	Size of Local Color Table     3 Bits
	----"
	packedBits _ self next.
	interlace _ (packedBits bitAnd: 16r40) ~= 0.
	hasLocalColor _ (packedBits bitAnd: 16r80) ~= 0.
	localColorSize _ 1 bitShift: ((packedBits bitAnd: 16r7) + 1).
	hasLocalColor ifTrue: [localColorTable _ self readColorTable: localColorSize].

	pass _ 0.
	xpos _ 0.
	ypos _ 0.
	rowByteSize _ ((width + 3) // 4) * 4.
	remainBitCount _ 0.
	bufByte _ 0.
	bufStream _ ReadStream on: ByteArray new.

	outCodes _ ByteArray new: maxOutCodes + 1.
	outCount _ 0.
	bitMask _ (1 bitShift: bitsPerPixel) - 1.
	prefixTable _ Array new: 4096.
	suffixTable _ Array new: 4096.

	initCodeSize _ self next.

	self setParameters: initCodeSize.
	bitsPerPixel > 8 ifTrue: [^self error: 'never heard of a GIF that deep'].
	bytes _ ByteArray new: rowByteSize * height.
	[(code _ self readCode) = eoiCode] whileFalse:
		[code = clearCode
			ifTrue:
				[self setParameters: initCodeSize.
				curCode _ oldCode _ code _ self readCode.
				finChar _ curCode bitAnd: bitMask.
				"Horrible hack to avoid running off the end of the bitmap.  Seems to cure problem reading some gifs!!? tk 6/24/97 20:16"
				xpos = 0 ifTrue: [
						ypos < height ifTrue: [
							bytes at: (ypos * rowByteSize) + xpos + 1 put: finChar]]
					ifFalse: [bytes at: (ypos * rowByteSize) + xpos + 1 put: finChar].
				self updatePixelPosition]
			ifFalse:
				[curCode _ inCode _ code.
				curCode >= freeCode ifTrue:
					[curCode _ oldCode.
					outCodes at: (outCount _ outCount + 1) put: finChar].
				[curCode > bitMask] whileTrue:
					[outCount > maxOutCodes
						ifTrue: [^self error: 'corrupt GIF file (OutCount)'].
					outCodes at: (outCount _ outCount + 1)
						put: (suffixTable at: curCode + 1).
					curCode _ prefixTable at: curCode + 1].
				finChar _ curCode bitAnd: bitMask.
				outCodes at: (outCount _ outCount + 1) put: finChar.
				i _ outCount.
				[i > 0] whileTrue:
					["self writePixel: (outCodes at: i) to: bits"
					bytes at: (ypos * rowByteSize) + xpos + 1 put: (outCodes at: i).
					self updatePixelPosition.
					i _ i - 1].
				outCount _ 0.
				prefixTable at: freeCode + 1 put: oldCode.
				suffixTable at: freeCode + 1 put: finChar.
				oldCode _ inCode.
				freeCode _ freeCode + 1.
				self checkCodeSize]].
	prefixTable _ suffixTable _ nil.

	f _ ColorForm extent: width@height depth: 8.
	f bits copyFromByteArray: bytes.
	"Squeak can handle depths 1, 2, 4, and 8"
	bitsPerPixel > 4 ifTrue: [^ f].
	"reduce depth to save space"
	c _ ColorForm extent: width@height
		depth: (bitsPerPixel = 3 ifTrue: [4] ifFalse: [bitsPerPixel]).
	f displayOn: c.
	^ c
! !

!GIFReadWriter methodsFor: 'private-decoding' stamp: 'KLC 1/25/2004 14:04'!
readBody
	"Read the GIF blocks. Modified to return a form.  "

	| form extype block blocksize packedFields delay1 |
	form _ nil.
	[stream atEnd] whileFalse: [
		block _ self next.
		block = Terminator ifTrue: [^ form].
		block = ImageSeparator ifTrue: [
			form isNil
				ifTrue: [form _ self readBitData]
				ifFalse: [self skipBitData].
		] ifFalse: [
			block = Extension
				ifFalse: [^ form "^ self error: 'Unknown block type'"].
			"Extension block"
			extype _ self next.	"extension type"
			extype = 16rF9 ifTrue: [  "graphics control"
				self next = 4 ifFalse: [^ form "^ self error: 'corrupt GIF file'"].
				"====
				Reserved                      3 Bits
				Disposal Method               3 Bits
				User Input Flag               1 Bit
				Transparent Color Flag        1 Bit
				==="
 
				packedFields _ self next.
				delay1 := self next.	"delay time 1"
				delay := (self next*256 + delay1) *10.	 "delay time 2"
				transparentIndex _ self next.
				(packedFields bitAnd: 1) = 0 ifTrue: [transparentIndex _ nil].
				self next = 0 ifFalse: [^ form "^ self error: 'corrupt GIF file'"].
			] ifFalse: [
				"Skip blocks"
				[(blocksize _ self next) > 0]
					whileTrue: [
						"Read the block and ignore it and eat the block terminator"
						self next: blocksize]]]]! !

!GIFReadWriter methodsFor: 'private-decoding'!
readCode
	^self nextBits! !

!GIFReadWriter methodsFor: 'private-decoding' stamp: 'RAA 4/25/2001 08:48'!
readColorTable: numberOfEntries

	| array r g b |

	array _ Array new: numberOfEntries.
	1 to: array size do: [ :i |
		r _ self next.  
		g _ self next.  
		b _ self next.
		array at: i put: (Color r: r g: g b: b range: 255)
	].
	^array! !

!GIFReadWriter methodsFor: 'private-decoding' stamp: 'RAA 4/25/2001 08:49'!
readHeader
	| is89 byte hasColorMap |
	(self hasMagicNumber: 'GIF87a' asByteArray)
		ifTrue: [is89 _ false]
		ifFalse: [(self hasMagicNumber: 'GIF89a' asByteArray)
			ifTrue: [is89 _ true]
			ifFalse: [^ self error: 'This does not appear to be a GIF file']].
	self readWord.	"skip Screen Width"
	self readWord.	"skip Screen Height"
	byte _ self next.
	hasColorMap _ (byte bitAnd: 16r80) ~= 0.
	bitsPerPixel _ (byte bitAnd: 7) + 1.
	byte _ self next.	"skip background color."
	self next ~= 0
		ifTrue: [is89
			ifFalse: [^self error: 'corrupt GIF file (screen descriptor)']].
	hasColorMap
		ifTrue:
			[colorPalette _ self readColorTable: (1 bitShift: bitsPerPixel)]
		ifFalse:
			["Transcript cr; show: 'GIF file does not have a color map.'."
			colorPalette _ nil "Palette monochromeDefault"].! !

!GIFReadWriter methodsFor: 'private-decoding'!
readWord
	^self next + (self next bitShift: 8)! !

!GIFReadWriter methodsFor: 'private-decoding'!
skipBitData
	| misc blocksize |
	self readWord.  "skip Image Left"
	self readWord.  "skip Image Top"
	self readWord.  "width"
	self readWord.  "height"
	misc _ self next.
	(misc bitAnd: 16r80) = 0 ifFalse: [ "skip colormap"
		1 to: (1 bitShift: (misc bitAnd: 7) + 1) do: [:i |
			self next; next; next]].
	self next.  "minimum code size"
	[(blocksize _ self next) > 0]
		whileTrue: [self next: blocksize]! !

!GIFReadWriter methodsFor: 'private-bits access'!
flushBits
	remainBitCount = 0 ifFalse:
		[self nextBytePut: bufByte.
		remainBitCount _ 0].
	self flushBuffer! !

!GIFReadWriter methodsFor: 'private-bits access'!
nextBits
	| integer readBitCount shiftCount byte |
	integer _ 0.
	remainBitCount = 0
		ifTrue:
			[readBitCount _ 8.
			shiftCount _ 0]
		ifFalse:
			[readBitCount _ remainBitCount.
			shiftCount _ remainBitCount - 8].
	[readBitCount < codeSize]
		whileTrue:
			[byte _ self nextByte.
			byte == nil ifTrue: [^eoiCode].
			integer _ integer + (byte bitShift: shiftCount).
			shiftCount _ shiftCount + 8.
			readBitCount _ readBitCount + 8].
	(remainBitCount _ readBitCount - codeSize) = 0
		ifTrue:	[byte _ self nextByte]
		ifFalse:	[byte _ self peekByte].
	byte == nil ifTrue: [^eoiCode].
	^(integer + (byte bitShift: shiftCount)) bitAnd: maxCode! !

!GIFReadWriter methodsFor: 'private-bits access'!
nextBitsPut: anInteger
	| integer writeBitCount shiftCount |
	shiftCount _ 0.
	remainBitCount = 0
		ifTrue:
			[writeBitCount _ 8.
			integer _ anInteger]
		ifFalse:
			[writeBitCount _ remainBitCount.
			integer _ bufByte + (anInteger bitShift: 8 - remainBitCount)].
	[writeBitCount < codeSize]
		whileTrue:
			[self nextBytePut: ((integer bitShift: shiftCount) bitAnd: 255).
			shiftCount _ shiftCount - 8.
			writeBitCount _ writeBitCount + 8].
	(remainBitCount _ writeBitCount - codeSize) = 0
		ifTrue: [self nextBytePut: (integer bitShift: shiftCount)]
		ifFalse: [bufByte _ integer bitShift: shiftCount].
	^anInteger! !

!GIFReadWriter methodsFor: 'private-packing'!
fillBuffer
	| packSize |
	packSize _ self next.
	bufStream _ ReadStream on: (self next: packSize)! !

!GIFReadWriter methodsFor: 'private-packing'!
flushBuffer
	bufStream isEmpty ifTrue: [^self].
	self nextPut: bufStream size.
	self nextPutAll: bufStream contents.
	bufStream _ WriteStream on: (ByteArray new: 256)! !

!GIFReadWriter methodsFor: 'private-packing'!
nextByte
	bufStream atEnd
		ifTrue:
			[self atEnd ifTrue: [^nil].
			self fillBuffer].
	^bufStream next! !

!GIFReadWriter methodsFor: 'private-packing'!
nextBytePut: aByte
	bufStream nextPut: aByte.
	bufStream size >= 254 ifTrue: [self flushBuffer]! !

!GIFReadWriter methodsFor: 'private-packing'!
peekByte
	bufStream atEnd
		ifTrue:
			[self atEnd ifTrue: [^nil].
			self fillBuffer].
	^bufStream peek! !

!GIFReadWriter methodsFor: 'private'!
checkCodeSize
	(freeCode > maxCode and: [codeSize < 12])
		ifTrue:
			[codeSize _ codeSize + 1.
			maxCode _ (1 bitShift: codeSize) - 1]! !

!GIFReadWriter methodsFor: 'private'!
setParameters: initCodeSize
	clearCode _ 1 bitShift: initCodeSize.
	eoiCode _ clearCode + 1.
	freeCode _ clearCode + 2.
	codeSize _ initCodeSize + 1.
	maxCode _ (1 bitShift: codeSize) - 1! !

!GIFReadWriter methodsFor: 'private'!
updatePixelPosition
	(xpos _ xpos + 1) >= width ifFalse: [^self].
	xpos _ 0.
	interlace
		ifFalse: [ypos _ ypos + 1. ^self].
	pass = 0 ifTrue:
		[(ypos _ ypos + 8) >= height
			ifTrue:
				[pass _ pass + 1.
				ypos _ 4].
		^self].
	pass = 1 ifTrue:
		[(ypos _ ypos + 8) >= height
			ifTrue:
				[pass _ pass + 1.
				ypos _ 2].
		^self].
	pass = 2 ifTrue:
		[(ypos _ ypos + 4) >= height
			ifTrue:
				[pass _ pass + 1.
				ypos _ 1].
		^self].
	pass = 3 ifTrue:
		[ypos _ ypos + 2.
		^self].

	^self error: 'can''t happen'! !

!GIFReadWriter methodsFor: 'stream access' stamp: 'bf 5/29/2003 01:23'!
close
	"Write terminator"
	self nextPut: Terminator.
	^super close! !

!GIFReadWriter commentStamp: '<historical>' prior: 0!
Copyright (c) Kazuki Yasumatsu, 1995. All rights reserved.

Used with permission.  Modified for use in Squeak.!
!GIFReadWriter class methodsFor: 'class initialization'!
initialize
	"GIFReadWriter initialize"

	ImageSeparator _ $, asInteger.
	Extension _ $!! asInteger.
	Terminator _ $; asInteger.
! !

!GIFReadWriter class methodsFor: 'examples' stamp: 'bf 5/29/2003 01:56'!
exampleAnim
	"GIFReadWriter exampleAnim"

	| writer extent center |
	writer := GIFReadWriter on: (FileStream newFileNamed: 'anim.gif').
	writer loopCount: 20.		"Repeat 20 times"
	writer delay: 10.		"Wait 10/100 seconds"
	extent := 42@42.
	center := extent / 2.
	Cursor write showWhile: [
		[2 to: center x - 1 by: 2 do: [:r |
			"Make a fancy anim without using Canvas - inefficient as hell"
			| image |
			image := ColorForm extent: extent depth: 8.
			0.0 to: 359.0 do: [:theta | image colorAt: (center + (Point r: r degrees: theta)) rounded put: Color red].
			writer nextPutImage: image]
		]	ensure: [writer close]].! !

!GIFReadWriter class methodsFor: 'examples' stamp: 'nk 7/30/2004 21:40'!
grabScreenAndSaveOnDisk
	"GIFReaderWriter grabScreenAndSaveOnDisk"

	| form fileName |
	form := Form fromUser.
	form bits size = 0 ifTrue: [^Beeper beep].
	fileName := FileDirectory default nextNameFor: 'Squeak' extension: 'gif'.
	Utilities informUser: 'Writing ' , fileName
		during: [GIFReadWriter putForm: form onFileNamed: fileName]! !

!GIFReadWriter class methodsFor: 'image reading/writing' stamp: 'asm 12/11/2003 21:29'!
typicalFileExtensions
	"Answer a collection of file extensions (lowercase) which files that I can 
	read might commonly have"

	self
		allSubclasses detect: [:cls | cls wantsToHandleGIFs ]
					 ifNone: ["if none of my subclasses wants , then i''ll have to do"
							^ #('gif' )].
	^ #( )! !

!GIFReadWriter class methodsFor: 'image reading/writing' stamp: 'asm 12/11/2003 21:29'!
wantsToHandleGIFs
	^ false! !

!HashAndEqualsTestCase methodsFor: 'running' stamp: 'stephaneducasse 2/3/2006 22:39'!
setUp
	"subclasses will add their prototypes into this collection"
	prototypes := OrderedCollection new ! !

!HashAndEqualsTestCase methodsFor: 'testing' stamp: 'mjr 8/20/2003 18:56'!
testEquality
	"Check that TextFontChanges report equality correctly"
	prototypes
		do: [:p | self
				should: [(EqualityTester with: p) result]] ! !

!HashAndEqualsTestCase methodsFor: 'testing' stamp: 'al 6/12/2008 21:58'!
testHash
	"test that TextFontChanges hash correctly"
	prototypes do: [:p |
		self should: [(HashTester with: p) result]] ! !

!HashAndEqualsTestCase commentStamp: 'mjr 8/20/2003 17:37' prior: 0!
I am a simple TestCase that tests for correct operation of #hash and #=.

Subclasses of me need to fill my prototypes with suitable objects to be tested.!
!HashTester methodsFor: 'as yet unclassified'!
resultFor: runs 
	"Test that the hash is the same over runs and answer the result"
	| hash |
	hash := self prototype hash.
	1
		to: runs
		do: [:i | hash = self prototype hash
				ifFalse: [^ false]].
	^ true ! !

!HashTester commentStamp: 'mjr 8/20/2003 12:48' prior: 0!
I provide a simple way to test the hash properties of any object.  

I am given an object that should be tested and I treat it like a prototype.  I take a copy of it when I am given it so that it can't change whilst I am holding on to it.  I can then test that multiple copies of this object all hash to the same value.!
!HashTesterTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!
testBasicBehaviour
	self
		should: [(HashTester with: 1)
				resultFor: 100].
	self
		should: [(HashTester with: 'fred')
				resultFor: 100].
	self
		shouldnt: [(HashTester with: BadHasher new)
				resultFor: 100] ! !

!HashTesterTest commentStamp: 'mjr 8/20/2003 12:48' prior: 0!
I am a simple test case to check that HashTester works correctly!
!HeadlessSave class methodsFor: 'script entry' stamp: 'sm 2/13/2011 19:35'!
run: arguments 
	| proc |
	proc := [
		| basicName newName |
		RVMOperations print: 'Do wait, let system run non-busy, and then save and quit'.
		(Delay forSeconds: 10) wait.
		RVMOperations print: 'Do headless save now.'.
		basicName := SmalltalkImage current imageName withoutLast: '.image' size.
		newName := basicName, '-headless.image'.
		SmalltalkImage current saveAs: newName.
		SmalltalkImage current snapshot: false andQuit: true.
		] newProcess.
	
	proc priority: Processor userBackgroundPriority.
	proc resume.
! !

!HelloWorld commentStamp: 'StefanMarr 5/14/2011 16:42' prior: 0!
Simple example for how to use ScriptStarter.

HelloWorld prints all arguments given to #run:.!
!HelloWorld class methodsFor: 'script entry'!
run: arguments 
	ScriptConsole print: 'Hello World!!'.
	arguments
		do: [:elem | ScriptConsole print: elem].
	SmalltalkImage current snapshot: false andQuit: true! !

!HierarchyBrowser methodsFor: 'initialization' stamp: 'ssa 9/10/2009 13:34'!
setClass: aBehavior selector: aSymbol
	"Set the state of a new, uninitialized Browser."

	| isMeta aClass messageCatIndex |
	aBehavior ifNil: [^ self].
	(aBehavior isKindOf: Metaclass)
		ifTrue: [
			isMeta _ true.
			aClass _ aBehavior soleInstance]
		ifFalse: [
			isMeta _ false.
			aClass _ aBehavior].
	self selectCategoryForClass: aClass.
	self selectClass: aClass.
	self metaClassIndicated: isMeta.
	aSymbol ifNil: [^ self].
	messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.
	self messageCategoryListIndex: (messageCatIndex > 0
		ifTrue: [messageCatIndex + 1]
		ifFalse: [0]).
	messageCatIndex = 0 ifTrue: [^ self].
	self messageListIndex: (
		(aBehavior organization listAtCategoryNumber: messageCatIndex)
			indexOf: aSymbol).! !

!HierarchyBrowser class methodsFor: 'as yet unclassified' stamp: 'ssa 3/1/2010 13:54'!
newFor: aClass
	"Open a new HierarchyBrowser on the given class"
	self newFor: aClass labeled: nil

"HierarchyBrowser newFor: Boolean"! !

!HierarchyBrowser class methodsFor: 'as yet unclassified' stamp: 'ssa 3/1/2010 13:54'!
newFor: aClass labeled: aLabel
	"Open a new HierarchyBrowser on the given class, using aLabel as the window title."

	|  newBrowser |
	newBrowser _ self new initHierarchyForClass: aClass.
	Browser openBrowserView: (newBrowser openSystemCatEditString: nil)
		label: (aLabel isNil ifTrue:[newBrowser labelString]ifFalse:[aLabel])

"HierarchyBrowser newFor: Boolean labeled: 'Testing'"! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/10/2009 13:29'!
childrenOf: anObject

	^anObject subobjects! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:44'!
currentSelection
	"Answer the value of currentSelection"

	currentSelection isNil ifTrue:[self currentSelection: nil].
	^ currentSelection! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:44'!
currentSelection: anObject
	"Set the value of currentSelection"

	currentSelection _ anObject! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 3/1/2010 14:12'!
getClassList

	|  prev classes |
	classes _ OrderedCollection new.
	 centralClass allSuperclasses reverseDo:  [:aClass | classes add: aClass].
	classes add:  centralClass.
	 centralClass subclassesDo: [:aClass| classes add: aClass].
	prev _nil.
	^(classes collect:[:cls| prev _ ClassHierarchyExplorerWrapper with: cls name: cls name model: self parent: prev]) asArray! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 12:02'!
initializeList

	self list do:[:each| self levels at: each put:0]! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 12:01'!
levelOf: anItem

	^self levels at: anItem ifAbsent:[0]! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 12:01'!
levels
	"Answer the value of levels"

	levels isNil ifTrue:[self levels: Dictionary new].
	^ levels! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 12:00'!
levels: anObject
	"Set the value of levels"

	levels _ anObject! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/10/2009 13:39'!
list
	"Answer the value of list"

	list isNil ifTrue:[self list: (OrderedCollection with:self subject )].
	^ list! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/10/2009 13:36'!
list: anObject
	"Set the value of list"

	list _ anObject asOrderedCollection! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:44'!
myBrowser
	"Answer the value of myBrowser"

	myBrowser isNil ifTrue:[self myBrowser: nil].
	^ myBrowser! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:44'!
myBrowser: anObject
	"Set the value of myBrowser"

	myBrowser _ anObject! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 11:42'!
openItems
	"Answer the value of openItems"

	openItems isNil ifTrue:[self openItems: Set new].
	^ openItems! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 11:42'!
openItems: anObject
	"Set the value of openItems"

	openItems _ anObject! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 13:28'!
progenyOf: anObject

	| all |
	all _ (self childrenOf: anObject)copy.
	all isEmpty ifTrue:[^all].
	all copy do:[:each| all addAll: (self progenyOf: each)].
	^all ! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 11:18'!
selection
	"Answer the value of selection"

	selection isNil ifTrue:[self selection: nil].
	^ selection! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/9/2009 17:15'!
selection: anObject
	"Set the value of selection"

	selection _ anObject .
	! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 7/7/2010 12:40'!
subject
	"Answer the value of subject"

	subject isNil ifTrue:[self subject: Object].
	^ subject! !

!HierarchyOutlineBrowser methodsFor: 'accessing' stamp: 'ssa 9/10/2009 08:25'!
subject: anObject
	"Set the value of subject"

	subject _ anObject! !

!HierarchyOutlineBrowser methodsFor: 'user interfacing' stamp: 'ssa 3/1/2010 14:23'!
openSystemCatEditString: aString
	"Create a pluggable version of all the views for a Browser, including views and controllers.  The top list view is of the currently selected system class category--a single item list."
	| systemCategoryListView classListView messageCategoryListView messageListView browserCodeView topView switchView y annotationPane underPane optionalButtonsView |


	topView _ (StandardSystemView new) model: self.
	topView borderWidth: 1.
		"label and minSize taken care of by caller"

	systemCategoryListView _ PluggableListView on: self
		list: #systemCategorySingleton
		selected: #indexIsOne 
		changeSelected: #indexIsOne:
		menu: #systemCatSingletonMenu:
		keystroke: #systemCatSingletonKey:from:.
	systemCategoryListView window: (0 @ 0 extent: 200 @ 12).
	topView addSubView: systemCategoryListView.

	classListView _ LyPluggableOutlineView on: self
		list: #getClassList
		selected: #currentSelection
		changeSelected: #currentSelection:
		menu: #classListMenu:shifted:
		keystroke: #classListKey:from:.
	classListView window: (0 @ 0 extent: 67 @ 62).
	topView addSubView: classListView below: systemCategoryListView.

	messageCategoryListView _ PluggableListView on: self
		list: #messageCategoryList
		selected: #messageCategoryListIndex
		changeSelected: #messageCategoryListIndex:
		menu: #messageCategoryMenu:.
	messageCategoryListView controller terminateDuringSelect: true.
	messageCategoryListView window: (0 @ 0 extent: 66 @ 70).
	topView addSubView: messageCategoryListView toRightOf: classListView.

	switchView _ self buildInstanceClassSwitchView.
	switchView 
		window: switchView window 
		viewport: (classListView viewport bottomLeft 
					corner: messageCategoryListView viewport bottomLeft).
	switchView borderWidth: 1.
	topView addSubView: switchView below: classListView.

	messageListView _ PluggableListView on: self
		list: #messageList
		selected: #messageListIndex
		changeSelected: #messageListIndex:
		menu: #messageListMenu:shifted:
		keystroke: #messageListKey:from:.
	messageListView menuTitleSelector: #messageListSelectorTitle.
	messageListView window: (0 @ 0 extent: 67 @ 70).
	topView addSubView: messageListView toRightOf: messageCategoryListView.

	 self wantsAnnotationPane
		ifTrue:
			[annotationPane _ PluggableTextView on: self
				text: #annotation accept: nil
				readSelection: nil menu: nil.
			annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).
			topView addSubView: annotationPane below: switchView.
			y _ 110 - 12 - self optionalAnnotationHeight.
			underPane _ annotationPane]
		ifFalse:
			[y _ 110 - 12.
			underPane _ switchView].

	self wantsOptionalButtons ifTrue:
		[optionalButtonsView _ self buildOptionalButtonsView.
		optionalButtonsView borderWidth: 1.
		topView addSubView: optionalButtonsView below: underPane.
		underPane _ optionalButtonsView.
		y _ y - self optionalButtonHeight].

	browserCodeView _ PluggableTextView on: self 
			text: #contents accept: #contents:notifying:
			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.
	browserCodeView window: (0@0 extent: 200@y).
	topView addSubView: browserCodeView below: underPane.
	aString ifNotNil: [browserCodeView editString: aString.
			browserCodeView hasUnacceptedEdits: true].
	topView setUpdatablePanesFrom: #(getClassList messageCategoryList messageList).
	^ topView! !

!HierarchyOutlineBrowser methodsFor: 'menu support' stamp: 'ssa 9/10/2009 14:42'!
inspectSelection

	self selection inspect! !

!HierarchyOutlineBrowser methodsFor: 'menu support' stamp: 'ssa 9/10/2009 14:47'!
menu: aMenu


	aMenu add: 'inspect' action: #inspectSelection.
	aMenu add: 'outline' action: #outlineSelection.
	^ aMenu! !

!HierarchyOutlineBrowser methodsFor: 'menu support' stamp: 'ssa 9/10/2009 14:43'!
outlineSelection

	self selection outline! !

!HierarchyOutlineBrowser methodsFor: 'menu support' stamp: 'RAA 4/7/1999 16:53'!
perform: selector orSendTo: otherTarget
	"Selector was just chosen from a menu by a user.  If can respond, then
perform it on myself. If not, send it to otherTarget, presumably the
editPane from which the menu was invoked."

	(self respondsTo: selector)
		ifTrue: [^ self perform: selector]
		ifFalse: [^ otherTarget perform: selector]! !

!HierarchyOutlineBrowser methodsFor: 'opening/closing' stamp: 'ssa 9/9/2009 13:02'!
hasChildren: anObject

	^(self childrenOf: anObject) notEmpty ! !

!HierarchyOutlineBrowser methodsFor: 'opening/closing' stamp: 'ssa 9/9/2009 14:07'!
hideChildrenOfSelection

	| kids |
	self openItems remove: self selection.
	kids _ self progenyOf: self selection.
	kids do:[:each| self levels removeKey: each ifAbsent:[].
		self openItems remove: each ifAbsent:[]].
	self list removeAll: kids ifAbsent:[]
! !

!HierarchyOutlineBrowser methodsFor: 'opening/closing' stamp: 'ssa 9/9/2009 11:42'!
isOpen: anItem

	^self openItems includes: anItem! !

!HierarchyOutlineBrowser methodsFor: 'opening/closing' stamp: 'ssa 9/9/2009 12:10'!
showChildrenOfSelection

	| kids nextLevel |
	self openItems add: self selection.
	nextLevel _ (self levelOf: self selection) + 1.
	kids _ self childrenOf: self selection.
	kids isEmpty ifTrue:[^self error:'should never try to show children of an childless object'].
	kids do:[:each| self levels at: each put: nextLevel].
	self list addAll: kids after: self selection! !

!HierarchyOutlineBrowser methodsFor: 'opening/closing' stamp: 'ssa 9/10/2009 07:30'!
toggleSelection

	self selection isNil ifTrue:[^self].
	(self isOpen: self selection)
		ifTrue:[self hideChildrenOfSelection]
		ifFalse:[self showChildrenOfSelection].
	self changed:#list! !

!HierarchyOutlineBrowser methodsFor: 'arrow keys' stamp: 'ssa 9/9/2009 14:47'!
arrowKey: aChar from: view
	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index.  Derived from a Martin Pammer submission, 02/98"

     | keyEvent oldSelection nextSelection max min howMany |

	(#(1 4 11 12 30 31) includes: (keyEvent _ aChar asciiValue)) ifFalse:
		[
			^ self].

     oldSelection := view getCurrentSelectionIndex.
     nextSelection := oldSelection.
     max := view maximumSelection.
     min := view minimumSelection.
     howMany := view numSelectionsInView.	"get this exactly??"

     keyEvent == 31 ifTrue:
		["down-arrow; move down one, wrapping to top if needed"
		nextSelection := oldSelection + 1.
		nextSelection > max ifTrue: [nextSelection _ 1]].

     keyEvent == 30 ifTrue:
		["up arrow; move up one, wrapping to bottom if needed"
		nextSelection := oldSelection - 1.
		nextSelection < 1 ifTrue: [nextSelection _ max]].

     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"
     keyEvent == 4  ifTrue: [nextSelection := max].   "end"
     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection - howMany)].  "page up"
     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany) min: max].  "page down"
     nextSelection = oldSelection  ifFalse:
		[self okToChange
			ifTrue:
				[view changeModelSelection: nextSelection.
				"view controller moveMarker"]]
			! !

!HierarchyOutlineBrowser methodsFor: 'as yet unclassified' stamp: 'RAA 6/21/1999 15:22'!
genericMenu: aMenu

	aMenu add: 'no menu yet' target: self selector: #yourself.
	^aMenu! !

!HierarchyOutlineBrowser methodsFor: 'as yet unclassified' stamp: 'RAA 4/7/1999 16:44'!
getCurrentSelection

	^currentSelection! !

!HierarchyOutlineBrowser methodsFor: 'as yet unclassified' stamp: 'RAA 4/7/1999 16:46'!
noteNewSelection: x

	currentSelection _ x.
	self changed: #getCurrentSelection.
	currentSelection ifNil: [^self].
	currentSelection sendSettingMessageTo: self.
! !

!HierarchyOutlineBrowser methodsFor: 'as yet unclassified' stamp: 'RAA 4/7/1999 16:47'!
update: aSymbol

	aSymbol == #hierarchicalList ifTrue: [
		^self changed: #getList
	].
	super update: aSymbol! !

!HierarchyOutlineBrowser commentStamp: '<historical>' prior: 0!
Contributed by Bob Arning as part of the ObjectExplorer package.
!
!ImageReadWriter methodsFor: 'accessing'!
nextImage
	"Dencoding an image on stream and answer the image."

	^self subclassResponsibility! !

!ImageReadWriter methodsFor: 'accessing'!
nextPutImage: anImage
	"Encoding anImage on stream."

	^self subclassResponsibility! !

!ImageReadWriter methodsFor: 'stream access'!
atEnd

	^stream atEnd! !

!ImageReadWriter methodsFor: 'stream access' stamp: 'sd 1/30/2004 15:18'!
close
	
	stream close! !

!ImageReadWriter methodsFor: 'stream access'!
contents

	^stream contents! !

!ImageReadWriter methodsFor: 'stream access'!
cr

	^stream nextPut: Character cr asInteger! !

!ImageReadWriter methodsFor: 'stream access'!
lf
	"PPM and PBM are used LF as CR."

	^stream nextPut: Character lf asInteger! !

!ImageReadWriter methodsFor: 'stream access'!
next

	^stream next! !

!ImageReadWriter methodsFor: 'stream access'!
next: size

	^stream next: size! !

!ImageReadWriter methodsFor: 'stream access'!
nextLong
	"Read a 32-bit quantity from the input stream."

	^(stream next bitShift: 24) + (stream next bitShift: 16) +
		(stream next bitShift: 8) + stream next! !

!ImageReadWriter methodsFor: 'stream access'!
nextLongPut: a32BitW
	"Write out a 32-bit integer as 32 bits."

	stream nextPut: ((a32BitW bitShift: -24) bitAnd: 16rFF).
	stream nextPut: ((a32BitW bitShift: -16) bitAnd: 16rFF).
	stream nextPut: ((a32BitW bitShift: -8) bitAnd: 16rFF).
	stream nextPut: (a32BitW bitAnd: 16rFF).
	^a32BitW! !

!ImageReadWriter methodsFor: 'stream access'!
nextPut: aByte

	^stream nextPut: aByte! !

!ImageReadWriter methodsFor: 'stream access'!
nextPutAll: aByteArray

	^stream nextPutAll: aByteArray! !

!ImageReadWriter methodsFor: 'stream access'!
nextWord
	"Read a 16-bit quantity from the input stream."

	^(stream next bitShift: 8) + stream next! !

!ImageReadWriter methodsFor: 'stream access'!
nextWordPut: a16BitW
	"Write out a 16-bit integer as 16 bits."

	stream nextPut: ((a16BitW bitShift: -8) bitAnd: 16rFF).
	stream nextPut: (a16BitW bitAnd: 16rFF).
	^a16BitW! !

!ImageReadWriter methodsFor: 'stream access' stamp: 'tao 10/23/97 18:00'!
peekFor: aValue

	^stream peekFor: aValue! !

!ImageReadWriter methodsFor: 'stream access'!
position

	^stream position! !

!ImageReadWriter methodsFor: 'stream access'!
position: anInteger

	^stream position: anInteger! !

!ImageReadWriter methodsFor: 'stream access'!
size

	^stream size! !

!ImageReadWriter methodsFor: 'stream access'!
skip: anInteger

	^stream skip: anInteger! !

!ImageReadWriter methodsFor: 'stream access'!
space

	^stream nextPut: Character space asInteger! !

!ImageReadWriter methodsFor: 'stream access'!
tab

	^stream nextPut: Character tab asInteger! !

!ImageReadWriter methodsFor: 'private'!
changePadOfBits: bits width: width height: height depth: depth from: oldPad
to: newPad
	"Change padding size of bits."

	| srcRowByteSize dstRowByteSize newBits srcRowBase rowEndOffset |
	(#(8 16 32) includes: oldPad)
		ifFalse: [^self error: 'Invalid pad: ', oldPad printString].
	(#(8 16 32) includes: newPad)
		ifFalse: [^self error: 'Invalid pad: ', newPad printString].
	srcRowByteSize _ width * depth + oldPad - 1 // oldPad * (oldPad / 8).
	srcRowByteSize * height = bits size
		ifFalse: [^self error: 'Incorrect bitmap array size.'].
	dstRowByteSize _ width * depth + newPad - 1 // newPad * (newPad / 8).
	newBits _ ByteArray new: dstRowByteSize * height.
	srcRowBase _ 1.
	rowEndOffset _ dstRowByteSize - 1.
	1 to: newBits size by: dstRowByteSize do:
		[:dstRowBase |
		newBits replaceFrom: dstRowBase
			to: dstRowBase + rowEndOffset
			with: bits
			startingAt: srcRowBase.
		srcRowBase _ srcRowBase + srcRowByteSize].
	^newBits! !

!ImageReadWriter methodsFor: 'private'!
hasMagicNumber: aByteArray
	| position |
	position _ stream position.
	((stream size - position) >= aByteArray size and:
	[(stream next: aByteArray size)  = aByteArray])
		ifTrue: [^true].
	stream position: position.
	^false! !

!ImageReadWriter methodsFor: 'private' stamp: 'sd 1/30/2004 15:18'!
on: aStream
	(stream _ aStream) reset.
	stream binary.
	"Note that 'reset' makes a file be text.  Must do this after."! !

!ImageReadWriter methodsFor: 'private'!
unpackBits: bits depthTo8From: depth with: width height: height pad: pad
	"Unpack bits of depth 1, 2, or 4 image to it of depth 8 image."

	| bitMask pixelInByte bitsWidth upBitsWidth stopWidth
	 trailingSize upBits bitIndex upBitIndex val |
	(#(1 2 4) includes: depth)
		ifFalse: [^self error: 'depth must be 1, 2, or 4'].
	(#(8 16 32) includes: pad)
		ifFalse: [^self error: 'pad must be 8, 16, or 32'].
	bitMask _ (1 bitShift: depth) - 1.
	pixelInByte _ 8 / depth.
	bitsWidth _ width * depth + pad - 1 // pad * (pad / 8).
	upBitsWidth _ width * 8 + pad - 1 // pad * (pad / 8).
	stopWidth _ width * depth + 7 // 8.
	trailingSize _ width - (stopWidth - 1 * pixelInByte).
	upBits _ ByteArray new: upBitsWidth * height.
	1 to: height do: [:i |
		bitIndex _ i - 1 * bitsWidth.
		upBitIndex _ i - 1 * upBitsWidth.
		1 to: stopWidth - 1 do: [:j |
			val _ bits at: (bitIndex _ bitIndex + 1).
			upBitIndex _ upBitIndex + pixelInByte.
			1 to: pixelInByte do: [:k |
				upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).
				val _ val bitShift: depth negated]].
		val _ (bits at: (bitIndex _ bitIndex + 1))
				bitShift: depth negated * (pixelInByte - trailingSize).
		upBitIndex _ upBitIndex + trailingSize.
		1 to: trailingSize do: [:k |
			upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).
			val _ val bitShift: depth negated]].
	^ upBits
! !

!ImageReadWriter methodsFor: 'testing' stamp: 'tao 10/27/97 09:26'!
understandsImageFormat
	"Test to see if the image stream format is understood by this decoder.
	This should be implemented in each subclass of ImageReadWriter so that
	a proper decoder can be selected without ImageReadWriter having to know
	about all possible image file types."

	^ false! !

!ImageReadWriter commentStamp: '<historical>' prior: 0!
Copyright (c) Kazuki Yasumatsu, 1995. All rights reserved.

I am an abstract class to provide for encoding and/or decoding an image on a stream.

Instance Variables:
	stream		<ReadStream | WriteStream>	stream for image storages

Class Variables:
	ImageNotStoredSignal		<Signal>	image not stored error signal
	MagicNumberErrorSignal		<Signal>	magic number error signal

Subclasses must implement the following messages:
	accessing
		nextImage
		nextPutImage:
	testing
		canUnderstand         (added tao 10/26/97)!
!ImageReadWriter class methodsFor: 'instance creation'!
on: aStream
	"Answer an instance of the receiver for encoding and/or decoding images on the given."

	^ self new on: aStream
! !

!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'nk 7/16/2003 17:59'!
allTypicalFileExtensions
	"Answer a collection of file extensions (lowercase) which files that my subclasses can read might commonly have"
	"ImageReadWriter allTypicalFileExtensions"
	| extensions |
	extensions _ Set new.
	self allSubclassesDo: [ :cls | extensions addAll: cls typicalFileExtensions ].
	^extensions! !

!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ls 9/15/1998 19:08'!
formFromFileNamed: fileName
	"Answer a ColorForm stored on the file with the given name."
	| stream |
	stream _ FileStream readOnlyFileNamed: fileName.
	^self formFromStream: stream! !

!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'tk 5/7/1998 17:35'!
formFromServerFile: fileName
	"Answer a ColorForm stored on the file with the given name.  Meant to be called from during the getting of updates from the server.  That assures that (Utilities serverUrls) returns the right group of servers."

	| form urls doc |
	urls _ Utilities serverUrls collect:
		[:url | url, fileName].  " fileName starts with: 'updates/'  "
	urls do: [:aURL |
		(fileName findTokens: '.') last asLowercase = 'gif' ifTrue: [
			form _ HTTPSocket httpGif: aURL.
			form = (ColorForm extent: 20@20 depth: 8) 
				ifTrue: [self inform: 'The file ',aURL,' is ill formed.'].
			^ form].
		(fileName findTokens: '.') last asLowercase = 'bmp' ifTrue: [
			doc _ HTTPSocket httpGet: aURL accept: 'image/bmp'.
			form _ Form fromBMPFile: doc.
			doc close.
			form ifNil: [self inform: 'The file ',aURL,' is ill formed.'. ^ Form new]
				ifNotNil: [^ form]].
		self inform: 'File ', fileName, 'does not end with .gif or .bmp'].
	self inform: 'That file not found on any server we know'.! !

!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'sd 1/30/2004 15:18'!
formFromStream: aBinaryStream
	"Answer a ColorForm stored on the given stream.  closes the stream"
	| reader readerClass form  |

	readerClass _ self withAllSubclasses
		detect: [:subclass | subclass understandsImageFormat: aBinaryStream]
		ifNone: [
			aBinaryStream close.
			^self error: 'image format not recognized'].
	reader _ readerClass new on: aBinaryStream reset.
	Cursor read showWhile: [
		form _ reader nextImage.
		reader close].
	^ form
! !

!ImageReadWriter class methodsFor: 'image reading/writing'!
putForm: aForm onFileNamed: fileName
	"Store the given form on a file of the given name."

	| writer |
	writer _ self on: (FileStream newFileNamed: fileName) binary.
	Cursor write showWhile: [writer nextPutImage: aForm].
	writer close.
! !

!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'tk
9/13/97 16:13'!
putForm: aForm onStream: aWriteStream
	"Store the given form on a file of the given name."

	| writer |
	writer _ self on: aWriteStream.
	Cursor write showWhile: [writer nextPutImage: aForm].
	writer close.
! !

!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'nk 7/16/2003 17:55'!
typicalFileExtensions
	"Answer a collection of file extensions (lowercase) which files that I can read might commonly have"
	^#()! !

!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ar 3/1/2006 22:59'!
understandsImageFormat: aStream 
	^[(self new on: aStream) understandsImageFormat] on: Error do:[:ex| ex return: false]! !

!InfiniteForm methodsFor: 'accessing' stamp: 'ssa 8/28/2009 11:40'!
depth
	^patternForm depth! !

!InfiniteForm methodsFor: 'as yet unclassified' stamp: 'ssa 8/28/2009 11:39'!
hasNonStandardPalette

	^patternForm hasNonStandardPalette! !

!InputSensor methodsFor: 'mouse' stamp: 'ssa 10/27/2008 20:37'!
waitClick
	"Wait for the user to press any mouse button and release it, then answer with the 
	current location of the cursor."

	| pt |
	pt _ self waitButton.
	self waitNoButton.
	^pt! !

!InputSensor methodsFor: 'user interrupts' stamp: 'sm 2/24/2011 16:44'!
installInterruptWatcher
	"Initialize the interrupt watcher process. Terminate the old process if any."
	"Sensor installInterruptWatcher"

	InterruptWatcherProcess ifNotNil: [InterruptWatcherProcess terminate].
	InterruptSemaphore _ Semaphore new.
	InterruptWatcherProcess _ [self userInterruptWatcher] forkAt: Processor lowIOPriority.
	InterruptWatcherProcess name: 'InterruptWatcher'.
	self primInterruptSemaphore: InterruptSemaphore.
! !

!Inspector methodsFor: 'accessing' stamp: 'ssa 8/26/2009 10:43'!
selectionIndex: anObject
	"Set the value of selectionIndex"

	selectionIndex _ anObject! !

!Inspector methodsFor: 'accessing' stamp: 'ssa 8/26/2009 10:43'!
selectionUpdateTime
	"Answer the value of selectionUpdateTime"

	selectionUpdateTime isNil ifTrue:[self selectionUpdateTime: nil].
	^ selectionUpdateTime! !

!Inspector methodsFor: 'accessing' stamp: 'ssa 8/26/2009 10:43'!
selectionUpdateTime: anObject
	"Set the value of selectionUpdateTime"

	selectionUpdateTime _ anObject! !

!Inspector methodsFor: 'accessing' stamp: 'ssa 8/26/2009 10:43'!
timeOfLastListUpdate: anObject
	"Set the value of timeOfLastListUpdate"

	timeOfLastListUpdate _ anObject! !

!Inspector methodsFor: 'selecting' stamp: 'tk 4/10/1998 17:57'!
selection
	"The receiver has a list of variables of its inspected object.
	One of these is selected. Answer the value of the selected variable."
	| basicIndex |
	selectionIndex = 0 ifTrue: [^ ''].
	selectionIndex = 1 ifTrue: [^ object].
	selectionIndex = 2 ifTrue: [^ object longPrintString].
	(selectionIndex - 2) <= object class instSize
		ifTrue: [^ object instVarAt: selectionIndex - 2].
	basicIndex _ selectionIndex - 2 - object class instSize.
	(object basicSize <= (self i1 + self i2)  or: [basicIndex <= self i1])
		ifTrue: [^ object basicAt: basicIndex]
		ifFalse: [^ object basicAt: object basicSize - (self i1 + self i2) + basicIndex]! !

!Inspector methodsFor: 'selecting' stamp: 'ads 1/24/2011 13:02'!
selectionPrintString
	| text nm |
	selectionUpdateTime _ [text _ [(RVMPrimitivesNeededForBootstrapping printPrefixFor: self selection),(self selection printString)]
		on: Error do: 
		[nm _ self selectionIndex < 3
					ifTrue: ['self']
					ifFalse: [self selectedSlotName].
		text _ ('<error in printString: evaluate "' , nm , ' printString" to debug>') asText.
		text
			addAttribute: TextColor red
			from: 1
			to: text size.
		text]] timeToRun.
	^ text! !

!Inspector methodsFor: 'menu commands' stamp: 'ssa 1/6/2010 20:21'!
exploreSelection
	"Open an explorer on the receiver's model's currently selected object."

	self selectionIndex = 0 ifTrue: [^ self changed: #flash].
	^ self selection explore! !

!Inspector methodsFor: 'menu commands' stamp: 'ssa 7/7/2010 13:04'!
fieldListMenu: aMenu
	"Arm the supplied menu with items for the field-list of the receiver"



	aMenu addList: #(
		('inspect (i)'						inspectSelection)
		('explore (e)'						exploreSelection)
		('locate'						locateSelection)).

	self addCollectionItemsTo: aMenu.

	aMenu addList: #(
		-
		('method refs to this inst var'		referencesToSelection)
		('methods storing into this inst var'	defsOfSelection)
		('objects pointing to this value'		objectReferencesToSelection)
		('chase pointers'					chasePointers)
		-
		('browse full (b)'					browseMethodFull)
		('browse class'						browseClass)
		('browse hierarchy'					classHierarchy)
		('browse protocol (p)'				browseFullProtocol)
		-
		('inst var refs...'					browseInstVarRefs)
		('inst var defs...'					browseInstVarDefs)
		('class var refs...'					classVarRefs)
		('class variables'					browseClassVariables)
		('class refs (N)'						browseClassRefs)
		-
		('copy name (c)'					copyName)		
		('basic inspect'						inspectBasic)).


	^ aMenu


"			-
			('alias for this value'			aliasForValue)
			('watcher for this slot'			watcherForSlot)"

! !

!Inspector methodsFor: 'menu commands' stamp: 'ssa 7/7/2010 13:04'!
inspectorKey: aChar from: view
	"Respond to a Command key issued while the cursor is over my field list"

	aChar == $i ifTrue: [^ self selection inspect].
	aChar == $e ifTrue: [^ self selection explore].
	aChar == $b ifTrue:	[^ self browseMethodFull].
	aChar == $h ifTrue:	[^ self classHierarchy].
	aChar == $c ifTrue: [^ self copyName].
	aChar == $p ifTrue: [^ self browseFullProtocol].
	aChar == $N ifTrue: [^ self browseClassRefs].
	"aChar == $t ifTrue: [^ self tearOffTile]."
	aChar == $v ifTrue: [^ self viewerForValue].

	^ self arrowKey: aChar from: view! !

!Inspector methodsFor: 'menu commands' stamp: 'ssa 11/16/2008 01:53'!
locateSelection
	"Open a locator on the receiver's model's currently selected object."

	self selectionIndex = 0 ifTrue: [^ self changed: #flash].
	^ self selection locate! !

!Inspector class methodsFor: 'instance creation' stamp: 'ssa 8/26/2009 11:23'!
newFrom: anInspector
	"Use anInspector's contents for that of a new instance of me"
	
	| in |
	in _ self new.
	in contents: anInspector contents.
	in myDependents: anInspector myDependents.
	in dependents do:[:each| (each respondsTo:#model:) ifTrue:[each model: in]].
	in selectionIndex: anInspector selectionIndex.
	in timeOfLastListUpdate: anInspector timeOfLastListUpdate.
	in selectionUpdateTime: anInspector selectionUpdateTime.
	in object: anInspector object.
	^in! !

!Inspector class methodsFor: 'instance creation' stamp: 'ssa 3/24/2010 14:43'!
openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass
	| topView inspector listView valueView evalView v |
	inspector _ self inspect: anObject.
	topView _ StandardSystemView new model: inspector.
	topView borderWidth: 1.

	listView _ PluggableListView on: inspector
		list: #fieldList
		selected: #selectionIndex
		changeSelected: #toggleIndex:
		menu: #fieldListMenu:
		keystroke: #inspectorKey:from:.
	(inspector isMemberOf: DictionaryInspector)
		ifTrue: [listView menu: #dictionaryMenu:].
	listView window: (0 @ 0 extent: 40 @ 40).
	topView addSubView: listView.

	valueView _ valueViewClass new.
		"PluggableTextView or PluggableFormView"
	(valueView respondsTo: #getText) ifTrue: [
		valueView on: inspector 
			text: #contents accept: #accept:
			readSelection: #contentsSelection menu: #codePaneMenu:shifted:].
	(valueViewClass inheritsFrom: FormView) ifTrue: [
		valueView model: inspector].
	 v_ "MSWScrollBarView on:" valueView.
	v window: (0 @ 0 extent: 75 @ 40).
	topView addSubView: v toRightOf: listView.
	
	withEval ifTrue:
		[evalView _ PluggableTextView new on: inspector 
			text: #trash accept: #trash:
			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.
		evalView window: (0 @ 0 extent: 115 @ 20).
		evalView askBeforeDiscardingEdits: false.
		topView addSubView: evalView below: listView].
	topView label: label.
	topView minimumSize: 180 @ 120.
	topView setUpdatablePanesFrom: #(fieldList).
	topView controller open! !

!InstructionStream methodsFor: 'scanning' stamp: 'ssa 5/11/2010 16:14'!
skipBackBeforeJump
	"Assuming that the receiver is positioned jast after a jump, skip back one or two bytes, depending on the size of the previous jump instruction."
	| strm short |
	strm _ InstructionStream on: self method.
	(strm scanFor: [:byte |
		((short _ byte between: 152 and: 159) or: [byte between: 168 and: 175])
			and: [strm pc = (short ifTrue: [pc-1] ifFalse: [pc-2])]]) ifFalse: [self error: 'Where''s the jump??'. self jump: 0].
	self jump: (short ifTrue: [-1] ifFalse: [-2]).
! !

!Integer methodsFor: 'truncation and round off' stamp: 'ssa 11/27/2009 16:44'!
atRandom
	"Answer a random integer from 1 to self.  This implementation uses a
	shared generator. Heavy users should their own implementation or use
	Interval>atRandom: directly."

	self = 0 ifTrue: [ ^0 ].
	self < 0 ifTrue: [ ^self negated atRandom negated ].
	^self atRandom: Collection randomForPicking ! !

!Integer methodsFor: 'printing' stamp: 'ar 7/18/2001 22:09'!
asStringWithCommasSigned
	"123456789 asStringWithCommasSigned"
	"-123456789 asStringWithCommasSigned"
	| digits |
	digits _ self abs printString.
	^ String streamContents:
		[:strm | 
		self sign = -1 ifTrue: [strm nextPut: $-] ifFalse:[strm nextPut: $+].
		1 to: digits size do: 
			[:i | strm nextPut: (digits at: i).
			(i < digits size and: [(i - digits size) \\ 3 = 0])
				ifTrue: [strm nextPut: $,]]]! !

!Integer methodsFor: 'printing' stamp: 'ssa 8/26/2009 12:23'!
printeth
	"1 printeth '1st'"
	"2 printeth '2nd'"
	"3 printeth '3rd'"
	"4 printeth '4th'"
	"5 printeth '5th'"
	"1234 printeth '1234th'"
	"121 printeth '121st'"
	| str suffix |
	str _ self printString.
	suffix _ (#('st' 'nd' 'rd' 'th')at: ((str last asNumber max:1) min:4)).
	^str,suffix! !

!Integer methodsFor: 'explorer' stamp: 'ssa 7/7/2010 21:07'!
hasContentsInExplorer

	^false! !

!Integer methodsFor: '*RVM-benchmarks' stamp: 'dmu 1/1/1970 00:40'!
tinyRVMBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results"
	"0 tinyBenchmarks"
	"On a 292 MHz G3 Mac: 22727272 bytecodes/sec; 984169 sends/sec"
	"On a 400 MHz PII/Win98:  18028169 bytecodes/sec; 1081272 sends/sec"
	| t1 t2 r n1 n2 s1 s2 totalYields |
	n1 _ 1.
	s1 _ RVMMulticoreSample capture.
	[t1 _ Time millisecondsToRun: [n1 benchmark].
	t1 < 1000] whileTrue:[n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[t2 _ Time millisecondsToRun: [r _ n2 benchFib].
	t2 < 1000] whileTrue:[n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."
     s2 _ RVMMulticoreSample capture.
     totalYields _ s2 totalYields.
	^ ((n1 * 500000 * 1000) // t1) printString, ' bytecodes/sec; ',
	  ((r * 1000) // t2) printString, ' sends/sec; ',
	   totalYields printString, ' total yields; ',
	   (t1 + t2) printString, ' total ms'! !

!Integer methodsFor: '*Ly-Explorer' stamp: 'laza 3/17/2005 13:37'!
explorerContents
	^{
		'hexadecimal' -> 16.
		'octal' -> 8.
		'binary' -> 2
	} collect: [:each |
		ObjectExplorerWrapper with: each key translated name: (self printStringBase: each value) model: self]! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:21'!
acTableIndex

	^acTableIndex! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:20'!
acTableIndex: anInteger

	acTableIndex _ anInteger! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:21'!
dcTableIndex

	^dcTableIndex! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:20'!
dcTableIndex: anInteger

	dcTableIndex _ anInteger! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!
heightInBlocks

	^heightInBlocks! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:10'!
heightInBlocks: anInteger

	heightInBlocks _ anInteger! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:09'!
id

	^id! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:09'!
id: anObject

	id _ anObject! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'ar 3/4/2001 01:19'!
mcuWidth: mw mcuHeight: mh dctSize: ds

	mcuWidth _ mw.
	mcuHeight _ mh.
	dctSize _ ds.
	hSampleFactor _ mcuWidth // widthInBlocks.
	vSampleFactor _ mcuHeight // heightInBlocks! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:15'!
priorDCValue: aNumber

	priorDCValue _ aNumber! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:43'!
qTableIndex
	^qTableIndex! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!
qTableIndex: anInteger

	qTableIndex _ anInteger! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:18'!
totalMcuBlocks

	^ heightInBlocks * widthInBlocks! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:16'!
updateDCValue: aNumber

	priorDCValue _ priorDCValue + aNumber.
	^priorDCValue! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!
widthInBlocks

	^widthInBlocks! !

!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:10'!
widthInBlocks: anInteger

	widthInBlocks _ anInteger! !

!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 12:24'!
initializeSampleStreamBlocks: aCollection

	mcuBlocks _ aCollection.
	self resetSampleStream! !

!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'ar 3/4/2001 22:16'!
nextSample

	| dx dy blockIndex sampleIndex sample |
	dx _ currentX // hSampleFactor.
	dy _ currentY // vSampleFactor.
	blockIndex _ dy // dctSize * widthInBlocks + (dx // dctSize) + 1.
	sampleIndex _ dy \\ dctSize * dctSize + (dx \\ dctSize) + 1.
	sample _ (mcuBlocks at: blockIndex) at: sampleIndex.
	currentX _ currentX + 1.
	currentX < (mcuWidth * dctSize)
		ifFalse:
			[currentX _ 0.
			currentY _ currentY + 1].
	^ sample! !

!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 12:24'!
resetSampleStream

	currentX _ 0.
	currentY _ 0! !

!JPEGColorComponent commentStamp: '<historical>' prior: 0!
I represent a single component of color in JPEG YCbCr color space.  I can accept a list of blocks in my component from the current MCU, then stream the samples from this block for use in color conversion.  I also store the running DC sample value for my component, used by the Huffman decoder.

The following layout is fixed for the JPEG primitives to work:
	currentX 		<SmallInteger>
	currentY 		<SmallInteger>
	hSampleFactor 	<SmallInteger>
	vSampleFactor 	<SmallInteger>
	mcuBlocks 		<Array of: <IntegerArray of: DCTSize2 * Integer>>
	widthInBlocks 	<SmallInteger>
	heightInBlocks 	<SmallInteger>
	dctSize 			<SmallInteger>
	mcuWidth 		<SmallInteger>
	mcuHeight 		<SmallInteger>
	priorDCValue 	<SmallInteger>
!
!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/20/97 14:27'!
bits: anObject

	bits _ anObject! !

!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:31'!
lookaheadBits
	^lookaheadBits! !

!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:38'!
lookaheadSymbol
	^lookaheadSymbol! !

!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:59'!
maxcode
	^maxcode! !

!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/20/97 14:27'!
values: anObject

	values _ anObject! !

!JPEGHuffmanTable methodsFor: 'computation' stamp: 'tao 10/24/97 12:28'!
makeDerivedTables

	| huffSize huffCode code si index lookbits |
	mincode _ Array new: 16.
	maxcode _ Array new: 17.
	valptr _ Array new: 17.
	huffSize _ OrderedCollection new.
	1 to: 16 do: [:l | 1 to: (bits at: l) do: [:i | huffSize add: l]].
	huffSize add: 0.
	code _ 0.
	huffCode _ Array new: huffSize size.
	si _ huffSize at: 1.
	index _ 1.
	[(huffSize at: index) ~= 0] whileTrue:
		[[(huffSize at: index) = si] whileTrue:
			[huffCode at: index put: code.
			index _ index + 1.
			code _ code + 1].
		code _ code << 1.
		si _ si + 1].

	index _ 1.
	1 to: 16 do:
		[:l |
		(bits at: l) ~= 0
			ifTrue:
				[valptr at: l put: index.
				mincode at: l put: (huffCode at: index).
				index _ index + (bits at: l).
				maxcode at: l put: (huffCode at: index-1)]
			ifFalse:
				[maxcode at: l put: -1]].
	maxcode at: 17 put: 16rFFFFF.

	lookaheadBits _ (Array new: 1 << Lookahead) atAllPut: 0.
	lookaheadSymbol _ Array new: 1 << Lookahead.
	index _ 1.
	1 to: Lookahead do:
		[:l |
		1 to: (bits at: l) do:
			[:i |
			lookbits _ (huffCode at: index) << (Lookahead - l) + 1.
			(1 << (Lookahead - l) to: 1 by: -1) do:
				[:ctr |
				lookaheadBits at: lookbits put: l.
				lookaheadSymbol at: lookbits put: (values at: index).
				lookbits _ lookbits + 1].
			index _ index + 1]]! !

!JPEGHuffmanTable methodsFor: 'computation' stamp: 'tao 10/21/97 22:44'!
valueForCode: code length: length

	^ values at: ((valptr at: length) + code - (mincode at: length))! !

!JPEGHuffmanTable commentStamp: '<historical>' prior: 0!
I represent the table of values used to decode Huffman entropy-encoded bitstreams.  From the JFIF file header entropy values, I build a derived table of codes and values for faster decoding.!
!JPEGHuffmanTable class methodsFor: 'constants' stamp: 'tao 10/21/97 22:15'!
lookahead

	^ Lookahead! !

!JPEGHuffmanTable class methodsFor: 'initialization' stamp: 'tao 10/21/97 11:06'!
initialize

	Lookahead _ 8.
	BitBufferSize _ 16! !

!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/4/2001 20:42'!
fillBuffer

	| byte |
	[bitsInBuffer <= 16]
		whileTrue:[
			byte _ self next.
			(byte = 16rFF and: [(self peekFor: 16r00) not])
					ifTrue:
						[self position: self position - 1.
						^0].
			bitBuffer _ (bitBuffer bitShift: 8) bitOr: byte.
			bitsInBuffer _ bitsInBuffer + 8].
	^ bitsInBuffer! !

!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/4/2001 18:43'!
getBits: requestedBits
	| value |
	requestedBits > bitsInBuffer ifTrue:[
		self fillBuffer.
		requestedBits > bitsInBuffer ifTrue:[
			self error: 'not enough bits available to decode']].
	value _ bitBuffer bitShift: (requestedBits - bitsInBuffer).
	bitBuffer _ bitBuffer bitAnd: (1 bitShift: (bitsInBuffer - requestedBits)) -1.
	bitsInBuffer _ bitsInBuffer - requestedBits.
	^ value! !

!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/6/2001 12:34'!
nextByte
	^self next asInteger! !

!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/6/2001 12:35'!
nextBytes: n
	^(self next: n) asByteArray! !

!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/4/2001 17:40'!
reset
	super reset.
	self resetBitBuffer! !

!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/4/2001 18:44'!
resetBitBuffer
	bitBuffer _ 0.
	bitsInBuffer _ 0.
! !

!JPEGReadStream methodsFor: 'huffman trees' stamp: 'ar 3/4/2001 21:06'!
buildLookupTable: values counts: counts
	| min max |
	min _ max _ nil.
	1 to: counts size do:[:i|
		(counts at: i) = 0 ifFalse:[
			min ifNil:[min _ i-1].
			max _ i]].
	^self
		createHuffmanTables: values 
		counts: {0},counts 
		from: min+1 
		to: max.! !

!JPEGReadStream methodsFor: 'huffman trees' stamp: 'ar 3/4/2001 18:46'!
createHuffmanTables: values counts: counts from: minBits to: maxBits
	"Create the actual tables"
	| table tableStart tableSize tableEnd 
	valueIndex tableStack numValues deltaBits maxEntries
	lastTable lastTableStart tableIndex lastTableIndex |

	table _ WordArray new: ((4 bitShift: minBits) max: 16).

	"Create the first entry - this is a dummy.
	It gives us information about how many bits to fetch initially."
	table at: 1 put: (minBits bitShift: 24) + 2. "First actual table starts at index 2"

	"Create the first table from scratch."
	tableStart _ 2. "See above"
	tableSize _ 1 bitShift: minBits.
	tableEnd _ tableStart + tableSize.
	"Store the terminal symbols"
	valueIndex _ (counts at: minBits+1).
	tableIndex _ 0.
	1 to: valueIndex do:[:i|
		table at: tableStart + tableIndex put: (values at: i).
		tableIndex _ tableIndex + 1].
	"Fill up remaining entries with invalid entries"
	tableStack _ OrderedCollection new: 10. "Should be more than enough"
	tableStack addLast: 
		(Array 
			with: minBits	"Number of bits (e.g., depth) for this table"
			with: tableStart	"Start of table"
			with: tableIndex "Next index in table"
			with: minBits	"Number of delta bits encoded in table"
			with: tableSize - valueIndex "Entries remaining in table").
	"Go to next value index"
	valueIndex _ valueIndex + 1.
	"Walk over remaining bit lengths and create new subtables"
	minBits+1 to: maxBits do:[:bits|
		numValues _ counts at: bits+1.
		[numValues > 0] whileTrue:["Create a new subtable"
			lastTable _ tableStack last.
			lastTableStart _ lastTable at: 2.
			lastTableIndex _ lastTable at: 3.
			deltaBits _ bits - (lastTable at: 1).
			"Make up a table of deltaBits size"
			tableSize _ 1 bitShift: deltaBits.
			tableStart _ tableEnd.
			tableEnd _ tableEnd + tableSize.
			[tableEnd > table size ]
				whileTrue:[table _ self growHuffmanTable: table].
			"Connect to last table"
			self assert:[(table at: lastTableStart + lastTableIndex) = 0]."Entry must be unused"
			table at: lastTableStart + lastTableIndex put: (deltaBits bitShift: 24) + tableStart.
			lastTable at: 3 put: lastTableIndex+1.
			lastTable at: 5 put: (lastTable at: 5) - 1.
			self assert:[(lastTable at: 5) >= 0]. "Don't exceed tableSize"
			"Store terminal values"
			maxEntries _ numValues min: tableSize.
			tableIndex _ 0.
			1 to: maxEntries do:[:i|
				table at: tableStart + tableIndex put: (values at: valueIndex).
				valueIndex _ valueIndex + 1.
				numValues _ numValues - 1.
				tableIndex _ tableIndex+1].
			"Check if we have filled up the current table completely"
			maxEntries = tableSize ifTrue:[
				"Table has been filled. Back up to the last table with space left."
				[tableStack isEmpty not and:[(tableStack last at: 5) = 0]]
						whileTrue:[tableStack removeLast].
			] ifFalse:[
				"Table not yet filled. Put it back on the stack."
				tableStack addLast:
					(Array
						with: bits		"Nr. of bits in this table"
						with: tableStart	"Start of table"
						with: tableIndex "Index in table"
						with: deltaBits	"delta bits of table"
						with: tableSize - maxEntries "Unused entries in table").
			].
		].
	].
	 ^table copyFrom: 1 to: tableEnd-1! !

!JPEGReadStream methodsFor: 'huffman trees' stamp: 'ar 3/4/2001 18:44'!
decodeValueFrom: table
	"Decode the next value in the receiver using the given huffman table."
	| bits bitsNeeded tableIndex value |
	bitsNeeded _ (table at: 1) bitShift: -24.	"Initial bits needed"
	tableIndex _ 2.							"First real table"
	[bits _ self getBits: bitsNeeded.			"Get bits"
	value _ table at: (tableIndex + bits).		"Lookup entry in table"
	(value bitAnd: 16r3F000000) = 0] 			"Check if it is a non-leaf node"
		whileFalse:["Fetch sub table"
			tableIndex _ value bitAnd: 16rFFFF.	"Table offset in low 16 bit"
			bitsNeeded _ (value bitShift: -24) bitAnd: 255. "Additional bits in high 8 bit"
			bitsNeeded > MaxBits ifTrue:[^self error:'Invalid huffman table entry']].
	^value! !

!JPEGReadStream methodsFor: 'huffman trees' stamp: 'ar 3/4/2001 18:21'!
growHuffmanTable: table
	| newTable |
	newTable _ table species new: table size * 2.
	newTable replaceFrom: 1 to: table size with: table startingAt: 1.
	^newTable! !

!JPEGReadStream commentStamp: '<historical>' prior: 0!
Encapsulates huffman encoded access to JPEG data.

The following layout is fixed for the JPEG primitives to work:

	collection	<ByteArray | String>
	position		<SmallInteger>
	readLimit	<SmallInteger>
	bitBuffer	<SmallInteger>
	bitsInBuffer	<SmallInteger>!
!JPEGReadStream class methodsFor: 'class initialization' stamp: 'ar 3/4/2001 18:32'!
initialize
	"JPEGReadStream initialize"
	MaxBits _ 16.! !

!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 13:46'!
hACTable

	hACTable ifNil: [hACTable _ Array new: HuffmanTableSize].
	^ hACTable! !

!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 13:46'!
hDCTable

	hDCTable ifNil: [hDCTable _ Array new: HuffmanTableSize].
	^ hDCTable! !

!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 08:46'!
qTable

	qTable ifNil: [qTable _ Array new: QuantizationTableSize].
	^ qTable! !

!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:18'!
colorConvertFloatYCbCrMCU

	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |
	ySampleStream _ currentComponents at: 1.
	cbSampleStream _ currentComponents at: 2.
	crSampleStream _ currentComponents at: 3.
	ySampleStream resetSampleStream.
	cbSampleStream resetSampleStream.
	crSampleStream resetSampleStream.
	bits _ mcuImageBuffer bits.
	1 to: bits size do:
		[:i |
		y _ ySampleStream nextSample.
		cb _ cbSampleStream nextSample - FloatSampleOffset.
		cr _ crSampleStream nextSample - FloatSampleOffset.
		red _ self sampleFloatRangeLimit: (y + (1.40200 * cr)).
		green _ self sampleFloatRangeLimit: (y - (0.34414 * cb) - (0.71414 * cr)).
		blue _ self sampleFloatRangeLimit: (y + (1.77200 * cb)).
		bits at: i put: 16rFF000000 + (red << 16) + (green << 8) + blue].
	! !

!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:17'!
colorConvertGrayscaleMCU

	| ySampleStream y bits |
	ySampleStream _ currentComponents at: 1.
	ySampleStream resetSampleStream.
	bits _ mcuImageBuffer bits.
	1 to: bits size do:
		[:i |
		y _ (ySampleStream nextSample) + (residuals at: 2).
		y > MaxSample ifTrue: [y _ MaxSample].
		residuals at: 2 put: (y bitAnd: ditherMask).
		y _ y bitAnd: MaxSample - ditherMask.
		y < 1 ifTrue: [y _ 1].
		bits at: i put: 16rFF000000 + (y<<16) + (y<<8) + y].
	! !

!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:18'!
colorConvertIntYCbCrMCU

	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |
	ySampleStream _ currentComponents at: 1.
	cbSampleStream _ currentComponents at: 2.
	crSampleStream _ currentComponents at: 3.
	ySampleStream resetSampleStream.
	cbSampleStream resetSampleStream.
	crSampleStream resetSampleStream.
	bits _ mcuImageBuffer bits.
	1 to: bits size do:
		[:i |
		y _ ySampleStream nextSample.
		cb _ cbSampleStream nextSample - SampleOffset.
		cr _ crSampleStream nextSample - SampleOffset.
		red _ y + ((FIXn1n40200 * cr) // 65536) + (residuals at: 1).
		red > MaxSample
			ifTrue: [red _ MaxSample]
			ifFalse: [red < 0 ifTrue: [red _ 0]].
		residuals at: 1 put: (red bitAnd: ditherMask).
		red _ red bitAnd: MaxSample - ditherMask.
		red < 1 ifTrue: [red _ 1].
		green _ y - ((FIXn0n34414 * cb) // 65536) -
			((FIXn0n71414 * cr) // 65536) + (residuals at: 2).
		green > MaxSample
			ifTrue: [green _ MaxSample]
			ifFalse: [green < 0 ifTrue: [green _ 0]].
		residuals at: 2 put: (green bitAnd: ditherMask).
		green _ green bitAnd: MaxSample - ditherMask.
		green < 1 ifTrue: [green _ 1].
		blue _ y + ((FIXn1n77200 * cb) // 65536) + (residuals at: 3).
		blue > MaxSample
			ifTrue: [blue _ MaxSample]
			ifFalse: [blue < 0 ifTrue: [blue _ 0]].
		residuals at: 3 put: (blue bitAnd: ditherMask).
		blue _ blue bitAnd: MaxSample - ditherMask.
		blue < 1 ifTrue: [blue _ 1].
		bits at: i put: 16rFF000000 + (red bitShift: 16) + (green bitShift: 8) + blue].
	! !

!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/7/2001 01:02'!
colorConvertMCU

	^ currentComponents size = 3
		ifTrue:
			[self useFloatingPoint
				ifTrue: [self colorConvertFloatYCbCrMCU]
				ifFalse: [self primColorConvertYCbCrMCU: currentComponents
								bits: mcuImageBuffer bits
								residuals: residuals
								ditherMask: ditherMask.]]
		ifFalse: [self primColorConvertGrayscaleMCU]! !

!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:19'!
primColorConvertGrayscaleMCU
	self primColorConvertGrayscaleMCU: (currentComponents at: 1)
			bits: mcuImageBuffer bits
			residuals: residuals
			ditherMask: ditherMask.! !

!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/15/2001 18:11'!
primColorConvertGrayscaleMCU: componentArray bits: bits residuals: residualArray ditherMask: mask
	<primitive: 'primitiveColorConvertGrayscaleMCU' module: 'JPEGReaderPlugin'>
	"JPEGReaderPlugin doPrimitive: #primitiveColorConvertGrayscaleMCU."
	^self colorConvertGrayscaleMCU! !

!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 21:36'!
primColorConvertIntYCbCrMCU
	self primColorConvertYCbCrMCU: currentComponents
			bits: mcuImageBuffer bits
			residuals: residuals
			ditherMask: ditherMask.! !

!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 21:36'!
primColorConvertYCbCrMCU: componentArray bits: bits residuals: residualArray ditherMask: mask
	<primitive: 'primitiveColorConvertMCU' module: 'JPEGReaderPlugin'>
	^self colorConvertIntYCbCrMCU! !

!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 15:43'!
sampleFloatRangeLimit: aNumber

	^ (aNumber rounded max: 0) min: MaxSample! !

!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'di 9/15/1998 14:30'!
sampleRangeLimit: aNumber

	aNumber < 0 ifTrue: [^ 0].
	aNumber > MaxSample ifTrue: [^ MaxSample].
	^ aNumber! !

!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 15:16'!
dctFloatRangeLimit: value

	^ (value / 8.0) + FloatSampleOffset.! !

!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 16:34'!
idctBlockFloat: anArray component: aColorComponent

	| t0 t1 t2 t3 t4 t5 t6 t7 t10 t11 t12 t13 z5 z10 z11 z12 z13 qt ws |
	qt _ self qTable at: (aColorComponent qTableIndex).
	ws _ Array new: DCTSize2.

	"Pass 1: process columns from input, store into work array"
	1 to: DCTSize do: [:i |
		t0 _ (anArray at: i) * (qt at: i).
		t1 _ (anArray at: (DCTSize*2 + i)) * (qt at: (DCTSize*2 + i)).
		t2 _ (anArray at: (DCTSize*4 + i)) * (qt at: (DCTSize*4 + i)).
		t3 _ (anArray at: (DCTSize*6 + i)) * (qt at: (DCTSize*6 + i)).
		t10 _ t0 + t2.
		t11 _ t0 - t2.
		t13 _ t1 + t3.
		t12 _ (t1 - t3) * DCTK1 - t13.
		t0 _ t10 + t13.
		t3 _ t10 - t13.
		t1 _ t11 + t12.
		t2 _ t11 - t12.
		t4 _ (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).
		t5 _ (anArray at: (DCTSize*3 + i)) * (qt at: (DCTSize*3 + i)).
		t6 _ (anArray at: (DCTSize*5 + i)) * (qt at: (DCTSize*5 + i)).
		t7 _ (anArray at: (DCTSize*7 + i)) * (qt at: (DCTSize*7 + i)).
		z13 _ t6 + t5.
		z10 _ t6 - t5.
		z11 _ t4 + t7.
		z12 _ t4 - t7.
		t7 _ z11 + z13.
		t11 _ (z11 - z13) * DCTK1.
		z5 _ (z10 + z12) * DCTK2.
		t10 _ DCTK3 * z12 - z5.
		t12 _ DCTK4 * z10 + z5.
		t6 _ t12 - t7.
		t5 _ t11 - t6.
		t4 _ t10 + t5.
		ws at: i put: t0 + t7.
		ws at: (DCTSize*7 + i) put: t0 - t7.
		ws at: (DCTSize + i) put: t1 + t6.
		ws at: (DCTSize*6 + i) put: t1 - t6.
		ws at: (DCTSize*2 + i) put: t2 + t5.
		ws at: (DCTSize*5 + i) put: t2 - t5.
		ws at: (DCTSize*4 + i) put: t3 + t4.
		ws at: (DCTSize*3 + i) put: t3 - t4].

		"Pass 2: process rows from the workspace"
	(0 to: DCTSize2-DCTSize by: DCTSize) do: [:i |
		t10 _ (ws at: (i+1)) + (ws at: (i+5)).
		t11 _ (ws at: (i+1)) - (ws at: (i+5)).
		t13 _ (ws at: (i+3)) + (ws at: (i+7)).
		t12 _ ((ws at: (i+3)) - (ws at: (i+7))) * DCTK1 - t13.
		t0 _ t10 + t13.
		t3 _ t10 - t13.
		t1 _ t11 + t12.
		t2 _ t11 - t12.
		z13 _ (ws at: (i+6)) + (ws at: (i+4)).
		z10 _ (ws at: (i+6)) - (ws at: (i+4)).
		z11 _ (ws at: (i+2)) + (ws at: (i+8)).
		z12 _ (ws at: (i+2)) - (ws at: (i+8)).
		t7 _ z11 + z13.
		t11 _ (z11 - z13) * DCTK1.
		z5 _ (z10 + z12) * DCTK2.
		t10 _ DCTK3 * z12 - z5.
		t12 _ DCTK4 * z10 + z5.
		t6 _ t12 - t7.
		t5 _ t11 - t6.
		t4 _ t10 + t5.

		"final output stage: scale down by a factor of 8 and range-limit"
		anArray at: (i+1) put: (self dctFloatRangeLimit: (t0 + t7)).
		anArray at: (i+8) put: (self dctFloatRangeLimit: (t0 - t7)).
		anArray at: (i+2) put: (self dctFloatRangeLimit: (t1 + t6)).
		anArray at: (i+7) put: (self dctFloatRangeLimit: (t1 - t6)).
		anArray at: (i+3) put: (self dctFloatRangeLimit: (t2 + t5)).
		anArray at: (i+6) put: (self dctFloatRangeLimit: (t2 - t5)).
		anArray at: (i+5) put: (self dctFloatRangeLimit: (t3 + t4)).
		anArray at: (i+4) put: (self dctFloatRangeLimit: (t3 - t4))]


! !

!JPEGReadWriter methodsFor: 'dct' stamp: 'ar 3/4/2001 21:35'!
idctBlockInt: anArray component: aColorComponent
	^self idctBlockInt: anArray qt: (self qTable at: aColorComponent qTableIndex)! !

!JPEGReadWriter methodsFor: 'dct' stamp: 'ar 3/4/2001 21:34'!
idctBlockInt: anArray qt: qt

	|  ws anACTerm dcval z1 z2 z3 z4 z5 t0 t1 t2 t3 t10 t11 t12 t13 shift |
	ws _ Array new: DCTSize2.

	"Pass 1: process columns from anArray, store into work array"
	shift _ 1 bitShift: ConstBits - Pass1Bits.
	1 to: DCTSize do:
		[:i |
		anACTerm _ nil.
		1 to: DCTSize-1 do:[:row|
			anACTerm ifNil:[
				(anArray at: row * DCTSize + i) = 0 ifFalse:[anACTerm _ row]]].
		anACTerm == nil
			ifTrue:
				[dcval _ (anArray at: i) * (qt at: 1) bitShift: Pass1Bits.
				0 to: DCTSize-1 do: [:j | ws at: (j * DCTSize + i) put: dcval]]
			ifFalse:
				[z2 _ (anArray at: (DCTSize * 2 + i)) * (qt at: (DCTSize * 2 + i)).
				z3 _ (anArray at: (DCTSize * 6 + i)) * (qt at: (DCTSize * 6 + i)).
				z1 _ (z2 + z3) * FIXn0n541196100.
				t2 _ z1 + (z3 * FIXn1n847759065 negated).
				t3 _ z1 + (z2 * FIXn0n765366865).
				z2 _ (anArray at: i) * (qt at: i).
				z3 _ (anArray at: (DCTSize * 4 + i)) * (qt at: (DCTSize * 4 + i)).
				t0 _ (z2 + z3) bitShift: ConstBits.
				t1 _ (z2 - z3) bitShift: ConstBits.
				t10 _ t0 + t3.
				t13 _ t0 - t3.
				t11 _ t1 + t2.
				t12 _ t1 - t2.
				t0 _ (anArray at: (DCTSize * 7 + i)) * (qt at: (DCTSize * 7 + i)).
				t1 _ (anArray at: (DCTSize * 5 + i)) * (qt at: (DCTSize * 5 + i)).
				t2 _ (anArray at: (DCTSize * 3 + i)) * (qt at: (DCTSize * 3 + i)).
				t3 _ (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).
				z1 _ t0 + t3.
				z2 _ t1 + t2.
				z3 _ t0 + t2.
				z4 _ t1 + t3.
				z5 _ (z3 + z4) * FIXn1n175875602.
				t0 _ t0 * FIXn0n298631336.
				t1 _ t1 * FIXn2n053119869.
				t2 _ t2 * FIXn3n072711026.
				t3 _ t3 * FIXn1n501321110.
				z1 _ z1 * FIXn0n899976223 negated.
				z2 _ z2 * FIXn2n562915447 negated.
				z3 _ z3 * FIXn1n961570560 negated.
				z4 _ z4 * FIXn0n390180644 negated.
				z3 _ z3 + z5.
				z4 _ z4 + z5.
				t0 _ t0 + z1 + z3.
				t1 _ t1 +z2 +z4.
				t2 _ t2 + z2 + z3.
				t3 _ t3 + z1 + z4.
				ws at: i put: (t10 + t3) >> (ConstBits - Pass1Bits).
				ws at: (DCTSize * 7 + i) put: (t10 - t3) // shift.
				ws at: (DCTSize * 1 + i) put: (t11 + t2) // shift.
				ws at: (DCTSize * 6 + i) put: (t11 - t2) // shift.
				ws at: (DCTSize * 2 + i) put: (t12 + t1) // shift.
				ws at: (DCTSize * 5 + i) put: (t12 - t1) // shift.
				ws at: (DCTSize * 3 + i) put: (t13 + t0) // shift.
				ws at: (DCTSize * 4 + i) put: (t13 - t0) // shift]].

	"Pass 2: process rows from work array, store back into anArray"
	shift _ 1 bitShift: ConstBits + Pass1Bits + 3.
	0 to: DCTSize2-DCTSize by: DCTSize do:
		[:i |
		z2 _ ws at: i + 3.
		z3 _ ws at: i + 7.
		z1 _ (z2 + z3) * FIXn0n541196100.
		t2 _ z1 + (z3 * FIXn1n847759065 negated).
		t3 _ z1 + (z2 * FIXn0n765366865).
		t0 _ (ws at: (i + 1)) + (ws at: (i + 5)) bitShift: ConstBits.
		t1 _ (ws at: (i + 1)) - (ws at: (i + 5)) bitShift: ConstBits.
		t10 _ t0 + t3.
		t13 _ t0 - t3.
		t11 _ t1 + t2.
		t12 _ t1 -t2.
		t0 _ ws at: (i + 8).
		t1 _ ws at: (i + 6).
		t2 _ ws at: (i + 4).
		t3 _ ws at: (i + 2).
		z1 _ t0 + t3.
		z2 _ t1 + t2.
		z3 _ t0 + t2.
		z4 _ t1 + t3.
		z5 _ (z3 + z4) * FIXn1n175875602.
		t0 _ t0 * FIXn0n298631336.
		t1 _ t1 * FIXn2n053119869.
		t2 _ t2 * FIXn3n072711026.
		t3 _ t3 * FIXn1n501321110.
		z1 _ z1 * FIXn0n899976223 negated.
		z2 _ z2 * FIXn2n562915447 negated.
		z3 _ z3 * FIXn1n961570560 negated.
		z4 _ z4 * FIXn0n390180644 negated.
		z3 _ z3 + z5.
		z4 _ z4 + z5.
		t0 _ t0 + z1 + z3.
		t1 _ t1 + z2 + z4.
		t2 _ t2 + z2 + z3.
		t3 _ t3 + z1 + z4.
		anArray at: (i + 1) put: (self sampleRangeLimit: (t10 + t3) // shift + SampleOffset).
		anArray at: (i + 8) put: (self sampleRangeLimit: (t10 - t3) // shift + SampleOffset).
		anArray at: (i + 2) put: (self sampleRangeLimit: (t11 + t2) // shift + SampleOffset).
		anArray at: (i + 7) put: (self sampleRangeLimit: (t11 - t2) // shift + SampleOffset).
		anArray at: (i + 3) put: (self sampleRangeLimit: (t12 + t1) // shift + SampleOffset).
		anArray at: (i + 6) put: (self sampleRangeLimit: (t12 - t1) // shift + SampleOffset).
		anArray at: (i + 4) put: (self sampleRangeLimit: (t13 + t0) // shift + SampleOffset).
		anArray at: (i + 5) put: (self sampleRangeLimit: (t13 - t0) // shift + SampleOffset)].


! !

!JPEGReadWriter methodsFor: 'dct' stamp: 'ar 3/7/2001 00:58'!
idctMCU

	| comp fp ci |
	fp _ self useFloatingPoint.
	1 to: mcuMembership size do:[:i|
		ci _ mcuMembership at: i.
		comp _ currentComponents at: ci.
		fp ifTrue:[
			self idctBlockFloat: (mcuSampleBuffer at: i) component: comp.
		] ifFalse:[
			self primIdctInt: (mcuSampleBuffer at: i)
				qt: (qTable at: comp qTableIndex)]].! !

!JPEGReadWriter methodsFor: 'dct' stamp: 'ar 3/4/2001 21:37'!
primIdctBlockInt: anArray component: aColorComponent
	^self primIdctInt: anArray qt: (self qTable at: aColorComponent qTableIndex)! !

!JPEGReadWriter methodsFor: 'dct' stamp: 'ar 3/4/2001 21:35'!
primIdctInt: anArray qt: qt
	<primitive: 'primitiveIdctInt' module: 'JPEGReaderPlugin'>
	^self idctBlockInt: anArray qt: qt! !

!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 16:16'!
scaleQuantizationTable: table

	| index |

	index _ 1.
	1 to: DCTSize do:
		[:row |
		1 to: DCTSize do:
			[:col |
			table at: index
				put: ((table at: index) * (QTableScaleFactor at: row) *
					(QTableScaleFactor at: col)) rounded.
			index _ index + 1]].
	^ table
! !

!JPEGReadWriter methodsFor: 'error handling' stamp: 'tao 10/19/97 12:25'!
notSupported: aString

	self error: aString , ' is not currently supported'! !

!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 20:55'!
decodeBlockInto: anArray component: aColorComponent dcTable: huffmanDC acTable: huffmanAC

	| byte i zeroCount |
	byte _ stream decodeValueFrom: huffmanDC.
	byte ~= 0 ifTrue: [byte _ self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte].
	byte _ aColorComponent updateDCValue: byte.
	anArray atAllPut: 0.
	anArray at: 1 put: byte.
	i _ 2.
	[i <= DCTSize2] whileTrue:
		[byte _ stream decodeValueFrom: huffmanAC.
		zeroCount _ byte >> 4.
		byte _ byte bitAnd: 16r0F.
		byte ~= 0
			ifTrue:
				[i _ i + zeroCount.
				byte _ self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte.
				anArray at:	 (JPEGNaturalOrder at: i) put: byte]
			ifFalse:
				[zeroCount = 15 ifTrue: [i _ i + zeroCount] ifFalse: [^ self]].
		i _ i + 1]
		! !

!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/7/2001 01:00'!
decodeMCU

	| comp ci |
	(restartInterval ~= 0 and: [restartsToGo = 0]) ifTrue: [self processRestart].
	1 to: mcuMembership size do:[:i|
		ci _ mcuMembership at: i.
		comp _ currentComponents at: ci.
		self
			primDecodeBlockInto: (mcuSampleBuffer at: i)
			component: comp
			dcTable: (hDCTable at: comp dcTableIndex)
			acTable: (hACTable at: comp acTableIndex)
			stream: stream.
	].
	restartsToGo _ restartsToGo - 1.! !

!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 17:27'!
getBits: requestedBits
	^stream getBits: requestedBits! !

!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 21:32'!
primDecodeBlockInto: sampleBuffer component: comp dcTable: dcTable acTable: acTable stream: jpegStream
	<primitive: 'primitiveDecodeMCU' module: 'JPEGReaderPlugin'>
	^self decodeBlockInto: sampleBuffer component: comp dcTable: dcTable acTable: acTable! !

!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 17:40'!
processRestart
	stream resetBitBuffer.
	self parseNextMarker.
	currentComponents do: [:c | c priorDCValue: 0].
	restartsToGo _ restartInterval.! !

!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 01:17'!
scaleAndSignExtend: aNumber inFieldWidth: w

	aNumber < (1 bitShift: (w - 1))
		ifTrue: [^aNumber - (1 bitShift: w) + 1]
		ifFalse: [^aNumber]! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/4/2001 18:38'!
initialSOSSetup

	mcuWidth _ (components detectMax: [:c | c widthInBlocks]) widthInBlocks.
	mcuHeight _ (components detectMax: [:c | c heightInBlocks]) heightInBlocks.
	components do:[:c |
		c mcuWidth: mcuWidth mcuHeight: mcuHeight dctSize: DCTSize].
	stream resetBitBuffer.! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'mir 6/13/2001 13:06'!
okToIgnoreMarker: aMarker

	^ (((16rE0 to: 16rEF) includes: aMarker) "unhandled APPn markers"
		or: [aMarker = 16rDC or: [aMarker = 16rFE]]) "DNL or COM markers"
		or: [aMarker = 16r99] "Whatever that is"! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/6/2001 22:28'!
parseAPPn

	| length buffer thumbnailLength markerStart |
	markerStart _ self position.
	length _ self nextWord.
	buffer _ self next: 4.
	(buffer asString = 'JFIF') ifFalse: [
		"Skip APPs that we're not interested in"
		stream next: length-6.
		^self].
	self next.
	majorVersion _ self next.
	minorVersion _ self next.
	densityUnit _ self next.
	xDensity _ self nextWord.
	yDensity _ self nextWord.
	thumbnailLength _ self next * self next * 3.
	length _ length - (self position - markerStart).
	length = thumbnailLength ifFalse: [self error: 'APP0 thumbnail length is incorrect.'].
	self next: length! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/20/97 13:36'!
parseDecoderRestartInterval

	| length |
	length _ self nextWord.
	length = 4 ifFalse: [self error: 'DRI length incorrect'].
	restartInterval _ self nextWord.! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'mir 6/12/2001 11:28'!
parseFirstMarker

	| marker |
	self next = 16rFF ifFalse: [self error: 'JFIF marker expected'].
	marker _ self next.
	marker = 16rD9
		ifTrue: [^self "halt: 'EOI encountered.'"].
	marker = 16rD8 ifFalse: [self error: 'SOI marker expected'].
	self parseStartOfInput.
! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/4/2001 18:36'!
parseHuffmanTable

	| length markerStart index bits count huffVal isACTable hTable |
	markerStart _ self position.
	length _ self nextWord.
	[self position - markerStart >= length] whileFalse:
		[index _ self next.
		isACTable _ (index bitAnd: 16r10) ~= 0.
		index _ (index bitAnd: 16r0F) + 1.
		index > HuffmanTableSize
			ifTrue: [self error: 'image has more than ', HuffmanTableSize printString,
				' quantization tables'].
		bits _ self next: 16.
		count _ bits sum.
		(count > 256 or: [(count > (length - (self position - markerStart)))])
			ifTrue: [self error: 'Huffman Table count is incorrect'].
		huffVal _ self next: count.
		hTable _ stream buildLookupTable: huffVal counts: bits.
		isACTable
			ifTrue:
				[self hACTable at: index put: hTable]
			ifFalse:
				[self hDCTable at: index put: hTable]].! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:32'!
parseNOP

	"don't need to do anything, here"! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'BG 3/16/2005 08:24'!
parseNextMarker
	"Parse the next marker of the stream"

	| byte discardedBytes |
	discardedBytes _ 0.
	[(byte _ self next) = 16rFF] whileFalse: [discardedBytes _ discardedBytes + 1].	
	[[(byte _ self next) = 16rFF] whileTrue. byte = 16r00] whileTrue:
		[discardedBytes _ discardedBytes + 2].
	discardedBytes > 0 ifTrue: [self "notifyWithLabel: 'warning: extraneous data discarded'"].
	self perform:
		(JFIFMarkerParser
			at: byte
			ifAbsent:
				[(self okToIgnoreMarker: byte)
					ifTrue: [#skipMarker]
					ifFalse: [self error: 'marker ', byte printStringHex , ' cannot be handled']])! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/3/2001 22:19'!
parseQuantizationTable

	| length markerStart n prec value table |
	markerStart _ self position.
	length _ self nextWord.
	[self position - markerStart >= length] whileFalse:
		[value _ self next.
		n _ (value bitAnd: 16r0F) + 1.
		prec _ (value >> 4) > 0.
		n > QuantizationTableSize
			 ifTrue: [self error: 'image has more than ',
				QuantizationTableSize printString,
				' quantization tables'].
		table _ IntegerArray new: DCTSize2.
		1 to: DCTSize2 do:
			[:i |
			value _ (prec
				ifTrue: [self nextWord]
				ifFalse: [self next]).
			table at: (JPEGNaturalOrder at: i) put: value].
		self useFloatingPoint ifTrue: [self scaleQuantizationTable: table].
		self qTable at: n put: table]! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:07'!
parseStartOfFile

	| length markerStart value n |
	markerStart _ self position.
	length _ self nextWord.
	dataPrecision _ self next.
	dataPrecision = 8
		ifFalse: [self error: 'cannot handle ', dataPrecision printString, '-bit components'].
	height _ self nextWord.
	width _ self nextWord.
	n _ self next.
	(height = 0) | (width = 0) | (n = 0) ifTrue: [self error: 'empty image'].
	(length - (self position - markerStart)) ~= (n * 3)
		ifTrue: [self error: 'component length is incorrect'].
	components _ Array new: n.
	1 to: components size do:
		[:i |
		components
			at: i
			put:
				(JPEGColorComponent new
					id: self next;
					"heightInBlocks: (((value _ self next) >> 4) bitAnd: 16r0F);
					widthInBlocks: (value bitAnd: 16r0F);"
					widthInBlocks: (((value _ self next) >> 4) bitAnd: 16r0F);
					heightInBlocks: (value bitAnd: 16r0F);

					qTableIndex: self next + 1)]! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/22/97 17:38'!
parseStartOfInput

	restartInterval _ 0.
	densityUnit _ 0.
	xDensity _ 1.
	yDensity _ 1
! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/26/97 21:53'!
parseStartOfScan

	| length n id value dcNum acNum comp |
	length _ self nextWord.
	n _ self next.
	(length ~= (n*2 + 6)) | (n < 1) ifTrue: [self error: 'SOS length is incorrect'].
	currentComponents _ Array new: n.
	1 to: n do: [:i |
		id _ self next.
		value _ self next.
		dcNum _ (value >> 4) bitAnd: 16r0F.
		acNum _ value bitAnd: 16r0F.
		comp _ components detect: [:c | c id = id].
		comp
			dcTableIndex: dcNum+1;
			acTableIndex: acNum+1.
		currentComponents at: i put: comp].
	ss _ self next.
	se _ self next.
	value _ self next.
	ah _ (value >> 4) bitAnd: 16r0F.
	al _ value bitAnd: 16r0F.
	self initialSOSSetup.
	self perScanSetup.
	sosSeen _ true! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/7/2001 01:01'!
perScanSetup

	mcusPerRow _ (width / (mcuWidth * DCTSize)) ceiling.
	mcuRowsInScan _ (height / (mcuHeight * DCTSize)) ceiling.
	(currentComponents size = 3 or: [currentComponents size = 1])
		ifFalse: [self error: 'JPEG color space not recognized'].
	mcuMembership _ OrderedCollection new.
	currentComponents withIndexDo:
		[:c :i |
		c priorDCValue: 0.
		mcuMembership addAll: ((1 to: c totalMcuBlocks) collect: [:b | i])].
	mcuMembership _ mcuMembership asArray.
	mcuSampleBuffer _ (1 to: mcuMembership size) collect: [:i | IntegerArray new: DCTSize2].
	currentComponents withIndexDo:
		[:c :i |
			c initializeSampleStreamBlocks:
				((1 to: mcuMembership size)
					select: [:j | i = (mcuMembership at: j)]
					thenCollect: [:j | mcuSampleBuffer at: j])].
	mcuImageBuffer _ Form
		extent: (mcuWidth @ mcuHeight) * DCTSize
		depth: 32.
	restartsToGo _ restartInterval.! !

!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/22/97 16:27'!
skipMarker

	| length markerStart |
	markerStart _ self position.
	length _ self nextWord.
	self next: length - (self position - markerStart)
! !

!JPEGReadWriter methodsFor: 'preferences' stamp: 'tao 10/26/97 22:09'!
useFloatingPoint

	^ false! !

!JPEGReadWriter methodsFor: 'public access' stamp: 'ar 3/7/2001 00:18'!
decompressionTest
	"Test decompression; don't generate actual image"
	| xStep yStep x y |
MessageTally spyOn:[
	ditherMask _ DitherMasks at: 32.
	residuals _ WordArray new: 3.
	sosSeen _ false.
	self parseFirstMarker.
	[sosSeen] whileFalse: [self parseNextMarker].
	xStep _ mcuWidth * DCTSize.
	yStep _ mcuHeight * DCTSize.
	y _ 0.
	1 to: mcuRowsInScan do:
		[:row |
		x _ 0.
		1 to: mcusPerRow do:
			[:col |
			self decodeMCU.
			self idctMCU.
			self colorConvertMCU.
			x _ x + xStep].
		y _ y + yStep].
].! !

!JPEGReadWriter methodsFor: 'public access' stamp: 'tao 9/18/1998 08:53'!
nextImage

	^ self nextImageDitheredToDepth: Display depth
! !

!JPEGReadWriter methodsFor: 'public access' stamp: 'ar 10/28/2001 16:25'!
nextImageDitheredToDepth: depth

	| form xStep yStep x y bb |
	ditherMask _ DitherMasks
		at: depth
		ifAbsent: [self error: 'can only dither to display depths'].
	residuals _ WordArray new: 3.
	sosSeen _ false.
	self parseFirstMarker.
	[sosSeen] whileFalse: [self parseNextMarker].
	form _ Form extent: (width @ height) depth: depth.
	bb _ BitBlt current toForm: form.
	bb sourceForm: mcuImageBuffer.
	bb colorMap: (mcuImageBuffer colormapIfNeededFor: form).
	bb sourceRect: mcuImageBuffer boundingBox.
	bb combinationRule: Form over.
	xStep _ mcuWidth * DCTSize.
	yStep _ mcuHeight * DCTSize.
	y _ 0.
	1 to: mcuRowsInScan do:
		[:row |
		x _ 0.
		1 to: mcusPerRow do:
			[:col |
			self decodeMCU.
			self idctMCU.
			self colorConvertMCU.
			bb destX: x; destY: y; copyBits.
			x _ x + xStep].
		y _ y + yStep].
	^ form! !

!JPEGReadWriter methodsFor: 'public access' stamp: 'ar 3/4/2001 17:26'!
setStream: aStream
	"Feed it in from an existing source"
	stream _ JPEGReadStream on: aStream upToEnd.! !

!JPEGReadWriter methodsFor: 'testing' stamp: 'ar 3/4/2001 00:50'!
understandsImageFormat
	"Answer true if the image stream format is understood by this decoder."
	self next = 16rFF ifFalse: [^ false].
	self next = 16rD8 ifFalse: [^ false].
	^ true
! !

!JPEGReadWriter methodsFor: 'private' stamp: 'ar 3/4/2001 17:34'!
on: aStream
	super on: aStream.
	stream _ JPEGReadStream on: stream upToEnd.! !

!JPEGReadWriter commentStamp: '<historical>' prior: 0!
I am a subclass of ImageReadWriter that understands JFIF file streams, and can decode JPEG images.
This code is based upon the Independent Joint Photographic Experts Group (IJPEG) software, originally written in C by Tom Lane, Philip Gladstone, Luis Ortiz, Jim Boucher, Lee Crocker, Julian Minguillon, George Phillips, Davide Rossi, Ge' Weijers, and other members of the Independent JPEG Group.

!
!JPEGReadWriter class methodsFor: 'image reading/writing' stamp: 'nk 7/16/2003 17:56'!
typicalFileExtensions
	"Answer a collection of file extensions (lowercase) which files that I can read might commonly have"
	^#('jpg' 'jpeg')! !

!JPEGReadWriter class methodsFor: 'image reading/writing' stamp: 'ar 6/16/2002 18:54'!
understandsImageFormat: aStream
	(JPEGReadWriter2 understandsImageFormat: aStream) ifTrue:[^false].
	aStream reset.
	aStream next = 16rFF ifFalse: [^ false].
	aStream next = 16rD8 ifFalse: [^ false].
	^true! !

!JPEGReadWriter class methodsFor: 'initialization' stamp: 'ar 3/3/2001 23:07'!
initialize
	"JPEGReadWriter initialize"
	"general constants"
	DCTSize _ 8.
	MaxSample _ (2 raisedToInteger: DCTSize) - 1.
	SampleOffset _ MaxSample // 2.
	FloatSampleOffset _ SampleOffset asFloat.
	DCTSize2 _ DCTSize squared.
	QuantizationTableSize _ 4.
	HuffmanTableSize _ 4.

	"floating-point Inverse Discrete Cosine Transform (IDCT) constants"
	ConstBits _ 13.
	Pass1Bits _ 2.
	DCTK1 _ 2 sqrt.
	DCTK2 _ 1.847759065.
	DCTK3 _ 1.082392200.
	DCTK4 _ -2.613125930.
	Pass1Div _ 1 bitShift: ConstBits - Pass1Bits.
	Pass2Div _ 1 bitShift: ConstBits + Pass1Bits + 3.

	"fixed-point Inverse Discrete Cosine Transform (IDCT) constants"
	FIXn0n298631336 _ 2446.
	FIXn0n390180644 _ 3196.
	FIXn0n541196100 _ 4433.
	FIXn0n765366865 _ 6270.
	FIXn0n899976223 _ 7373.
	FIXn1n175875602 _ 9633.
	FIXn1n501321110 _ 12299.
	FIXn1n847759065 _ 15137.
	FIXn1n961570560 _ 16069.
	FIXn2n053119869 _ 16819.
	FIXn2n562915447 _ 20995.
	FIXn3n072711026 _ 25172.

	"fixed-point color conversion constants"
	FIXn0n34414 _ 22554.
	FIXn0n71414 _ 46802.
	FIXn1n40200 _ 91881.
	FIXn1n77200 _  116130.

	"reordering table from JPEG zig-zag order"
	JPEGNaturalOrder _ #(
		1 2 9 17 10 3 4 11
		18 25 33 26 19 12 5 6
		13 20 27 34 41 49 42 35
		28 21 14 7 8 15 22 29
		36 43 50 57 58 51 44 37
		30 23 16 24 31 38 45 52
		59 60 53 46 39 32 40 47
		54 61 62 55 48 56 63 64).

	"scale factors for the values in the Quantization Tables"
	QTableScaleFactor _ (0 to: DCTSize-1) collect:
		[:k | k = 0
			ifTrue: [1.0]
			ifFalse: [(k * Float pi / 16) cos * 2 sqrt]].

	"dithering masks"
	(DitherMasks _ Dictionary new)
		add: 0 -> 0;
		add: 1 -> 127;
		add: 2 -> 63;
		add: 4 -> 63;
		add: 8 -> 31;
		add: 16 -> 7;
		add: 32 -> 0.

	"dictionary of marker parsers"
	(JFIFMarkerParser _ Dictionary new)
		add: (16r01 -> #parseNOP);
		add: (16rC0 -> #parseStartOfFile);
		add: (16rC4 -> #parseHuffmanTable);
		addAll: ((16rD0 to: 16rD7) collect: [:m | Association key: m value: #parseNOP]);
		add: (16rD8 -> #parseStartOfInput);
		add: (16rD9 -> #parseEndOfInput);
		add: (16rDA -> #parseStartOfScan);
		add: (16rDB -> #parseQuantizationTable);
		add: (16rDD -> #parseDecoderRestartInterval);
		add: (16rE0 -> #parseAPPn);
		add: (16rE1 -> #parseAPPn)! !

!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:34'!
primImageHeight: aJPEGCompressStruct

	<primitive: 'primImageHeight' module: 'JPEGReadWriter2Plugin'>
	self primitiveFailed
! !

!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!
primImageWidth: aJPEGCompressStruct

	<primitive: 'primImageWidth' module: 'JPEGReadWriter2Plugin'>
	self primitiveFailed
! !

!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!
primJPEGCompressStructSize

	<primitive: 'primJPEGCompressStructSize' module: 'JPEGReadWriter2Plugin'>
	self primitiveFailed
! !

!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!
primJPEGDecompressStructSize

	<primitive: 'primJPEGDecompressStructSize' module: 'JPEGReadWriter2Plugin'>
	self primitiveFailed
! !

!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!
primJPEGErrorMgr2StructSize

	<primitive: 'primJPEGErrorMgr2StructSize' module: 'JPEGReadWriter2Plugin'>
	self primitiveFailed
! !

!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'ar 11/27/2001 00:39'!
primJPEGPluginIsPresent
	<primitive: 'primJPEGPluginIsPresent' module: 'JPEGReadWriter2Plugin'>
	^false! !

!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!
primJPEGReadHeader: aJPEGDecompressStruct fromByteArray: source errorMgr: aJPEGErrorMgr2Struct

	<primitive: 'primJPEGReadHeaderfromByteArrayerrorMgr' module: 'JPEGReadWriter2Plugin'>
	self primitiveFailed
! !

!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jmv 12/7/2001 13:45'!
primJPEGReadImage: aJPEGDecompressStruct fromByteArray: source onForm: form doDithering: ditherFlag errorMgr: aJPEGErrorMgr2Struct

	<primitive: 'primJPEGReadImagefromByteArrayonFormdoDitheringerrorMgr' module: 'JPEGReadWriter2Plugin'>
	self primitiveFailed
! !

!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!
primJPEGWriteImage: aJPEGCompressStruct onByteArray: destination form: form quality: quality progressiveJPEG: progressiveFlag errorMgr: aJPEGErrorMgr2Struct

	<primitive: 'primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgr' module: 'JPEGReadWriter2Plugin'>
	self primitiveFailed
! !

!JPEGReadWriter2 methodsFor: 'public access' stamp: 'JMM 1/11/2005 14:56'!
compress: aForm quality: quality
	"Encode the given Form and answer the compressed ByteArray. Quality goes from 0 (low) to 100 (high), where -1 means default."

	| sourceForm jpegCompressStruct jpegErrorMgr2Struct buffer byteCount |
	aForm unhibernate.
	"odd width images of depth 16 give problems; avoid them."
	sourceForm _ (aForm depth = 32) | (aForm width even & (aForm depth = 16))
		ifTrue: [aForm]
		ifFalse: [aForm asFormOfDepth: 32].
	jpegCompressStruct _ ByteArray new: self primJPEGCompressStructSize.
	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.
	buffer _ ByteArray new: sourceForm width * sourceForm height + 1024.
	byteCount _ self primJPEGWriteImage: jpegCompressStruct 
		onByteArray: buffer
		form: sourceForm
		quality: quality
		progressiveJPEG: false
		errorMgr: jpegErrorMgr2Struct.
	byteCount = 0 ifTrue: [self error: 'buffer too small for compressed data'].
	^ buffer copyFrom: 1 to: byteCount
! !

!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jm 11/20/2001 10:01'!
imageExtent: aByteArray 
	"Answer the extent of the compressed image encoded in the given ByteArray."

	| jpegDecompressStruct jpegErrorMgr2Struct w h |
	jpegDecompressStruct _ ByteArray new: self primJPEGDecompressStructSize.
	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.
	self
		primJPEGReadHeader: jpegDecompressStruct 
		fromByteArray: aByteArray
		errorMgr: jpegErrorMgr2Struct.
	w _ self primImageWidth: jpegDecompressStruct.
	h _ self primImageHeight: jpegDecompressStruct.
	^ w @ h
! !

!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jm 11/20/2001 10:23'!
nextImage
	"Decode and answer a Form from my stream."

	^ self nextImageSuggestedDepth: Display depth
! !

!JPEGReadWriter2 methodsFor: 'public access' stamp: 'sd 1/30/2004 15:19'!
nextImageSuggestedDepth: depth
	"Decode and answer a Form of the given depth from my stream. Close the stream if it is a file stream. Possible depths are 16-bit and 32-bit."

	| bytes width height form jpegDecompressStruct jpegErrorMgr2Struct depthToUse |
	bytes _ stream upToEnd.
	stream close.
	jpegDecompressStruct _ ByteArray new: self primJPEGDecompressStructSize.
	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.
	self 
		primJPEGReadHeader: jpegDecompressStruct 
		fromByteArray: bytes
		errorMgr: jpegErrorMgr2Struct.
	width _ self primImageWidth: jpegDecompressStruct.
	height _ self primImageHeight: jpegDecompressStruct.
	"Odd width images of depth 16 gave problems. Avoid them (or check carefully!!)"
	depthToUse _ ((depth = 32) | width odd) ifTrue: [32] ifFalse: [16].
	form _ Form extent: width@height depth: depthToUse.
	(width = 0 or: [height = 0]) ifTrue: [^ form].
	self
		primJPEGReadImage: jpegDecompressStruct
		fromByteArray: bytes
		onForm: form
		doDithering: true
		errorMgr: jpegErrorMgr2Struct.
	^ form
! !

!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jm 11/20/2001 10:21'!
nextPutImage: aForm
	"Encode the given Form on my stream with default quality."

	^ self nextPutImage: aForm quality: -1 progressiveJPEG: false
! !

!JPEGReadWriter2 methodsFor: 'public access' stamp: 'JMM 1/11/2005 14:45'!
nextPutImage: aForm quality: quality progressiveJPEG: progressiveFlag
	"Encode the given Form on my stream with the given settings. Quality goes from 0 (low) to 100 (high), where -1 means default. If progressiveFlag is true, encode as a progressive JPEG."

	| sourceForm jpegCompressStruct jpegErrorMgr2Struct buffer byteCount |
	aForm unhibernate.
	"odd width images of depth 16 give problems; avoid them."
	sourceForm _ (aForm depth = 32) | (aForm width even & (aForm depth = 16))
		ifTrue: [aForm]
		ifFalse: [aForm asFormOfDepth: 32].
	jpegCompressStruct _ ByteArray new: self primJPEGCompressStructSize.
	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.
	buffer _ ByteArray new: sourceForm width * sourceForm height + 1024.
	byteCount _ self primJPEGWriteImage: jpegCompressStruct 
		onByteArray: buffer
		form: sourceForm
		quality: quality
		progressiveJPEG: progressiveFlag
		errorMgr: jpegErrorMgr2Struct.
	byteCount = 0 ifTrue: [self error: 'buffer too small for compressed data'].
	stream next: byteCount putAll: buffer startingAt: 1.
	self close.
! !

!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jmv 12/7/2001 13:49'!
uncompress: aByteArray into: aForm
	"Uncompress an image from the given ByteArray into the given Form.
	Fails if the given Form has the wrong dimensions or depth.
	If aForm has depth 16, do ordered dithering."

	| jpegDecompressStruct jpegErrorMgr2Struct w h |
	aForm unhibernate.
	jpegDecompressStruct _ ByteArray new: self primJPEGDecompressStructSize.
	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.
	self 
		primJPEGReadHeader: jpegDecompressStruct 
		fromByteArray: aByteArray
		errorMgr: jpegErrorMgr2Struct.
	w _ self primImageWidth: jpegDecompressStruct.
	h _ self primImageHeight: jpegDecompressStruct.
	((aForm width = w) & (aForm height = h)) ifFalse: [
		^ self error: 'form dimensions do not match'].

	"odd width images of depth 16 give problems; avoid them"
	w odd
		ifTrue: [
			aForm depth = 32 ifFalse: [^ self error: 'must use depth 32 with odd width']]
		ifFalse: [
			((aForm depth = 16) | (aForm depth = 32)) ifFalse: [^ self error: 'must use depth 16 or 32']].

	self primJPEGReadImage: jpegDecompressStruct
		fromByteArray: aByteArray
		onForm: aForm
		doDithering: true
		errorMgr: jpegErrorMgr2Struct.
! !

!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jmv 12/7/2001 13:48'!
uncompress: aByteArray into: aForm doDithering: ditherFlag
	"Uncompress an image from the given ByteArray into the given Form. 
	Fails if the given Form has the wrong dimensions or depth.
	If aForm has depth 16 and ditherFlag = true, do ordered dithering."

	| jpegDecompressStruct jpegErrorMgr2Struct w h |
	aForm unhibernate.
	jpegDecompressStruct _ ByteArray new: self primJPEGDecompressStructSize.
	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.
	self 
		primJPEGReadHeader: jpegDecompressStruct 
		fromByteArray: aByteArray
		errorMgr: jpegErrorMgr2Struct.
	w _ self primImageWidth: jpegDecompressStruct.
	h _ self primImageHeight: jpegDecompressStruct.
	((aForm width = w) & (aForm height = h)) ifFalse: [
		^ self error: 'form dimensions do not match'].

	"odd width images of depth 16 give problems; avoid them"
	w odd
		ifTrue: [
			aForm depth = 32 ifFalse: [^ self error: 'must use depth 32 with odd width']]
		ifFalse: [
			((aForm depth = 16) | (aForm depth = 32)) ifFalse: [^ self error: 'must use depth 16 or 32']].

	self primJPEGReadImage: jpegDecompressStruct
		fromByteArray: aByteArray
		onForm: aForm
		doDithering: ditherFlag
		errorMgr: jpegErrorMgr2Struct.
! !

!JPEGReadWriter2 methodsFor: 'testing' stamp: 'ar 11/27/2001 00:40'!
isPluginPresent
	^self primJPEGPluginIsPresent! !

!JPEGReadWriter2 methodsFor: 'testing' stamp: 'ar 11/27/2001 00:39'!
understandsImageFormat
	"Answer true if the image stream format is understood by this decoder."
	self isPluginPresent ifFalse:[^false]. "cannot read it otherwise"
	self next = 16rFF ifFalse: [^ false].
	self next = 16rD8 ifFalse: [^ false].
	^ true
! !

!JPEGReadWriter2 commentStamp: '<historical>' prior: 0!
I provide fast JPEG compression and decompression. I require the VM pluginJPEGReadWriter2Plugin, which is typically stored in same directory as the Squeak virtual machine.

JPEGReadWriter2Plugin is based on LIBJPEG library. This sentence applies to the plugin:
   "This software is based in part on the work of the Independent JPEG Group".

The LIBJPEG license allows it to be used free for any purpose so long as its origin and copyright are acknowledged. You can read more about LIBJPEG and get the complete source code at www.ijg.org.
!
!JPEGReadWriter2 class methodsFor: 'image reading/writing' stamp: 'ar 6/16/2002 18:54'!
primJPEGPluginIsPresent
	<primitive: 'primJPEGPluginIsPresent' module: 'JPEGReadWriter2Plugin'>
	^false! !

!JPEGReadWriter2 class methodsFor: 'image reading/writing' stamp: 'jm 12/22/2001 11:55'!
putForm: aForm quality: quality progressiveJPEG: progressiveFlag onFileNamed: fileName
	"Store the given Form as a JPEG file of the given name, overwriting any existing file of that name. Quality goes from 0 (low) to 100 (high), where -1 means default. If progressiveFlag is true, encode as a progressive JPEG."

	| writer |
	FileDirectory deleteFilePath: fileName.
	writer _ self on: (FileStream newFileNamed: fileName) binary.
	Cursor write showWhile: [
		writer nextPutImage: aForm quality: quality progressiveJPEG: progressiveFlag].
	writer close.
! !

!JPEGReadWriter2 class methodsFor: 'image reading/writing' stamp: 'nk 7/16/2003 17:56'!
typicalFileExtensions
	"Answer a collection of file extensions (lowercase) which files that I can read might commonly have"
	^#('jpg' 'jpeg')! !

!LargePositiveInteger methodsFor: 'printing' stamp: 'ssa 9/11/2009 16:52'!
printOn: aStream
	"hack to fix strange LPI bug"
	^(self - 1 + 1)printOn: aStream base: 10! !

!LinkedList methodsFor: 'converting' stamp: 'ssa 1/26/2010 16:24'!
asOrderedCollection

	^(self collect:[:link| link])asOrderedCollection! !

!LinkedList methodsFor: 'explorer' stamp: 'ssa 1/26/2010 16:32'!
hasContentsInExplorer

	^self isEmpty not! !

!ListController methodsFor: 'menu messages' stamp: 'ssa 9/15/2009 16:53'!
processKeyboard
	"Derived from a Martin Pammer submission, 02/98"

     | keyEvent oldSelection nextSelection max min howMany |
	sensor keyboardPressed ifFalse: [^ self].

     keyEvent := sensor keyboard asciiValue.
	(keyEvent = $l asciiValue and:[Sensor commandKeyPressed])ifTrue:[self view topView adjustWidths].
     oldSelection := view selection.
     nextSelection := oldSelection.
     max := view maximumSelection.
     min := view minimumSelection.
     howMany := view clippingBox height // view list lineGrid.

     keyEvent == 31 ifTrue:
		["down-arrow; move down one, wrapping to top if needed"
		nextSelection := oldSelection + 1.
		nextSelection > max ifTrue: [nextSelection _ 1]].

     keyEvent == 30 ifTrue:
		["up arrow; move up one, wrapping to bottom if needed"
		nextSelection := oldSelection - 1.
		nextSelection < 1 ifTrue: [nextSelection _ max]].

     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"
     keyEvent == 4  ifTrue: [nextSelection := max].   "end"
     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection -
howMany)].  "page up"
     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany)
min: max].  "page down"
     nextSelection = oldSelection  ifFalse:
		[model okToChange
			ifTrue:
				[self changeModelSelection: nextSelection.
				self moveMarker]]
			! !

!ListItemWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 3/31/1999 12:15'!
hasEquivalentIn: aCollection

	aCollection detect: [ :each | 
		each withoutListWrapper = item withoutListWrapper
	] ifNone: [^false].
	^true! !

!ListItemWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 4/4/1999 17:58'!
sendSettingMessageTo: aModel

	aModel 
		perform: (self settingSelector ifNil: [^self])
		with: self withoutListWrapper
! !

!ListItemWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 3/31/1999 21:31'!
settingSelector

	^nil! !

!ListItemWrapper methodsFor: 'converting' stamp: 'RAA 3/30/1999 18:17'!
asString

	^item asString! !

!ListItemWrapper methodsFor: 'converting' stamp: 'RAA 3/31/1999 12:13'!
withoutListWrapper

	^item withoutListWrapper! !

!ListItemWrapper methodsFor: 'accessing' stamp: 'RAA 3/31/1999 16:32'!
contents

	^Array new! !

!ListItemWrapper methodsFor: 'accessing' stamp: 'RAA 4/1/1999 20:09'!
hasContents

	^self contents isEmpty not! !

!ListItemWrapper methodsFor: 'accessing' stamp: 'RAA 8/3/1999 09:40'!
highlightingColor

	^Color red! !

!ListItemWrapper methodsFor: 'accessing' stamp: 'dgd 9/26/2004 18:22'!
icon
	"Answer a form to be used as icon"
	^ nil! !

!ListItemWrapper methodsFor: 'accessing' stamp: 'ssa 11/24/2009 19:07'!
item
	"Answer the value of item"

	item isNil ifTrue:[self item: nil].
	^ item! !

!ListItemWrapper methodsFor: 'accessing' stamp: 'ssa 11/24/2009 19:07'!
item: anObject
	"Set the value of item"

	item _ anObject! !

!ListItemWrapper methodsFor: 'accessing' stamp: 'ssa 11/24/2009 19:07'!
model
	"Answer the value of model"

	model isNil ifTrue:[self model: nil].
	^ model! !

!ListItemWrapper methodsFor: 'accessing' stamp: 'ssa 11/24/2009 19:07'!
model: anObject
	"Set the value of model"

	model _ anObject! !

!ListItemWrapper methodsFor: 'accessing' stamp: 'RAA 4/2/1999 15:14'!
preferredColor

	^nil! !

!ListItemWrapper methodsFor: 'accessing' stamp: 'RAA 3/30/1999 18:27'!
setItem: anObject

	item _ anObject! !

!ListItemWrapper methodsFor: 'accessing' stamp: 'RAA 3/31/1999 16:44'!
setItem: anObject model: aModel

	item _ anObject.
	model _ aModel.! !

!ListItemWrapper commentStamp: '<historical>' prior: 0!
Contributed by Bob Arning as part of the ObjectExplorer package.
!
!ListItemWrapper class methodsFor: 'as yet unclassified' stamp: 'RAA 3/30/1999 18:28'!
with: anObject

	^self new setItem: anObject! !

!ListItemWrapper class methodsFor: 'as yet unclassified' stamp: 'RAA 3/31/1999 16:44'!
with: anObject model: aModel

	^self new setItem: anObject model: aModel! !

!ListView methodsFor: 'displaying'!
scrollSelectionIntoView
	"Selection is assumed to be on and clipped out of view.
	Uses controller scrollView to keep selection right"
	| delta |
	(delta _ self insetDisplayBox bottom - self selectionBox bottom) < 0
		ifTrue: [^ self controller scrollView: delta - (list lineGrid-1)]. "up"
	(delta _ self insetDisplayBox top - self selectionBox top) > 0
		ifTrue: [^ self controller scrollView: delta + 1] "down"! !

!ListView methodsFor: 'clipping box access' stamp: 'ssa 9/11/2009 18:25'!
clippingBox
	"Answer the rectangle in which the model can be displayed--this is the 
	insetDisplayBox inset by the height of a line for an item."

	^self insetDisplayBox insetBy: 
		(Rectangle
			left: 0
			right: 0
			top: 0
			bottom: 0 "self insetDisplayBox height \\ list lineGrid")! !

!ListView methodsFor: 'selecting' stamp: 'ssa 9/11/2009 18:25'!
findSelection: aPoint 
	"Determine which selection is displayed in an area containing the point, 
	aPoint. Answer the selection if one contains the point, answer nil 
	otherwise."

	| trialSelection |
	(self clippingBox  containsPoint: aPoint) ifFalse: [^nil].
	trialSelection _ aPoint y - list compositionRectangle top // list lineGrid + 1.
	topDelimiter == nil ifFalse: [trialSelection _ trialSelection - 1].
	(trialSelection < 1) | (trialSelection > self maximumSelection)
		ifTrue: [^ nil]
		ifFalse: [^ trialSelection]! !

!ListView methodsFor: 'updating' stamp: 'ssa 1/22/2010 14:49'!
update: aSymbol 
        "Refer to the comment in View|update:."
        "Hacked to support MSWScrollBars - ssa 12/11/97 16:42"

        aSymbol  == #list
                ifTrue: 
                        [self list: model list.
                        self displayView]
                ifFalse:[
                        aSymbol == #listIndex
                                ifTrue: 
                                        [self moveSelectionBox: model listIndex]].
        (self superView isKindOf: MSWScrollBarView)
                ifTrue:[self superView updateElevator]! !

!ListView methodsFor: 'accessing' stamp: 'ssa 1/29/2010 13:43'!
isEmpty
	"Answer the value of isEmpty"

	isEmpty isNil ifTrue:[self isEmpty: nil].
	^ isEmpty! !

!ListView methodsFor: 'accessing' stamp: 'ssa 1/29/2010 13:43'!
isEmpty: anObject
	"Set the value of isEmpty"

	isEmpty _ anObject! !

!ListView methodsFor: 'accessing' stamp: 'ssa 1/29/2010 13:43'!
textStyle
	"Answer the value of textStyle"

	textStyle isNil ifTrue:[self textStyle: nil].
	^ textStyle! !

!ListView methodsFor: 'accessing' stamp: 'ssa 1/29/2010 13:43'!
textStyle: anObject
	"Set the value of textStyle"

	textStyle _ anObject! !

!ListView methodsFor: '*Interface-MSWLook'!
percentPreceedingContent
        "Answer the percent of my content that not visible since it has been scrolled of the top of the screen.  ssa 12/5/97 15:37"

        | para lineIndex |
        para _ self list.
        lineIndex _ para lineIndexOfTop: para visibleRectangle top.
        lineIndex = 1 ifTrue:[^0.0].
        ^lineIndex / para numberOfLines asFloat
! !

!ListView methodsFor: '*Interface-MSWLook'!
scrollBy: anInteger 
        "Scroll up by this amount adjusted by lineSpacing and list limits"
        "Hacked to support MSWScrollBarView - ssa 12/10/97 16:26"

        | maximumAmount minimumAmount amount |
        maximumAmount _ 0 max:
                list clippingRectangle top - list compositionRectangle top.
        minimumAmount _ 0 min:
                list clippingRectangle bottom - list compositionRectangle bottom.
        amount _ (anInteger min: maximumAmount) max: minimumAmount.
        amount ~= 0
                ifTrue: [list scrollBy: amount negated.
                                (self superView isKindOf: MSWScrollBarView)  "______HERE IS THE HACK"
                                        ifTrue:[self superView updateElevator].
                          ^ true]
                ifFalse: [^ false]  "Return false if no scrolling took place"! !

!ListView methodsFor: '*Interface-MSWLook' stamp: 'ssa 9/9/2009 15:24'!
totalContentHeight
        "Answer the total height of my contents. ssa 12/5/97 15:16"
        ^ self list compositionRectangle height / self unitContentHeight! !

!ListView methodsFor: '*Interface-MSWLook'!
unitContentHeight
        "Answer the unit height of my contents. ssa 12/5/97 15:16"
        ^ self list lineGrid asFloat! !

!ListView methodsFor: '*Interface-MSWLook'!
visibleContentHeight
        "Answer the total height of my contents. ssa 12/5/97 15:16"
        ^ self list clippingRectangle height / self unitContentHeight! !

!LongTestCase commentStamp: 'DamirLaurent 5/2/2011 22:17' prior: 0!
I'm a TestCase which takes time to run. I can be disabled using #doNotRunLongTestCases and enabled again using #runLongTestCases.

Tests that are long should be subclasses of myself.

I also provide a setting for the SettingsBrowser!
!LongTestCase class methodsFor: 'accessing' stamp: 'StephaneDucasse 10/18/2010 14:02'!
allTestSelectors
	self shouldRun ifTrue: [
		^super testSelectors].
	^#().! !

!LongTestCase class methodsFor: 'accessing' stamp: 'StephaneDucasse 10/18/2010 12:21'!
doNotRunLongTestCases
	"Tells the system that long tests should not be run"
	
	self shouldRun: false! !

!LongTestCase class methodsFor: 'accessing' stamp: 'StephaneDucasse 10/18/2010 12:21'!
runLongTestCases
	"Tell the system that long tests should be run"
	
	self shouldRun: true.! !

!LongTestCase class methodsFor: 'accessing' stamp: 'DamirLaurent 5/2/2011 21:33'!
shouldRun
	"Return whether long tests should be run or not"
	
	RunLongTestCases ifNil: [self runLongTestCases].
	^ RunLongTestCases ! !

!LongTestCase class methodsFor: 'accessing' stamp: 'StephaneDucasse 10/18/2010 12:21'!
shouldRun: aBoolean
	"Set whether long tests should be run or not"
	
	RunLongTestCases := aBoolean! !

!LongTestCase class methodsFor: 'initialization' stamp: 'DamirLaurent 5/2/2011 21:32'!
initialize

	self runLongTestCases! !

!LongTestCase class methodsFor: 'instance creation' stamp: 'StephaneDucasse 10/18/2010 14:02'!
buildSuite

	| suite |
	suite := self suiteClass new.
	self shouldRun ifTrue: [
		self addToSuiteFromSelectors: suite].
	^suite! !

!LongTestCase class methodsFor: 'settings' stamp: 'DamirLaurent 5/2/2011 21:59'!
runLongTestsSettingOn: aBuilder
	"<systemsettings>"
	
	(aBuilder setting: #shouldRun)
		target: self;
		parent: #pharoSystem;
		label: 'Run Long Tests' translated;
		description: 'Whether to run long SUnit TestCase. Tests which take long time to run should be subclasses of LongTestCase.' translated.! !

!LongTestCase class methodsFor: 'testing' stamp: 'md 2/22/2006 14:21'!
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self name = #LongTestCase
			! !

!LongTestCaseTest methodsFor: 'setup'!
setUp

	longTestCaseSettingValue := LongTestCase shouldRun! !

!LongTestCaseTest methodsFor: 'setup'!
tearDown

	LongTestCase shouldRun: longTestCaseSettingValue! !

!LongTestCaseTest methodsFor: 'testing'!
testLongTestCaseDoNotRun
	"self debug: #testLongTestCaseDoNotRun"
	"self run: #testLongTestCaseDoNotRun"

	LongTestCase doNotRunLongTestCases.
	LongTestCaseTestUnderTest markAsNotRun.
	self deny: LongTestCaseTestUnderTest hasRun.
	LongTestCaseTestUnderTest suite run.
	self deny: LongTestCaseTestUnderTest hasRun.


	! !

!LongTestCaseTest methodsFor: 'testing' stamp: 'md 12/5/2004 21:28'!
testLongTestCaseRun
	"self debug: #testLongTestCaseRun"
	"self run: #testLongTestCaseRun"

	LongTestCase runLongTestCases.
	LongTestCaseTestUnderTest markAsNotRun.
	self deny: LongTestCaseTestUnderTest hasRun.
	LongTestCaseTestUnderTest suite run.
	self assert: LongTestCaseTestUnderTest hasRun.
	LongTestCase doNotRunLongTestCases.

	! !

!LongTestCaseTestUnderTest methodsFor: 'testing' stamp: 'md 11/14/2004 21:30'!
testWhenRunMarkTestedToTrue


	RunStatus := true.! !

!LongTestCaseTestUnderTest class methodsFor: 'accessing' stamp: 'sd 9/25/2004 14:02'!
hasRun

	^ RunStatus! !

!LongTestCaseTestUnderTest class methodsFor: 'accessing' stamp: 'md 11/14/2004 21:37'!
markAsNotRun

	^ RunStatus := false! !

!LyGraphicsLibrary class methodsFor: 'importing' stamp: 'ssa 8/28/2009 20:36'!
fileReaderServicesForFile: fullName suffix: suffix

	^(#('gif' 'jpg' 'jpeg' 'bmp')includes: suffix)
		ifTrue: [ self services]
		ifFalse: [#()]! !

!LyGraphicsLibrary class methodsFor: 'importing' stamp: 'ssa 3/9/2010 12:42'!
importGraphic: fileName
	"self importGraphic:'/Users/samadams/Desktop/ssa working/lockClosed.gif'"
	| fname image selector |
	fname _ fileName sansPeriodSuffix.
	selector _ fname copyFrom: (fname lastIndexOf:$/)+ 1 to: fname size.
	image _ Form fromFileNamed: fileName.
	self installGraphic: image named: selector.
! !

!LyGraphicsLibrary class methodsFor: 'importing' stamp: 'ssa 11/26/2009 22:54'!
installGraphic: aForm named: aString
	"add a new method to me named aString that regenerates aForm"
	| selector response code startString |
	startString _ aString  select:[:c| c isLetter | c isDigit].
	selector _ (self respondsTo: startString asSymbol)
		ifTrue:[[response _ FillInTheBlank request:'Selector #',startString,' already used.\Enter a new selector\to store this graphic under' withCRs initialAnswer: startString.
			response isEmpty ifTrue:[^self].
			self respondsTo: response asSymbol] whileTrue.
			response]
		ifFalse:[startString].
	code _ selector,'
	"Cursor blank showWhile:[self ',selector,' follow:[Sensor cursorPoint] while:[Sensor noButtonPressed]]"
	"FormView open: self ',selector,' named: ''',selector,'''"
	^',aForm storeString.

	self class compile: code classified:'graphics'! !

!LyGraphicsLibrary class methodsFor: 'importing' stamp: 'ssa 8/28/2009 19:51'!
serviceImportGraphic

	^SimpleServiceEntry 
		provider: self 
		label: 'import graphic' 
		selector: #importGraphic: 
		description: 'import graphic to LyGraphicLibrary' 
		buttonLabel: 'install'! !

!LyGraphicsLibrary class methodsFor: 'importing' stamp: 'ssa 8/28/2009 19:48'!
services

	^ Array with: self serviceImportGraphic

	! !

!LyGraphicsLibrary class methodsFor: 'graphics' stamp: 'ssa 1/5/2010 20:33'!
selfTwistyClosed
	"Cursor blank showWhile:[self selfTwistyClosed follow:[Sensor cursorPoint] while:[Sensor noButtonPressed]]"
	^((ColorForm
	extent: 5@10
	depth: 8
	fromArray: #( 4278190080 0 4294901760 0 4294967040 0 4294967295 0 4294967295 4278190080 4294967295 4278190080 4294967295 0 4294967040 0 4294901760 0 4278190080 0)
	offset: 0@0)
	colorsFromArray: #(#( ) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0)  ))! !

!LyGraphicsLibrary class methodsFor: 'graphics' stamp: 'ssa 1/5/2010 20:33'!
selfTwistyOpen
	"Cursor blank showWhile:[self selfTwistyOpen follow:[Sensor cursorPoint] while:[Sensor noButtonPressed]]"
	^((ColorForm
	extent: 10@10
	depth: 8
	fromArray: #( 0 4278190080 0 255 4294901760 0 65535 4294901760 0 16777215 4294967040 0 4294967295 4294967040 0 16777215 4294967295 0 255 4294967295 0 0 16777215 4278190080 0 255 4278190080 0 0 16711680)
	offset: 0@0)
	colorsFromArray: #(#( ) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0)  ))! !

!LyGraphicsLibrary class methodsFor: 'graphics' stamp: 'ssa 1/4/2010 16:22'!
workWarningCone
	"Cursor blank showWhile:[self workWarningCone follow:[Sensor cursorPoint] while:[Sensor noButtonPressed]]"
	^((ColorForm
	extent: 64@64
	depth: 8
	fromArray: #( 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4271808092 1549557758 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4266482012 1503549182 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4262222169 1128495870 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 1360216899 1128487254 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 135742239 1128481560 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 136201027 524501875 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 140067651 1128481566 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124109 742605599 1128481624 1459551998 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124040 320806723 524501827 1442774782 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124039 236526106 522133279 1442774782 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278079746 269028884 336863007 2052521726 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278084614 33820180 437919519 2544107262 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278059008 21712149 2223281059 2170748670 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4272103936 1610637408 2164359520 23110654 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4267704416 6291457 1616928864 1610711550 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4261412960 16810336 1616928769 2170585598 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4267713120 1610702944 23093344 2172739838 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 2734710784 1616928864 1616904577 1610703011 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 1610637313 1616904193 1619091585 2170585473 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 570458368 16810336 2170585440 1619067265 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 23093377 1619067232 1610702977 2172748198 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124116 177443713 2172748161 2172748161 2744355443 1459551998 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124109 135807833 1451853446 2256950614 1499225210 1912536830 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124040 656296259 1128481603 1130125660 1547918402 1912536830 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124071 675496771 1229144905 1128483139 1229538140 503250686 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278079752 356729667 1128483139 1128874825 1128483145 1938554622 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278085416 356731203 1128874825 1128483139 1229538121 2054094590 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278061095 407061315 1128481603 1128874825 1128483139 1131347710 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4269886504 505356063 1128481603 1128481603 1126113091 1230222590 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4267728903 1126111775 438247199 1126122271 522133315 2309198590 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4261437536 2205032218 521805599 438247199 524506515 2743173630 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4261478400 1619104405 2223409430 1433306757 2510520705 2172739838 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 2164285441 1610702977 1652654465 2172748161 2172752513 2172748195 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 1616904288 2170577025 1610711425 2172748161 2457960833 2173862273 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 6316128 1610702977 2170585473 2172748161 2172748178 2172748161 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124195 16777312 23093249 1619067265 1652646529 2173862273 2172748161 2784952062 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124128 6324481 1619100000 2172748161 2172748161 2172748161 2457960800 2751397630 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124132 1616928864 1619091585 2172748130 2172740242 2172752513 1619100033 2516516606 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124040 1684013408 2170552672 2164359553 2172748161 2172748161 1650483787 754908926 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278080551 1292416129 25264513 1619100033 2172748161 2173862290 2170683692 676855550 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124051 270422312 673012102 3028386177 1686208897 2173862290 2172756901 2536256029 946883070 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 671615244 507651880 742015836 1549183400 3030627491 2745414822 2996280648 1112087881 743721308 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278059779 134752019 1127876648 675891523 1229538121 1230784638 2120173897 1230981449 1229537353 493902409 1229586174 4278124286 4278124286 4278124286 4278124286 4278124286 4262200071 134875678 523380520 357122889 1128876355 1229539657 1229539657 1598638409 1229539423 1465152329 1128876542 4278124286 4278124286 4278124286 4278124286 4278124286 4268950279 134752286 1126705192 843663683 1229146441 1229146441 1229544521 1230981471 1229539657 1517383241 1230784841 1560215294 4278124286 4278124286 4278124286 4278124286 4266930691 134875706 1126639660 977486665 1229539651 1229539657 1548306780 1229545289 1600080223 1517383772 1229539679 1228938750 4278124286 4278124286 4278124286 4278124286 4278085939 134875667 1126639656 1212760905 1128876361 1229539657 1230784841 1598643273 1598644060 2117628255 1230784841 1598044211 4278124286 4278124286 4278124286 4278124286 4278124145 1846151692 405219111 1109346627 1128874825 1128876380 1229539679 1230784860 1229539679 1483823689 1548306780 1228943922 4278124286 4278124286 4278124286 4278124286 4278124286 2388069385 167912236 524492611 1128483139 1229146441 1229539657 1229539651 1128487260 2119671369 1229545289 1545418808 3221159678 4278124286 4278124286 4278124286 4278124286 4272786956 51387734 1549344579 524492611 1128481603 1128481603 1128481603 1130121632 1520322889 1230981468 1079676573 3388931838 4278124286 4278124286 4278124286 4278124286 4278095517 320020034 1549556825 1128481603 524501827 1128481603 1497586780 1549574304 1598638409 1598644128 2695732618 4278124286 4278124286 4278124286 4278124286 4278124286 4278124205 2685616926 1130143327 2656853081 1549556060 1499225180 1549753439 2694864713 1598638409 2694884768 2915041022 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 2911781407 522142537 1553883040 2657067100 2690621600 2694881375 1599889225 1235263661 2695741950 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4273778012 522133315 1128874825 1230784860 1549551945 1128481628 1229545376 2912985276 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124205 1547902751 1128481603 1128874825 1128481567 1128483164 2695736749 2919169790 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 2908504863 522142531 1126122271 1128481603 1549574317 2913861374 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4272791625 1128472387 524501827 1128488096 2913840583 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278100128 1547913539 1229146460 2694884781 3170828030 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124205 2912985248 2694884781 2696740606 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4273778080 2694888702 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286 4278124286)
	offset: 0@0)
	colorsFromArray: #(#(1.0 1.0 1.0) #(0.972 0.878 0.815) #(0.972 0.815 0.627) #(0.972 0.784 0.564) #(0.972 0.784 0.47) #(0.972 0.753 0.595) #(0.972 0.753 0.501) #(0.972 0.721 0.564) #(0.972 0.721 0.501) #(0.972 0.721 0.313) #(0.972 0.69 0.439) #(0.972 0.69 0.282) #(0.972 0.658 0.408) #(0.972 0.658 0.376) #(0.972 0.658 0.156) #(0.972 0.627 0.376) #(0.972 0.627 0.345) #(0.972 0.627 0.313) #(0.972 0.627 0.125) #(0.972 0.595 0.282) #(0.972 0.595 0.094) #(0.972 0.564 0.313) #(0.972 0.564 0.219) #(0.972 0.533 0.188) #(0.972 0.533 0.125) #(0.972 0.533 0.063) #(0.972 0.533 0.031) #(0.972 0.533 0.0) #(0.972 0.501 0.0) #(0.972 0.47 0.219) #(0.972 0.47 0.063) #(0.972 0.47 0.031) #(0.94 0.94 0.972) #(0.94 0.94 0.94) #(0.94 0.909 0.878) #(0.94 0.753 0.627) #(0.94 0.721 0.533) #(0.94 0.69 0.501) #(0.94 0.69 0.47) #(0.94 0.658 0.501) #(0.94 0.658 0.439) #(0.94 0.627 0.47) #(0.94 0.627 0.439) #(0.94 0.627 0.408) #(0.94 0.595 0.408) #(0.94 0.595 0.376) #(0.94 0.595 0.345) #(0.94 0.564 0.376) #(0.94 0.564 0.345) #(0.94 0.564 0.282) #(0.94 0.533 0.345) #(0.94 0.533 0.25) #(0.94 0.501 0.313) #(0.94 0.501 0.282) #(0.94 0.501 0.219) #(0.94 0.501 0.188) #(0.94 0.47 0.25) #(0.94 0.47 0.188) #(0.94 0.47 0.156) #(0.94 0.47 0.0) #(0.94 0.439 0.188) #(0.94 0.439 0.094) #(0.94 0.439 0.063) #(0.94 0.439 0.0) #(0.94 0.408 0.156) #(0.94 0.408 0.125) #(0.94 0.408 0.063) #(0.94 0.408 0.031) #(0.94 0.408 0.0) #(0.94 0.376 0.094) #(0.94 0.376 0.031) #(0.94 0.376 0.0) #(0.94 0.345 0.063) #(0.94 0.313 0.031) #(0.94 0.313 0.0) #(0.909 0.784 0.627) #(0.909 0.721 0.564) #(0.909 0.658 0.47) #(0.909 0.658 0.408) #(0.909 0.627 0.47) #(0.909 0.627 0.439) #(0.909 0.595 0.408) #(0.909 0.595 0.376) #(0.909 0.564 0.282) #(0.909 0.533 0.345) #(0.909 0.501 0.188) #(0.909 0.47 0.156) #(0.909 0.408 0.188) #(0.909 0.408 0.063) #(0.909 0.408 0.0) #(0.909 0.376 0.156) #(0.909 0.376 0.063) #(0.909 0.345 0.031) #(0.909 0.345 0.0) #(0.909 0.313 0.031) #(0.909 0.282 0.0) #(0.878 0.878 0.909) #(0.878 0.878 0.878) #(0.878 0.847 0.847) #(0.878 0.847 0.815) #(0.878 0.815 0.753) #(0.878 0.784 0.721) #(0.878 0.721 0.595) #(0.878 0.658 0.501) #(0.878 0.627 0.501) #(0.878 0.595 0.47) #(0.878 0.533 0.376) #(0.878 0.533 0.313) #(0.878 0.533 0.219) #(0.878 0.501 0.313) #(0.878 0.501 0.282) #(0.878 0.501 0.25) #(0.878 0.47 0.313) #(0.878 0.47 0.282) #(0.878 0.47 0.25) #(0.878 0.47 0.219) #(0.878 0.47 0.188) #(0.878 0.439 0.25) #(0.878 0.439 0.219) #(0.878 0.439 0.188) #(0.878 0.439 0.156) #(0.878 0.439 0.125) #(0.878 0.439 0.094) #(0.878 0.408 0.156) #(0.878 0.408 0.125) #(0.878 0.376 0.125) #(0.878 0.345 0.094) #(0.878 0.313 0.0) #(0.878 0.282 0.0) #(0.847 0.847 0.847) #(0.847 0.815 0.815) #(0.847 0.69 0.627) #(0.847 0.627 0.408) #(0.847 0.595 0.408) #(0.847 0.564 0.345) #(0.847 0.564 0.313) #(0.847 0.501 0.345) #(0.847 0.501 0.25) #(0.847 0.439 0.282) #(0.847 0.439 0.219) #(0.847 0.408 0.156) #(0.847 0.408 0.125) #(0.847 0.345 0.063) #(0.847 0.313 0.063) #(0.815 0.815 0.847) #(0.815 0.815 0.815) #(0.815 0.784 0.753) #(0.815 0.69 0.595) #(0.815 0.69 0.564) #(0.815 0.658 0.564) #(0.815 0.595 0.439) #(0.815 0.533 0.408) #(0.815 0.533 0.345) #(0.815 0.501 0.313) #(0.815 0.439 0.25) #(0.815 0.408 0.219) #(0.815 0.376 0.156) #(0.815 0.345 0.125) #(0.815 0.345 0.0) #(0.815 0.313 0.0) #(0.815 0.282 0.031) #(0.815 0.282 0.0) #(0.815 0.25 0.0) #(0.784 0.784 0.753) #(0.784 0.753 0.784) #(0.784 0.721 0.69) #(0.784 0.69 0.627) #(0.784 0.658 0.595) #(0.784 0.627 0.533) #(0.784 0.501 0.345) #(0.784 0.313 0.094) #(0.784 0.313 0.0) #(0.784 0.282 0.063) #(0.784 0.282 0.031) #(0.784 0.25 0.0) #(0.753 0.753 0.753) #(0.753 0.69 0.658) #(0.753 0.658 0.564) #(0.753 0.595 0.501) #(0.753 0.25 0.0) #(0.721 0.721 0.721) #(0.721 0.69 0.69) #(0.721 0.595 0.564) #(0.721 0.595 0.533) #(0.721 0.408 0.156) #(0.69 0.313 0.125) #(0.69 0.25 0.031) #(0.69 0.25 0.0) #(0.69 0.219 0.0) #(0.658 0.345 0.188) #(0.658 0.313 0.125) #(0.658 0.282 0.094) #(0.658 0.25 0.063) #(0.658 0.219 0.0) #(0.627 0.313 0.156) #(0.627 0.25 0.063) #(0.627 0.219 0.031) #(0.595 0.376 0.282) #(0.595 0.25 0.063) #(0.595 0.188 0.0) #(0.564 0.533 0.533) #(0.564 0.219 0.063) #(0.564 0.188 0.0) #(0.533 0.533 0.533) #(0.533 0.501 0.501) #(0.533 0.156 0.0) #(0.47 0.439 0.439) #(0.47 0.408 0.345) #(0.47 0.345 0.313) #(0.47 0.282 0.188) #(0.47 0.219 0.031) #(0.47 0.188 0.031) #(0.47 0.156 0.0) #(0.439 0.408 0.376) #(0.439 0.219 0.125) #(0.439 0.188 0.094) #(0.439 0.156 0.063) #(0.439 0.156 0.031) #(0.439 0.125 0.0) #(0.408 0.188 0.063) #(0.408 0.156 0.031) #(0.408 0.125 0.0) #(0.376 0.345 0.313) #(0.376 0.313 0.282) #(0.376 0.125 0.0) #(0.345 0.345 0.345) #(0.345 0.282 0.282) #(0.313 0.313 0.313) #(0.313 0.313 0.282) #(0.313 0.094 0.0) #(0.282 0.094 0.0) #(0.25 0.25 0.25) #(0.25 0.125 0.031) #(0.25 0.063 0.0) #(0.219 0.219 0.219) #(0.219 0.188 0.188) #(0.219 0.156 0.125) #(0.219 0.125 0.063) #(0.219 0.125 0.0) #(0.219 0.094 0.031) #(0.219 0.063 0.0) #(0.188 0.188 0.188) #(0.188 0.063 0.0) #(0.156 0.156 0.156) #(0.156 0.031 0.0) #(0.125 0.063 0.031) #(0.125 0.031 0.0) #(0.094 0.094 0.094) #(0.094 0.063 0.063) #(0.094 0.031 0.0) #(0.063 0.031 0.031) #(0.063 0.0 0.0) #(0.031 0.031 0.031) #(0.0 0.0 0.0) #( ) #(0.0 0.0 0.0)  ))! !

!LyGraphicsLibrary class methodsFor: 'transforming' stamp: 'ssa 8/31/2009 12:30'!
audition: selector
	"self audition: #rgbAddButton"
	"Audition a graphic, resizing it dynamically based on its screen x location, Answering the resized icon"
	
	| resized |
	Sensor waitNoButton.
	Cursor blank show.
	[Sensor noButtonPressed]
		whileTrue:[ resized _ self graphicNamed: selector resizedTo: Sensor cursorPoint.
			resized follow:[Sensor cursorPoint] while:[false]].
	Cursor normal show.
	^resized! !

!LyGraphicsLibrary class methodsFor: 'transforming' stamp: 'ssa 8/31/2009 13:14'!
graphicNamed: selector resizedTo: anExtentPoint
	"(self graphicNamed: #rgbAddButton resizedTo: 16@16) followCursor"
	"(self graphicNamed: #rgbAddButton resizedTo: 400@400) followCursor"

	| base resized |
	base _ self perform: selector.
	resized _ base scaledToSize: anExtentPoint.
	resized offset: (base offset/ base extent) * resized offset rounded.
	^resized! !

!LyGraphicsLibrary class methodsFor: 'transforming' stamp: 'ssa 8/31/2009 17:19'!
graphicNamed: selector withWhitemappedTo: aColor 
	"(self graphicNamed: #closedTwisty withWhitemappedTo: Color lightBlue) followCursor"
	"(self graphicNamed: #closedTwisty withWhitemappedTo: Color green) followCursor"

	| base |
	base _ self perform: selector.
	base mapColor: Color white to: aColor.
	^base! !

!LyPluggableOutlineController methodsFor: 'selecting' stamp: 'ssa 9/9/2009 16:35'!
redButtonActivity
	
	super redButtonActivity.
	self view twistyTargets keys detect:[:box| box containsPoint: Sensor cursorPoint] ifNone:[^self].
	self model toggleSelection! !

!LyPluggableOutlineView methodsFor: 'accessing' stamp: 'ssa 9/9/2009 10:58'!
boxFor: index
	"Answer the rectangle in which the item is displayed."
	
	| offset |
	offset _ (index - 1 + (topDelimiter == nil ifTrue: [0] ifFalse: [1]))* list lineGrid.
	^(self insetDisplayBox left @ (list compositionRectangle top +offset) 
		extent: self insetDisplayBox width @ list lineGrid)
		insetBy: (Rectangle left: 1 right: 1 top: 1 bottom: 0)! !

!LyPluggableOutlineView methodsFor: 'accessing' stamp: 'ssa 9/9/2009 10:52'!
getChildrenSelector
	"Answer the value of getChildrenSelector"

	getChildrenSelector isNil ifTrue:[self getChildrenSelector: #subobjects].
	^ getChildrenSelector! !

!LyPluggableOutlineView methodsFor: 'accessing' stamp: 'ssa 9/9/2009 10:51'!
getChildrenSelector: anObject
	"Set the value of getChildrenSelector"

	getChildrenSelector _ anObject! !

!LyPluggableOutlineView methodsFor: 'accessing' stamp: 'ssa 3/1/2010 12:28'!
indentBoxFor: index
	"Answer the rectangle which counds the whitespace in front of the item at this index"
	
	| itemBox indents |
	itemBox _ self boxFor: index.
	indents _ self indentFor:(self objects at: index).
	
	^itemBox width: (Paragraph withText: indents asText style: self textStyle)  boundingBox width.! !

!LyPluggableOutlineView methodsFor: 'accessing' stamp: 'ssa 9/9/2009 14:42'!
indentFor: anItem

	| aStream |
	aStream _ WriteStream on:''.
	(self levelOf: anItem) timesRepeat:[aStream tab].
	^aStream contents,'    '! !

!LyPluggableOutlineView methodsFor: 'accessing' stamp: 'ssa 9/10/2009 16:00'!
labelForItem: anItem
	"Subclasses may want to override"

	^(self indentFor: anItem),anItem outlineString! !

!LyPluggableOutlineView methodsFor: 'accessing' stamp: 'ssa 9/9/2009 11:59'!
levelOf: anItem

	^self model levelOf: anItem! !

!LyPluggableOutlineView methodsFor: 'accessing' stamp: 'ssa 9/9/2009 16:25'!
twistyTargets
	"Answer the value of twistyTargets"

	twistyTargets isNil ifTrue:[self twistyTargets: Dictionary new].
	^ twistyTargets! !

!LyPluggableOutlineView methodsFor: 'accessing' stamp: 'ssa 9/9/2009 16:24'!
twistyTargets: anObject
	"Set the value of twistyTargets"

	twistyTargets _ anObject! !

!LyPluggableOutlineView methodsFor: 'displaying' stamp: 'ssa 9/11/2009 17:06'!
displayTwisties

	| box isOpen twisty to firstIndex |
	firstIndex _ self firstShown.
	firstIndex to: ((self list numberOfLines - 2)min:(firstIndex + self numSelectionsInView )) do:[:index|
		(self model hasChildren: (self objects at: index)) ifTrue:[ 
			box _ self indentBoxFor: index.
			isOpen _ self model isOpen:(self objects at: index).
			twisty _ isOpen ifTrue:[self openedTwistyIcon]ifFalse:[self closedTwistyIcon].
			twisty
				displayOn: Display
				at: (to_box topRight - (twisty width@0))
				clippingBox: (box intersect: self clippingBox)
				rule: Form paint
				fillColor: nil.
			self twistyTargets at:(to extent: twisty extent) put: index]].! !

!LyPluggableOutlineView methodsFor: 'displaying' stamp: 'ssa 1/22/2010 14:03'!
displayView

	self list foregroundColor: self foregroundColor backgroundColor: self backgroundColor.
	self list displayOn: Display at: self insetDisplayBox origin - (0@self scrollCache) clippingBox: self insetDisplayBox.
	(self insetDisplayBox copy areasOutside: (self insetDisplayBox origin extent: self list compositionRectangle   extent )) do:[:box| Display fill: box fillColor: Color white].
	self displayTwisties.
	! !

!LyPluggableOutlineView methodsFor: 'displaying' stamp: 'ssa 11/25/2009 12:55'!
positionList

	list wrappingBox: self wrappingBox  clippingBox: self clippingBox! !

!LyPluggableOutlineView methodsFor: 'icons' stamp: 'ssa 9/9/2009 13:33'!
closedTwistyIcon

	^LyGraphicsLibrary selfTwistyClosed! !

!LyPluggableOutlineView methodsFor: 'icons' stamp: 'ssa 9/9/2009 13:33'!
openedTwistyIcon

	^LyGraphicsLibrary selfTwistyOpen! !

!LyPluggableOutlineView methodsFor: 'scrolling support' stamp: 'ssa 11/25/2009 12:36'!
scrollBy: anInteger 

	super scrollBy: anInteger .
	self displayTwisties.
	^true! !

!LyPluggableOutlineView methodsFor: 'controller access' stamp: 'ssa 9/9/2009 16:34'!
defaultControllerClass

	^LyPluggableOutlineController! !

!LyPluggableOutlineView methodsFor: 'controller access' stamp: 'ssa 9/9/2009 16:28'!
defaultCsntrollerClass

	^LyPluggableOutlineController! !

!MSWLookTransporter methodsFor: 'initializing' stamp: 'sm 3/10/2011 12:25'!
initialize
	self initializePackage.
	self initializePreambleAndPostscript.
	self initializeTeam.! !

!MSWLookTransporter methodsFor: 'initializing' stamp: 'sm 3/9/2011 16:48'!
initializePackage
	self package: (PackageInfo named: 'Interface-MSWLook').! !

!MSWLookTransporter methodsFor: 'initializing' stamp: 'sm 3/11/2011 11:34'!
initializePreambleAndPostscript
	self
		preambleBlock: [:file | PackageWhoseContentsMustBeTransportedInOrder 
								new 
									saveClassAndMethodModificationsInOrder: self
									trickyModificationsThatNeedToBeDoneInOrder on: file];
		postscriptBlock: [:file | 	
			file nextPutAll: '"Just using some of the things of the MSWLook, not the actual systems view."'; cr.
			file nextPutAll: 'MSWSystemView unInstall.'; cr.
		].! !

!MSWLookTransporter methodsFor: 'initializing' stamp: 'sm 3/9/2011 17:05'!
initializeTeam
	self team: (ProjectTeam new
				initialsOfProjectMembers: {'dmu'. 'smu'. 'ssa'. 'ads'. 'sm'. 'piv'. 'max'};
		
				"The Renaissance image is based on Squeak 3.7, which was put out in 2004; the Renaissance project started in 2007 or 2008.
				 I don't understand why some of our methods are stamped 1970, though. -- Adam"
				timestampFilter: [:t | t year > 2005 or: [t year = 1970]]; 
		
				yourself).! !

!MSWLookTransporter methodsFor: 'initializing' stamp: 'sm 5/31/2011 14:14'!
trickyModificationsThatNeedToBeDoneInOrder
	"TODO: STEFAN find a better way to manage these changes, don't want to change method category, and this seems to be the only way for now to track those changes to core"
	
	^ {
		{ 'ScrollController'. 'controlInitialize' }.
		{ 'ScrollController'. 'controlTerminate' }.
		{ 'ScrollController'. 'controlActivity' }.
		{ 'ScrollController'. 'isControlActive' }.
		{ 'ScrollController'. 'moveMarker' }.
		{ 'ScrollController'. 'moveMarkerTo:' }.
		
		{ 'StandardSystemView class'. 'new' }.

		{ 'StandardSystemController' }.
		{ 'StandardSystemController'. 'adjustWindowCorners' }.
		{ 'StandardSystemController'. 'checkForReframe' }.
		
		{ 'StringHolderView' }.
		{ 'StringHolderView'. 'updateDisplayContents' }.
		{ 'StringHolderView class'. 'open:label:' }.
				
		{ 'ParagraphEditor'. 'controlActivity' }.
		{ 'ParagraphEditor'. 'scrollView:' }.
		
		{ 'Preferences class'. 'enable:'  }.
		
		{ 'Character class'. 'arrowDown' }.
		{ 'Character class'. 'arrowLeft' }.
		{ 'Character class'. 'arrowRight' }.
		{ 'Character class'. 'arrowUp' }.
		{ 'Character class'. 'escape' }.
		{ 'Character class'. 'nbsp' }.
		{ 'Character class'. 'pageDown' }.
		{ 'Character class'. 'pageUp' }.
		
		{ 'PluggableTextView class'. 'on:text:accept:readSelection:menu:' }.
		{  'PluggableListView class'. 'on:list:selected:changeSelected:menu:keystroke:' }.
		{  'DisplayTextView class'. 'open:label:' }.
		{  'DisplayTextView class'. 'example2' }.
		
		{ 'FileList class'. 'open' }.
		{ 'ParagraphEditor'. 'updateMarker' }.
		{ 'View'. 'unlock' }.


	}! !

!MSWScrollBarController methodsFor: 'delays' stamp: 'ssa 1/15/98 13:51'!
defaultUnitScrollDelay
        "Answer the delay to use when unit scrolling, i.e., pressing the up or down button."

        ^Delay forMilliseconds: 50! !

!MSWScrollBarController methodsFor: 'delays' stamp: 'ssa 1/15/98 13:52'!
wait

        self defaultUnitScrollDelay wait! !

!MSWScrollBarController methodsFor: 'accessing' stamp: 'ssa 8/22/2009 15:13'!
elevatorBox
        "Compute this each time since the view content my change."

        | box originY extentY |
        box _ self view elevatorShaft.
        extentY _ self viewToScroll  percentVisibleContent * box height.
        originY _  (self viewToScroll percentPreceedingContent * box height) min: box height - extentY.
        ^(box origin x asInteger @ (box origin y + originY) asInteger max: box origin) extent: ((box extent x asInteger @ extentY asInteger) min: box extent max: 10@box width)! !

!MSWScrollBarController methodsFor: 'accessing' stamp: 'ssa 12/5/97 16:00'!
scroller

        ^self viewToScroll controller! !

!MSWScrollBarController methodsFor: 'accessing' stamp: 'ssa 1/15/98 13:50'!
unitScrollDelay
        "<^hOf Delay>"
        "ssa 1/15/98 13:50 - Answer the instance variable, unitScrollDelay"

        unitScrollDelay isNil ifTrue:[self unitScrollDelay: self defaultUnitScrollDelay].
        ^unitScrollDelay! !

!MSWScrollBarController methodsFor: 'accessing' stamp: 'ssa 1/15/98 13:50'!
unitScrollDelay: aDelay 
        "<aDelay: hOf Delay, ^self>"
        "ssa 1/15/98 13:50 - Set unitScrollDelay to be aDelay."

        unitScrollDelay _ aDelay! !

!MSWScrollBarController methodsFor: 'accessing' stamp: 'ssa 12/5/97 14:40'!
viewToScroll

        ^self view subViews first! !

!MSWScrollBarController methodsFor: 'scrolling' stamp: 'ssa 12/5/97 16:07'!
pageDown
        "Scroll down by one page length."
        self scroller scrollView: self pageHeight negated.
        self view updateElevator! !

!MSWScrollBarController methodsFor: 'scrolling' stamp: 'ssa 12/5/97 16:00'!
pageHeight
        "Answer the height of a page for the scrolling view."

        ^self viewToScroll displayBox height! !

!MSWScrollBarController methodsFor: 'scrolling' stamp: 'ssa 8/27/2009 07:11'!
pageUp
        "Scroll up by one page length."
       self scroller scrollView: self pageHeight.
        self view updateElevator! !

!MSWScrollBarController methodsFor: 'scrolling' stamp: 'stp 2/18/98 13:50'!
reallyScrollAbsolute

        | height center offset |
        center _ self view elevatorBox center y.
        offset _ (center - Sensor cursorPoint y). 
        height _ self view elevatorShaft height.
        (self viewToScroll percentPreceedingContent ~= 0.0 or:
                        [self viewToScroll percentVisibleContent < 1.0])
                ifTrue:[self scroller scrollView: ((offset / height) 
                                * (self scroller view totalContentHeight 
                                        * self scroller view unitContentHeight)) asInteger.
                        self view updateElevator]! !

!MSWScrollBarController methodsFor: 'scrolling' stamp: 'stp 2/18/98 13:53'!
scrollAbsolute
        | lastY thisY |
        [Sensor redButtonPressed]
                whileTrue:  
                        [thisY := Sensor cursorPoint y.
                        lastY isNil
                                ifTrue: [lastY := thisY.
                                        self reallyScrollAbsolute]
                                ifFalse: [lastY = thisY
                                        ifFalse: [lastY := thisY.
                                                self reallyScrollAbsolute]]]! !

!MSWScrollBarController methodsFor: 'scrolling' stamp: 'ssa 1/15/98 13:54'!
unitDown
        "Scroll down by one content unit."

        self view displayDownButtonPressed.
        [Sensor redButtonPressed] whileTrue:[
                self scroller scrollView: self unitHeight negated.
                self view updateElevator.
                self wait].
        self view displayDownButton.
! !

!MSWScrollBarController methodsFor: 'scrolling' stamp: 'ssa 12/5/97 16:00'!
unitHeight
        "Answer the height of a content unit for the scrolling view."

        ^self viewToScroll unitContentHeight! !

!MSWScrollBarController methodsFor: 'scrolling' stamp: 'ssa 1/15/98 13:54'!
unitUp
        "Scroll up by one content unit."

        self view displayUpButtonPressed.
        [Sensor redButtonPressed] whileTrue:[
                self scroller scrollView: self unitHeight.
                self view updateElevator.
                self wait].
        self view displayUpButton.
! !

!MSWScrollBarController methodsFor: 'control activity' stamp: 'ssa 1/8/98 16:28'!
controlActivity 
        "Refer to the comment in Controller|controlActivity."

        (Sensor redButtonPressed and:[self view scrollBarBox containsPoint: Sensor cursorPoint])
                                ifTrue: [^self redButtonActivity].
        super controlActivity
! !

!MSWScrollBarController methodsFor: 'control activity' stamp: 'ssa 8/27/2009 04:44'!
redButtonActivity

        | point |
"       self scroller view visibleContentHeight >= (self scroller view totalContentHeight + 2)
                ifTrue:[^self]."
        point _ Sensor cursorPoint.
        (self view upButtonBox containsPoint: point)
                ifTrue:[^self unitUp].
        (self view downButtonBox containsPoint: point)
                ifTrue:[^self unitDown].
        (self view elevatorBox containsPoint: point)
                ifTrue:[^self scrollAbsolute].
	
        self view elevatorBox center y > point y
                ifTrue:[self wait.  self pageUp]
                ifFalse:[self wait.   self pageDown].

! !

!MSWScrollBarController methodsFor: 'delegation' stamp: 'ssa 8/21/2009 12:55'!
doesNotUnderstand: aMessage
        "Here it comes, the dreaded doesNotUnderstand:  HACK   ssa 1/23/98 14:55"

        ^self viewToScroll controller perform: aMessage selector withArguments: aMessage arguments! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 11/30/2009 17:33'!
backgroundColor: aColor
	"Blow the caches"
	super backgroundColor: aColor.
	self elevatorCache:nil.
	self downButtonCache: nil.
	self upButtonCache: nil.
	! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/5/97 12:24'!
downButtonBox
        "<^hOf Rectangle>"
        "ssa 12/5/97 11:15 - Answer the instance variable, downButtonBox"

        downButtonBox isNil ifTrue:[self downButtonBox: self determineDownButtonBox].
        ^downButtonBox! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/5/97 11:15'!
downButtonBox: aRectangle 
        "<aRectangle: hOf Rectangle, ^self>"
        "ssa 12/5/97 11:15 - Set downButtonBox to be aRectangle."

        downButtonBox _ aRectangle! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/11/97 11:46'!
downButtonCache
        "<^hOf Form>"
        "ssa 12/11/97 11:43 - Answer the instance variable, downButtonCache"

        downButtonCache isNil ifTrue:[self downButtonCache: (Form extent:1@1)].
        ^downButtonCache! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/11/97 11:43'!
downButtonCache: aColorForm 
        "<aColorForm: hOf ColorForm, ^self>"
        "ssa 12/11/97 11:43 - Set downButtonCache to be aColorForm."

        downButtonCache _ aColorForm! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/5/97 16:29'!
elevatorBox
        "Answer the rectangle for the elevator."

        ^self controller elevatorBox! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 9/9/2009 16:45'!
elevatorCache
        "<^hOf Form>"
        "ssa 12/10/97 16:32 - Answer the instance variable, elevatorCache"

        elevatorCache isNil ifTrue:[self elevatorCache: (Form extent:1@1)].
        ^elevatorCache ! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/10/97 16:32'!
elevatorCache: aForm 
        "<aForm: hOf Form, ^self>"
        "ssa 12/10/97 16:32 - Set elevatorCache to be aForm."

        elevatorCache _ aForm! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/5/97 14:18'!
elevatorShaft
        "<^hOf Rectangle>"
        "ssa 12/5/97 14:18 - Answer the instance variable, elevatorShaft"

        elevatorShaft isNil ifTrue:[self elevatorShaft: self determineElevatorShaft].
        ^elevatorShaft! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/5/97 14:18'!
elevatorShaft: aRectangle 
        "<aRectangle: hOf Rectangle, ^self>"
        "ssa 12/5/97 14:18 - Set elevatorShaft to be aRectangle."

        elevatorShaft _ aRectangle! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/11/97 12:43'!
getWindow
        "This is here to break a recursive loop caused by the indirection of my display transformation."
        self window isNil ifTrue:[self window: Display boundingBox].
        ^self window! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 8/27/2009 04:51'!
model: aModel

	model ~~ nil & (model ~~ aModel)
		ifTrue: [model removeDependent: self].
	aModel ~~ nil & (aModel ~~ model)
		ifTrue: [aModel addDependent: self].
	model _ aModel.
! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/5/97 11:28'!
scrollBarBox
        "<^hOf Rectangle>"
        "ssa 12/5/97 11:15 - Answer the instance variable, scrollBarBox"

        scrollBarBox isNil ifTrue:[self scrollBarBox: self determineScrollBarBox].
        ^scrollBarBox! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/5/97 11:15'!
scrollBarBox: aRectangle 
        "<aRectangle: hOf Rectangle, ^self>"
        "ssa 12/5/97 11:15 - Set scrollBarBox to be aRectangle."

        scrollBarBox _ aRectangle! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/10/97 14:05'!
scrollBarWidth
        "<^hOf Integer>"
        "ssa 12/5/97 11:27 - Answer the instance variable, scrollBarWidth"

        scrollBarWidth isNil ifTrue:[self scrollBarWidth: 12].
        ^scrollBarWidth! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/5/97 11:27'!
scrollBarWidth: anInteger 
        "<anInteger: hOf Integer, ^self>"
        "ssa 12/5/97 11:27 - Set scrollBarWidth to be anInteger."

        scrollBarWidth _ anInteger! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 1/24/98 16:06'!
scrollingView

        ^self subViews isEmpty ifTrue:[nil] ifFalse:[self subViews first]! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/5/97 13:59'!
upButtonBox
        "<^hOf Rectangle>"
        "ssa 12/5/97 11:15 - Answer the instance variable, upButtonBox"

        upButtonBox isNil ifTrue:[self upButtonBox: self determineUpButtonBox].
        ^upButtonBox! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/5/97 11:15'!
upButtonBox: aRectangle 
        "<aRectangle: hOf Rectangle, ^self>"
        "ssa 12/5/97 11:15 - Set upButtonBox to be aRectangle."

        upButtonBox _ aRectangle! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/11/97 11:46'!
upButtonCache
        "<^hOf Form>"
        "ssa 12/11/97 11:43 - Answer the instance variable, upButtonCache"

        upButtonCache isNil ifTrue:[self upButtonCache: (Form extent:1@1)].
        ^upButtonCache! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/11/97 11:43'!
upButtonCache: aColorForm 
        "<aColorForm: hOf ColorForm, ^self>"
        "ssa 12/11/97 11:43 - Set upButtonCache to be aColorForm."

        upButtonCache _ aColorForm! !

!MSWScrollBarView methodsFor: 'accessing' stamp: 'ssa 12/11/97 12:44'!
window
        "This is here to break a recursive loop caused by the indirection of my display transformation."
        window isNil ifTrue:[self window: Display boundingBox].
        ^window! !

!MSWScrollBarView methodsFor: 'bordering' stamp: 'ssa 1/24/98 16:05'!
borderWidth: anything

        super borderWidth:1.
! !

!MSWScrollBarView methodsFor: 'control defaults' stamp: 'stp 02/18/98 0-11:'!
defaultControllerClass

        ^MSWScrollBarController! !

!MSWScrollBarView methodsFor: 'delegation' stamp: 'ssa 1/23/98 14:56'!
doesNotUnderstand: aMessage
        "Here it comes, the dreaded doesNotUnderstand:  HACK   ssa 1/23/98 14:55"

        ^self scrollingView perform: aMessage selector withArguments: aMessage arguments! !

!MSWScrollBarView methodsFor: 'delegation' stamp: 'ssa 3/24/2010 14:37'!
update: aSymbol
	self topView ifNotNil:[self topView isCollapsed ifFalse:[self updateElevator]].
	super update: aSymbol.
	"self subViews do:[:each| each update: aSymbol]"! !

!MSWScrollBarView methodsFor: 'delegation' stamp: 'ssa 1/21/2010 12:24'!
update: aSymbol with: aValue

	self updateElevator.
	super update: aSymbol  with: aValue.
	"self subViews do:[:each| each update: aSymbol with: aValue]"! !

!MSWScrollBarView methodsFor: 'delegation' stamp: 'ssa 8/27/2009 04:55'!
updateListsAndCodeIn: aWindow
	self updateElevator.
	super  updateListsAndCodeIn: aWindow.
	^self subViews first updateListsAndCodeIn: aWindow! !

!MSWScrollBarView methodsFor: 'display box access' stamp: 'ssa 8/27/2009 09:29'!
determineDownButtonBox
        "Answer the rectangle for the scroll bar down button."

        ^self scrollBarBox corner -  self scrollBarBox width asPoint extent: (self scrollBarBox width)asPoint! !

!MSWScrollBarView methodsFor: 'display box access' stamp: 'ssa 12/5/97 12:38'!
determineElevatorBox
        "Answer the rectangle for the scroll bar elevator."

        ^self scrollBarBox center -  (self scrollBarWidth asPoint // 2) extent: self scrollBarWidth asPoint! !

!MSWScrollBarView methodsFor: 'display box access' stamp: 'ssa 12/5/97 14:19'!
determineElevatorShaft
        "Answer the rectangle for the scroll bar down button."

        ^self upButtonBox bottomLeft corner: self downButtonBox topRight! !

!MSWScrollBarView methodsFor: 'display box access' stamp: 'ssa 12/5/97 12:47'!
determineScrollBarBox
        "Answer the rectangle for the scroll bar region."

        ^(self realInsetDisplayBox areasOutside: self insetDisplayBox) first! !

!MSWScrollBarView methodsFor: 'display box access' stamp: 'ssa 12/5/97 12:52'!
determineUpButtonBox
        "Answer the rectangle for the scroll bar up button."

        ^self scrollBarBox origin extent: self scrollBarBox width asPoint! !

!MSWScrollBarView methodsFor: 'display box access'!
displayBox
        "tah -- (17 July 1989 6:37:46 pm ) -- Answer the real displayBox"

        ^self realInsetDisplayBox expandBy: borderWidth! !

!MSWScrollBarView methodsFor: 'display box access' stamp: 'ssa 2/27/98 11:10'!
insetDisplayBox
        "Answer the inset displayBox reduced by the horizontal space for the scroll bar"

       ^WhereToLocateScrollBars = #left
                        ifTrue:[self insetDisplayBoxLeft]
                        ifFalse:[self insetDisplayBoxRight]! !

!MSWScrollBarView methodsFor: 'display box access' stamp: 'ssa 2/27/98 11:09'!
insetDisplayBoxLeft
        "Answer the inset displayBox reduced by the horizontal space for the scroll bar"

        | box |
        box _ self realInsetDisplayBox.
        ^box origin extent: box width - (self borderWidth left  + self scrollBarWidth) @ box height

! !

!MSWScrollBarView methodsFor: 'display box access' stamp: 'ssa 2/27/98 11:10'!
insetDisplayBoxRight
        "Answer the inset displayBox reduced by the horizontal space for the scroll bar"
        "Changed to left-side scroll bars--stp."
        "MSWScrollBarView someInstance"

        | box |
        box _ self realInsetDisplayBox.
        ^((box left + self scrollBarWidth) @ box top)
                extent: (box width - (self borderWidth left + self scrollBarWidth) @ box height)
! !

!MSWScrollBarView methodsFor: 'display box access' stamp: 'ssa 12/15/97 14:50'!
realInsetDisplayBox
        "tah -- (17 July 1989 6:05:48 pm ) -- answer the real inset displayBox "

        ^super insetDisplayBox! !

!MSWScrollBarView methodsFor: 'display transformation'!
displayTransform: anObject 
        "Apply the display transformation of the receiver to anObject (see 
        View|displayTransformation) and answer the resulting scaled, translated 
        object. It is normally applied to Rectangles, Points, and other objects with 
        coordinates defined in the View's local coordinate system in order to get a 
        corresponding object in display coordinates."

        ^(self realDisplayTransformation applyTo: anObject) rounded! !

!MSWScrollBarView methodsFor: 'display transformation' stamp: 'ssa 12/15/97 14:49'!
displayTransformation
        "This is a hook for to get the real displayTransformation"

        ^self scrollBarWidth = 0
                ifTrue: [self realDisplayTransformation]
                ifFalse: [WindowingTransformation window: self getWindow viewport: (self realInsetDisplayBox expandBy: self borderWidth)]! !

!MSWScrollBarView methodsFor: 'display transformation'!
realDisplayTransformation
        "This is a hook for labeledView to get the real displayTransformation"

        ^super displayTransformation! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 9/9/2009 16:44'!
deEmphasizeView

        super deEmphasizeView ! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 12/11/97 13:13'!
displayDownButton
        | box |
        box _ self downButtonBox.
        self downButtonCache extent = box extent
                ifFalse:[self drawDownButton].
        self downButtonCache displayOn: Display at: box origin! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 1/20/98 21:45'!
displayDownButtonPressed
        | box cf bb |
        box _ self downButtonBox.
        Display fill: box fillColor: Color darkGray.
        Display fill: (box origin + (2 @ 2) corner: box corner - (1 @ 1))
                fillColor: Color gray.
        cf _ ColorForm mappingWhiteToTransparentFrom: (Form
                                        extent: 13 @ 13
                                        depth: 1
                                        fromArray: #(0 0 0 0 0 260046848 117440512 33554432 0 0 0 0 0 )
                                        offset: 0 @ 0).
        bb _ BitBlt
                                destForm: Display
                                sourceForm: cf
                                fillColor: Color black
                                combinationRule: Form paint
                                destOrigin: box origin + 2
                                sourceOrigin: 0 @ 0
                                extent: cf extent
                                clipRect: box truncated.
        bb copyBits! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 9/9/2009 17:02'!
displayElevatorOn: aForm
        | box shaft |
        box _ self elevatorBox.
	shaft _ self elevatorShaft.
        self elevatorCache extent = box extent
                ifFalse:[self drawElevator].
        self elevatorCache displayOn: aForm at: box origin - shaft origin! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 9/9/2009 16:52'!
displayElevatorShaftOn: aForm

        | box |
        box _ self elevatorShaft.
         aForm fill: (0@0 extent: box extent) fillColor: self backgroundColor darker darker
! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 12/11/97 13:18'!
displayUpButton
        | box |
        box _ self upButtonBox.
        self upButtonCache extent = box extent
                ifFalse:[self drawUpButton].
        self upButtonCache displayOn: Display at: box origin! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 1/20/98 21:45'!
displayUpButtonPressed
        | box cf bb |
        box _ self upButtonBox.
        Display fill: box fillColor: Color darkGray.
        Display fill: (box origin + (2 @ 2) corner: box corner - (1 @ 1))
                fillColor: Color gray.
        cf _ ColorForm mappingWhiteToTransparentFrom: (Form
                                        extent: 13 @ 13
                                        depth: 1
                                        fromArray: #(0 0 0 0 0 33554432 117440512 260046848 0 0 0 0 0 )
                                        offset: 0 @ 0).
        bb _ BitBlt
                                destForm: Display
                                sourceForm: cf
                                fillColor: Color black
                                combinationRule: Form paint
                                destOrigin: box origin + 2
                                sourceOrigin: 0 @ 0
                                extent: cf extent
                                clipRect: box truncated.
        bb copyBits! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 9/9/2009 16:58'!
displayView


        self displayUpButton.
        self displayDownButton.
        self updateElevator
! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 8/27/2009 09:30'!
drawDownButton
        | box pen cf bb form |
        form _ Form extent: self downButtonBox extent depth: Display depth.
        box _ form boundingBox.
        pen _ Pen new.
        pen destForm: form.
        pen color: Color black.
        pen place: box bottomLeft.
        pen goto: box topLeft.
        pen goto: box topRight. 
        pen color: Color black.
        pen place: box bottomLeft + (1 @ 0).
        pen goto: box topLeft + 1.
        pen goto: box topRight + (0 @ 1).
        pen color: Color black.
        pen place: box bottomLeft + (1 @ 1 negated).
        pen goto: box bottomRight - (1 @ 1).
        pen goto: box topRight + (1 negated @ 1).
        pen color: Color black.
        pen place: box bottomLeft.
        pen goto: box bottomRight.
        pen goto: box topRight.
        form fill: (box origin + (2 @ 2) corner: box corner - (1 @ 1))
                fillColor: self backgroundColor.
        cf _ ColorForm mappingWhiteToTransparentFrom: (Form
                                        extent: 13 @ 13
                                        depth: 1
                                        fromArray: #(0 0 0 0 0 260046848 117440512 33554432 0 0 0 0 0 )
                                        offset: 0 @ 0).
        bb _ BitBlt
                                destForm: form
                                sourceForm: cf
                                fillColor: Color black
                                combinationRule: Form paint
                                destOrigin: box origin + 1
                                sourceOrigin: 0 @ 0
                                extent: cf extent
                                clipRect: box truncated.
        bb copyBits.
        self downButtonCache: form! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 8/21/2009 13:03'!
drawElevator
        | box pen form |
        form _ Form extent: self controller elevatorBox extent depth: Display depth.
        box _ form boundingBox.
        pen _ Pen new.
        pen destForm: form.
        pen color: self backgroundColor.
        pen place: box bottomLeft. 
        pen goto: box topLeft.
        pen goto: box topRight.
        pen color: Color black.
        pen place: box bottomLeft + (1 @ 0).
        pen goto: box topLeft + 1.
        pen goto: box topRight + (0 @ 1).
        pen color: Color black.
        pen place: box bottomLeft + (1 @ 1 negated).
        pen goto: box bottomRight - (1 @ 1).
        pen goto: box topRight + (1 negated @ 1).
        pen color: Color black.
        pen place: box bottomLeft.
        pen goto: box bottomRight.
        pen goto: box topRight.
        form fill: (box origin + (2 @ 2) corner: box corner - (1 @ 1))
                fillColor: self backgroundColor.
        self elevatorCache: form! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 8/21/2009 13:03'!
drawUpButton
        | box pen cf bb form |
        form _ Form extent: self upButtonBox extent depth: Display depth.
        box _ form boundingBox.
        pen _ Pen new.
        pen destForm: form.
        pen color: self backgroundColor.
        pen place: box bottomLeft.
        pen goto: box topLeft.
        pen goto: box topRight. 
        pen color: Color black.
        pen place: box bottomLeft + (1 @ 0).
        pen goto: box topLeft + 1.
        pen goto: box topRight + (0 @ 1).
        pen color: Color black.
        pen place: box bottomLeft + (1 @ 1 negated).
        pen goto: box bottomRight - (1 @ 1).
        pen goto: box topRight + (1 negated @ 1).
        pen color: Color black.
        pen place: box bottomLeft.
        pen goto: box bottomRight.
        pen goto: box topRight.
        form fill: (box origin + (2 @ 2) corner: box corner - (1 @ 1))
                fillColor: self backgroundColor.
        cf _ ColorForm mappingWhiteToTransparentFrom: (Form
                                        extent: 13 @ 13
                                        depth: 1
                                        fromArray: #(0 0 0 0 0 33554432 117440512 260046848 0 0 0 0 0 )
                                        offset: 0 @ 0).
        bb _ BitBlt
                                destForm: form
                                sourceForm: cf
                                fillColor: Color black
                                combinationRule: Form paint
                                destOrigin: box origin + 1
                                sourceOrigin: 0 @ 0
                                extent: cf extent
                                clipRect: box truncated.
        bb copyBits.
        self upButtonCache: form! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 9/9/2009 16:46'!
emphasizeView

        self displayView.
        super emphasizeView! !

!MSWScrollBarView methodsFor: 'displaying' stamp: 'ssa 9/9/2009 15:18'!
updateElevator
       | newForm |

	newForm _ Form fromDisplay: self elevatorShaft.
	self displayElevatorShaftOn: newForm.
        self displayElevatorOn: newForm.
	newForm displayOn: Display at: self elevatorShaft origin! !

!MSWScrollBarView methodsFor: 'lock access' stamp: 'ssa 12/5/97 16:10'!
unlock
        "Flush the cache."
        self scrollBarBox: nil.
        self upButtonBox: nil.
        self downButtonBox: nil.
        self elevatorShaft: nil.
        super unlock! !

!MSWScrollBarView methodsFor: 'subview additions' stamp: 'ssa 1/15/98 15:50'!
addSubView: aView in: aRelativeRectangle borderWidth: width
        "11/3/96 ssa - added for compatibility."
 
        "Make 'aView' into a subview. Use 'aRelativeRectangle' and the 
        super view's window to compute (1) a viewport within the 
        superview for 'aView' and (2) the window extent for 'aView'. Note: 
        defining the windowing transformation and deriving the viewport is 
        logically equivalent but does not seem to be easily done"

        | subViewPort myWindow myExtent myOrigin |
        self addSubView: aView ifCyclic: [self error: 'cycle in subView structure.'].
        aView borderWidth: width.
        myWindow _ self window.
        myExtent _ myWindow extent.
        myOrigin _ myWindow origin.
        subViewPort _ myExtent * aRelativeRectangle origin + myOrigin 
                                                corner: myExtent * aRelativeRectangle corner + myOrigin.
        aView window: aView window viewport: subViewPort
! !

!MSWScrollBarView methodsFor: 'subview additions' stamp: 'ssa 8/27/2009 04:49'!
on: aView
        "tah -- (17 July 1989 7:17:34 pm ) -- Add a subview to this view"

        self on: aView borderWidth: 0.
	self model: aView model! !

!MSWScrollBarView methodsFor: 'subview additions'!
on: aView borderWidth: aBorderWidth
        "tah -- (17 July 1989 7:17:34 pm ) -- Add a subview to this view"

        self addSubView: aView in: (0@0 extent: (1@1)) borderWidth: aBorderWidth! !

!MSWScrollBarView methodsFor: 'testing' stamp: 'ssa 1/8/98 16:13'!
containsPoint: aPoint
        "Overriden to access my real insetDsiplayBox"

        ^ self realInsetDisplayBox containsPoint: aPoint! !

!MSWScrollBarView class methodsFor: 'instance creation' stamp: 'ssa 3/24/2010 15:07'!
on: aScrollingView
        "<aScrollingView: {hOf ListView | hOf TextView | hOf StringHolderView | hOf ParagraphEditor | hOf CodeView | hOf PPSListView | hOf SelectionInListView}, ^iOf self>"
        "Answer an instance of me that encapsulates aScrollingView by providing Windows-style scroll bars"

       ^aScrollingView class == self class   "prevent scrollbars on scrolbars"
		ifTrue:[aScrollingView error:'should never try to embed scrollbar views']
		ifFalse:[self new on: aScrollingView]! !

!MSWScrollBarView class methodsFor: 'class initialization' stamp: 'ssa 1/5/2010 18:10'!
initialize
        "Make an initial decision as to which side to locate the scrollbars.  See preferences to change sides."

        self locateScrollBarsOnRightSide! !

!MSWScrollBarView class methodsFor: 'preferences' stamp: 'ssa 2/27/98 11:40'!
locateScrollBarsOnLeftSide
        "Set the flag to locate the ScrollBars on the left hand side of the view."
        "MSWScrollBarView locateScrollBarsOnLeftSide"

        | openWindows |
        WhereToLocateScrollBars _ #left.
        self allInstances do:[:each| each unlock].
        openWindows _ ScheduledControllers controllersSatisfying:
                [:each| (each view  respondsTo:#isCollapsed)
                                and:[each view isCollapsed not]].
        openWindows reverseDo:[:each| each view uncacheBits display].
        ScheduledControllers restore! !

!MSWScrollBarView class methodsFor: 'preferences' stamp: 'ssa 2/27/98 11:39'!
locateScrollBarsOnRightSide
        "Set the flag to locate the ScrollBars on the right hand side of the view."
        "MSWScrollBarView locateScrollBarsOnRightSide"

        | openWindows |
        WhereToLocateScrollBars _ #right.
        self allInstances do:[:each| each unlock].
        openWindows _ ScheduledControllers controllersSatisfying:
                [:each| (each view  respondsTo:#isCollapsed)
                                and:[each view isCollapsed not]].
        openWindows reverseDo:[:each| each view uncacheBits display].
        ScheduledControllers restore! !

!MSWSystemController methodsFor: 'accessing' stamp: 'ar 1/22/98 23:30'!
lastSystemActivity
        ^lastSystemActivity ifNil:[lastSystemActivity _ 0]! !

!MSWSystemController methodsFor: 'accessing' stamp: 'ar 1/22/98 23:30'!
lastSystemActivity: aNumber
        lastSystemActivity _ aNumber! !

!MSWSystemController methodsFor: 'basic control sequence' stamp: 'ssa 9/11/2009 16:36'!
redButtonActivity
	| box p |
	p _ sensor cursorPoint.
	  ((box _ view systemBoxFrame) containsPoint: p)
			 ifTrue: [^self systemActivity].
	  ((box _ view shrinkBoxFrame) containsPoint: p)
	  		 ifTrue: [Utilities awaitMouseUpIn: box
					repeating: [] ifSucceed: [self collapse. ^ self].
	   				^ self].
	 ((box _ view growBoxFrame) containsPoint: p)
			ifTrue: [Utilities awaitMouseUpIn: box repeating: [] ifSucceed:	[view isCollapsed
				 ifTrue:[self expand]
			      ifFalse:[view isFullScreen 
						ifTrue:[self restore] 
						ifFalse:[self fullScreen]].
				 ^ self].
		   ^ self].
	 super redButtonActivity.! !

!MSWSystemController methodsFor: 'basic control sequence' stamp: 'ar 1/22/98
23:33'!
systemActivity  "The system menu button has been pressed"       | time |
        time _ Time millisecondClockValue.      (time- self lastSystemActivity) < self
doubleClickTime                 ifTrue:[^self close].   self lastSystemActivity: time.  ^self
blueButtonActivity! !

!MSWSystemController methodsFor: 'menu messages' stamp: 'ar 1/22/98 22:41'!
restore
        view restore! !

!MSWSystemController methodsFor: 'private' stamp: 'ar 1/22/98 23:32'!
doubleClickTime
        "Return the maximum delay time for double clicks.
        This value is in milliseconds."
        ^500! !

!MSWSystemController methodsFor: 'borders' stamp: 'ssa 1/25/98 00:00'!
adjustWindowCorners 
        | box cornerBox p clicked f2 |
        box _ view windowBox.
        clicked _ false.
        #(topLeft topRight bottomRight bottomLeft)
                do: [:readCorner |
                        cornerBox _ ((box insetBy: 2) perform: readCorner) - (4@4) extent: 8@8.
                        (cornerBox containsPoint: sensor cursorPoint)
                                ifTrue: 
                                ["Display reverse: cornerBox."
                                (Cursor perform: readCorner) showWhile:
                                        [[(cornerBox containsPoint: (p _ sensor cursorPoint))
                                                and: [(clicked _ sensor anyButtonPressed) not]]
                                                whileTrue.
                                "Display reverse: cornerBox."
                                clicked ifTrue:
                                        [view newFrame:
                                                [:f | p _ sensor cursorPoint.
                                                readCorner = #topLeft ifTrue:
                                                        [f2 _ p corner: f bottomRight].
                                                readCorner = #bottomLeft ifTrue:
                                                        [f2 _ (f withBottom: p y) withLeft: p x].
                                                readCorner = #bottomRight ifTrue:
                                                        [f2 _ f topLeft corner: p].
                                                readCorner = #topRight ifTrue:
                                                        [f2 _ (f withTop: p y) withRight: p x].
                                                f2]]]]].
        ^ clicked! !

!MSWSystemController methodsFor: 'borders' stamp: 'ssa 1/24/98 23:47'!
cursorOnBorder 
        | cp i box |
        view isCollapsed ifTrue: [^ false].
        cp _ sensor cursorPoint.
        ((view labelDisplayBox insetBy: 5@5) containsPoint: cp)
                ifTrue: [^ false].
        (i _ view subViews findFirst: [:v | v displayBox containsPoint: cp]) = 0
                ifTrue: [box _ view windowBox]
                ifFalse: [box _ (view subViews at: i) insetDisplayBox].
        ^ ((box insetBy: 3) containsPoint: cp) not
                and: [(box expandBy: 4) containsPoint: cp]! !

!MSWSystemView methodsFor: 'label accessing' stamp: 'ssa 3/24/2010 16:03'!
closeBoxFrame

        | boxHeight |
        boxHeight _ self labelDisplayBox height -  11.
        ^ Rectangle origin: (self labelDisplayBox topRight + (boxHeight negated-9@7)) extent:
boxHeight+2@boxHeight

        "MSWSystemView initializeCache"! !

!MSWSystemView methodsFor: 'label accessing' stamp: 'ssa 1/24/98 23:35'!
growBoxFrame

        | boxHeight |
        boxHeight _ self labelDisplayBox height -  11.
        ^ Rectangle origin: (self labelDisplayBox topRight + (2*boxHeight negated-12@7)) extent:
boxHeight+2@boxHeight

        "NiceSystemView initializeCache"! !

!MSWSystemView methodsFor: 'label accessing' stamp: 'ssa 2/6/98 14:24'!
labelHeight
        ^self isCollapsed
                ifFalse:[18 + 6]
                ifTrue:[(LabelStyle fontAt: 2) height + 14]! !

!MSWSystemView methodsFor: 'label accessing' stamp: 'ssa 1/24/98 23:56'!
labelTextRegion
        labelText == nil ifTrue: [^ self labelDisplayBox center extent: 0@0].
        ^ (labelText boundingBox
                        align: labelText boundingBox leftCenter
                        with: self labelDisplayBox leftCenter + (25@0))
                intersect: (self labelDisplayBox origin corner: self labelDisplayBox corner -
(55@0))! !

!MSWSystemView methodsFor: 'label accessing' stamp: 'ssa 1/24/98 23:34'!
shrinkBoxFrame

        | boxHeight |
        boxHeight _ self labelDisplayBox height -  11.
        ^ Rectangle origin: (self labelDisplayBox topRight + (3*boxHeight negated-15@7)) extent:
boxHeight+2@boxHeight

        "NiceSystemView initializeCache"! !

!MSWSystemView methodsFor: 'label accessing' stamp: 'ssa 1/24/98 23:17'!
systemBoxFrame

        | boxHeight |
        boxHeight _ self labelDisplayBox height - 11 .
        ^ Rectangle origin: (self labelDisplayBox origin + (7@7)) extent:
boxHeight@boxHeight

        "NiceSystemView initializeCache"! !

!MSWSystemView methodsFor: 'framing' stamp: 'stp 02/18/98 0-15:'!
collapse
        "If the receiver is not already collapsed, change its view to be that of its 
        label only."

        self isCollapsed ifFalse:
                        [expandedViewport _ self viewport.
                        savedSubViews _ subViews.
                        self resetSubViews.
                        labelText isNil ifTrue: [self label: nil.  bitsValid _ false.].
                        self window: (self inverseDisplayTransform:
                                        ((self labelDisplayBox topLeft extent: (labelText extent x + 80) @ self labelHeight)
                                                 intersect: self labelDisplayBox))]! !

!MSWSystemView methodsFor: 'framing' stamp: 'ar 1/22/98 22:47'!
fullScreen
        | portRect |
        portRect _ self viewport.
        growFrame _ portRect topLeft - self labelOffset
                                corner: portRect corner.
        ^super fullScreen! !

!MSWSystemView methodsFor: 'framing' stamp: 'ar 1/22/98 22:49'!
restore
        self reframeTo: ( growFrame isNil ifTrue:[self initialFrame]
ifFalse:[growFrame])! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ssa 3/24/2010 15:27'!
deEmphasizeLabel
        "Un-Highlight the label."
        labelFrame height = 0 ifTrue: [^ self].  "no label"
        self displayLabelBackground: false.
        self displayLabelTextDeEmphasized.
        self displayLabelBorder.
	self displayClosingGuardBoxIfNeeded.
! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ssa 3/24/2010 15:32'!
displayClosingGuardBoxIfNeeded
	"display closing guard active, if true"
	
	| aRect |
	self controller preventClosing ifTrue:[
		aRect _ self closeBoxFrame.
		self closingGuardIcon displayOn: Display at: aRect origin + (2@1) clippingBox: aRect rule: Form over fillColor: nil].
! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ssa 3/24/2010 15:42'!
displayDeEmphasizedOLD
        "Display this view with emphasis off.
        If windowBits is not nil, then simply BLT if possible,
                but force full display for top window so color is preserved."

	self displayBorder.
	super displayDeEmphasized.
	self deEmphasizeLabel! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ssa 3/24/2010 15:43'!
displayEmphasizedOLD
        "Display with label highlighted to indicate that it is active."

	self displayBorder.
	super displayEmphasized.
	self emphasizeLabel ! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ssa 3/24/2010 15:41'!
displayLabelBackground: emphasized
        "Clear or emphasize the inner region of the label"

        emphasized
                ifTrue:[Display
                                        fill: self labelDisplayBox
                                        fillColor: self labelBackgroundColor]
                ifFalse:[Display
                                        fill: self labelDisplayBox
                                        fillColor:self labelBackgroundColor darker darker].
                self displayLabelBoxes.
! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ssa 3/24/2010 15:25'!
displayLabelBoxes
        CloseBoxForm ifNil:[CloseBoxForm _ self drawCloseBoxForm].
        GrowBoxForm ifNil:[GrowBoxForm _ self drawGrowBoxForm].
        ShrinkBoxForm ifNil:[ShrinkBoxForm _ self drawShrinkBoxForm].
        SystemBoxForm ifNil:[SystemBoxForm _ self drawSystemBoxForm].
        CloseBoxForm displayOn: Display at: self closeBoxFrame origin.
        GrowBoxForm displayOn: Display at: self growBoxFrame origin.
        self isCollapsed 
                ifFalse:[ShrinkBoxForm displayOn: Display at: self shrinkBoxFrame origin].

        SystemBoxForm displayOn: Display at: self  systemBoxFrame origin.
		"display closing guard active, if true"
	self displayClosingGuardBoxIfNeeded.
! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ssa 3/24/2010 15:41'!
displayLabelText
        "The label goes in the center of the window"
        | labelRect |
        labelText foregroundColor: Color black
                        backgroundColor: self labelBackgroundColor.
        labelRect _ self labelTextRegion.
        "Display fill: (labelRect expandBy: 3@0) fillColor: self labelColor."
        labelText displayOn: Display at: labelRect topLeft +(0@1) clippingBox: labelRect
                        rule: Form under fillColor: labelText fillColor! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ssa 3/24/2010 15:41'!
displayLabelTextDeEmphasized
        | labelRect |
        labelText foregroundColor: Color gray
                        backgroundColor: self labelBackgroundColor.
        labelRect _ self labelTextRegion.
        labelText displayOn: Display at: labelRect topLeft +(0@1) clippingBox: labelRect
                        rule: Form under fillColor: labelText fillColor! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ssa 3/24/2010 15:41'!
displayLabelTextEmphasized
        | labelRect |
        labelText foregroundColor: Color black
                        backgroundColor: self labelBackgroundColor.
        labelRect _ self labelTextRegion.
        labelText displayOn: Display at: labelRect topLeft +(0@1) clippingBox: labelRect
                        rule: Form under fillColor: labelText fillColor! !

!MSWSystemView methodsFor: 'displaying' stamp: 'stp 02/18/98 0-13:'!
drawCloseBoxForm
        "Answer a thinner 'X' for the close box."
        "CloseBoxForm bitEdit"

        ^Form
                extent: 15@13
                depth: 8
                fromArray: #( 50529027 50529027 50529027 50529024 51252750 235802126 235802126 235801600 
                        51249923 50529027 50529027 50531328 51249921 16974595 50528513 50531328 51249923 16843523 
                        50397443 50531328 51249923 50397443 16843523 50531328 51249923 50528513 16974595 50531328 
                        51249923 50397443 16843523 50531328 51249923 16843523 50397443 50531328 51249921 16974595 
                        50528513 50531328 51249923 50529027 50529027 50531328 51249923 50529027 50529027 50531328 
                        51121164 202116108 202116108 202116096)
                offset: 0@0! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ar 1/22/98 22:10'!
drawGrowBoxForm
        | box pen form |
        form _ Form extent: self growBoxFrame extent depth: 8.
        box _ form boundingBox.
        pen _ Pen new.
        pen destForm: form.
        pen color: Color gray.
        pen place: box bottomLeft.
        pen goto: box topLeft.
        pen goto: box topRight.
        pen color: Color veryLightGray.
        pen place: box bottomLeft + (1 @ 0).
        pen goto: box topLeft + 1.
        pen goto: box topRight + (0 @ 1).
        pen color: Color darkGray.
        pen place: box bottomLeft + (1 @ 1 negated).
        pen goto: box bottomRight - (1 @ 1).
        pen goto: box topRight + (1 negated @ 1).
        pen color: Color black.
        pen place: box bottomLeft.
        pen goto: box bottomRight.
        pen goto: box topRight.
        form fill: (box origin + (2 @ 2) corner: box corner - (1 @ 1))
                fillColor: Color gray.
        pen color: Color black.
        pen place: box topLeft + (3@3).
        pen goto: box bottomLeft + (3 @ -3).
        pen goto: box bottomRight + (-3 @ -3).
        pen goto: box topRight + (-3@3).
        pen defaultNib: 2.
        pen place: box topRight + (-4@3).
        pen goto: box topLeft + (3@3).
        ^form! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ar 1/22/98 22:11'!
drawShrinkBoxForm
        | box pen form |
        form _ Form extent: self growBoxFrame extent depth: 8.
        box _ form boundingBox.
        pen _ Pen new.
        pen destForm: form.
        pen color: Color gray.
        pen place: box bottomLeft.
        pen goto: box topLeft.
        pen goto: box topRight.
        pen color: Color veryLightGray.
        pen place: box bottomLeft + (1 @ 0).
        pen goto: box topLeft + 1.
        pen goto: box topRight + (0 @ 1).
        pen color: Color darkGray.
        pen place: box bottomLeft + (1 @ 1 negated).
        pen goto: box bottomRight - (1 @ 1).
        pen goto: box topRight + (1 negated @ 1).
        pen color: Color black.
        pen place: box bottomLeft.
        pen goto: box bottomRight.
        pen goto: box topRight.
        form fill: (box origin + (2 @ 2) corner: box corner - (1 @ 1))
                fillColor: Color gray.
        pen color: Color black.
        pen defaultNib: 2.
        pen place: box bottomRight + (-4 @ -3).
        pen goto: box bottomLeft + (3 @ -3).
        ^form! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ssa 1/24/98 23:09'!
drawSystemBoxForm
        | box pen form |
        form _ Form extent: self systemBoxFrame extent depth: 8.
        box _ form boundingBox.
        pen _ Pen new.
        pen destForm: form.
        pen color: Color gray.
        pen place: box bottomLeft.
        pen goto: box topLeft.
        pen goto: box topRight.
        pen color: Color veryLightGray.
        pen place: box bottomLeft + (1 @ 0).
        pen goto: box topLeft + 1.
        pen goto: box topRight + (0 @ 1).
        pen color: Color darkGray.
        pen place: box bottomLeft + (1 @ 1 negated).
        pen goto: box bottomRight - (1 @ 1).
        pen goto: box topRight + (1 negated @ 1).
        pen color: Color black.
        pen place: box bottomLeft.
        pen goto: box bottomRight.
        pen goto: box topRight.
        form fill: (box origin + (2 @ 2) corner: box corner - (1 @ 1))
                fillColor: Color gray.
        ^form! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ssa 1/24/98 22:49'!
emphasizeLabel
        "Highlight the label."
        labelFrame height = 0 ifTrue: [^ self].  "no label"
        self displayLabelBackground: true.
        self displayLabelBoxes.
        self displayLabelTextEmphasized.
        self displayLabelBorder! !

!MSWSystemView methodsFor: 'displaying' stamp: 'ssa 3/24/2010 15:44'!
labelBackgroundColor

	^Color veryLightGray lighter! !

!MSWSystemView methodsFor: 'bordering' stamp: 'ssa 3/25/2010 14:30'!
baseColor
	^Color gray ! !

!MSWSystemView methodsFor: 'bordering' stamp: 'ssa 3/25/2010 14:34'!
borderBox: box

	Display border: (box insetBy: 0@0) widthRectangle: (1@1 corner: 0@0) rule: Form paint fillColor: self baseColor.
	Display border: (box insetBy: 0@0) widthRectangle: (0@0 corner: 1@1) rule: Form paint fillColor: self baseColor darker darker darker.
	
	Display border: (box insetBy: 1@1) widthRectangle: (1@1 corner: 0@0) rule: Form paint fillColor: self baseColor lighter.
	Display border: (box insetBy: 1@1) widthRectangle: (0@0 corner: 1@1) rule: Form paint fillColor: self baseColor darker .
	
	Display border: (box insetBy: 2@2) widthRectangle: (1@1 corner: 0@0) rule: Form paint fillColor: self baseColor.
	Display border: (box insetBy: 2@2) widthRectangle: (0@0 corner: 1@1) rule: Form paint fillColor: self baseColor lighter.
! !

!MSWSystemView methodsFor: 'bordering' stamp: 'ssa 3/25/2010 14:39'!
borderBoxNoBottom: box

	Display border: (box insetBy: 0@0) widthRectangle: (1@1 corner: 0@0) rule: Form paint fillColor: self baseColor.
	Display border: (box insetBy: 0@0) widthRectangle: (0@0 corner: 1@0) rule: Form paint fillColor: self baseColor darker darker darker.
	
	Display border: (box insetBy: 1@1) widthRectangle: (1@1 corner: 0@0) rule: Form paint fillColor: self baseColor lighter.
	Display border: (box insetBy: 1@1) widthRectangle: (0@0 corner: 1@0) rule: Form paint fillColor: self baseColor darker .
	
	Display border: (box insetBy: 2@2) widthRectangle: (1@1 corner: 0@0) rule: Form paint fillColor: self baseColor.
	Display border: (box insetBy: 2@2) widthRectangle: (0@0 corner: 1@0) rule: Form paint fillColor: self baseColor lighter.
! !

!MSWSystemView methodsFor: 'bordering' stamp: 'ssa 9/4/1998 16:52'!
borderWidth: anInteger
	"Override to support standard borders"! !

!MSWSystemView methodsFor: 'bordering' stamp: 'ssa 3/25/2010 14:33'!
displayBorder
        "Display the receiver's border (using the receiver's borderColor)."

        | |
        self isCollapsed ifTrue:[^self].
        borderWidth = 0
                ifTrue:
                        [insideColor == nil
                                ifFalse: 
                                        [Display fill: self displayBox fillColor: self backgroundColor]]
                ifFalse:
                        [self borderBox: self displayBox]! !

!MSWSystemView methodsFor: 'bordering' stamp: 'ssa 3/24/2010 17:09'!
displayBorderOLD
        "Display the receiver's border (using the receiver's borderColor)."

        | box |
        self isCollapsed ifTrue:[^self].
        borderWidth = 0
                ifTrue:
                        [insideColor == nil
                                ifFalse: 
                                        [Display fill: self displayBox fillColor: self backgroundColor]]
                ifFalse:
                        [box _ self displayBox.
        "left edge"
        Display fill: (box origin extent: 1@(box height - 1))
                fillColor: Color gray.
        Display fill: (box origin +(1@1) extent: 1@(box height - 2))
                fillColor: Color veryLightGray.
        Display fill: (box origin +(2@2) extent: 2@(box height-4))
                fillColor: Color gray.
        Display fill: (box origin +(4@3) extent: 1@(box height-6))
                fillColor: Color veryDarkGray.
        Display fill: (box origin +(5@4) extent: 1@(box height-8))
                fillColor: Color black.

        "right edge"
        Display fill: (box topRight -(1@0)extent: 1@(box height - 1))
                fillColor: Color black.
        Display fill: (box topRight +(-2@1) extent: 1@(box height - 2))
                fillColor: Color veryDarkGray.
        Display fill: (box topRight +(-4@2) extent: 2@(box height-4))
                fillColor: Color gray.
        Display fill: (box topRight +(-5@5) extent: 1@(box height-10))
                fillColor: Color veryLightGray.
        Display fill: (box topRight +(-6@6) extent: 1@(box height-12))
                fillColor: Color gray.

        "top edge"
        Display fill: (box origin extent: box width@1)
                fillColor: Color gray.
        Display fill: (box origin +(1@1) extent: (box width - 2)@1)
                fillColor: Color veryLightGray.
        Display fill: (box origin +(2@2) extent: (box width-4)@2)
                fillColor: Color gray.
        Display fill: (box origin +(4@4) extent: (box width-8)@1)
                fillColor: Color veryDarkGray.
        Display fill: (box origin +(5@5) extent: (box width-10)@1)
                fillColor: Color black.

        "bottom edge"
        Display fill: (box bottomLeft -(0@1) extent: box width @1)
                fillColor: Color black.
        Display fill: (box bottomLeft +(1 @ -2) extent: (box width - 2)@1)
                fillColor: Color veryDarkGray.
        Display fill: (box bottomLeft +(2 @ -4) extent: (box width-4)@2)
                fillColor: Color gray.
        Display fill: (box bottomLeft +(4 @ -5) extent: (box width-7)@1)
                fillColor: Color veryLightGray.
        Display fill: (box bottomLeft +(5 @ -6) extent: (box width-9)@1)
                fillColor: Color gray.
                        insideColor == nil ifFalse:
                                [Display fill: self insetDisplayBox fillColor: self backgroundColor]]! !

!MSWSystemView methodsFor: 'bordering' stamp: 'ssa 3/25/2010 14:37'!
displayCollaspedLabelBorder
        "Display the receiver's label border."

        | |
        borderWidth = 0
                ifTrue:
                        [insideColor == nil
                                ifFalse: 
                                        [Display fill: self displayBox fillColor: self backgroundColor]]
                ifFalse:
                        [self borderBox: self labelDisplayBox]! !

!MSWSystemView methodsFor: 'bordering' stamp: 'ssa 3/25/2010 14:39'!
displayLabelBorder
        "Display the receiver's label border."

        | |
        self isCollapsed ifTrue:[^self displayCollaspedLabelBorder].
        borderWidth = 0
                ifTrue:
                        [insideColor == nil
                                ifFalse: 
                                        [Display fill: self displayBox fillColor: self backgroundColor]]
                ifFalse:
                        [self borderBoxNoBottom: self labelDisplayBox]! !

!MSWSystemView methodsFor: 'bordering' stamp: 'ssa 3/25/2010 14:32'!
displayLabelBorderOLD
        "Display the receiver's label border."

        | box |
        self isCollapsed ifTrue:[^self displayCollaspedLabelBorder].
        borderWidth = 0
                ifTrue:
                        [insideColor == nil
                                ifFalse: 
                                        [Display fill: self displayBox fillColor: self backgroundColor]]
                ifFalse:
                        [box _ self labelDisplayBox.
        "left edge"
        Display fill: (box origin extent: 1@(box height))
                fillColor: Color gray.
        Display fill: (box origin +(1@1) extent: 1@(box height))
                fillColor: Color veryLightGray.
        Display fill: (box origin +(2@2) extent: 2@(box height))
                fillColor: Color gray.
        Display fill: (box origin +(4@3) extent: 1@(box height))
                fillColor: Color veryDarkGray.
        Display fill: (box origin +(5@4) extent: 1@(box height))
                fillColor: Color black.

        "right edge"
        Display fill: (box topRight -(1@0)extent: 1@(box height))
                fillColor: Color black.
        Display fill: (box topRight +(-2@1) extent: 1@(box height))
                fillColor: Color veryDarkGray.
        Display fill: (box topRight +(-4@2) extent: 2@(box height))
                fillColor: Color gray.
        Display fill: (box topRight +(-5@5) extent: 1@(box height))
                fillColor: Color veryLightGray.
        Display fill: (box topRight +(-6@6) extent: 1@(box height))
                fillColor: Color gray.

        "top edge"
        Display fill: (box origin extent: box width@1)
                fillColor: Color gray.
        Display fill: (box origin +(1@1) extent: (box width - 2)@1)
                fillColor: Color veryLightGray.
        Display fill: (box origin +(2@2) extent: (box width-4)@2)
                fillColor: Color gray.
        Display fill: (box origin +(4@4) extent: (box width-8)@1)
                fillColor: Color veryDarkGray.
        Display fill: (box origin +(5@5) extent: (box width-10)@1)
                fillColor: Color black]! !

!MSWSystemView methodsFor: 'testing' stamp: 'ar 1/22/98 22:07'!
cacheBitsAsTwoTone
        ^false! !

!MSWSystemView methodsFor: 'testing' stamp: 'ar 1/22/98 22:37'!
isFullScreen
        | frame |
        frame _ model fullScreenSize.
        ^(frame topLeft + self labelOffset corner: frame corner) = self viewport
! !

!MSWSystemView methodsFor: 'controller access' stamp: 'stp 02/18/98 0-11:'!
defaultControllerClass
        ^MSWSystemController! !

!MSWSystemView methodsFor: 'initialize' stamp: 'ssa 3/25/2010 14:36'!
initialize
        "change the default border to 3 to support stylish edges."


        super initialize. 
        self borderWidthLeft: 3 right: 3 top: 0 bottom: 3! !

!MSWSystemView methodsFor: 'window access' stamp: 'ssa 8/24/2009 10:13'!
defaultWindow
        "Build the minimum Rectangle that encloses all the windows of the 
        receiver's subViews. The answer is a Rectangle obtained by expanding 
        this minimal Rectangle by the borderWidth of the receiver. If the 
        receiver has no subViews, then a Rectangle enclosing the entire display 
        screen is answered. It is used internally by View methods if no window 
        has been specified for the View. Specialized subclasses of View should 
        redefine View|defaultWindow to handle the default case for instances 
        that have no subViews."

        | aRectangle |
        subViews isEmpty ifTrue: [^DisplayScreen boundingBox copy].
        aRectangle _ self firstSubView viewport.
        subViews do: [:aView | aRectangle _ aRectangle merge: aView viewport].
        ^aRectangle! !

!MSWSystemView class methodsFor: 'class initialization' stamp: 'ssaq 2/27/98 11:17'!
initialize
        "MSWSystemView initialize"

        self install! !

!MSWSystemView class methodsFor: 'class initialization' stamp: 'ssa 2/27/98 11:02'!
initializeCache
        "MSWSystemView initializeCache"
        GrowBoxForm _ nil.
        ShrinkBoxForm _ nil.
        SystemBoxForm _ nil.
        CloseBoxForm _ nil.! !

!MSWSystemView class methodsFor: 'class initialization' stamp: 'ssa 3/24/2010 15:16'!
install
        "MSWSystemView install"
        
        Preferences enable:#nicerSystemViews! !

!MSWSystemView class methodsFor: 'class initialization' stamp: 'ssa 3/24/2010 15:16'!
unInstall
        "MSWSystemView unInstall"

        Preferences disable:#nicerSystemViews! !

!ManyFilesPerClass methodsFor: 'directories' stamp: 'ads 12/2/2010 15:12'!
createDirectoriesFor: cls

	| catDir |
	catDir _ self classCategoryDirFor: cls category.
	classDir _ self createDir: cls name in: catDir mustBeNew: false.
	baseDir _ self createDir: 'base' in: classDir mustBeNew: false.
	metaDir _ self createDir: 'meta' in: classDir mustBeNew: false.! !

!ManyFilesPerClass methodsFor: 'loading' stamp: 'ads 12/10/2010 12:28'!
saveScriptForLoadingPackageBackIn: p
	"Not implemented."! !

!ManyFilesPerClass methodsFor: 'saving' stamp: 'ads 12/2/2010 15:20'!
methodSourceFor: sel in: clsHalf 
	| method |
	method _ clsHalf methodDict at: sel ifAbsent: [^ sel printString, 'CORRUPTED'].
	^ (method getSourceFor: sel in: clsHalf) asString! !

!ManyFilesPerClass methodsFor: 'saving' stamp: 'ads 12/14/2010 14:15'!
saveAllExtensionMethodsForPackage: p
	p extensionMethods asArray do: [:m | | cls catDir |
		cls _ Smalltalk at: m classSymbol.
		self createDirectoriesFor: cls.
		catDir _ self createDir: m category in: (m classIsMeta ifTrue: [metaDir] ifFalse: [baseDir]) mustBeNew: false.
		self saveMethodNamed: m methodSymbol inCategory: m category of: m actualClass in: catDir.
	] displayingProgress: 'Saving ', p name, ' extension methods'.
! !

!ManyFilesPerClass methodsFor: 'saving' stamp: 'ads 12/2/2010 15:18'!
saveCategory: cat of: clsHalf in: dir
	| selectors catDir |
	catDir _ self createDir: cat in: dir mustBeNew: false.
	selectors := (cat asString = ClassOrganizer allCategory)
				ifTrue: [ clsHalf organization allMethodSelectors ]
				ifFalse: [ clsHalf organization listAtCategoryNamed: cat ].
	selectors do: [:sel| self saveMethodNamed: sel inCategory: cat of: clsHalf in: catDir]! !

!ManyFilesPerClass methodsFor: 'saving' stamp: 'ads 12/2/2010 15:14'!
saveClass: cls forPackage: p
	self createDirectoriesFor: cls.
	self saveClassHalf: cls in:  baseDir.
	self saveClassHalf: cls class in:  metaDir! !

!ManyFilesPerClass methodsFor: 'saving' stamp: 'ads 12/5/2010 12:06'!
saveClassHalf: clsHalf in: dir
	self saveClassHalfDefinition: clsHalf in: dir.
	self saveClassHalfComment: clsHalf in: dir.
	self saveClassHalfCategories: clsHalf in: dir
! !

!ManyFilesPerClass methodsFor: 'saving' stamp: 'ads 12/2/2010 15:17'!
saveClassHalfCategories: clsHalf in: dir
	clsHalf organization categories do: [:cat | self saveCategory: cat of: clsHalf in: dir]! !

!ManyFilesPerClass methodsFor: 'saving' stamp: 'ads 12/5/2010 12:10'!
saveClassHalfComment: clsHalf in: dir
	| fs |
	fs _ dir fileNamed: 'comment.txt'.
	fs nextPutAll: clsHalf organization classComment asString.
	fs close.! !

!ManyFilesPerClass methodsFor: 'saving' stamp: 'ads 12/5/2010 12:10'!
saveClassHalfDefinition: clsHalf in: dir
	| fs |
	fs _ dir fileNamed: 'definition.txt'.
	fs nextPutAll: clsHalf definition.
	fs close.! !

!ManyFilesPerClass methodsFor: 'saving' stamp: 'sm 5/2/2011 20:49'!
saveMethodNamed: sel inCategory: cat of: clsHalf in: catDir
	| src fs selOrFoo |
	src := self methodSourceFor: sel in: clsHalf.
	selOrFoo := (sel isKindOf: String) ifTrue: [sel] ifFalse: [sel printString].
	fs := catDir fileNamed: selOrFoo, '.txt'.
	fs nextPutAll: src.
	fs close
	! !

!ManyTestResourceTestCase methodsFor: 'running' stamp: 'nfr 1/3/2010 18:07'!
testTearDownOrder
	| myResourceSetUpOrder myResourceReverseTearDownOrder |
	myResourceReverseTearDownOrder := OrderedCollection new: 7.
	myResourceSetUpOrder := (OrderedCollection new: 7)
		add: SimpleTestResource;
		add: SimpleTestResourceA1;
		add: SimpleTestResourceA2;
		add: SimpleTestResourceA;
		add: SimpleTestResourceB1;
		add: SimpleTestResourceB;
		yourself.
	self
		assert: (myResourceSetUpOrder allSatisfy: [:each | each isAvailable])
		description: 'At test start, not all my resources were set up'.
	self class resources
		do: [:each | each resetOrAddResourcesTo: myResourceReverseTearDownOrder].
	self
		assert: myResourceReverseTearDownOrder = myResourceSetUpOrder
		description: 'Wrong order for tearDown'.
	self
		assert: (myResourceSetUpOrder allSatisfy: [:each | each isAvailable])
		description: 'At test start, not all my resources were set up'! !

!ManyTestResourceTestCase methodsFor: 'utility' stamp: 'NiallRoss 7/18/2010 11:52'!
clearOuterResourceStateDuring: aBlock
	"This self-testing test must clear the outer state of its resources before starting and after finishing, so that it can construct test cases and suites of itself and test them."
	
	self
		assert: SimpleTestResourceA1 isAlreadyAvailable
		description: 'The resource was not set up for the test'.
	SimpleTestResourceA reset.
	SimpleTestResourceB reset.
	SimpleTestResourceA1 reset.
	self
		deny: SimpleTestResourceA1 isAlreadyAvailable
		description: 'The resource was still set up before we began the run'.
	^[super clearOuterResourceStateDuring: aBlock]
		ensure:
			[self
				deny: SimpleTestResourceA1 isAlreadyAvailable
				description: 'The resource was still set up after we finished the run'.
			self
				deny: SimpleTestResourceB1 isAlreadyAvailable
				description: 'The resource was still set up after we finished the run'.
			SimpleTestResourceA isAvailable.
			self
				assert: SimpleTestResourceA1 isAlreadyAvailable
				description: 'The resource was not set up again after the test'.
			SimpleTestResourceB isAvailable.
			self
				assert: SimpleTestResourceB1 isAlreadyAvailable
				description: 'The resource was not set up again after the test']! !

!ManyTestResourceTestCase class methodsFor: 'accessing' stamp: 'nfr 1/3/2010 18:13'!
resources
	^super resources
		, (Array with: SimpleTestResourceA with: SimpleTestResourceB)! !

!ManyTestResourceTestCase class methodsFor: 'testing' stamp: ' 17/7/10 17:28'!
shouldInheritSelectors
	^true! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:37'!
anyOne
	^contents anyOne! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:37'!
at: row at: column
	^contents at: (self indexForRow: row andColumn: column)! !

!Matrix methodsFor: 'accessing' stamp: 'raok 11/28/2002 14:14'!
at: r at: c ifInvalid: v
	"If r,c is a valid index for this matrix, answer the corresponding element.
	 Otherwise, answer v."

	(r between: 1 and: nrows) ifFalse: [^v].
	(c between: 1 and: ncols) ifFalse: [^v].
	^contents at: (r-1)*ncols + c
! !

!Matrix methodsFor: 'accessing' stamp: 'raok 11/22/2002 12:37'!
at: row at: column incrementBy: value
	"Array2D>>at:at:add: was the origin of this method, but in Smalltalk add:
	 generally suggests adding an element to a collection, not doing a sum.
	 This method, and SequenceableCollection>>at:incrementBy: that supports
	 it, have been renamed to reveal their intention more clearly."

	^contents at: (self indexForRow: row andColumn: column) incrementBy: value! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:40'!
at: row at: column put: value
	^contents at: (self indexForRow: row andColumn: column) put: value! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:42'!
atAllPut: value
	contents atAllPut: value! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:43'!
atRandom
	^contents atRandom
! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:43'!
atRandom: aGenerator
	^contents atRandom: aGenerator! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:44'!
columnCount
	^ncols! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:48'!
identityIndexOf: anElement
	^self identityIndexOf: anElement ifAbsent: [0@0]
! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:48'!
identityIndexOf: anElement ifAbsent: anExceptionBlock
	^self rowAndColumnForIndex:
		 (contents identityIndexOf: anElement ifAbsent: [^anExceptionBlock value])
! !

!Matrix methodsFor: 'accessing' stamp: 'raok 11/22/2002 13:13'!
indexOf: anElement
	"If there are integers r, c such that (self at: r at: c) = anElement,
	 answer some such r@c, otherwise answer 0@0.  This kind of perverse
	 result is provided by analogy with SequenceableCollection>>indexOf:.
	 The order in which the receiver are searched is UNSPECIFIED except
	 that it is the same as the order used by #indexOf:ifAbsent: and #readStream."

	^self indexOf: anElement ifAbsent: [0@0]
! !

!Matrix methodsFor: 'accessing' stamp: 'raok 11/22/2002 13:10'!
indexOf: anElement ifAbsent: anExceptionBlock
	"If there are integers r, c such that (self at: r at: c) = anElement,
	 answer some such r@c, otherwise answer the result of anExceptionBlock."

	^self rowAndColumnForIndex:
		 (contents indexOf: anElement ifAbsent: [^anExceptionBlock value])
! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:49'!
replaceAll: oldObject with: newObject
	contents replaceAll: oldObject with: newObject! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:44'!
rowCount
	^nrows! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:49'!
size
	^contents size! !

!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:52'!
swap: r1 at: c1 with: r2 at: c2
	contents swap: (self indexForRow: r1 andColumn: c1)
			 with: (self indexForRow: r2 andColumn: c2)! !

!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/22/2002 12:41'!
atColumn: column
	|p|

	p := (self indexForRow: 1 andColumn: column)-ncols.
	^(1 to: nrows) collect: [:row | contents at: (p := p+ncols)]
! !

!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/28/2002 14:21'!
atColumn: column put: aCollection
	|p|

	aCollection size = nrows ifFalse: [self error: 'wrong column size'].
	p := (self indexForRow: 1 andColumn: column)-ncols.
	aCollection do: [:each | contents at: (p := p+ncols) put: each].
	^aCollection
! !

!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 10/21/2002 23:32'!
atRow: row
	(row between: 1 and: nrows)
		ifFalse: [self error: '1st subscript out of range'].
	^contents copyFrom: (row-1)*ncols+1 to: row*ncols! !

!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/22/2002 12:42'!
atRow: row put: aCollection
	|p|

	aCollection size = ncols ifFalse: [self error: 'wrong row size'].
	p := (self indexForRow: row andColumn: 1)-1.
	aCollection do: [:each | contents at: (p := p+1) put: each].
	^aCollection! !

!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 10/23/2002 20:41'!
diagonal
	"Answer (1 to: (nrows min: ncols)) collect: [:i | self at: i at: i]"
	|i|

	i := ncols negated.
	^(1 to: (nrows min: ncols)) collect: [:j | contents at: (i := i + ncols + 1)]! !

!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/28/2002 14:21'!
swapColumn: anIndex withColumn: anotherIndex
	|a b|

	a := self indexForRow: 1 andColumn: anIndex.
	b := self indexForRow: 1 andColumn: anotherIndex.
	nrows timesRepeat: [
		contents swap: a with: b.
		a := a + ncols.
		b := b + ncols].
! !

!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/28/2002 14:22'!
swapRow: anIndex withRow: anotherIndex
	|a b|

	a := self indexForRow: anIndex andColumn: 1.
	b := self indexForRow: anotherIndex andColumn: 1.
	ncols timesRepeat: [
		contents swap: a with: b.
		a := a + 1.
		b := b + 1].
! !

!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 10/22/2002 00:13'!
transposed
	self assert: [nrows = ncols].
	^self indicesCollect: [:row :column | self at: column at: row]! !

!Matrix methodsFor: 'adding' stamp: 'raok 10/21/2002 22:53'!
add: newObject
	self shouldNotImplement! !

!Matrix methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:01'!
+* aCollection
	"Premultiply aCollection by self.  aCollection should be an Array or Matrix.
	 The name of this method is APL's +.x squished into Smalltalk syntax."

	^aCollection preMultiplyByMatrix: self
! !

!Matrix methodsFor: 'arithmetic' stamp: 'raok 11/28/2002 14:22'!
preMultiplyByArray: a
	"Answer a +* self where a is an Array."

	nrows = 1 ifFalse: [self error: 'dimensions do not conform'].
	^Matrix rows: a size columns: ncols tabulate: [:row :col |
		(a at: row) * (contents at: col)]
! !

!Matrix methodsFor: 'arithmetic' stamp: 'nice 12/27/2009 03:10'!
preMultiplyByMatrix: m
	"Answer m +* self where m is a Matrix."
	

	nrows = m columnCount ifFalse: [self error: 'dimensions do not conform'].
	^Matrix rows: m rowCount columns: ncols tabulate: [:row :col | | s |
		s := 0.
		1 to: nrows do: [:k | s := (m at: row at: k) * (self at: k at: col) + s].
		s]! !

!Matrix methodsFor: 'comparing' stamp: 'raok 11/22/2002 12:58'!
= aMatrix
	^aMatrix class == self class and: [
	 aMatrix rowCount = nrows and: [
	 aMatrix columnCount = ncols and: [
	 aMatrix privateContents = contents]]]! !

!Matrix methodsFor: 'comparing' stamp: 'raok 11/22/2002 13:14'!
hash
	"I'm really not sure what would be a good hash function here.
	 The essential thing is that it must be compatible with #=, and
	 this satisfies that requirement."

	^contents hash! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:57'!
asArray
	^contents shallowCopy! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:57'!
asBag
	^contents asBag! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!
asByteArray
	^contents asByteArray! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!
asCharacterSet
	^contents asCharacterSet! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 23:00'!
asFloatArray
	^contents asFloatArray! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!
asIdentitySet
	^contents asIdentitySet! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 23:00'!
asIntegerArray
	^contents asIntegerArray! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!
asOrderedCollection
	^contents asOrderedCollection! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!
asSet
	^contents asSet! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!
asSortedArray
	^contents asSortedArray! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:59'!
asSortedCollection
	^contents asSortedCollection! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:59'!
asSortedCollection: aBlock
	^contents asSortedCollection: aBlock! !

!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 23:00'!
asWordArray
	^contents asWordArray! !

!Matrix methodsFor: 'converting' stamp: 'raok 11/22/2002 13:02'!
readStream
	"Answer a ReadStream that returns all the elements of the receiver
	 in some UNSPECIFIED order."

	^ReadStream on: contents! !

!Matrix methodsFor: 'copying' stamp: 'raok 11/22/2002 12:57'!
, aMatrix
	"Answer a new matrix having the same number of rows as the receiver and aMatrix,
	 its columns being the columns of the receiver followed by the columns of aMatrix."
	|newCont newCols anArray oldCols a b c|

	self assert: [nrows = aMatrix rowCount].
	newCont := Array new: self size + aMatrix size.
	anArray := aMatrix privateContents.
	oldCols := aMatrix columnCount.
	newCols := ncols + oldCols.
	a := b := c := 1.
	1 to: nrows do: [:r |
		newCont replaceFrom: a to: a+ncols-1 with: contents startingAt: b.
		newCont replaceFrom: a+ncols to: a+newCols-1 with: anArray startingAt: c.
		a := a + newCols.
		b := b + ncols.
		c := c + oldCols].
	^self class rows: nrows columns: newCols contents: newCont
		
! !

!Matrix methodsFor: 'copying' stamp: 'raok 11/22/2002 12:58'!
,, aMatrix
	"Answer a new matrix having the same number of columns as the receiver and aMatrix,
	 its rows being the rows of the receiver followed by the rows of aMatrix."

	self assert: [ncols = aMatrix columnCount].
	^self class rows: nrows + aMatrix rowCount columns: ncols
		contents: contents , aMatrix privateContents
! !

!Matrix methodsFor: 'copying' stamp: 'raok 10/21/2002 23:07'!
copy
	^self class rows: nrows columns: ncols contents: contents copy! !

!Matrix methodsFor: 'copying' stamp: 'nice 10/5/2009 09:09'!
postCopy
	super postCopy.
	contents := contents copy! !

!Matrix methodsFor: 'copying' stamp: 'raok 10/21/2002 23:07'!
shallowCopy
	^self class rows: nrows columns: ncols contents: contents shallowCopy! !

!Matrix methodsFor: 'copying' stamp: 'raok 10/21/2002 23:27'!
shuffled
	^self class rows: nrows columns: ncols contents: (contents shuffled)! !

!Matrix methodsFor: 'copying' stamp: 'raok 10/21/2002 23:27'!
shuffledBy: aRandom
	^self class rows: nrows columns: ncols contents: (contents shuffledBy: aRandom)! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:41'!
collect: aBlock
	"Answer a new matrix with transformed elements; transformations should be independent."

	^self class rows: nrows columns: ncols contents: (contents collect: aBlock)! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:42'!
difference: aCollection
	"Union is in because the result is always a Set.
	 Difference and intersection are out because the result is like the receiver,
	 and with irregular seleection that cannot be."
	self shouldNotImplement! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:40'!
do: aBlock
	"Pass elements to aBlock one at a time in row-major order."
	contents do: aBlock! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/23/2002 20:57'!
indicesCollect: aBlock
	|r i|

	r := Array new: nrows * ncols.
	i := 0.
	1 to: nrows do: [:row |
		1 to: ncols do: [:column |
			r at: (i := i+1) put: (aBlock value: row value: column)]].
	^self class rows: nrows columns: ncols contents: r! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:49'!
indicesDo: aBlock
	1 to: nrows do: [:row |
		1 to: ncols do: [:column |
			aBlock value: row value: column]].! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:51'!
indicesInject: start into: aBlock
	|current|

	current := start.
	1 to: nrows do: [:row |
		1 to: ncols do: [:column |
			current := aBlock value: current value: row value: column]].
	^current! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:42'!
intersection: aCollection
	"Union is in because the result is always a Set.
	 Difference and intersection are out because the result is like the receiver,
	 and with irregular seleection that cannot be."
	self shouldNotImplement! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:42'!
reject: aBlock
	self shouldNotImplement! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:42'!
select: aBlock
	self shouldNotImplement! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/22/2002 00:15'!
with: aCollection collect: aBlock
	"aCollection must support #at:at: and be at least as large as the receiver."

	^self withIndicesCollect: [:each :row :column |
		aBlock value: each value: (aCollection at: row at: column)]
! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:53'!
with: aCollection do: aBlock
	"aCollection must support #at:at: and be at least as large as the receiver."

	self withIndicesDo: [:each :row :column |
		aBlock value: each value: (aCollection at: row at: column)].
! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:55'!
with: aCollection inject: startingValue into: aBlock
	"aCollection must support #at:at: and be at least as large as the receiver."

	^self withIndicesInject: startingValue into: [:value :each :row :column |
		aBlock value: value value: each value: (aCollection at: row at: column)]! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!
withIndicesCollect: aBlock
	|i r|

	i := 0.
	r := contents shallowCopy.
	1 to: nrows do: [:row |
		1 to: ncols do: [:column |
			i := i+1.
			r at: i put: (aBlock value: (r at: i) value: row value: column)]].
	^self class rows: nrows columns: ncols contents: r
! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!
withIndicesDo: aBlock
	|i|

	i := 0.
	1 to: nrows do: [:row |
		1 to: ncols do: [:column |
			aBlock value: (contents at: (i := i+1)) value: row value: column]].
! !

!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!
withIndicesInject: start into: aBlock
	|i current|

	i := 0.
	current := start.
	1 to: nrows do: [:row |
		1 to: ncols do: [:column |
			current := aBlock value: current value: (contents at: (i := i+1)) 
							  value: row value: column]].
	^current! !

!Matrix methodsFor: 'printing' stamp: 'raok 10/21/2002 23:22'!
storeOn: aStream
	aStream nextPut: $(; nextPutAll: self class name;
		nextPutAll: ' rows: '; store: nrows;
		nextPutAll: ' columns: '; store: ncols;
		nextPutAll: ' contents: '; store: contents;
		nextPut: $)! !

!Matrix methodsFor: 'removing' stamp: 'raok 10/21/2002 22:54'!
remove: anObject ifAbsent: anExceptionBlock
	self shouldNotImplement! !

!Matrix methodsFor: 'removing' stamp: 'klub 9/14/2009 16:34'!
removeAll

	self shouldNotImplement! !

!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:24'!
identityIncludes: anObject
	^contents identityIncludes: anObject! !

!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:23'!
includes: anObject
	^contents includes: anObject! !

!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:24'!
includesAllOf: aCollection
	^contents includesAllOf: aCollection! !

!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:24'!
includesAnyOf: aCollection
	^contents includesAnyOf: aCollection! !

!Matrix methodsFor: 'testing' stamp: 'raok 11/22/2002 13:03'!
isSequenceable
	"LIE so that arithmetic on matrices will work.
	 What matters for arithmetic is not that there should be random indexing
	 but that the structure should be stable and independent of the values of
	 the elements.  #isSequenceable is simply the wrong question to ask."
	^true! !

!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:25'!
occurrencesOf: anObject
	^contents occurrencesOf: anObject! !

!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 22:40'!
indexForRow: row andColumn: column
	(row between: 1 and: nrows)
		ifFalse: [self error: '1st subscript out of range'].
	(column between: 1 and: ncols)
		ifFalse: [self error: '2nd subscript out of range'].
	^(row-1) * ncols + column! !

!Matrix methodsFor: 'private' stamp: 'raok 11/22/2002 12:56'!
privateContents
	"Only used in #, #,, and #= so far.
	 It used to be called #contents, but that clashes with Collection>>contents."

	^contents! !

!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 22:47'!
rowAndColumnForIndex: index
	|t|

	t := index - 1.
	^(t // ncols + 1)@(t \\ ncols + 1)! !

!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 23:05'!
rows: rows columns: columns contents: anArray
	self assert: [rows isInteger and: [rows >= 0]].
	self assert: [columns isInteger and: [columns >= 0]].
	self assert: [rows * columns = anArray size].
	nrows := rows.
	ncols := columns.
	contents := anArray.
	^self! !

!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 13:09'!
atRows: rs columns: cs
	"Answer a Matrix obtained by slicing the receiver.
	 rs and cs should be sequenceable collections of positive integers."

	^self class rows: rs size columns: cs size tabulate: [:r :c |
		self at: (rs at: r) at: (cs at: c)]! !

!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 12:30'!
atRows: r1 to: r2 columns: c1 to: c2
	"Answer a submatrix [r1..r2][c1..c2] of the receiver."
	|rd cd|

	rd := r1 - 1.
	cd := c1 - 1.
	^self class rows: r2-rd columns: c2-cd tabulate: [:r :c| self at: r+rd at: c+cd]
! !

!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 13:05'!
atRows: r1 to: r2 columns: c1 to: c2 ifInvalid: element
	"Answer a submatrix [r1..r2][c1..c2] of the receiver.
	 Portions of the result outside the bounds of the original matrix
	 are filled in with element."
	|rd cd|

	rd := r1 - 1.
	cd := c1 - 1.
	^self class rows: r2-rd columns: c2-cd tabulate: [:r :c| self at: r+rd at: c+cd ifInvalid: element]
! !

!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 12:32'!
atRows: r1 to: r2 columns: c1 to: c2 put: aMatrix
	"Set the [r1..r2][c1..c2] submatrix of the receiver
	 from the [1..r2-r1+1][1..c2-c1+1] submatrix of aMatrix.
	 As long as aMatrix responds to at:at: and accepts arguments in the range shown,
	 we don't care if it is bigger or even if it is a Matrix at all."
	|rd cd|

	rd := r1 - 1.
	cd := c1 - 1.
	r1 to: r2 do: [:r |
		c1 to: c2 do: [:c |
			self at: r at: c put: (aMatrix at: r-rd at: c-cd)]].
	^aMatrix
! !

!Matrix commentStamp: '<historical>' prior: 0!
I represent a two-dimensional array, rather like Array2D.
There are three main differences between me and Array2D:
(1) Array2D inherits from ArrayedCollection, but isn't one.  A lot of things that should work
    do not work in consequence of this.
(2) Array2D uses "at: column at: row" index order, which means that nothing you write using
    it is likely to work either.  I use the almost universal "at: row at: column" order, so it is
    much easier to adapt code from other languages without going doolally.
(3) Array2D lets you specify the class of the underlying collection, I don't.

Structure:
  nrows : a non-negative integer saying how many rows there are.
  ncols : a non-negative integer saying how many columns there are.
  contents : an Array holding the elements in row-major order.  That is, for a 2x3 array
    the contents are (11 12 13 21 22 23).  Array2D uses column major order.

    You can specify the class of 'contents' when you create a new Array2D,
    but Matrix always gives you an Array.

    There is a reason for this.  In strongly typed languages like Haskell and Clean,
    'unboxed arrays' save you both space AND time.  But in Squeak, while
    WordArray and FloatArray and so on do save space, it costs time to use them.
    A LOT of time.  I've measured aFloatArray sum running nearly twice as slow as
    anArray sum.  The reason is that whenever you fetch an element from an Array,
    that's all that happens, but when you fetch an element from aFloatArray, a whole
    new Float gets allocated to hold the value.  This takes time and churns memory.
    So the paradox is that if you want fast numerical stuff, DON'T use unboxed arrays!!

    Another reason for always insisting on an Array is that letting it be something
    else would make things like #, and #,, rather more complicated.  Always using Array
    is the simplest thing that could possibly work, and it works rather well.

I was trying to patch Array2D to make more things work, but just couldn't get my head
around the subscript order.  That's why I made Matrix.

Element-wise matrix arithmetic works; you can freely mix matrices and numbers but
don't try to mix matrices and arrays (yet).
Matrix multiplication, using the symbol +* (derived from APL's +.x), works between
(Matrix or Array) +* (Matrix or Array).  Don't try to use a number as an argument of +*.
Matrix * Number and Number * Matrix work fine, so you don't need +* with numbers.

Still to come: oodles of stuff.  Gaussian elimination maybe, other stuff probably not.
!
!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/23/2002 20:58'!
column: aCollection
	"Should this be called #fromColumn:?"

	^self rows: aCollection size columns: 1 contents: aCollection asArray shallowCopy! !

!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 00:09'!
diagonal: aCollection
	|r i|
	r := self zeros: aCollection size.
	i := 0.
	aCollection do: [:each | i := i+1. r at: i at: i put: each].
	^r! !

!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/23/2002 20:59'!
identity: n
	|r|

	r := self zeros: n.
	1 to: n do: [:i | r at: i at: i put: 1].
	^r! !

!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 00:06'!
new: dim
	"Answer a dim*dim matrix.  Is this an abuse of #new:?  The argument is NOT a size."
	^self rows: dim columns: dim! !

!Matrix class methodsFor: 'instance creation' stamp: 'raok 11/25/2002 12:51'!
new: dim element: element
	"Answer a dim*dim matrix with all elements set to element.
	 Is this an abuse of #new:?  The argument is NOT a size."

	^self rows: dim columns: dim element: element! !

!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 19:54'!
new: dim tabulate: aBlock
	"Answer a dim*dim matrix where it at: i at: j is aBlock value: i value: j."
	^self rows: dim columns: dim tabulate: aBlock! !

!Matrix class methodsFor: 'instance creation' stamp: 'raok 11/28/2002 14:08'!
ones: n
	^self new: n element: 1
! !

!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/23/2002 20:59'!
row: aCollection
	"Should this be called #fromRow:?"

	^self rows: 1 columns: aCollection size contents: aCollection asArray shallowCopy! !

!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 00:04'!
rows: rows columns: columns
	^self rows: rows columns: columns contents: (Array new: rows*columns)! !

!Matrix class methodsFor: 'instance creation' stamp: 'raok 11/28/2002 14:10'!
rows: rows columns: columns element: element
	^self rows: rows columns: columns
		contents: ((Array new: rows*columns) atAllPut: element; yourself)! !

!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 19:51'!
rows: rows columns: columns tabulate: aBlock
	"Answer a new Matrix of the given dimensions where
	 result at: i at: j     is   aBlock value: i value: j"
	|a i|

	a := Array new: rows*columns.
	i := 0.
	1 to: rows do: [:row |
		1 to: columns do: [:column |
			a at: (i := i+1) put: (aBlock value: row value: column)]].
	^self rows: rows columns: columns contents: a
! !

!Matrix class methodsFor: 'instance creation' stamp: 'raok 11/28/2002 14:09'!
zeros: n
	^self new: n element: 0! !

!Matrix class methodsFor: 'private' stamp: 'raok 10/21/2002 23:06'!
rows: rows columns: columns contents: contents
	^self new rows: rows columns: columns contents: contents! !

!Message methodsFor: 'private' stamp: 'ssa 5/27/2010 11:13'!
arguments: anArray

	args _ anArray! !

!Message methodsFor: 'private' stamp: 'ssa 7/16/2010 19:03'!
selector: aSymbol

	selector _ aSymbol.
! !

!Message methodsFor: 'sending' stamp: 'ssa 5/28/2010 17:06'!
sentTo: receiver
	"answer the result of sending this message to receiver"

	lookupClass == nil
		ifTrue: [^ receiver perform: selector withArguments: args asArray]
		ifFalse: [^ receiver perform: selector withArguments: args asArray inSuperclass: lookupClass]! !

!MessageSet class methodsFor: 'instance creation' stamp: 'ssa 9/3/2008 11:07'!
openMessageList: messageList name: labelString autoSelect: autoSelectString
	"Open a system view for a MessageSet on messageList. 
	 1/24/96 sw: the there-are-no msg now supplied by my sender"

	| messageSet |
	messageSet _ self messageList: messageList.
	messageSet autoSelectString: autoSelectString.
	ScheduledControllers scheduleActive: (self open: messageSet name: labelString)! !

!MessageTally methodsFor: 'comparing'!
< aMessageTally 
	"Refer to the comment in Magnitude|<."

	^tally > aMessageTally tally! !

!MessageTally methodsFor: 'comparing' stamp: 'tk 7/5/2001 22:05'!
= aMessageTally

	self species == aMessageTally species ifFalse: [^ false].
	^ aMessageTally method == method! !

!MessageTally methodsFor: 'comparing'!
> aMessageTally 
	"Refer to the comment in Magnitude|>."

	^tally < aMessageTally tally! !

!MessageTally methodsFor: 'comparing'!
hash
	"Hash is reimplemented because = is implemented."

	^method asOop! !

!MessageTally methodsFor: 'comparing'!
isPrimitives
	"Detect pseudo node used to carry tally of local hits"
	^ receivers == nil! !

!MessageTally methodsFor: 'comparing'!
sonsOver: threshold

	| hereTally last sons |
	(receivers == nil or: [receivers size = 0]) ifTrue: [^#()].
	hereTally _ tally.
	sons _ receivers select:  "subtract subNode tallies for primitive hits here"
		[:son |
		hereTally _ hereTally - son tally.
		son tally > threshold].
	hereTally > threshold
		ifTrue: 
			[last _ MessageTally new class: class method: method.
			^sons copyWith: (last primitives: hereTally)].
	^sons! !

!MessageTally methodsFor: 'comparing' stamp: 'tk 7/5/2001 22:04'!
species
	^MessageTally! !

!MessageTally methodsFor: 'initialize-release'!
close

	(Timer isMemberOf: Process) ifTrue: [Timer terminate].
	Timer _ ObservedProcess _ nil.
	class _ method _ tally _ receivers _ nil! !

!MessageTally methodsFor: 'initialize-release' stamp: 'nk 3/8/2004 12:29'!
initialize
	maxClassNameSize _ self class defaultMaxClassNameSize.
	maxClassPlusSelectorSize _ self class defaultMaxClassPlusSelectorSize.
	maxTabs _ self class defaultMaxTabs.! !

!MessageTally methodsFor: 'initialize-release' stamp: 'dmu 9/17/2010 12:02'!
spyEvery: millisecs on: aBlock 
	"Create a spy and spy on the given block at the specified rate."

	| myDelay startTime time0 |
	(aBlock isMemberOf: BlockContext)
		ifFalse: [self error: 'spy needs a block here'].
	self class: aBlock receiver class method: aBlock method.
		"set up the probe"
	ObservedProcess _ Processor thisProcess.
	myDelay := Delay forMilliseconds: millisecs.
	time0 := Time millisecondClockValue.
	gcStats _ SmalltalkImage current getVMParameters.
	Timer :=
		[[true] whileTrue: 
			[startTime := Time millisecondClockValue.
			myDelay wait.
			ObservedProcess suspend.
			self tally: ObservedProcess suspendedContextWaitingIfNecessary
				"tally can be > 1 if ran a long primitive"
				by: (Time millisecondClockValue - startTime) // millisecs.
				ObservedProcess resume].
		nil] newProcess.
	Timer priority: Processor userInterruptPriority.
		"activate the probe and evaluate the block"
	Timer resume.
	^ aBlock ensure:
		["Collect gc statistics"
		SmalltalkImage current getVMParameters keysAndValuesDo:
			[:idx :gcVal| gcStats at: idx put: (gcVal - (gcStats at: idx))].
		"cancel the probe and return the value"
		Timer notNil ifTrue:[Timer terminate].
		time := Time millisecondClockValue - time0]! !

!MessageTally methodsFor: 'initialize-release' stamp: 'dmu 9/17/2010 12:03'!
spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration 
	"Create a spy and spy on the given process at the specified rate."
	| myDelay time0 endTime sem |
	(aProcess isKindOf: Process)
		ifFalse: [self error: 'spy needs a Process here'].
	self class: aProcess suspendedContextWaitingIfNecessary receiver class method: aProcess suspendedContext method.
	"set up the probe"
	ObservedProcess _ aProcess.
	myDelay _ Delay forMilliseconds: millisecs.
	time0 _ Time millisecondClockValue.
	endTime _ time0 + msecDuration.
	sem _ Semaphore new.
	gcStats _ SmalltalkImage current  getVMParameters.
	Timer _ [[| startTime | 
			startTime _ Time millisecondClockValue.
			myDelay wait.
			ObservedProcess suspend.
			self tally: ObservedProcess suspendedContextWaitingIfNecessary by: Time millisecondClockValue - startTime // millisecs.
			startTime < endTime.
			ObservedProcess resume] whileTrue.
			sem signal]
				forkAt: (ObservedProcess priority + 1 min: Processor highestPriority).
	"activate the probe and wait for it to finish"
	sem wait.
	"Collect gc statistics"
	SmalltalkImage current  getVMParameters keysAndValuesDo:
		[:idx :gcVal| gcStats at: idx put: (gcVal - gcStats at: idx)].
	time _ Time millisecondClockValue - time0! !

!MessageTally methodsFor: 'printing' stamp: 'dew 3/15/2000 21:49'!
fullPrintOn: aStream tallyExact: isExact orThreshold: perCent
	| threshold |  
	isExact ifFalse: [threshold _ (perCent asFloat / 100 * tally) rounded].
	aStream nextPutAll: '**Tree**'; cr.
	self treePrintOn: aStream
		tabs: OrderedCollection new
		thisTab: ''
		total: tally
		totalTime: time
		tallyExact: isExact
		orThreshold: threshold.
	aStream nextPut: Character newPage; cr.
	aStream nextPutAll: '**Leaves**'; cr.
	self leavesPrintOn: aStream
		tallyExact: isExact
		orThreshold: threshold! !

!MessageTally methodsFor: 'printing' stamp: 'dew 3/22/2000 02:28'!
leavesPrintOn: aStream tallyExact: isExact orThreshold: threshold
	| dict |
	dict _ IdentityDictionary new: 100.
	self leavesInto: dict fromSender: nil.
	isExact ifTrue: 
		[dict asSortedCollection
			do: [:node |
				node printOn: aStream total: tally totalTime: nil tallyExact: isExact.
				node printSenderCountsOn: aStream]]
		ifFalse:
		[(dict asOrderedCollection
				select: [:node | node tally > threshold])
			asSortedCollection
			do: [:node |
				node printOn: aStream total: tally totalTime: time tallyExact: isExact]]! !

!MessageTally methodsFor: 'printing' stamp: 'nk 3/8/2004 12:14'!
printOn: aStream 
	| aSelector className aClass |
	(class isNil or: [method isNil]) ifTrue: [^super printOn: aStream].
	aSelector := class selectorAtMethod: method setClass: [:c | aClass := c].
	className := aClass name contractTo: self maxClassNameSize.
	aStream
		nextPutAll: className;
		nextPutAll: ' >> ';
		nextPutAll: (aSelector 
					contractTo: self maxClassPlusSelectorSize - className size)! !

!MessageTally methodsFor: 'printing' stamp: 'nk 3/8/2004 12:15'!
printOn: aStream total: total totalTime: totalTime tallyExact: isExact 
	| aSelector className myTally aClass percentage |
	isExact 
		ifTrue: 
			[myTally := tally.
			receivers == nil 
				ifFalse: [receivers do: [:r | myTally := myTally - r tally]].
			aStream
				print: myTally;
				space]
		ifFalse: 
			[percentage := tally asFloat / total * 100.0 roundTo: 0.1.
			aStream
				print: percentage;
				nextPutAll: '% {';
				print: (percentage * totalTime / 100) rounded;
				nextPutAll: 'ms} '].
	receivers == nil 
		ifTrue: 
			[aStream
				nextPutAll: 'primitives';
				cr]
		ifFalse: 
			[aSelector := class selectorAtMethod: method setClass: [:c | aClass := c].
			className := aClass name contractTo: self maxClassNameSize.
			aStream
				nextPutAll: class name;
				nextPutAll: (aClass = class 
							ifTrue: ['>>']
							ifFalse: ['(' , aClass name , ')>>']);
				nextPutAll: (aSelector 
							contractTo: self maxClassPlusSelectorSize - className size);
				cr]! !

!MessageTally methodsFor: 'printing' stamp: 'dew 3/22/2000 02:28'!
printSenderCountsOn: aStream
	| mergedSenders mergedNode |
	mergedSenders _ IdentityDictionary new.
	senders do:
		[:node |
		mergedNode _ mergedSenders at: node method ifAbsent: [nil].
		mergedNode == nil
			ifTrue: [mergedSenders at: node method put: node]
			ifFalse: [mergedNode bump: node tally]].
	mergedSenders asSortedCollection do:
		[:node | 
		10 to: node tally printString size by: -1 do: [:i | aStream space].
		node printOn: aStream total: tally totalTime: nil tallyExact: true]! !

!MessageTally methodsFor: 'printing' stamp: 'nk 3/8/2004 12:23'!
treePrintOn: aStream tabs: tabs thisTab: myTab total: total totalTime: totalTime tallyExact: isExact orThreshold: threshold 
	| sons sonTab |
	tabs do: [:tab | aStream nextPutAll: tab].
	tabs size > 0 
		ifTrue: 
			[self 
				printOn: aStream
				total: total
				totalTime: totalTime
				tallyExact: isExact].
	sons := isExact ifTrue: [receivers] ifFalse: [self sonsOver: threshold].
	sons isEmpty 
		ifFalse: 
			[tabs addLast: myTab.
			sons := sons asSortedCollection.
			(1 to: sons size) do: 
					[:i | 
					sonTab := i < sons size ifTrue: ['  |'] ifFalse: ['  '].
					(sons at: i) 
						treePrintOn: aStream
						tabs: (tabs size < self maxTabs 
								ifTrue: [tabs]
								ifFalse: [(tabs select: [:x | x = '[']) copyWith: '['])
						thisTab: sonTab
						total: total
						totalTime: totalTime
						tallyExact: isExact
						orThreshold: threshold].
			tabs removeLast]! !

!MessageTally methodsFor: 'printing format' stamp: 'nk 3/8/2004 12:29'!
maxClassNameSize
	^maxClassNameSize! !

!MessageTally methodsFor: 'printing format' stamp: 'nk 3/8/2004 12:30'!
maxClassNameSize: aNumber
	maxClassNameSize := aNumber! !

!MessageTally methodsFor: 'printing format' stamp: 'nk 3/8/2004 12:29'!
maxClassPlusSelectorSize
	^maxClassPlusSelectorSize! !

!MessageTally methodsFor: 'printing format' stamp: 'nk 3/8/2004 12:30'!
maxClassPlusSelectorSize: aNumber
	maxClassPlusSelectorSize := aNumber! !

!MessageTally methodsFor: 'printing format' stamp: 'nk 3/8/2004 12:29'!
maxTabs
	^maxTabs! !

!MessageTally methodsFor: 'printing format' stamp: 'nk 3/8/2004 12:30'!
maxTabs: aNumber
	maxTabs := aNumber! !

!MessageTally methodsFor: 'reporting'!
report: strm 
	"Print a report, with cutoff percentage of each element of the tree 
	(leaves, roots, tree)=2, on the stream, strm."

	self report: strm cutoff: 2! !

!MessageTally methodsFor: 'reporting' stamp: 'spfa 6/1/2004 19:23'!
report: strm cutoff: threshold 
	tally = 0
		ifTrue: [strm nextPutAll: ' - no tallies obtained']
		ifFalse: 
			[strm nextPutAll: ' - '; print: tally; nextPutAll: ' tallies, ', time printString, ' msec.'; cr; cr.
			self fullPrintOn: strm tallyExact: false orThreshold: threshold].
		
	time isZero ifFalse:	
		[self reportGCStatsOn: strm].! !

!MessageTally methodsFor: 'reporting' stamp: 'ar 7/18/2001 22:12'!
reportGCStatsOn: str
	| oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime rootOverflows |
	upTime _ time.
	oldSpaceEnd			_ gcStats at: 1.
	youngSpaceEnd		_ gcStats at: 2.
	memoryEnd			_ gcStats at: 3.
	fullGCs				_ gcStats at: 7.
	fullGCTime			_ gcStats at: 8.
	incrGCs				_ gcStats at: 9.
	incrGCTime			_ gcStats at: 10.
	tenureCount			_ gcStats at: 11.
	rootOverflows		_ gcStats at: 22.

	str cr.
	str	nextPutAll: '**Memory**'; cr.
	str	nextPutAll:	'	old			';
		nextPutAll: oldSpaceEnd asStringWithCommasSigned; nextPutAll: ' bytes'; cr.
	str	nextPutAll: '	young		';
		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommasSigned; nextPutAll: ' bytes'; cr.
	str	nextPutAll: '	used		';
		nextPutAll: youngSpaceEnd asStringWithCommasSigned; nextPutAll: ' bytes'; cr.
	str	nextPutAll: '	free		';
		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommasSigned; nextPutAll: ' bytes'; cr.

	str cr.
	str	nextPutAll: '**GCs**'; cr.
	str	nextPutAll: '	full			';
		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';
		print: ((fullGCTime / upTime * 100) roundTo: 1.0);
		nextPutAll: '% uptime)'.
	fullGCs = 0 ifFalse:
		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].
	str	cr.
	str	nextPutAll: '	incr		';
		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';
		print: ((incrGCTime / upTime * 100) roundTo: 1.0);
		nextPutAll: '% uptime)'.
	incrGCs = 0 ifFalse:
		[str nextPutAll:', avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'].
	str cr.
	str	nextPutAll: '	tenures		';
		nextPutAll: tenureCount asStringWithCommas.
	tenureCount = 0 ifFalse:
		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].
	str	cr.
	str	nextPutAll: '	root table	';
		nextPutAll: rootOverflows asStringWithCommas; nextPutAll:' overflows'.
	str cr.
! !

!MessageTally methodsFor: 'reporting' stamp: 'stp 05/08/1999 12:06'!
tally
	"Answer the receiver's number of tally."

	^tally! !

!MessageTally methodsFor: 'reporting' stamp: 'stp 05/08/1999 11:47'!
time
	"Answer the receiver's run time."

	^time! !

!MessageTally methodsFor: 'private'!
class: aClass method: aMethod

	class _ aClass.
	method _ aMethod.
	tally _ 0.
	receivers _ Array new: 0! !

!MessageTally methodsFor: 'private'!
copyWithTally: hitCount
	^ (MessageTally new class: class method: method) bump: hitCount! !

!MessageTally methodsFor: 'private'!
method

	^method! !

!MessageTally methodsFor: 'private'!
primitives: anInteger

	tally _ anInteger.
	receivers _ nil! !

!MessageTally methodsFor: 'collecting leaves'!
bump: hitCount
	tally _ tally + hitCount! !

!MessageTally methodsFor: 'collecting leaves'!
bump: hitCount fromSender: senderTally
	"Add this hitCount to the total, and include a reference to the
	sender responsible for the increment"
	self bump: hitCount.
	senders == nil ifTrue: [senders _ OrderedCollection new].
	senderTally == nil
		ifFalse: [senders add: (senderTally copyWithTally: hitCount)]! !

!MessageTally methodsFor: 'collecting leaves'!
into: leafDict fromSender: senderTally
	| leafNode |
	leafNode _ leafDict at: method
		ifAbsent: [leafDict at: method
			put: (MessageTally new class: class method: method)].
	leafNode bump: tally fromSender: senderTally! !

!MessageTally methodsFor: 'collecting leaves'!
leavesInto: leafDict fromSender: senderTally
	| rcvrs |
	rcvrs _ self sonsOver: 0.
	rcvrs size = 0
		ifTrue: [self into: leafDict fromSender: senderTally]
		ifFalse: [rcvrs do:
				[:node |
				node isPrimitives
					ifTrue: [node leavesInto: leafDict fromSender: senderTally]
					ifFalse: [node leavesInto: leafDict fromSender: self]]]! !

!MessageTally methodsFor: 'tallying'!
bumpBy: count

	tally _ tally + count! !

!MessageTally methodsFor: 'tallying'!
tally: context by: count
	"Explicitly tally the specified context and its stack."
	| root |
	context method == method ifTrue: [^self bumpBy: count].
	(root _ context home sender) == nil
		ifTrue: [^ (self bumpBy: count) tallyPath: context by: count].
	^ (self tally: root by: count) tallyPath: context by: count! !

!MessageTally methodsFor: 'tallying'!
tallyPath: context by: count
	| aMethod path |
	aMethod _ context method.
	receivers do: 
		[:aMessageTally | 
		aMessageTally method == aMethod ifTrue: [path _ aMessageTally]].
	path == nil ifTrue: 
		[path _ MessageTally new class: context receiver class method: aMethod.
		receivers _ receivers copyWith: path].
	^ path bumpBy: count! !

!MessageTally class methodsFor: 'defaults' stamp: 'nk 3/8/2004 12:27'!
defaultMaxClassNameSize
	"Return the default maximum width of the class name alone"
	^30! !

!MessageTally class methodsFor: 'defaults' stamp: 'nk 3/8/2004 12:27'!
defaultMaxClassPlusSelectorSize
	"Return the default maximum width of the class plus selector together (not counting the '>>')"
	^60! !

!MessageTally class methodsFor: 'defaults' stamp: 'nk 3/8/2004 12:26'!
defaultMaxTabs
	"Return the default number of tabs after which leading white space is compressed"
	^18! !

!MessageTally class methodsFor: 'defaults' stamp: 'nk 3/8/2004 12:41'!
defaultPollPeriod
	"Answer the number of milliseconds between interrupts for spyOn: and friends.
	This should be faster for faster machines."
	^DefaultPollPeriod ifNil: [ DefaultPollPeriod _ 1 ]! !

!MessageTally class methodsFor: 'defaults' stamp: 'nk 3/8/2004 12:41'!
defaultPollPeriod: numberOfMilliseconds
	"Set the default number of milliseconds between interrupts for spyOn: and friends.
	This should be faster for faster machines."
	DefaultPollPeriod := numberOfMilliseconds! !

!MessageTally class methodsFor: 'spying' stamp: 'nk 3/8/2004 10:34'!
spyOn: aBlock    "MessageTally spyOn: [100 timesRepeat: [3.14159 printString]]"
	| node result |
	node _ self new.
	result _ node spyEvery: self defaultPollPeriod on: aBlock.
	(StringHolder new contents: (String streamContents: [:s | node report: s; close]))
		openLabel: 'Spy Results'.
	^ result! !

!MessageTally class methodsFor: 'spying' stamp: 'nk 3/8/2004 10:34'!
spyOn: aBlock toFileNamed: fileName 
	"Spy on the evaluation of aBlock. Write the data collected on a file
	named fileName."

	| file value node |
	node _ self new.
	value _ node spyEvery: self defaultPollPeriod on: aBlock.
	file _ FileStream newFileNamed: fileName.
	node report: file; close.
	file close.
	^value! !

!MessageTally class methodsFor: 'spying' stamp: 'nk 3/8/2004 10:35'!
spyOnProcess: aProcess forMilliseconds: msecDuration 
	"| p |  
	p _ [100000 timesRepeat: [3.14159 printString]] fork.  
	(Delay forMilliseconds: 100) wait.  
	MessageTally spyOnProcess: p forMilliseconds: 1000"
	| node |
	node _ self new.
	node
		spyEvery: self defaultPollPeriod
		onProcess: aProcess
		forMilliseconds: msecDuration.
	(StringHolder new
		contents: (String
				streamContents: [:s | node report: s;
						 close]))
		openLabel: 'Spy Results'! !

!MessageTally class methodsFor: 'spying' stamp: 'nk 3/8/2004 10:35'!
spyOnProcess: aProcess forMilliseconds: msecDuration toFileNamed: fileName 
	"Spy on the evaluation of aProcess. Write the data collected on a file  
	named fileName. Will overwrite fileName"
	| file node |
	node _ self new.
	node
		spyEvery: self defaultPollPeriod
		onProcess: aProcess
		forMilliseconds: msecDuration.
	file _ FileStream fileNamed: fileName.
	node report: file;
		 close.
	file close! !

!MessageTally class methodsFor: 'spying'!
tallySends: aBlock   "MessageTally tallySends: [3.14159 printString]"
	^ self tallySendsTo: nil inBlock: aBlock showTree: true! !

!MessageTally class methodsFor: 'spying' stamp: 'tk 5/4/1998 17:01'!
tallySendsTo: receiver inBlock: aBlock showTree: treeOption
	"MessageTally tallySends: [3.14159 printString]"
	"This method uses the simulator to count the number of calls on each method
	invoked in evaluating aBlock. If receiver is not nil, then only sends
	to that receiver are tallied.
	Results are presented as leaves, sorted by frequency,
	preceded, optionally, by the whole tree."
	| prev tallies startTime totalTime |
	startTime _ Time millisecondClockValue.
	tallies _ MessageTally new class: aBlock receiver class
							method: aBlock method.
	prev _ aBlock.
	thisContext sender
		runSimulated: aBlock
		contextAtEachStep:
			[:current |
			current == prev ifFalse: 
				["call or return"
				prev sender == nil ifFalse: 
					["call only"
					(receiver == nil or: [current receiver == receiver])
						ifTrue: [tallies tally: current by: 1]].
				prev _ current]].

	totalTime _ Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.
	(StringHolder new contents:
		(String streamContents:
			[:s |
			s nextPutAll: 'This simulation took ' , totalTime printString
							, ' seconds.'; cr.
			treeOption
				ifTrue: [tallies fullPrintOn: s tallyExact: true orThreshold: 0]
				ifFalse: [tallies leavesPrintOn: s tallyExact: true orThreshold: 0].
			tallies close]))
		openLabel: 'Spy Results'! !

!MessageTally class methodsFor: 'spying'!
time: aBlock

	^ Time millisecondsToRun: aBlock! !

!Metaclass methodsFor: '*transporter' stamp: 'ads 12/14/2010 10:27'!
fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex filteringCategoriesBy: catFilterBlock
	^self fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex filteringCategoriesBy: catFilterBlock initializing: true! !

!Metaclass methodsFor: '*transporter' stamp: 'ads 12/14/2010 10:30'!
fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex filteringCategoriesBy: catFilterBlock initializing: aBool
	super fileOutOn: aFileStream
		moveSource: moveSource
		toFile: fileIndex
		filteringCategoriesBy: catFilterBlock.
	(aBool and:[moveSource not and: [self methodDict includesKey: #initialize]]) ifTrue: 
		[aFileStream cr.
		aFileStream cr.
		aFileStream nextChunkPut: thisClass name , ' initialize'.
		aFileStream cr]! !

!MethodContext methodsFor: 'printing' stamp: 'ads 1/24/2011 13:02'!
printOn: aStream
  | h |
  aStream nextPutAll: (RVMPrimitivesNeededForBootstrapping printPrefixFor: self).
  (self class methodDictionary includesKey: #outerContext) ifTrue: [
    self outerContext
      ifNil: [super printOn: aStream]
      ifNotNil:
        [
          aStream nextPutAll: '[] in '.
          self outerContext printOn: aStream]
  ] ifFalse: [
    self isExecutingBlock ifFalse: [^ super printOn: aStream].
    h _ self blockHome.
    h ifNil: [^ aStream nextPutAll: '[]'].
    aStream nextPutAll: '[] from '.
    h printOn: aStream
  ]! !

!MethodContext methodsFor: 'converting' stamp: 'ssa 9/7/2009 14:36'!
asContext

	^self! !

!MethodHolder methodsFor: 'menu' stamp: 'ssa 9/4/2008 15:23'!
doItReceiver
	"If there is an instance associated with me, answer it, for true mapping of self.  If not, then do what other code-bearing tools do, viz. give access to the class vars."


	^ self selectedClass ifNil: [FakeClassPool new]! !

!MethodReference methodsFor: '*packageinfo-base' stamp: 'ab 5/23/2003 22:58'!
category
	^ self actualClass organization categoryOfElement: methodSymbol! !

!MethodReference methodsFor: '*packageinfo-base' stamp: 'ab 5/23/2003 22:58'!
sourceCode
	^ self actualClass sourceCodeAt: methodSymbol! !

!MethodReference methodsFor: '*transporter' stamp: 'ads 12/7/2010 17:04'!
changeRecords
	"changeRecordsAt: seems broken; doesn't handle class-side methods properly. -- Adam
	^ (self actualClass changeRecordsAt: self methodSymbol) ifNil: [{}]"
	| cls aList |
	cls _ self actualClass.
	aList _ VersionsBrowser new
			scanVersionsOf: (cls compiledMethodAt: self methodSymbol ifAbsent: [^ {}])
			class: cls theNonMetaClass meta: cls isMeta
			category: (cls whichCategoryIncludesSelector: self methodSymbol)
			selector: self methodSymbol.
	^ (aList ifNotNil: [aList changeList]) ifNil: [{}]! !

!MethodReference methodsFor: '*transporter' stamp: 'ads 12/1/2010 12:23'!
removeFromSystem
	self actualClass removeSelector: self methodSymbol.! !

!MethodReference methodsFor: '*transporter' stamp: 'ads 2/2/2011 15:02'!
topLevelPackageName
	| category |
	category := (self category notNil and: [self category beginsWith: '*'])
						ifTrue: [self category asString allButFirst capitalized]
						ifFalse: [self actualClass theNonMetaClass category asString].
	^ category copyUpTo: $-! !

!Model methodsFor: '*RVM-Archiving'!
archiveOn: aStream
	"To be consistent with Object, don't file out the dependents (subclasses may wish to override or put back the dependencies back in some other manner -- see Figure>dearchiveFrom:)."

	| oldDependents |
	oldDependents _ dependents.
	dependents _ nil.
	super archiveOn: aStream.
	dependents _ oldDependents.! !

!Mutex methodsFor: 'mutual exclusion' stamp: 'dmu 6/14/2010 16:16'!
critical: aBlock
	"Evaluate aBlock protected by the receiver."
	| activeProcess |
	activeProcess := Processor thisProcess.
	activeProcess == owner ifTrue:[^aBlock value].
	^semaphore critical:[
		owner := activeProcess.
		aBlock ensure:[owner := nil]].! !

!Mutex methodsFor: 'initialize' stamp: 'das 11/3/2005 22:53'!
initialize
	semaphore := Semaphore forMutualExclusion.! !

!Mutex class methodsFor: 'as yet unclassified' stamp: 'dmu 11/13/2010 16:19'!
forMutualExclusion ^ self new! !

!NPBIS methodsFor: 'as yet unclassified' stamp: 'sm 6/1/2011 15:57'!
do: aStep
	self critical: [
		rankThreads do: [ :thread |
			thread startStep: aStep.].
	
		rankThreads do: [ :ignored | 
			self wait.
		]
	].! !

!NPBIS methodsFor: 'as yet unclassified' stamp: 'sm 6/1/2011 14:22'!
fullVerify
	" To save copy and memory sorting can be done directly: "
	| key idx count |
	key := 1. idx := 1.
	
	1 to: numKeys do: [ :i | 
		[ (idx == (masterHist at: key))
		   and: [ ((key >= maxKey)	or: [ idx >= numKeys ]) not ] ] whileTrue: [
			key := key + 1 
		].
		keyArray at: idx put: key.
		idx := idx + 1.
	].

	" Confirm keys correctly sorted: count incorrectly sorted keys, if any "
	count := 0.
	
	2 to: numKeys do: [ :i | 
		((keyArray at: (i - 1)) > (keyArray at: i)) ifTrue: [ count := count + 1]].

	(count ~= 0)
		ifTrue: [ Error signal: 'Full_verify: number of keys out of sort: '. count asString ]
		ifFalse: [ PassedVerification := PassedVerification + 1].
    
    ^ PassedVerification! !

!NPBIS methodsFor: 'as yet unclassified' stamp: 'StefanMarr 10/16/2009 00:23'!
initKeys: aDouble
	| x k |
	k := maxKey / 4.
	
	1 to: numKeys do: [ :i |
		(i == 32769) ifTrue: [ Transcript show: 'Seed at: ', (rng seed asString);cr.].
		x := rng randlc: aDouble. 
		x := x + (rng randlc: aDouble).
		x := x + (rng randlc: aDouble).
		x := x + (rng randlc: aDouble).
		
		keyArray at: i put: (x * k) asInteger.
		].! !

!NPBIS methodsFor: 'as yet unclassified' stamp: 'sm 6/1/2011 14:23'!
partialVerify: iteration
	| k offset |

	1 to: NPBISBase testArraySize do: [ :i |
		k := partialVerifyVals at: i.
		offset := iteration.
		( (0 <= k) and: [k <= (numKeys - 1)]) ifTrue: [
			(benchmarkClass == #S) ifTrue: [
					((i - 1) <= 2) ifTrue: [ offset := iteration. ]
						    ifFalse: [ offset := 0 - iteration.].
				].
			
			((masterHist at: k) ~= ((testRankArray at: i) + offset))
				ifTrue: [
					Error signal: 'Failed partial verification: iteration ', iteration asString, ', test key ', i asString ]
				ifFalse: [
					NPBISBase passedVerification: (NPBISBase passedVerification + 1). ]
			]
		]! !

!NPBIS methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 17:18'!
rank: iteration
	keyArray at: (iteration + 1) put: iteration.
	keyArray at: (1 + iteration + (NPBISBase maxIterations)) put: (maxKey - iteration).
	
	1 to: NPBISBase testArraySize do: [
		:i | partialVerifyVals at: i put: (keyArray at: (1 + (testIndexArray at: i)) ) ].
	
	" Clear the work array "
	1 to: maxKey do: [ :i | masterHist at: i put: 0 ].
	
	" In the section, the keys themselves are used as their
	  own indexes to determine how many of each there are: their
	  individual population "
	1 to: numKeys do: [ :i | masterHist at: (1 + (keyArray at: i)) incrementBy: 1 ].
	" Now they have individual key population "
	
	" Density to Distribution conversion "
	1 to: (maxKey - 1) do: [ :i | masterHist at: (i + 1) incrementBy: (masterHist at: i). ].
	
	self partialVerify: iteration.! !

!NPBIS methodsFor: 'as yet unclassified' stamp: 'StefanMarr 9/21/2009 23:31'!
resetMasterHist
	1 to: maxKey do: [ :i | masterHist at: i put: 0 ].! !

!NPBIS methodsFor: 'as yet unclassified' stamp: 'sm 6/1/2011 14:24'!
run
	| mainTimer tPhase1 tPhase2 tKeyInit tVerify executionVerified |

	ScriptConsole println: ' Size: ', totalKeys asString, ' Iterations: ', NPBISBase maxIterations asString.
	
	mainTimer := runner createTimer: 'precise-total'.
	tPhase1 := runner createTimer: 'phase1'.
	tPhase2 := runner createTimer: 'phase2'.
	tKeyInit := runner createTimer: 'keyInit'.
	tVerify := runner createTimer: 'verifyCompletely'.
	
	NPBISBase passedVerification: 0.
	
	serial
		ifTrue: [
			tKeyInit start.
			self initKeys: NPBIS amult.
			tKeyInit stop. 
			
			self rank: 1. ]
		ifFalse: [
			self setupThreads.
			
			tKeyInit start.
			self do: #initKeys.
			tKeyInit stop.
			
			RankThread iteration: 1.
			self do: #step1.
			
			self resetMasterHist.
			
			self do: #step2.
			self partialVerify: 1].
		
	NPBISBase passedVerification: 0.
		
	mainTimer start.
		
	1 to: NPBIS maxIterations do: [:i | 
		serial
			ifTrue: [ self rank: i. ]
			ifFalse: [ 
				RankThread iteration: i.
				tPhase1 start.
				self do: #step1.
				tPhase1 stop.
				
				self resetMasterHist.
				
				tPhase2 start.
				self do: #step2.
				tPhase2 stop.
				
				self partialVerify: i]
		].
	
	mainTimer stop.
	
	tVerify start.
	self fullVerify.
	tVerify stop.
	
	executionVerified := ((NPBISBase passedVerification) == ((5 * NPBIS maxIterations) + 1)).
	executionVerified
		ifFalse: [ Error signal: 'Benchmark verification failed'].
		
	serial ifFalse: [ self do: #quit. ].
	^ executionVerified! !

!NPBIS methodsFor: 'license' stamp: 'StefanMarr 4/15/2011 17:04'!
license
	^'This code is based on the Java version of NPB3.

Permission to use, copy, distribute and modify this software for any purpose
with or without fee is hereby granted. We request, however, that all derived
work reference the NAS Parallel Benchmarks 3.0. This software is provided "as
is" without express or implied warranty.

Information on NPB 3.0, including the Technical Report NAS-02-008
"Implementation of the NAS Parallel Benchmarks in Java", original
specifications, source code, results and information on how to submit new
results, is available at:

   http://www.nas.nasa.gov/Software/NPB/'! !

!NPBIS methodsFor: 'accessors' stamp: 'StefanMarr 9/23/2009 19:14'!
keyArray
	^keyArray ! !

!NPBIS methodsFor: 'accessors' stamp: 'StefanMarr 9/23/2009 19:15'!
masterHist
	^masterHist ! !

!NPBIS methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 23:00'!
rng: val
	rng := val! !

!NPBIS methodsFor: 'accessors' stamp: 'StefanMarr 5/14/2011 01:00'!
runner: aRunner
	runner := aRunner
	! !

!NPBIS methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 22:59'!
serial: val
	serial := val! !

!NPBIS commentStamp: 'StefanMarr 5/14/2011 01:04' prior: 0!
NPBIS definines the general benchmark Integer Sort benchmark of the NAS Parallel Benchmarks.

See NPBSuite>>benchIS for the actual benchmark implemented based on SMark.

Instance Variables:
	bid	<ProtoObject | PseudoContext>
	results	<ProtoObject | PseudoContext>
	serial	<Boolean>
	rng	<NPBRandom>
	runner	<SMarkRunner>!
!NPBIS class methodsFor: 'constants' stamp: 'StefanMarr 9/21/2009 18:15'!
amult
	^1220703125.0! !

!NPBIS class methodsFor: 'constants' stamp: 'StefanMarr 5/14/2011 10:39'!
defaultProblemSize
	^ #S! !

!NPBIS class methodsFor: 'instance creation' stamp: 'StefanMarr 9/23/2009 19:12'!
newOfSizeClass: aSymbol with: nThreads serial: aBool
	| o |
	o := super new.
	
	o initializeWithSizeClass: aSymbol andNumberOfThreads: nThreads.
	
	o serial: aBool.
	o rng: NPBRandom new.
	^o
	
	
! !

!NPBISBase methodsFor: 'as yet unclassified' stamp: 'StefanMarr 11/7/2010 12:31'!
checksum: intArray name: aString stop: aBool
	| check |
	
	check := intArray sum.
	1 halt.
	"RVMOperations print: name, ' checksum is ', check asString."
	
	aBool ifTrue: [
		1 halt.
		self StopSystemHere]! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 4/15/2011 17:19'!
initializeValues
	"initialize the object after construction"
	totalKeys := 1 << self totalKeysLog2.
	maxKey := 1 << maxKeyLog2.
	numKeys := totalKeys.
	sizeOfBuffers := totalKeys.
	keyArray := Array new: sizeOfBuffers.
	masterHist := Array new: maxKey. 
	partialVerifyVals := Array new: NPBISBase testArraySize.
	masterHist doWithIndex: 
		[ :val :i | 
		masterHist 
			at: i
			put: 0 ]! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 16:36'!
master
	^ master! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 16:37'!
master: val
	master := val! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/17/2009 08:30'!
maxKey
	^ maxKey! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/17/2009 08:30'!
maxKey: val
	maxKey := val! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/17/2009 08:28'!
maxKeyLog2
	^ maxKeyLog2 ! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/17/2009 08:28'!
maxKeyLog2: val
	maxKeyLog2 := val! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 15:21'!
numBuckets 
	^ numBuckets! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 15:21'!
numBuckets: val
	numBuckets := val! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/17/2009 08:29'!
numBucketsLog2 
	^ numBucketsLog2 ! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/17/2009 08:29'!
numBucketsLog2: val
	numBucketsLog2 := val! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 15:21'!
numKeys
	^ numKeys! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 15:36'!
numKeys: val
	numKeys := val! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 16:02'!
numThreads
	^ numThreads! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 16:02'!
numThreads: val
	numThreads := val! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/23/2009 19:32'!
partialVerifyVals
	^partialVerifyVals ! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 16:37'!
rankThreads
	^rankThreads ! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 16:37'!
rankThreads: val
	rankThreads := val! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 15:22'!
sizeOfBuffers
	^ sizeOfBuffers! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 15:22'!
sizeOfBuffers: val
	sizeOfBuffers := val! !

!NPBISBase methodsFor: 'accessors' stamp: 'SM 9/16/2009 22:50'!
testIndexArray
	^ testIndexArray! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 1/16/2011 20:47'!
testIndexArray: val
	testIndexArray := val! !

!NPBISBase methodsFor: 'accessors' stamp: 'SM 9/16/2009 22:51'!
testRankArray
	^ testRankArray! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 1/16/2011 20:46'!
testRankArray: val
	testRankArray := val! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/17/2009 08:30'!
totalKeys
	^ totalKeys! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 9/21/2009 15:38'!
totalKeys: val
	totalKeys := val! !

!NPBISBase methodsFor: 'accessors' stamp: 'SM 9/16/2009 22:54'!
totalKeysLog2
	^totalKeysLog2! !

!NPBISBase methodsFor: 'accessors' stamp: 'StefanMarr 1/16/2011 20:46'!
totalKeysLog2: val
	totalKeysLog2 := val! !

!NPBISBase methodsFor: 'license' stamp: 'StefanMarr 4/15/2011 17:04'!
license
	^'This code is based on the Java version of NPB3.

Permission to use, copy, distribute and modify this software for any purpose
with or without fee is hereby granted. We request, however, that all derived
work reference the NAS Parallel Benchmarks 3.0. This software is provided "as
is" without express or implied warranty.

Information on NPB 3.0, including the Technical Report NAS-02-008
"Implementation of the NAS Parallel Benchmarks in Java", original
specifications, source code, results and information on how to submit new
results, is available at:

   http://www.nas.nasa.gov/Software/NPB/'! !

!NPBISBase methodsFor: 'initialization' stamp: 'StefanMarr 10/5/2009 18:14'!
initialize
	mtxCritical := Semaphore forMutualExclusion.
	mtxNotify := Semaphore new.! !

!NPBISBase methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 10:44'!
initializeWithSizeClass: aSymbol andNumberOfThreads: numberOfThreads 
	| consts |
	benchmarkClass := aSymbol asSymbol.
		
	consts := NPBISBase perform: benchmarkClass.
	consts keysAndValuesDo: 
		[ :key :val | 
		self
			perform: (key , ':') asSymbol
			with: val ].
	numThreads := numberOfThreads.
	
	self initializeValues.
	^ self! !

!NPBISBase methodsFor: 'initialization' stamp: 'sm 6/1/2011 15:52'!
setupThreads
	"Initialize the threads/processes for the benchmark"
	
	| start end remainder offset rStart rEnd rRemainder rOffset rThread |
	
	start := 0. end := 0. remainder := totalKeys \\ numThreads. offset := 0.
	rStart := 0. rEnd := 0. rRemainder := maxKey \\ numThreads. rOffset := 0.
	
	rankThreads := Array new: numThreads.
	
	1 to: numThreads do: [ :i |
		| zeroIdx |
		zeroIdx := i - 1.
		start := (zeroIdx * ((totalKeys / numThreads) asInteger)) + offset.
		end :=  ((zeroIdx * ((totalKeys / numThreads) asInteger))) + ((totalKeys / numThreads) asInteger) - 1 + offset.
		(remainder > 0) ifTrue: [
			remainder := remainder - 1.
			offset := offset + 1.
			end := end + 1].
		
		rStart := (zeroIdx * ((maxKey / numThreads) asInteger)) + rOffset.
		rEnd := ((zeroIdx * ((maxKey / numThreads) asInteger))) + ((maxKey / numThreads) asInteger) -1 + rOffset.
		
		(rRemainder > 0) ifTrue: [
			rRemainder := rRemainder - 1.
			rOffset := rOffset + 1.
			rEnd := rEnd + 1].
		
		rThread := RankThread newFor: self with: i start: (start + 1) end: (end + 1) rStart: (rStart + 1) rEnd: (rEnd + 1).
		rankThreads at: i put: rThread.
		rThread rankThreads: rankThreads.
		rThread start.
	].! !

!NPBISBase methodsFor: 'synchronization' stamp: 'StefanMarr 10/5/2009 18:13'!
critical: aBlock
	mtxCritical critical: aBlock! !

!NPBISBase methodsFor: 'synchronization' stamp: 'StefanMarr 10/5/2009 18:13'!
notify
	mtxNotify signal ! !

!NPBISBase methodsFor: 'synchronization' stamp: 'StefanMarr 10/5/2009 18:12'!
wait
	mtxNotify wait ! !

!NPBISBase commentStamp: 'StefanMarr 5/14/2011 01:03' prior: 0!
NPBISBase definines the commonalities for the general benchmark and its actual worker-threads.

See NPBSuite>>benchIS for the actual benchmark implemented based on SMark.

Instance Variables:
	testIndexArray	<Object>
	testRankArray	<Object>
	masterHist	<(SequenceableCollection of: Object)>
	keyArray	<(Array of: (CharacterBlock | Magnitude | Point | String | UUID))>
	partialVerifyVals	<Array>
	sizeClass	<ProtoObject | PseudoContext>
	totalKeys	<Collection | Duration | Number | Point>
	maxKey	<Collection | Duration | Number | Point>
	numBuckets	<ProtoObject | PseudoContext>
	numKeys	<Collection | Color | DateAndTime | Duration | Number | OBMetaNode | Point | Timespan | TraitComposition | TraitDescription | TraitTransformation>
	sizeOfBuffers	<ProtoObject | PseudoContext>
	timerOn	<ProtoObject | PseudoContext>
	timer	<ProtoObject | PseudoContext>
	totalKeysLog2	<ProtoObject | PseudoContext>
	maxKeyLog2	<ProtoObject | PseudoContext>
	numBucketsLog2	<ProtoObject | PseudoContext>
	numThreads	<ProtoObject | PseudoContext>
	rankThreads	<(SequenceableCollection of: RankThread)>
	master	<NPBISBase>
	benchmarkClass	<ProtoObject>
	mtxNotify	<Semaphore>
	mtxCritical	<Semaphore>!
!NPBISBase class methodsFor: 'constants' stamp: 'SM 9/16/2009 22:28'!
S
	^ Dictionary newFrom: {
		#testIndexArray -> { 48427. 17148. 23627. 62548. 4431 }.
		#testRankArray -> { 0. 18. 346. 64917. 65463 }.
		#totalKeysLog2 -> 16.
		#maxKeyLog2 -> 11.
		#numBucketsLog2 -> 9
	 }! !

!NPBISBase class methodsFor: 'constants' stamp: 'SM 9/16/2009 22:16'!
maxIterations
	^ 10! !

!NPBISBase class methodsFor: 'constants' stamp: 'StefanMarr 1/16/2011 21:40'!
passedVerification
	^PassedVerification! !

!NPBISBase class methodsFor: 'constants' stamp: 'StefanMarr 1/16/2011 21:41'!
passedVerification: val
	PassedVerification := val! !

!NPBISBase class methodsFor: 'constants' stamp: 'SM 9/16/2009 22:17'!
testArraySize
	^ 5! !

!NPBISBase class methodsFor: 'instance creation' stamp: 'StefanMarr 9/21/2009 18:28'!
newOfSizeClass: aSymbol with: numberOfThreads 
	| o |
	o := super new.
	o initializeWithSizeClass: aSymbol andNumberOfThreads: numberOfThreads.
	^o! !

!NPBRandom methodsFor: 'as yet unclassified'!
findSeedFor: aRank with: numOfThreads of: totalRanNumbers using: seed and: aGenMult
	| i t1 t2 an 
	 mq nq kk ik continueLoop |

	nq := (totalRanNumbers / numOfThreads) asInteger.
	mq := 0.

	[nq > 1] whileTrue: [
		mq := mq + 1.
		nq := nq / 2.
	].

	t1 := aGenMult.
	
	1 to: mq do: [ :ii |
		tran := t1.
		t2 := self randlc: t1.
		t1 := tran.
	].

	an := t1.
	
	kk := aRank.
	t1 := seed.
	t2 := an.

	i := 1.
	
	continueLoop := true.
	[(i <= 100) and: continueLoop] whileTrue: [
		ik := (kk / 2) asInteger.
		
		((2 * ik) ~= kk) ifTrue: [
			tran := t1.
			self randlc: t2.
			t1 := tran.].
		
		(ik == 0) ifTrue: [ continueLoop := false. ]
		ifFalse: [
			tran := t2.
			self randlc: t2.
			t2 := tran.
			kk := ik.
			i := i + 1.
			].
	].
   
	^ t1.! !

!NPBRandom methodsFor: 'as yet unclassified'!
randlc: aDouble
	| t1 t2 t3 t4 a1 a2 x1 x2 z |
	" Break A into two parts such that A = 2**23 * A1 + A2. "

	t1 := r23 * aDouble.
	a1 := t1 asInteger.
	a2 := aDouble - (t23 * a1).
	
	" Break X into two parts such that X = 2^23 * X1 + X2, compute
	  Z = A1 * X2 + A2 * X1  (mod 2^23), and then
	  X = 2^23 * Z + A2 * X2  (mod 2^46). "

	t1 := r23 * tran.
	x1 := t1 asInteger.
	x2 := tran - (t23 * x1).
	t1 := (a1 * x2) + (a2 * x1).
	t2 := (r23 * t1) asInteger.
	z := t1 - (t23 * t2).
	t3 := (t23 * z) + (a2 * x2).
	t4 := (r46 * t3) asInteger.
	tran := t3 - (t46 * t4).
	^ r46 * tran! !

!NPBRandom methodsFor: 'initialization'!
initialize
	tran := NPBRandom seed.
	amult := NPBIS amult.
	KS := 0.
	r23 := 0.5 raisedTo: 23.
	r46 := r23 raisedTo: 2.
	t23 := 2 raisedTo: 23.
	t46 := t23 raisedTo: 2.! !

!NPBRandom methodsFor: 'license' stamp: 'StefanMarr 4/15/2011 17:04'!
license
	^'This code is based on the Java version of NPB3.

Permission to use, copy, distribute and modify this software for any purpose
with or without fee is hereby granted. We request, however, that all derived
work reference the NAS Parallel Benchmarks 3.0. This software is provided "as
is" without express or implied warranty.

Information on NPB 3.0, including the Technical Report NAS-02-008
"Implementation of the NAS Parallel Benchmarks in Java", original
specifications, source code, results and information on how to submit new
results, is available at:

   http://www.nas.nasa.gov/Software/NPB/'! !

!NPBRandom methodsFor: 'accessing'!
seed
	^ tran! !

!NPBRandom methodsFor: 'private - accessing'!
seed: aSeed
	tran := aSeed! !

!NPBRandom class methodsFor: 'as yet unclassified'!
d2m46
	^ 0.5 raisedTo: 46! !

!NPBRandom class methodsFor: 'as yet unclassified'!
i246m1
	^ (2 raisedTo: 46) - 1! !

!NPBRandom class methodsFor: 'as yet unclassified'!
seed
	^314159265.0! !

!NPBSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 5/14/2011 01:00'!
benchIS
	"Run the IS benchmark"
	bench run.! !

!NPBSuite methodsFor: 'benchmarking' stamp: 'StefanMarr 5/14/2011 10:43'!
setUpBenchIS
	"Prepare IS benchmark"
	| sizeClass threadCnt |
	
	sizeClass := runner problemSize.
	sizeClass ifNil:	[ sizeClass := NPBIS defaultProblemSize. ].
	
	threadCnt := runner processes.
	
	bench := NPBIS newOfSizeClass: sizeClass with: threadCnt serial: (threadCnt == 0).
	bench runner: runner.! !

!NPBTest methodsFor: 'tests'!
testIS
	| verified runner suite |
	runner := SMarkRunner new.
	suite  := NPBSuite new.
	suite runner: runner.
	runner suite: suite.
	runner iterations: 1.
	runner processes: 4.
	runner problemSize: #S.
	
	self shouldnt: [	runner execute. 
				"TODO: update as soon as the SMark framework supports verification"
				verified := false. ]
		 raise: Error.
	self assert: verified.! !

!NPBTest methodsFor: 'tests'!
testKeyArrayContent
	| o keyArray |
	o := NPBIS newOfSizeClass: #S with: 0 serial: true.
	o initKeys: NPBIS amult.
	
	keyArray := o keyArray.
	
	self assert: (keyArray at: 65536) equals: 962.
	self assert:	(keyArray at: 65535) equals: 677.
	self assert: (keyArray at: 30001) equals: 557.
	self assert: (keyArray at: 1) equals: 1585.
	self assert: (keyArray at: 2) equals: 825.
	self assert: (keyArray at: 12) equals: 1140.
! !

!NPBTest methodsFor: 'running' stamp: 'StefanMarr 5/22/2011 10:23'!
setUp
	"Necessary for Squeak 4.2 compatibility, since method anotations are not supported in the base image."
	(self respondsTo:  #timeout:) ifTrue: [
		self timeout: 300.
	].! !

!Number methodsFor: 'arithmetic' stamp: 'ssa 11/27/2009 16:14'!
inverted

	^1/self! !

!Number methodsFor: 'mathematical functions' stamp: 'ssa 8/27/2009 14:58'!
pi

	^Float pi * self! !

!Number methodsFor: 'truncation and round off' stamp: 'ssa 8/30/2009 04:04'!
atRandom
	^self asFloat * (Collection atRandom: self class randomForPicking copy)! !

!Number methodsFor: 'converting' stamp: 'ssa 11/15/2008 08:57'!
asPointWithinRectangleWithExtent: extent
	"Answer a point showing what coordinate I would have if wrapped into a rectangle of this extent.
	Clip out of bounds answer to 0@0 if undershot or extent if overShot.  Only really useful for integers"
	| x y newX newY |
	x _ extent x.
	y _ extent y.
	self > (x*y) ifTrue:[^extent].
	self < 1 ifTrue:[^0@0].
	newX _ self \\ x = 0 ifTrue:[x]ifFalse:[self \\ x].
	newY _ self - 1 // x + 1.
	
	^newX@newY

	"{0 asPointWithinRectangleWithExtent:2@2.
	1 asPointWithinRectangleWithExtent:2@2.
	2 asPointWithinRectangleWithExtent:2@2.
	3 asPointWithinRectangleWithExtent:2@2.
	4 asPointWithinRectangleWithExtent:2@2.
	5 asPointWithinRectangleWithExtent:2@2.}     #(0@0 1@1 2@1 1@2 2@2 2@2)"
	
	"{0 asPointWithinRectangleWithExtent:3@3.
	1 asPointWithinRectangleWithExtent:3@3.
	2 asPointWithinRectangleWithExtent:3@3.
	3 asPointWithinRectangleWithExtent:3@3.
	4 asPointWithinRectangleWithExtent:3@3.
	5 asPointWithinRectangleWithExtent:3@3.
	6 asPointWithinRectangleWithExtent:3@3.
	7 asPointWithinRectangleWithExtent:3@3.
	8 asPointWithinRectangleWithExtent:3@3.
	9 asPointWithinRectangleWithExtent:3@3.
	10 asPointWithinRectangleWithExtent:3@3.}   #(0@0 1@1 2@1 3@1 1@2 2@2 3@2 1@3 2@3 3@3 3@3)"! !

!Number methodsFor: 'converting'!
theta: angle
	"Answer a new Point whose r value is the receiver and whose theta value is the argument."
	"KSC Extension"

	^(angle cos * self) @ (angle sin * self)! !

!Number methodsFor: 'intervals' stamp: 'ssa 9/7/2009 21:42'!
zeno
	"100 zeno"
	"-100 zeno"
	"Answer a collection of numbers representing Zeno's paradox steps between myself and zero"
	| steps distanceRemaining |
	steps _ OrderedCollection new.
	distanceRemaining _ self abs.
	[distanceRemaining > 1] whileTrue:[steps add: distanceRemaining * self sign.
		distanceRemaining _ distanceRemaining / 2.0].
	^steps asArray! !

!Number methodsFor: 'printing' stamp: 'ssa 1/1/1970 00:39'!
floatPrecisionForDecimalPlaces: places
	"Answer the floatPrecision that corresponds to the given number of decimal places"

	^ #(1 0.1 0.01 0.001 0.0001 0.00001 0.000001 0.0000001 0.00000001 0.000000001) at: (places + 1)

"
(0 to: 6) collect: [:i | Number floatPrecisionForDecimalPlaces: i]
"! !

!Number methodsFor: 'printing' stamp: 'ssa 1/1/1970 00:48'!
printShowingDecimalPlaces: placesDesired
	"Print the receiver showing precisely the given number of places desired .  If the placesDesired provided is positive, a decimal point and that many digits after the decimal point will always be shown.  If the placesDesired is zero, a whole number will be shown, without a decimal point.  This method could probably be greatly optimized -- improvements welcomed."

	| aString |
	placesDesired <= 0 ifTrue: [^ self rounded printString].

	aString _ ((self asFloat roundTo: (self floatPrecisionForDecimalPlaces: placesDesired)) asString), ((String new: placesDesired) atAllPut: $0).
	^ aString copyFrom: 1 to: ((aString indexOf: $.) + placesDesired)

"
0.23 printShowingDecimalPlaces: 2
23.5698 printShowingDecimalPlaces: 2
-234.567 printShowingDecimalPlaces: 5
23.4567 printShowingDecimalPlaces: 0
"! !

!Number methodsFor: 'printing' stamp: 'ssa 10/7/2008 18:20'!
printShowingMax3Digits
	"Print the receiver showing precisely the 3 digits, using K M B T for thousand, million, etc."
	"|num|
	num _ 0.00001234567890.
	20 timesRepeat:[num printShowingMax3Digits print.
		num _ num *10]."
	
	| s abs value |
	value _ self isFraction ifTrue:[self asFloat]ifFalse:[self].
	s _ value printString select:[:char| '0123456789' includes: char].
	s size <=3 ifTrue:[^value printString].
	abs _ value abs asFloat.
	abs < 0.01 ifTrue:[^((value * 1000) printShowingDecimalPlaces: 2),'m'].
	abs < 0.1 ifTrue:[^((value * 1000) printShowingDecimalPlaces: 1),'m'].
	abs < 10 ifTrue:[^value printShowingDecimalPlaces: 2].
	abs < 100 ifTrue:[^value printShowingDecimalPlaces: 1].
	abs < 1000 ifTrue:[^value asInteger printString].
	abs < 10000 ifTrue:[^((value /1000) printShowingDecimalPlaces: 2),'K'].
	abs < 100000 ifTrue:[^((value /1000) printShowingDecimalPlaces: 1),'K'].
	abs < 1000000 ifTrue:[^((value /1000) asInteger printString),'K'].
	abs < 10000000 ifTrue:[^((value /1000000) printShowingDecimalPlaces: 2),'M'].
	abs < 100000000 ifTrue:[^((value /1000000) printShowingDecimalPlaces: 1),'M'].
	abs < 1000000000 ifTrue:[^(value /1000000) asInteger printString,'M'].
	abs < 10000000000 ifTrue:[^((value /1000000000) printShowingDecimalPlaces: 2),'B'].
	abs < 100000000000 ifTrue:[^((value /1000000000) printShowingDecimalPlaces: 1),'B'].
	abs < 1000000000000 ifTrue:[^((value /1000000000) asInteger printString),'B'].
	abs < 10000000000000 ifTrue:[^((value /1000000000000) printShowingDecimalPlaces: 2),'T'].
	abs < 100000000000000 ifTrue:[^((value /1000000000000) printShowingDecimalPlaces: 1),'T'].
	abs < 1000000000000000 ifTrue:[^((value /1000000000000) asInteger printString),'T'].
	abs < 10000000000000000 ifTrue:[^((value /1000000000000000) printShowingDecimalPlaces: 2),'Q'].
	abs < 100000000000000000 ifTrue:[^((value /1000000000000000) printShowingDecimalPlaces: 1),'Q'].
	abs < 1000000000000000000 ifTrue:[^((value /1000000000000000) asInteger printString),'Q'].
	^'too big'
	
! !

!Number methodsFor: '*RVM-Archiving'!
archiveOn: aStream 
	aStream
		storeClass: self class;
		store: self! !

!Number class methodsFor: '*RVM-Archiving'!
dearchiveFrom: aStream
	^aStream read: self! !

!Object methodsFor: '*Javascript' stamp: 'aw 8/29/2007 14:27'!
~== anObject

	^ (self == anObject) not! !

!Object methodsFor: '*RVM-ensembles' stamp: 'ssa 4/21/2009 20:29'!
forMeRun: aBlock
	^ aBlock value! !

!Object methodsFor: '*RVM-ensembles' stamp: 'ads 1/30/2011 15:20'!
printConsole
  RVMOperations isRVM ifTrue: [RVMOperations print: self printString] ifFalse: [Transcript showInConsole ifFalse: [Transcript show: self printString; cr]]! !

!Object methodsFor: '*Sly' stamp: 'dmu 9/19/2010 22:45'!
comma: x
	^self , x! !

!Object methodsFor: '*Sly' stamp: 'dmu 3/25/2010 23:43'!
divideBy: x
	^ self / x! !

!Object methodsFor: '*Sly' stamp: 'dmu 8/27/2010 13:26'!
doubleEquals: anObject
	"a keyword verion of == for use with selector modifiers in Sly"
	^self == anObject! !

!Object methodsFor: '*Sly' stamp: 'dmu 8/27/2010 13:27'!
equals: anObject
	"a keyword verion of = for use with SlySelectorModifiers"
	^self = anObject! !

!Object methodsFor: '*Sly' stamp: 'dmu 3/25/2010 23:42'!
minus: x
	^ self - x! !

!Object methodsFor: '*Sly' stamp: 'dmu 3/25/2010 23:42'!
plus: x
	^ self + x! !

!Object methodsFor: '*Sly' stamp: 'dmu 3/25/2010 23:43'!
times: x
	^ self * x! !

!Object methodsFor: '*Sly2' stamp: 'ssa 6/17/2010 16:32'!
ENSasExplorerString
	^ self asExplorerString! !

!Object methodsFor: '*Sly2' stamp: 'ssa 6/17/2010 16:26'!
ENSasString

	^self asString! !

!Object methodsFor: '*Sly2' stamp: 'ssa 7/16/2010 19:19'!
ENSisEnsemble
	"SlyEnsemble overrides to true"
	^false! !

!Object methodsFor: '*Sly2' stamp: 'ssa 6/17/2010 13:35'!
ENSprintOn: aStream
	"Print a textual representation of myself on aStream"

	^ self printOn: aStream! !

!Object methodsFor: '*Sly2' stamp: 'ssa 6/17/2010 15:01'!
ENSprintString

	^self printString! !

!Object methodsFor: '*Sly2' stamp: 'ssa 7/16/2010 19:14'!
ENSsize

	^self size! !

!Object methodsFor: '*Sly2' stamp: 'ssa 6/17/2010 13:34'!
ENSstoreOn: aStream
	"Store a textual representation of myself on aStream"

	^ self storeOn: aStream! !

!Object methodsFor: '*Sly2' stamp: 'ssa 7/7/2010 13:56'!
sentToEnsemble: aMessage

	^self perform: aMessage selector withArguments: aMessage arguments! !

!Object methodsFor: '*Sly3' stamp: 'dmu 9/16/2010 23:45'!
asSingletonEnsemble
	^Sly3Ensemble withSoleMember: self! !

!Object methodsFor: '*Sly3' stamp: 'dmu 9/1/2010 23:22'!
collectionLY
	^ nil! !

!Object methodsFor: '*Sly3' stamp: 'ads 1/30/2011 15:20'!
doesNotUnderstand: aMessage 
	 "Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."
	"Testing: (3 activeProcess)"
	|  newSelector rps |
	rps _ {Sly3Adverb reflectiveAdverb stringWithUppercaseSuffix. Sly3ModWholly stringWithUppercaseSuffix}.
	rps do: [:rp |
		(aMessage selector beginsWith: rp) ifTrue: [
			newSelector _ aMessage selector copyFrom: rp size + 1 to: aMessage selector size.
			newSelector size = 0 ifTrue: [^ self].
			^ self perform: newSelector asSymbol withArguments: aMessage arguments
		]
	].
	(RVMOperations isMulticoreCoordinate: aMessage selector)
		 ifTrue:[RVMOperations teleport: self to: aMessage selector. 
				^self].
	(Preferences autoAccessors and: [self tryToDefineVariableAccess: aMessage])
		ifTrue: [^ aMessage sentTo: self].

	^ MessageNotUnderstood new 
		message: aMessage;
		receiver: self;
		signal! !

!Object methodsFor: '*sunit-preload' stamp: 'jp 3/17/2003 09:58'!
sunitAddDependent: anObject
 
        self addDependent: anObject! !

!Object methodsFor: '*sunit-preload' stamp: 'jp 3/17/2003 09:58'!
sunitChanged: anAspect
 
        self changed: anAspect! !

!Object methodsFor: '*sunit-preload' stamp: 'jp 3/17/2003 09:58'!
sunitRemoveDependent: anObject
 
        self removeDependent: anObject! !

!Object methodsFor: 'converting'!
asDisplayObject
	"kwa -- 7 July 1989, answer some DisplayObject which represents the receiver.  The default is DisplayString.  Subclasses may wish to override.
	kwa -- 5 December 1989, changed from DisplayText to DisplayString for efficiency."
	"ssa - 27 February 1990, at kwa's suggestion, changed asDisplayString back to asDisplayText to work around a bug in glyph scanning"
	"KSC Extension"

	^self asDisplayText! !

!Object methodsFor: 'converting'!
DisplayText
	"Convert the receiver into a DisplayText."
	"KSC Extension."

	^self asText asDisplayText! !

!Object methodsFor: 'converting' stamp: 'ssa 11/13/2008 10:34'!
asObjectCoordinate
	"Answer an RVMObjectCoordinate with my manycore coordinate details"
	
	^RVMObjectCoordinate for: self! !

!Object methodsFor: 'converting'!
asText
	"kwa -- 7 July 1989, answer some Text which represents the receiver.  The default is to use asString asText.  This is so any object can can be treated as a Text (whether it is or not).  Subclasses may wish to override (but shouldn't have to) to take advantage of emphasis et al."
	"KSC Extension"

	^self asString asText! !

!Object methodsFor: 'converting' stamp: 'ssa 12/16/2009 13:22'!
printDirectlyToDisplay
	"For debugging: write the receiver's printString directly to the display at (0, 100); senders of this are detected by the check-for-slips mechanism."

	self asString displayAt: 0@0

"StringMorph someInstance printDirectlyToDisplay"! !

!Object methodsFor: 'debugging' stamp: 'ssa 1/21/2010 12:08'!
display
	"Display my printString on the screen to avoid the transcript"
	
	self printString asParagraph display! !

!Object methodsFor: 'debugging' stamp: 'ssa 2/26/2009 01:59'!
locate
	"Open a object coordinate view on my location in the manycore world"
	"Array locate"
	RVMObjectCoordinateView openOn: self asObjectCoordinate! !

!Object methodsFor: 'debugging' stamp: 'ssa 8/8/2008 17:25'!
print

	Transcript cr;show: self printString! !

!Object methodsFor: 'inspecting' stamp: 'ssa 1/6/2010 20:19'!
inspect
	"Create and schedule an Inspector in which the user can examine the receiver's variables."

	self inspectorClass openOn: self withEvalPane: true! !

!Object methodsFor: 'macpal' stamp: 'ssa 9/8/2009 10:22'!
allInstanceVariableValues
	"Answer a collection whose elements are the values of those instance variables of the receiver"
	| c |
	c _ OrderedCollection new.
	1 to: self class instSize do:
		[:i | c add: (self instVarAt: i)].
	^ c! !

!Object methodsFor: 'macpal' stamp: 'ssa 9/8/2009 10:51'!
allInstanceVariableValuesPlusIndexed
	"Answer a collection whose elements are the values of those instance variables of the receiver.
	Also include the indexed variables if any"
	| c |
	c _ OrderedCollection new.
	1 to: self class instSize do:
		[:i | c add: (self instVarAt: i)].
	self class isVariable ifFalse:[^c].
	1 to: self size do:[:index|
		c add: (self basicAt: index)].
	^ c! !

!Object methodsFor: 'outlining' stamp: 'ssa 9/11/2009 16:40'!
explore

	ObjectExplorer new openExplorerFor: self! !

!Object methodsFor: 'outlining' stamp: 'ssa 3/9/2010 16:17'!
hasContents

	^false! !

!Object methodsFor: 'outlining' stamp: 'ssa 9/10/2009 16:00'!
outlineString

	^self printString! !

!Object methodsFor: 'outlining' stamp: 'ssa 9/10/2009 13:36'!
subobjects
	"Answer an appropriate collection of my sub objects for an outliner view"
	
	^self class allInstVarNames with: self allInstanceVariableValues collect:[:key :value| key -> value]! !

!Object methodsFor: 'printing' stamp: 'ssa 10/25/2008 20:45'!
archiveVersion
	"Subclasses should override when they implement a different archive version"

	^1! !

!Object methodsFor: 'printing'!
sicArchiveOn: aStream 
	"This is the generic archiver for objects. This can be used if you want to bypass superclass or other reasons for overriding archiveOn:"

	aStream
		storeObject: self;
		storeClass: self class.

	self class isVariable ifTrue:
		[aStream store: self basicSize.
		1 to: self basicSize do: [:i | aStream nextPut: (self basicAt: i)].].

	1 to: self class instSize do: [:i | aStream nextPut: (self instVarAt: i)].! !

!Object methodsFor: 'printing' stamp: 'ads 1/24/2011 13:03'!
longPrintOn: aStream
	"Append to the argument, aStream, the names and values of all 
	of the receiver's instance variables."

	self class allInstVarNames doWithIndex:
		[:title :index |
		aStream nextPutAll: title;
		 nextPut: $:;
		 space;
		 tab;
		 nextPutAll: (RVMPrimitivesNeededForBootstrapping printPrefixFor: (self instVarAt: index));
		print:(self instVarAt: index);
		 cr]! !

!Object methodsFor: 'printing' stamp: 'ssa 9/4/2009 22:29'!
printStringUpTo: limit
	"Answer a String whose characters are a description of the receiver.
	If you want to print without a character limit, use fullPrintString."
	| limitedString |
	limitedString _ String streamContents: [:s | self printOn: s] limitedTo: limit.
	limitedString size < limit ifTrue: [^ limitedString].
	^ limitedString, '...'! !

!Object methodsFor: 'testing' stamp: 'ssa 9/8/2009 10:48'!
hasInstanceVariables

	^self allInstanceVariableValuesPlusIndexed size > 0! !

!Object methodsFor: 'testing' stamp: 'ssa 5/12/2010 19:26'!
isArray
	"Return true if the receiver is an Array"
	^false! !

!Object methodsFor: 'testing' stamp: 'ssa 5/27/2010 10:40'!
isBoolean
	"Return true if the receiver is true or false.
	Note: Do not override in any class except Boolean."
	^false! !

!Object methodsFor: 'testing' stamp: 'ssa 8/11/2009 12:37'!
isCharacter
	^false! !

!Object methodsFor: 'testing' stamp: 'dmu 9/3/2010 15:00'!
isEnsemble
	"Sly3Ensemble overrides to true"
	^false! !

!Object methodsFor: 'testing' stamp: 'ssa 8/31/2009 14:14'!
isObject

	^true! !

!Object methodsFor: 'updating' stamp: 'ssa 5/12/2010 10:29'!
changed: anAspect with: anObject from: aSource
	"Receiver changed. The change is denoted by the argument anAspect. 
	Usually the argument is a Symbol that is part of the dependent's change 
	protocol. Inform all of the dependents. Also pass anObject for additional information."

	self dependents do: [:aDependent | aDependent update: anAspect with: anObject from: aSource]! !

!Object methodsFor: 'updating' stamp: 'ssa 5/12/2010 10:29'!
update: anAspect with: anObject from: aSource
	"Receive a change notice from an object of whom the receiver is a 
	dependent. The default behavior is to call update:,
	which by default does nothing; a subclass might want 
	to change itself in some way."

	^ self update: anAspect with: anObject! !

!Object methodsFor: 'user interface' stamp: 'ssa 6/17/2010 16:15'!
asExplorerString
	^ self printString! !

!Object methodsFor: 'user interface' stamp: 'ssa 11/30/2009 17:49'!
defaultBackgroundColor
	"Answer the color to be used as the base window color for a window whose model is an object of the receiver's class"
	
	(Smalltalk includesKey: #WINDOWCOLORSELECTOR)
		ifFalse:[Smalltalk at: #WINDOWCOLORSELECTOR put:[:obj| Preferences windowColorFor: obj  class name]].
	
	^((Smalltalk at: #WINDOWCOLORSELECTOR) value: self) ! !

!Object methodsFor: 'private' stamp: 'yo 6/29/2004 11:37'!
errorNotIndexable
	"Create an error notification that the receiver is not indexable."

	self error: ('Instances of {1} are not indexable' translated format: {self class name})! !

!Object methodsFor: 'private'!
errorSubscriptBounds: index 
	"Create an error notification that an improper integer was used as an index."

	self error: 'subscript is out of bounds: ' , index printString! !

!Object methodsFor: '*SlyBootstrap' stamp: 'dmu 3/18/2010 15:47'!
primitiveGetExtraPreheaderWord: anObject
	"ignores receiver, queries argument"
	<primitive: 'primitiveGetExtraPreheaderWord' module: 'RVMPlugin'>
	self primitiveFailed! !

!Object methodsFor: '*SlyBootstrap' stamp: 'dmu 3/18/2010 14:52'!
primitiveSetExtraPreheaderWord: w
	"sets word IN w to SELF"
	<primitive: 'primitiveSetExtraPreheaderWord' module: 'RVMPlugin'>
	self primitiveFailed! !

!Object methodsFor: '*SlyBootstrap' stamp: 'dmu 3/16/2010 19:11'!
primitiveSetExtraWordSelector: aSelector
	<primitive: 'primitiveSetExtraWordSelector' module: 'RVMPlugin'>
	self primitiveFailed! !

!Object methodsFor: '*RVM-Archiving'!
archiveOn: aStream 
	"This is the generic archiver for objects. If an object does anything special, this method will need to be subclassed along with the complementary method - dearchiveFrom:"

	aStream
		storeObject: self;
		storeClass: self class.

	self class isVariable ifTrue:
		[aStream store: self basicSize.
		1 to: self basicSize do: [:i | aStream nextPut: (self basicAt: i)].].

	1 to: self class instSize do: [:i | aStream nextPut: (self instVarAt: i)].! !

!Object methodsFor: '*RVM-Archiving'!
dearchiveFrom: aStream
	"This is the generic de-archiver for objects. If an object does anything special, this method will need to be subclassed along with the complementary method - archiveOn:"

	self class isVariable ifTrue:
		[1 to: self basicSize do: [:i | self basicAt: i put: aStream next]].

	1 to: self class instSize
	  do: [:j | self instVarAt: j put: aStream next]! !

!Object methodsFor: '*RVM-Archiving'!
sicArchiveOn: aStream 
	"This is the generic archiver for objects. This can be used if you want to bypass superclass or other reasons for overriding archiveOn:"

	aStream
		storeObject: self;
		storeClass: self class.

	self class isVariable ifTrue:
		[aStream store: self basicSize.
		1 to: self basicSize do: [:i | aStream nextPut: (self basicAt: i)].].

	1 to: self class instSize do: [:i | aStream nextPut: (self instVarAt: i)].! !

!Object class methodsFor: '*RVM-Archiving'!
dearchive: versionNumber from: aStream
	"Override this method when implementing new archive versions for a class."

	^versionNumber == self archiveVersion
		ifTrue: [self dearchiveFrom: aStream]
		ifFalse: [self error: 'Can''t dearchive this version.']! !

!Object class methodsFor: '*RVM-Archiving'!
dearchiveFrom: aStream

	| anObject |
	self isVariable
		ifTrue:[anObject _ self basicNew: (aStream read: Integer)]
		ifFalse:[anObject _ self dearchiveNewFrom: aStream].
	aStream storeObject: anObject.
	anObject dearchiveFrom: aStream.
	^anObject! !

!Object class methodsFor: '*RVM-Archiving'!
dearchiveNewFrom: aStream
	^self basicNew! !

!ObjectExplorer methodsFor: 'opening/closing' stamp: 'ssa 9/11/2009 16:15'!
hide: anItem
	"recursively hide this and all progeny"
		
	anItem isOpen ifTrue:[(self listedChildrenOf: anItem) do:[:each| self hide: each]].
	self levels removeKey: anItem ifAbsent:[].
	self list remove: anItem ifAbsent:[self halt].
	anItem isOpen: false.
! !

!ObjectExplorer methodsFor: 'opening/closing' stamp: 'ssa 2/26/2010 13:47'!
hideChildrenOfSelection

	(self listedChildrenOf: self currentSelection ) do:[:each| self hide: each].
	self currentSelection isOpen: false.
		
	! !

!ObjectExplorer methodsFor: 'opening/closing' stamp: 'ssa 9/11/2009 16:14'!
listedChildrenOf: aWrapper

	^self list select:[:item| item parent == aWrapper]! !

!ObjectExplorer methodsFor: 'opening/closing' stamp: 'ssa 2/26/2010 13:45'!
showChildrenOfSelection

	| kids |
	self currentSelection hasContents ifFalse:[^self].
	kids _ self currentSelection contents.
	self list addAll: kids after: self currentSelection.
	self currentSelection isOpen: true.! !

!ObjectExplorer methodsFor: 'opening/closing' stamp: 'ssa 9/11/2009 15:44'!
toggleSelection

	self currentSelection isNil ifTrue:[^self].
	self currentSelection isOpen
		ifTrue:[self hideChildrenOfSelection]
		ifFalse:[self showChildrenOfSelection].
	self changed:#list! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'RAA 9/23/1999 13:11'!
contentsSelection
	"Return the interval of text in the code pane to select when I set the pane's contents"

	^ 1 to: 0  "null selection"! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 2/8/2010 14:40'!
defaultRootLabel

	^'unlabeled object'! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'RAA 9/23/1999 13:15'!
doItContext
	"Answer the context in which a text selection can be evaluated."

	^nil! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'RAA 9/23/1999 13:19'!
doItReceiver
	"Answer the object that should be informed of the result of evaluating a
	text selection."

	currentSelection ifNil: [^rootObject].
	^currentSelection withoutListWrapper
! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 6/17/2010 16:25'!
getList
	^OrderedCollection with: (ObjectExplorerWrapper with: rootObject name: 'root' model: self parent: nil)
! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:35'!
inspector
	"Answer the value of inspector"

	inspector isNil ifTrue:[self inspector: nil].
	^ inspector! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:35'!
inspector: anObject
	"Set the value of inspector"

	inspector _ anObject! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'hg 9/7/2001 12:12'!
label

	^ rootObject printStringLimitedTo: 32! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:51'!
list
	"Answer the value of list"

	list isNil ifTrue:[self list: self getList].
	^ list! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:35'!
monitorList: anObject
	"Set the value of monitorList"

	monitorList _ anObject! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 12/17/2009 10:02'!
monitorProcess
	"Answer the value of monitorProcess"

	monitorProcess isNil ifTrue:[self monitorProcess: nil].
	^ monitorProcess! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 12/17/2009 10:02'!
monitorProcess: anObject
	"Set the value of monitorProcess"

	monitorProcess _ anObject! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'nk 7/24/2003 09:43'!
object
	^currentSelection ifNotNilDo: [ :cs | cs withoutListWrapper ]! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'nk 7/24/2003 10:02'!
parentObject
	currentSelection ifNil: [ ^nil ].
	currentSelection parent ifNil: [ ^rootObject ].
	^currentSelection parent withoutListWrapper! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 2/8/2010 14:40'!
rootLabel
	"Answer the value of rootLabel"

	rootLabel isNil ifTrue:[self rootLabel: self defaultRootLabel].
	^ rootLabel! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 2/8/2010 14:39'!
rootLabel: anObject
	"Set the value of rootLabel"

	rootLabel _ anObject! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:35'!
rootObject
	"Answer the value of rootObject"

	rootObject isNil ifTrue:[self rootObject: nil].
	^ rootObject! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:35'!
rootObject: anObject
	"Set the value of rootObject"

	rootObject _ anObject! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'nk 7/24/2003 09:47'!
selector
	^currentSelection ifNotNilDo: [ :cs | cs selector ]! !

!ObjectExplorer methodsFor: 'accessing' stamp: 'ssa 2/9/2010 04:26'!
wrapperFor: anObject

	^self list detect:[:wrapper| wrapper item == anObject]ifNone:[^nil]! !

!ObjectExplorer methodsFor: 'error handling' stamp: 'nk 7/24/2003 09:29'!
doesNotUnderstand: aMessage
	inspector ifNotNil: [ (inspector respondsTo: aMessage selector) ifTrue: [ ^inspector perform: aMessage selector withArguments: aMessage arguments ]].
	^super doesNotUnderstand: aMessage! !

!ObjectExplorer methodsFor: 'menus' stamp: 'sd 11/20/2005 21:27'!
chasePointers
	"Open a PointerFinder on the selected item"
	| path sel savedRoot saved |
	path := OrderedCollection new.
	sel := currentSelection.
	[ sel isNil ] whileFalse: [ path addFirst: sel asString. sel := sel parent ].
	path addFirst: #openPath.
	path := path asArray.
	savedRoot := rootObject.
	saved := self object.
	[ rootObject := nil.
	self changed: #getList.
	(Smalltalk includesKey: #PointerFinder)
		ifTrue: [PointerFinder on: saved]
		ifFalse: [self objectReferencesToSelection ]]
		ensure: [ rootObject := savedRoot.
			self changed: #getList.
			self changed: path.
		]! !

!ObjectExplorer methodsFor: 'menus' stamp: 'RAA 9/23/1999 13:22'!
codePaneMenu: aMenu shifted: shifted
	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"
	^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted
! !

!ObjectExplorer methodsFor: 'menus' stamp: 'sd 11/20/2005 21:27'!
defsOfSelection
	"Open a browser on all defining references to the selected instance variable, if that's what's currently selected."
	| aClass sel |

	(aClass := self parentObject class) isVariable ifTrue: [^ self changed: #flash].
	sel := self selector.
	self systemNavigation  browseAllStoresInto: sel from: aClass! !

!ObjectExplorer methodsFor: 'menus' stamp: 'nk 7/24/2003 10:26'!
exploreSelection
	"Open an ObjectExplorer on the current selection"
	self object explore! !

!ObjectExplorer methodsFor: 'menus' stamp: 'ssa 1/6/2010 20:35'!
explorerKey: aChar from: view

	"Similar to #genericMenu:..."
	| insideObject parentObject |
	currentSelection ifNotNil: [
		insideObject := self object.
		parentObject := self parentObject.
		inspector ifNil: [inspector := Inspector new].
		inspector
			inspect: parentObject;
			object: insideObject.

		aChar == $i ifTrue: [^ self inspectSelection].
		aChar == $e ifTrue: [^ self exploreSelection].

		aChar == $b ifTrue:	[^ inspector browseMethodFull].
		aChar == $h ifTrue:	[^ inspector classHierarchy].
		aChar == $c ifTrue: [^ inspector copyName].
		aChar == $p ifTrue: [^ inspector browseFullProtocol].
		aChar == $N ifTrue: [^ inspector browseClassRefs].
		aChar == $t ifTrue: [^ inspector tearOffTile].
		aChar == $v ifTrue: [^ inspector viewerForValue]].

	^ self arrowKey: aChar from: view! !

!ObjectExplorer methodsFor: 'menus' stamp: 'ssa 12/17/2009 10:13'!
genericMenu: aMenu 
	"Borrow a menu from my inspector"
	| insideObject menu parentObject |
	currentSelection
		ifNil: [menu := aMenu.
			menu
				add: '*nothing selected*'
				target: self
				selector: #yourself
				argument:nil]
		ifNotNil: [insideObject := self object.
			parentObject := self parentObject.
			inspector
				ifNil: [inspector := Inspector new].
			inspector inspect: parentObject;
				 object: insideObject.
			aMenu selections do:[:each| aMenu targets add: inspector].
			inspector fieldListMenu: aMenu.
			aMenu selections do:[:each| aMenu targets add: inspector].
			aMenu selections 
				do: [:i | (#(#inspectSelection #exploreSelection #referencesToSelection #defsOfSelection #objectReferencesToSelection #chasePointers ) includes: i )
						ifTrue: [aMenu targets at:(aMenu selections indexOf:i) put:self]].
			aMenu addLine;
				add: 'monitor changes'
				target: self
				selector: #monitor:
				argument: currentSelection].
	monitorList isEmptyOrNil
		ifFalse: [aMenu addLine;
				add: 'stop monitoring all'
				target: self
				selector: #stopMonitoring
				argument:nil].
	^ aMenu! !

!ObjectExplorer methodsFor: 'menus' stamp: 'nk 7/24/2003 10:26'!
inspectSelection
	"Open an Inspector on the current selection"
	self object inspect! !

!ObjectExplorer methodsFor: 'menus' stamp: 'nk 7/24/2003 10:00'!
objectReferencesToSelection
	"Open a browser on all references to the selected instance variable, if that's what currently selected. "
	self systemNavigation
		browseAllObjectReferencesTo: self object
		except: (Array with: self parentObject with: currentSelection with: inspector)
		ifNone: [:obj | self changed: #flash].
! !

!ObjectExplorer methodsFor: 'menus' stamp: 'sd 11/20/2005 21:27'!
referencesToSelection
	"Open a browser on all references to the selected instance variable, if that's what's currently selected."
	| aClass sel |

	(aClass := self parentObject class) isVariable ifTrue: [^ self changed: #flash].
	sel := self selector.
	self systemNavigation browseAllAccessesTo: sel from: aClass! !

!ObjectExplorer methodsFor: 'menus' stamp: 'RAA 9/23/1999 13:19'!
selectedClass
	"Answer the class of the receiver's current selection"

	^self doItReceiver class
! !

!ObjectExplorer methodsFor: 'menus' stamp: 'RAA 9/23/1999 13:10'!
trash
	"What goes in the bottom pane"
	^ ''! !

!ObjectExplorer methodsFor: 'menus' stamp: 'RAA 9/23/1999 13:10'!
trash: newText
	"Don't save it"
	^ true! !

!ObjectExplorer methodsFor: 'monitoring' stamp: 'ssa 12/17/2009 10:24'!
monitor: anObjectExplorerWrapper
	"Start stepping and watching the given wrapper for changes."
	anObjectExplorerWrapper ifNil: [ ^self ].
	self monitorList at: anObjectExplorerWrapper put: anObjectExplorerWrapper asString.
	self monitorProcess isNil ifFalse:[self monitorProcess terminate].
	self monitorProcess: [[self monitorList notEmpty]whileTrue:[(Delay forMilliseconds:200)wait.  self step]] newProcess.
	[self monitorProcess resume] fork! !

!ObjectExplorer methodsFor: 'monitoring' stamp: 'sd 11/20/2005 21:27'!
monitorList
	^monitorList ifNil: [ monitorList := WeakIdentityKeyDictionary new ].! !

!ObjectExplorer methodsFor: 'monitoring' stamp: 'ssa 12/17/2009 10:06'!
release
	self stopMonitoring.
	super release.! !

!ObjectExplorer methodsFor: 'monitoring' stamp: 'nk 7/12/2003 17:55'!
shouldGetStepsFrom: aWorld
	^self monitorList notEmpty! !

!ObjectExplorer methodsFor: 'monitoring' stamp: 'ssa 12/17/2009 10:20'!
step
	"If there's anything in my monitor list, see if the strings have changed."
	| string changes |
	changes := false.
	self monitorList keysAndValuesDo: [ :k :v |
		k ifNotNil: [
			k refresh.
			(string := k asString) ~= v ifTrue: [ self monitorList at: k put: string. changes := true ].
		]
	].

	changes ifTrue: [ | sel | 
		sel := currentSelection.
		self changed: #list.
		self noteNewSelection: sel.
	].
! !

!ObjectExplorer methodsFor: 'monitoring' stamp: 'ssa 12/17/2009 10:06'!
stopMonitoring
	monitorList := nil.
	self monitorProcess ifNotNil:[self monitorProcess terminate]! !

!ObjectExplorer methodsFor: 'user interface' stamp: 'ssa 9/10/2009 16:51'!
explorerFor: anObject
	
	^self explorerFor: anObject withLabel:'Object Explorer'! !

!ObjectExplorer methodsFor: 'user interface' stamp: 'ssa 3/24/2010 15:05'!
explorerFor: anObject withLabel: label 
	|  topView listView ptv |
	rootObject := anObject.
	topView := StandardSystemView new
				label: 'Exploring ',anObject class name,' ',label; 
				model: self;
				yourself.
	topView addSubView:(listView := ExplorerListView
						on: self
						list: #list
						selected: #getCurrentSelection
						changeSelected: #noteNewSelection:
						menu: #genericMenu:
						keystroke: #explorerKey:from:)
		in: (0 @ 0 corner: 1 @ 0.8)
		borderWidth:1.
	ptv _ PluggableTextView
				on: self
				text: #trash
				accept: #trash:
				readSelection: #contentsSelection
				menu: #codePaneMenu:shifted:.
	ptv askBeforeDiscardingEdits: false.
	topView
		addSubView: ptv	
		in: (0 @ 0.8 corner: 1 @ 1)
		borderWidth:1.
	listView autoDeselect: false.
	^ topView! !

!ObjectExplorer methodsFor: 'user interface' stamp: 'RAA 6/2/2000 16:23'!
initialExtent

	^300@500! !

!ObjectExplorer methodsFor: 'user interface' stamp: 'ssa 9/10/2009 16:42'!
openBrowser: aClass

	Browser newOnClass: aClass selector: nil! !

!ObjectExplorer methodsFor: 'user interface' stamp: 'ssa 9/11/2009 14:37'!
openExplorerFor: anObject
"
ObjectExplorer new openExplorerFor: Smalltalk
"

    (self explorerFor: anObject) controller open.
    ^ self
! !

!ObjectExplorer commentStamp: '<historical>' prior: 0!
ObjectExplorer provides a hierarchical alternative to #inspect. Simply evaluate an expression like:

World explore

and enjoy.!
!ObjectExplorer class methodsFor: 'instance creation' stamp: 'ssa 2/8/2010 14:44'!
openExplorerFor: anObject labeled: newRootLabel withLabel: label 

	| exp view |
	exp _ self new rootLabel: newRootLabel.
	view _ exp explorerFor: anObject withLabel: label .
	view  controller open! !

!ObjectExplorer class methodsFor: 'instance creation' stamp: 'ssa 2/8/2010 14:33'!
openExplorerFor: anObject withLabel: label 

	| exp |
	exp _ self new explorerFor: anObject withLabel: label .
	exp controller open! !

!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:14'!
parent
	^parent! !

!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:14'!
parent: anObject
	parent _ anObject! !

!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:49'!
selector
	parent ifNil: [ ^nil ].
	^(parent withoutListWrapper class allInstVarNames includes: itemName) ifTrue: [ itemName asSymbol ]! !

!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 6/21/1999 10:49'!
setItem: anObject name: aString model: aModel

	item _ anObject.
	model _ aModel.
	itemName _ aString.! !

!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:14'!
setItem: anObject name: aString model: aModel parent: itemParent
	parent _ itemParent.
	self setItem: anObject name: aString model: aModel! !

!ObjectExplorerWrapper methodsFor: 'converting' stamp: 'ssa 7/7/2010 11:08'!
asString
	| explorerString string |

	explorerString _ 
		[item asExplorerString]
			on: Error 
			do: ['<error: ', item class name, ' in asExplorerString: evaluate "' , itemName , ' asExplorerString" to debug>'].
	string _ (itemName ifNotNil: [itemName , ': '] ifNil: ['']) , explorerString.
	(string includes: Character cr)
		ifTrue: [^ string withSeparatorsCompacted].
	^ string! !

!ObjectExplorerWrapper methodsFor: 'converting' stamp: 'nk 7/24/2003 10:16'!
itemName
	^itemName! !

!ObjectExplorerWrapper methodsFor: 'monitoring' stamp: 'nk 7/12/2003 18:28'!
refresh
	"hack to refresh item given an object and a string that is either an index or an instance variable name."
	[ | index |
		(model class allInstVarNames includes: itemName)
			ifTrue: [ item _ model instVarNamed: itemName ]
			ifFalse: [ index _ itemName asNumber.
				(index between: 1 and: model basicSize) ifTrue: [ item _ model basicAt: index]]
	] on: Error do: [ :ex | item _ nil ]! !

!ObjectExplorerWrapper methodsFor: 'accessing' stamp: 'ssa 9/11/2009 16:17'!
contents

	(item respondsTo: #explorerContents) ifTrue: [^item explorerContents collect:[:e| e parent: self]].
	"For all others, show named vars first, then indexed vars"
	^(item class allInstVarNames asOrderedCollection withIndexCollect: [:each :index |
		self class
			with: (item instVarAt: index)
			name: each
			model: item
			parent: self]) ,
	((1 to: item basicSize) collect: [:index |
		self class
			with: (item basicAt: index)
			name: index printString
			model: item
			parent: self])! !

!ObjectExplorerWrapper methodsFor: 'accessing' stamp: 'ssa 9/11/2009 15:09'!
depth

	^self parent isNil ifTrue:[0]ifFalse:[self parent depth + 1]! !

!ObjectExplorerWrapper methodsFor: 'accessing' stamp: 'RAA 6/21/1999 11:27'!
hasContents

	^item hasContentsInExplorer
	
! !

!ObjectExplorerWrapper methodsFor: 'accessing' stamp: 'dgd 9/26/2004 18:34'!
icon
	"Answer a form to be used as icon"
	^ Preferences visualExplorer
		ifTrue: [item iconOrThumbnailOfSize: 16]
		ifFalse: [nil]! !

!ObjectExplorerWrapper methodsFor: 'accessing' stamp: 'ssa 9/11/2009 14:45'!
isOpen
	"Answer the value of isOpen"

	isOpen isNil ifTrue:[self isOpen: false].
	^ isOpen! !

!ObjectExplorerWrapper methodsFor: 'accessing' stamp: 'ssa 9/11/2009 14:45'!
isOpen: anObject
	"Set the value of isOpen"

	isOpen _ anObject! !

!ObjectExplorerWrapper methodsFor: 'accessing' stamp: 'ssa 9/11/2009 14:45'!
itemName: anObject
	"Set the value of itemName"

	itemName _ anObject! !

!ObjectExplorerWrapper commentStamp: '<historical>' prior: 0!
Contributed by Bob Arning as part of the ObjectExplorer package.
!
!ObjectExplorerWrapper class methodsFor: 'as yet unclassified' stamp: 'RAA 6/21/1999 10:50'!
with: anObject name: aString model: aModel

	^self new 
		setItem: anObject name: aString model: aModel! !

!ObjectExplorerWrapper class methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:16'!
with: anObject name: aString model: aModel parent: aParent

	^self new 
		setItem: anObject name: aString model: aModel parent: aParent
! !

!OneFilePerClass methodsFor: 'loading' stamp: 'ads 12/3/2010 12:32'!
filePathForClass: aClass
	| classCatDirName |
	classCatDirName := self validNameForDir: aClass category in: self rootDirectory.
	^ classCatDirName, self rootDirectory pathNameDelimiter asString, (self fileNameForClass: aClass)! !

!OneFilePerClass methodsFor: 'loading' stamp: 'sm 4/21/2011 23:08'!
saveScriptForLoadingPackageBackIn: p
	| file dirName |
	file := self rootDirectory newFileNamed: self rootName, '.st'.
	
	(file respondsTo: #lineEndConvention:) ifTrue: [
		file lineEndConvention: #lf.
	].
					
	preambleBlock ifNotNil: [ preambleBlock value: file ].

	file nextPutAll: '{'; cr.
	(self classesInOrderForLoading: p) do: [:class |
		file nextPutAll: String tab, (self filePathForClass: class) printString, '.'; cr.
	].
	dirName := (transporter baseDirectory = FileDirectory default ifTrue: [''] ifFalse: [transporter baseDirectory localName, FileDirectory pathNameDelimiter]), self rootName.
	file nextPutAll: '} do: [:fileName | ((FileDirectory default directoryNamed: ', dirName printString, ') readOnlyFileNamed: fileName) fileIn].'; cr.

	postscriptBlock ifNotNil: [ postscriptBlock value: file ].

	file close.! !

!OneFilePerClass methodsFor: 'saving' stamp: 'ads 12/3/2010 13:34'!
fileNameForClass: cls
	^ cls theNonMetaClass name, FileDirectory dot, 'st'! !

!OneFilePerClass methodsFor: 'saving' stamp: 'sm 4/21/2011 23:10'!
newFileForClass: cls do: blk
	| catDir fileName f |
	catDir := self classCategoryDirFor: cls theNonMetaClass category.
	fileName := self fileNameForClass: cls.
	(catDir fileExists: fileName) ifTrue: [
		f := catDir fileNamed: fileName.
		f setToEnd.
	] ifFalse: [
		f := catDir newFileNamed: fileName.										
	].

	(f respondsTo: #lineEndConvention:) ifTrue: [
		f lineEndConvention: #lf.
	].

	blk value: f.
	f close.! !

!OneFilePerClass methodsFor: 'saving' stamp: 'ads 12/14/2010 14:16'!
saveAllExtensionMethodsForPackage: p
	p extensionClasses asArray do: [:cls |
		self newFileForClass: cls do: [:f |
			(p extensionCategoriesForClass: cls) do: [:cat |
				cls fileOutCategory: cat on: f moveSource: false toFile: 0.
			].
		].
	] displayingProgress: 'Saving ', p name, ' extension methods'.! !

!OneFilePerClass methodsFor: 'saving' stamp: 'ads 12/14/2010 10:33'!
saveClass: class forPackage: p
	self newFileForClass: class do: [:f |
		class fileOutOn: f moveSource: false toFile: 0 filteringCategoriesBy: [:cat :classOrMetaclass | p includesMethodCategory: cat ofClass: classOrMetaclass].
	].! !

!OpaqueForm methodsFor: 'private' stamp: 'ssa 8/21/2009 20:42'!
colormapIfNeededFor: df

	^self colorForm colormapIfNeededFor: df! !

!OpaqueForm methodsFor: 'private' stamp: 'ssa 8/22/2009 13:50'!
setFigure: figureForm shape: shapeForm
	"Initialize the instance variables."

	| figure shape |
	figure _ figureForm.
	shape _ ColorForm mappingWhiteToTransparentFrom:( shapeForm asFormOfDepth: 8).
	figure displayOn: shape at: 0@0 clippingBox: figure boundingBox rule: Form paint fillColor: nil.
	self colorForm: shape! !

!OpaqueForm methodsFor: 'display box access' stamp: 'ssa 8/21/2009 20:28'!
computeBoundingBox
	"Answer the minimum enclosing rectangle around the image."

	^self colorForm boundingBox! !

!OpaqueForm methodsFor: 'accessing' stamp: 'ssa 8/21/2009 20:44'!
colorForm
	"Answer the value of colorForm"

	self! !

!OpaqueForm methodsFor: 'accessing' stamp: 'ssa 8/21/2009 20:44'!
colorForm: anObject
	"Set the value of colorForm"

	self become: anObject! !

!OpaqueForm methodsFor: 'accessing' stamp: 'ssa 8/21/2009 20:31'!
figure
	"Answer the visible image of the receiver."

	^ self colorForm! !

!OpaqueForm methodsFor: 'accessing' stamp: 'ssa 8/21/2009 20:31'!
offset
	"Answer the offset for displaying the image."

	^ self figure offset! !

!OpaqueForm methodsFor: 'accessing' stamp: 'ssa 8/21/2009 20:31'!
shape
	"Answer the form that indicates what part of the background should 
	get occluded in displaying the receiver."

	^ self colorForm! !

!OpaqueForm methodsFor: 'accessing' stamp: 'ssa 8/21/2009 20:34'!
valueAt: aPoint 
	"Answer the bit of the form image at position aPoint.  The value is
	either 0, 1 or 2 where 0 is white, 1 is black,  2 is transparent."

	(self colorForm isTransparentAt: aPoint) ifTrue:[^2].
	^(self colorAt: aPoint) isBlack ifTrue:[1]ifFalse:[0]! !

!OpaqueForm methodsFor: 'accessing' stamp: 'ssa 8/21/2009 20:37'!
valueAt: aPoint put: value
	"Store a bit of the form image at position aPoint.  The value is
	either 0, 1 or 2 where 0 is white, 1 is black,  2 is transparent."

	(1 - (value//2)) = 2 ifTrue:[self colorForm colorAt: aPoint put: Color transparent]
		ifFalse:[value\\2 = 0 ifTrue:[self colorForm colorAt: aPoint put: Color white]
			ifFalse:[self colorForm colorAt: aPoint put: Color black]]! !

!OpaqueForm methodsFor: 'displaying' stamp: 'ssa 9/2/2009 09:30'!
displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aColor
	"Display the receiver on the display medium aDisplayMedium positioned at aDisplayPoint within 
	the rectangle clipRectangle and with the rule, ruleInteger, and mask, aForm. "

	self colorForm displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger  fillColor: aColor! !

!OpaqueForm methodsFor: 'displaying' stamp: 'ssa 8/21/2009 20:39'!
displayOn: aDisplayMedium transformation: displayTransformation clippingBox:
clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aColor
	"See comment in Form."

	self colorForm displayOn: aDisplayMedium transformation: displayTransformation
clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: Form
under fillColor: aColor! !

!OpaqueForm methodsFor: 'printing' stamp: 'ssa 8/21/2009 20:40'!
storeOn: aStream
	"Append to the argument aStream a sequence of characters that is an expression 
	whose evaluation creates an object similar to the receiver.  The general format
	for OpaqueForm is
		OpaqueForm figure: ( figure ) shape: ( shape )."

	aStream nextPutAll: '(OpaqueForm colorForm: ('.
	self colorForm storeOn: aStream.
	aStream nextPutAll: '))'! !

!OpaqueForm methodsFor: 'editing'!
bitEdit
	"Create and schedule a view located in an area designated by the user that
	contains a view of the receiver magnified by 8@8 that can be modified
	using the Bit Editor.  It also contains a view of the original form."

	BitEditor openOnForm: self

	"OpaqueForm makeStar bitEdit."! !

!OpaqueForm commentStamp: '<historical>' prior: 0!
OpaqueForms include a shape as well as a figure form.  The shape indicates what part of the background should get occluded in displaying, so that patterns other than black in the figure form will still appear opaque.

Instance Variables:
	figure	<Form> the actual image
	shape	<Form> the mask for displaying!
!OpaqueForm class methodsFor: 'examples' stamp: 'ssa 8/21/2009 20:41'!
makeStar
	"Answer a new OpaqueForm in the shape of a five-pointed star
	filled with black."

	"OpaqueForm makeStar."
	"OpaqueForm makeStar bitEdit"

	| figure shape pen formRect |
	formRect_ 0@0 extent: 50@50.
	pen _ Pen new.
	pen defaultNib: 2.
	Display fill: formRect fillColor: Color white.
	pen north; place: formRect center; spiral: 45 angle: 144.
	shape _ Form fromDisplay: formRect.
	pen fillColor: Color white; north; place: formRect center; spiral: 30 angle: 144.
	figure _ Form fromDisplay: formRect.
	^ OpaqueForm figure: figure shape: shape! !

!OpaqueForm class methodsFor: 'examples'!
starCursor
	"Make the cursor track a five-pointed star."

	"OpaqueForm starCursor"

	Cursor blank showWhile:
		[self makeStar follow: [Sensor cursorPoint] while: [Sensor noButtonPressed]]! !

!OpaqueForm class methodsFor: 'instance creation'!
figure: figureForm shape: shapeForm
	"Answer a new instance of the receiver whose figure
	and shape forms are defined by the arguments."

	^ self new setFigure: figureForm shape: shapeForm! !

!OpaqueForm class methodsFor: 'instance creation'!
shape: aSolidForm
	"Answer a new instance of the receiver that is black where aSolidForm is black
	and transparent where aSolidForm is white."

	^ self new setFigure: aSolidForm shape: aSolidForm! !

!OrderedCollection methodsFor: 'accessing' stamp: 'ssa 9/14/2008 21:44'!
inspectorClass

	^ OrderedCollectionInspector! !

!OrderedCollection methodsFor: 'adding' stamp: 'ssa 9/9/2009 11:48'!
addAll: aCollection  after: anObject
	"Add each element of aCollection at my end. Answer aCollection."

	| after |
	after _ anObject.
	aCollection do:[:each| self add: each after: after.
		after _ each].
	^aCollection! !

!OrderedCollectionWithNilDetector methodsFor: 'adding' stamp: 'ssa 11/24/2009 19:54'!
add: newObject

	newObject ifNil:[self halt:'trying to add nil'].
	^super add: newObject! !

!OrderedCollectionWithNilDetector methodsFor: 'adding' stamp: 'ssa 11/24/2009 19:56'!
addAll: aCollection 
	"Add each element of aCollection at my end. Answer	aCollection."
(aCollection includes: nil) ifTrue:[self halt:'trying to add nil'].
	^ super addAll: aCollection! !

!OrderedCollectionWithNilDetector methodsFor: 'adding' stamp: 'ssa 11/24/2009 19:57'!
insert: anObject before: spot

	anObject ifNil:[self halt:'trying to add nil'].
	^super insert: anObject before: spot! !

!PackageDependencyTest methodsFor: 'test utility' stamp: 'Alexandre Bergel 5/22/2010 15:38'!
dependenciesOfPackageNamed: pkgNameAsString
	| deps classes |
	classes := self referencesInPackageNamed: pkgNameAsString.

	deps := Dictionary new.
	classes
		do: [:aClass | 
			| pkg |
			pkg := PackageOrganizer default
						packageOfClass: aClass
						ifNone: [].
			pkg
				ifNil: [Transcript cr; show: 'WARNING: No package for ' , pkg]
				ifNotNil: [(deps
							at: pkg packageName
							ifAbsentPut: [OrderedCollection new])
						  add: aClass]].
	deps
		removeKey: pkgNameAsString
		ifAbsent: [].
	^ deps! !

!PackageDependencyTest methodsFor: 'test utility' stamp: 'Alexandre Bergel 5/22/2010 15:47'!
referencesInClass: aClass
	| classes |
	classes := IdentitySet new.
	aClass isTrait
		ifFalse: [ classes add: aClass superclass ].
	
	"The following line is wrong because methods may be defined in a different package"
	"aClass methods do: [ :cm | classes addAll: (self referencesInCompiledMethod: cm) ]."
	^ classes! !

!PackageDependencyTest methodsFor: 'test utility' stamp: 'Alexandre Bergel 5/22/2010 15:32'!
referencesInCompiledMethod: aCompiledMethod
	| classes |
	classes := IdentitySet new.
	1
		to: aCompiledMethod numLiterals
		do: [:i | | lit | ((lit := aCompiledMethod literalAt: i) isVariableBinding
							and: [  lit value isBehavior ])
						ifTrue: [classes add: lit value ]].
	^ classes! !

!PackageDependencyTest methodsFor: 'test utility' stamp: 'Alexandre Bergel 5/22/2010 15:43'!
referencesInPackage: aPackageInfo
	| classes |
	classes := IdentitySet new.
	aPackageInfo classes do: [ :cls | classes addAll: (self referencesInClass: cls) ].
	aPackageInfo methods do: [ :mr | classes addAll: (self referencesInCompiledMethod: mr compiledMethod )].
	^ classes! !

!PackageDependencyTest methodsFor: 'test utility' stamp: 'Alexandre Bergel 5/22/2010 15:33'!
referencesInPackageNamed: pkgNameAsString
	| pi |
	pi := PackageOrganizer default
				packageNamed: pkgNameAsString
				ifAbsent: [^ self].

	^ self referencesInPackage: pi! !

!PackageDependencyTest methodsFor: 'test utility' stamp: 'StephaneDucasse 9/9/2010 14:50'!
testPackage: pkgName dependsExactlyOn: pkgList
	"Ensure that the package with the given name depends only on the packages in pkgList.
	NOTE: If you use this for fixing dependencies, classDeps includes the classes
	and users from the package(s) not declared as dependents. Basically, you need
	to fix all the references in classDeps to make the test pass."
	
	| classDeps pi pkgDeps |
	classDeps := IdentityDictionary new.
	pi := PackageOrganizer default packageNamed: pkgName ifAbsent:[^self]. "unloaded"
	pi classes do: [ :pkgClass | 
		(classDeps at: (pkgClass superclass ifNil: [ProtoObject]) 
			ifAbsentPut:[OrderedCollection new]) add: pkgClass name, ' superclass'.].
	pi methods do: [ :mref | | cm |
		cm := mref compiledMethod.
		1 to: cm numLiterals do: [ :i | | lit |
			((lit := cm literalAt: i) isVariableBinding 
				and:[lit value isBehavior]) ifTrue:[(classDeps at: lit value ifAbsentPut:[OrderedCollection new]) add: cm methodClass asString, '>>', cm selector]]].
	pkgDeps := Dictionary new.
	classDeps keys do: [ :aClass | | pkg |
		pkg := PackageOrganizer default packageOfClass: aClass ifNone:[nil].
		pkg ifNil: [
				Transcript cr; show: 'WARNING: No package for ', aClass.
				(classDeps removeKey: aClass) do:[:each| Transcript crtab; show: each]] 
			ifNotNil: [(pkgDeps at: pkg name ifAbsentPut:[OrderedCollection new]) add: aClass]].
	(pkgDeps removeKey: pkgName ifAbsent: [#()]) 
		do: [ :aClass | classDeps removeKey: aClass ifAbsent: []].
	pkgList do: [ :pkg |
		self assert: (pkgDeps includesKey: pkg) description: pkgName, ' no longer depends on ', pkg.
		(pkgDeps removeKey: pkg ifAbsent: [#()]) 
			do: [ :aClass | classDeps removeKey: aClass ifAbsent:[]]].
		
	classDeps keysAndValuesDo: [ :class :deps |
		Transcript cr; show: class name, ' dependencies:'.
		deps do: [ :each | Transcript crtab; show: each]].
	self assert: pkgDeps isEmpty
		description: pkgName, ' now depends on ', pkgDeps.
! !

!PackageDependencyTest methodsFor: 'test utility' stamp: 'Alexandre Bergel 5/22/2010 15:36'!
testPackage: pkgName dependsOnlyOn: pkgList 
	"Ensure that the package with the given name depends only on the
	packages in pkgList"
	| classes pi deps |
	
	deps := self dependenciesOfPackageNamed: pkgName.

	pkgList
		do: [:pkg | 
			self
				assert: (deps includesKey: pkg).
			deps removeKey: pkg].

	self assert: deps isEmpty! !

!PackageInfo methodsFor: 'testing' stamp: 'avi 3/9/2004 15:53'!
category: categoryName matches: prefix
	^ categoryName notNil and: [categoryName = prefix or: [categoryName beginsWith: prefix, '-']]! !

!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:18'!
coreCategoriesForClass: aClass
	^ aClass organization categories select: [:cat | (self isForeignClassExtension: cat) not]! !

!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:22'!
coreMethodsForClass: aClass
	^ (aClass selectors difference:
		((self foreignExtensionMethodsForClass: aClass) collect: [:r | r methodSymbol]))
			asArray collect: [:sel | self referenceForMethod: sel ofClass: aClass]! !

!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:20'!
extensionCategoriesForClass: aClass
	^ aClass organization categories select: [:cat | self isYourClassExtension: cat]! !

!PackageInfo methodsFor: 'testing' stamp: 'avi 4/6/2004 15:16'!
extensionMethodsForClass: aClass
	^ (self extensionCategoriesForClass: aClass)
		gather: [:cat | ((aClass organization listAtCategoryNamed: cat) ifNil: [#()])
							collect: [:sel | self referenceForMethod: sel ofClass: aClass]]! !

!PackageInfo methodsFor: 'testing' stamp: 'dvf 10/18/2002 23:22'!
extensionMethodsFromClasses: classes
	^classes
		gather: [:class | self extensionMethodsForClass: class]! !

!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:22'!
foreignExtensionCategoriesForClass: aClass
	^ aClass organization categories select: [:cat | self isForeignClassExtension: cat]! !

!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:23'!
foreignExtensionMethodsForClass: aClass
	^ (self foreignExtensionCategoriesForClass: aClass)
		gather: [:cat | (aClass organization listAtCategoryNamed: cat)
						  collect: [:sel | self referenceForMethod: sel ofClass: aClass]]! !

!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:23'!
includesClass: aClass
	^ self includesSystemCategory: aClass theNonMetaClass category! !

!PackageInfo methodsFor: 'testing' stamp: 'dvf 7/23/2003 14:08'!
includesClassNamed: aClassName
	^ self includesSystemCategory: ((SystemOrganization categoryOfElement: aClassName) ifNil: [^false])! !

!PackageInfo methodsFor: 'testing' stamp: 'ab 12/5/2002 00:16'!
includesMethod: aSymbol ofClass: aClass
	aClass ifNil: [^ false].
	^ self
		includesMethodCategory: ((aClass organization categoryOfElement: aSymbol)
										ifNil: [' '])
		ofClass: aClass! !

!PackageInfo methodsFor: 'testing' stamp: 'dvf 9/17/2002 00:18'!
includesMethodCategory: categoryName ofClass: aClass
	^ (self isYourClassExtension: categoryName)
		or: [(self includesClass: aClass)
				and: [(self isForeignClassExtension: categoryName) not]]! !

!PackageInfo methodsFor: 'testing' stamp: 'dvf 7/23/2003 14:06'!
includesMethodCategory: categoryName ofClassNamed: aClass
	^ (self isYourClassExtension: categoryName)
		or: [(self includesClassNamed: aClass)
				and: [(self isForeignClassExtension: categoryName) not]]! !

!PackageInfo methodsFor: 'testing' stamp: 'ab 11/14/2002 18:06'!
includesMethodReference: aMethodRef
	^ self includesMethod: aMethodRef methodSymbol ofClass: aMethodRef actualClass! !

!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:23'!
includesSystemCategory: categoryName
	^ self category: categoryName matches: self systemCategoryPrefix! !

!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:23'!
isForeignClassExtension: categoryName
	^ categoryName first = $* and: [(self isYourClassExtension: categoryName) not]! !

!PackageInfo methodsFor: 'testing' stamp: 'avi 11/10/2003 15:42'!
isOverrideMethod: aMethodReference
	^ aMethodReference category endsWith: '-override'! !

!PackageInfo methodsFor: 'testing' stamp: 'avi 3/10/2004 12:37'!
isYourClassExtension: categoryName
	^ categoryName notNil and: [self category: categoryName asLowercase matches: self methodCategoryPrefix]! !

!PackageInfo methodsFor: 'testing' stamp: 'dvf 10/18/2002 23:22'!
outsideClasses
	^ProtoObject withAllSubclasses difference: self classesAndMetaClasses! !

!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:25'!
referenceForMethod: aSymbol ofClass: aClass
	^ MethodReference new setStandardClass: aClass methodSymbol: aSymbol! !

!PackageInfo methodsFor: 'naming' stamp: 'ab 10/17/2002 00:05'!
categoryName
	|category|
	category _ self class category.
	^ (category endsWith: '-Info')
		ifTrue: [category copyUpToLast: $-]
		ifFalse: [category]! !

!PackageInfo methodsFor: 'naming' stamp: 'ab 10/16/2002 21:22'!
externalName
	^ self packageName! !

!PackageInfo methodsFor: 'naming' stamp: 'ab 6/10/2003 17:21'!
methodCategoryPrefix
	^ methodCategoryPrefix ifNil: [methodCategoryPrefix _ '*', self packageName asLowercase]! !

!PackageInfo methodsFor: 'naming' stamp: 'ab 10/16/2002 16:57'!
packageName
	^ packageName ifNil: [packageName _ self categoryName]! !

!PackageInfo methodsFor: 'naming' stamp: 'ab 10/16/2002 16:56'!
packageName: aString
	packageName _ aString! !

!PackageInfo methodsFor: 'naming' stamp: 'ab 10/28/2002 10:38'!
systemCategoryPrefix
	^ self packageName! !

!PackageInfo methodsFor: 'listing' stamp: 'ac 5/14/2003 16:23'!
classes
	^(self systemCategories gather:
		[:cat |
		(SystemOrganization listAtCategoryNamed: cat)
			collect: [:className | Smalltalk at: className]])
				sortBy: [:a :b | a className <= b className]! !

!PackageInfo methodsFor: 'listing' stamp: 'dvf 9/17/2002 00:56'!
classesAndMetaClasses
	| baseClasses |
	baseClasses := self classes.
	^baseClasses , (baseClasses collect: [:c | c class])! !

!PackageInfo methodsFor: 'listing' stamp: 'ab 11/13/2002 01:23'!
coreMethods
	^ self classesAndMetaClasses gather: [:class | self coreMethodsForClass: class]! !

!PackageInfo methodsFor: 'listing' stamp: 'cwp 3/17/2004 21:32'!
extensionClasses
	^ self externalClasses reject: [:class | (self extensionCategoriesForClass: class) isEmpty]! !

!PackageInfo methodsFor: 'listing' stamp: 'ab 6/10/2003 17:12'!
extensionMethods
	^ self externalClasses gather: [:class | self extensionMethodsForClass: class]! !

!PackageInfo methodsFor: 'listing' stamp: 'ab 12/3/2002 14:38'!
foreignClasses
	| s |
	s _ IdentitySet new.
	self foreignSystemCategories
		do: [:c | (SystemOrganization listAtCategoryNamed: c)
				do: [:cl | 
					| cls | 
					cls _ Smalltalk at: cl. 
					s add: cls;
					  add: cls class]].
	^ s! !

!PackageInfo methodsFor: 'listing' stamp: 'ab 12/3/2002 14:34'!
foreignSystemCategories
	^ SystemOrganization categories
		reject: [:cat | self includesSystemCategory: cat] ! !

!PackageInfo methodsFor: 'listing' stamp: 'ab 7/6/2003 21:49'!
methods
	^ (self extensionMethods, self coreMethods)
		select: [:method | method isValid and: [(#(DoIt DoItIn:) includes: method methodSymbol) not]]! !

!PackageInfo methodsFor: 'listing' stamp: 'avi 11/10/2003 15:35'!
overrideMethods
	^ self extensionMethods select: [:ea | self isOvverideMethod: ea]! !

!PackageInfo methodsFor: 'listing' stamp: 'ab 11/14/2002 18:39'!
selectors
	^ self methods collect: [:ea | ea methodSymbol]! !

!PackageInfo methodsFor: 'listing' stamp: 'ab 11/11/2002 21:51'!
systemCategories
	^ SystemOrganization categories select: [:cat | self includesSystemCategory: cat]! !

!PackageInfo methodsFor: 'dependencies' stamp: 'ab 11/18/2002 01:16'!
externalCallers
	^ self 
		externalRefsSelect: [:literal | literal isKindOf: Symbol] 
		thenCollect: [:l | l].! !

!PackageInfo methodsFor: 'dependencies' stamp: 'ab 6/10/2003 17:18'!
externalClasses
	| myClasses |
	myClasses _ self classesAndMetaClasses.
	^ Array streamContents:
		[:s |
		ProtoObject withAllSubclassesDo:
			[:class |
			(myClasses includes: class) ifFalse: [s nextPut: class]]]! !

!PackageInfo methodsFor: 'dependencies' stamp: 'avi 2/29/2004 13:38'!
externalRefsSelect: selBlock thenCollect: colBlock
	| pkgMethods dependents refs extMethods otherClasses otherMethods classNames |

	classNames _ self classes collect: [:c | c name].
	extMethods _ self extensionMethods collect: [:mr | mr methodSymbol].
	otherClasses _ self externalClasses difference: self externalSubclasses.
	otherMethods _  otherClasses gather: [:c | c selectors].
	pkgMethods _ self methods asSet collect: [:mr | mr methodSymbol].
	pkgMethods removeAllFoundIn: otherMethods.

	dependents _ Set new.
	otherClasses do: [:c |
		c selectorsAndMethodsDo:
			[:sel :compiled |
			(extMethods includes: sel) ifFalse: 
				[refs _ compiled literals select: selBlock thenCollect: colBlock.
				refs do: [:ea |
					((classNames includes: ea) or: [pkgMethods includes: ea])
							ifTrue: [dependents add: (self referenceForMethod: sel ofClass: c) -> ea]]]]].
	^ dependents! !

!PackageInfo methodsFor: 'dependencies' stamp: 'cwp 11/13/2002 00:24'!
externalSubclasses
	| pkgClasses subClasses |
	pkgClasses _ self classes.
	subClasses _ Set new.
	pkgClasses do: [:c | subClasses addAll: (c allSubclasses)].
	^ subClasses difference: pkgClasses
! !

!PackageInfo methodsFor: 'dependencies' stamp: 'ab 11/18/2002 01:15'!
externalUsers
	^ self 
		externalRefsSelect: [:literal | literal isVariableBinding] 
		thenCollect: [:l | l key]! !

!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/13/2003 15:40'!
addCoreMethod: aMethodReference
	| category |
	category _ self baseCategoryOfMethod: aMethodReference.
	aMethodReference actualClass organization
		classify: aMethodReference methodSymbol
		under: category
		suppressIfDefault: false! !

!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/11/2003 15:17'!
addExtensionMethod: aMethodReference
	| category |
	category _ self baseCategoryOfMethod: aMethodReference.
	aMethodReference actualClass organization
		classify: aMethodReference methodSymbol
		under: self methodCategoryPrefix, '-', category! !

!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/11/2003 15:16'!
addMethod: aMethodReference
	(self includesClass: aMethodReference class)
		ifTrue: [self addCoreMethod: aMethodReference]
		ifFalse: [self addExtensionMethod: aMethodReference]! !

!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/13/2003 15:39'!
baseCategoryOfMethod: aMethodReference
	| oldCat oldPrefix tokens | 
	oldCat _ aMethodReference category.
	({ 'as yet unclassified'. 'all' } includes: oldCat) ifTrue: [ oldCat _ '' ].
	tokens _ oldCat findTokens: '*-' keep: '*'.

	"Strip off any old prefixes"
	((tokens at: 1 ifAbsent: [ '' ]) = '*') ifTrue: [
		[ ((tokens at: 1 ifAbsent: [ '' ]) = '*') ]
			whileTrue: [ tokens removeFirst ].
		oldPrefix _ tokens removeFirst asLowercase.
		[ (tokens at: 1 ifAbsent: [ '' ]) asLowercase = oldPrefix ]
			whileTrue: [ tokens removeFirst ].
	].

	tokens isEmpty ifTrue: [^ 'as yet unclassified'].
	^ String streamContents:
		[ :s |
		tokens
			do: [ :tok | s nextPutAll: tok ]
			separatedBy: [ s nextPut: $- ]]! !

!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/11/2003 15:14'!
removeMethod: aMethodReference! !

!PackageInfo methodsFor: 'removing' stamp: 'ads 1/30/2011 10:40'!
removeFromSystem
	| extensionCategoriesByClass classes systemCategories |
	"Get the collections of classes and methods before actually doing the removal, so that removing the PackageInfo package will work."
	extensionCategoriesByClass := Dictionary new.
	self extensionClasses do: [:cls | extensionCategoriesByClass at: cls put: (self extensionCategoriesForClass: cls)].
	classes := self classes.
	systemCategories := self systemCategories.
	extensionCategoriesByClass keysAndValuesDo: [:cls :cats | cats do: [:cat | cls removeCategory: cat]].
	classes do: [:cls | cls removeFromSystem].
	systemCategories do: [:cat | (SystemOrganization listAtCategoryNamed: cat) isEmpty ifTrue: [SystemOrganization removeCategory: cat]].
! !

!PackageInfo methodsFor: 'comparing' stamp: 'avi 10/11/2003 00:09'!
= other
	^ other species = self species and: [other packageName = self packageName]! !

!PackageInfo methodsFor: 'comparing' stamp: 'avi 10/11/2003 14:20'!
hash
	^ packageName hash! !

!PackageInfo methodsFor: '*transporter' stamp: 'ads 12/5/2010 23:40'!
, p
	^ CompositePackageInfo new
		packages: {self. p};
		yourself! !

!PackageInfo methodsFor: '*transporter' stamp: 'ads 1/26/2011 14:13'!
includesPackage: p
	^ self = p! !

!PackageInfo methodsFor: '*transporter' stamp: 'ads 12/10/2010 12:05'!
name
	^ self packageName! !

!PackageInfo methodsFor: '*transporter' stamp: 'ads 1/26/2011 13:38'!
printOn: aStream
	aStream nextPutAll: self packageName.! !

!PackageInfo methodsFor: '*transporter' stamp: 'ads 1/26/2011 16:15'!
revertToVersionBeforeTeam: team
	self extensionMethods do: [:m | team revertToOldVersionOrRemove: m].
	self classes do: [:cls | cls removeFromSystem].
	self systemCategories do: [:cat | SystemOrganization removeCategoryIfEmpty: cat].
! !

!PackageInfo commentStamp: '<historical>' prior: 0!
Subclass this class to create new Packages.!
!PackageInfo class methodsFor: 'packages access' stamp: 'avi 11/12/2003 23:00'!
named: aString
	^ self new packageName: aString! !

!PackageInfo class methodsFor: 'class initialization' stamp: 'avi 2/18/2004 00:46'!
initialize
	self allSubclassesDo: [:ea | ea new register]! !

!PackageInfo class methodsFor: 'compatibility' stamp: 'avi 3/9/2004 16:28'!
default
	^ self allPackages detect: [:ea | ea class = self] ifNone: [self new register]! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'accessing' stamp: 'ads 1/24/2011 17:31'!
classesToBeRedefined
	| classNames |
	classNames := Set new.
	self trickyModificationsThatNeedToBeDoneInOrder do: [:a |
		a size = 1 ifTrue: [classNames add: a first].
	].
	^ classNames collect: [:className | Smalltalk at: className asSymbol]! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'accessing' stamp: 'ads 1/24/2011 15:24'!
extensionClasses
	| classes |
	classes := Set new.
	self extensionMethods do: [:m | classes add: m actualClass].
	^ classes! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'accessing' stamp: 'ads 1/24/2011 17:32'!
extensionMethods
	| result |
	result := Set new.
	self trickyModificationsThatNeedToBeDoneInOrder do: [:a |
		a size = 2 ifTrue: [result add: ((Smalltalk classNamed: a first) methodNamed: a second)].
	].
	^ result! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'accessing' stamp: 'ads 1/24/2011 14:11'!
name
	^ self class name! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'accessing' stamp: 'sm 3/11/2011 23:13'!
trickyModificationsThatNeedToBeDoneInOrder: someDefinitions
	trickyModificationsThatNeedToBeDoneInOrder := someDefinitions! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'comparing' stamp: 'ads 1/26/2011 13:36'!
= other
	^ self species = other species! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'comparing' stamp: 'ads 1/26/2011 13:36'!
hash
	^ self species hash! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'composing' stamp: 'ads 1/24/2011 15:11'!
, p
	^ CompositePackageInfo new
		packages: {self. p};
		yourself! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'composing' stamp: 'ads 1/26/2011 14:11'!
includesPackage: p
	^ self = p! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'testing' stamp: 'ads 1/24/2011 17:31'!
includesClass: aClass
	^ self classesToBeRedefined includes: aClass theNonMetaClass! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'testing' stamp: 'ads 1/24/2011 17:32'!
includesMethod: aSymbol ofClass: aClass
	aClass ifNil: [^ false].
	^ self extensionMethods includes: (aClass methodNamed: aSymbol)! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'saving' stamp: 'ads 2/2/2011 15:46'!
saveClassAndMethodModificationsInOrder: classAndMethodSpecs on: aFileStream
	classAndMethodSpecs do: [:spec | | class |
		class := Smalltalk classNamed: (spec at: 1).
		spec size > 1 ifTrue: [ | selector |
			selector := (spec at: 2) asSymbol.
			class methodDict at: selector ifAbsent: [self error: 'Could not find method named ', selector printString, ' in class ', class name].
			class printMethodChunk: selector withPreamble: true on: aFileStream moveSource: false toFile: 0.
		] ifFalse: [
			aFileStream nextChunkPut: class definition; cr.
		].
	] displayingProgress: 'Saving tricky stuff that needs to happen in order'.
! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'saving' stamp: 'sm 3/11/2011 20:39'!
saveTrickyModificationsToFile: aFileStream
	self saveClassAndMethodModificationsInOrder: self trickyModificationsThatNeedToBeDoneInOrder on: aFileStream.! !

!PackageWhoseContentsMustBeTransportedInOrder methodsFor: 'as yet unclassified' stamp: 'sm 3/11/2011 23:13'!
trickyModificationsThatNeedToBeDoneInOrder
	^ trickyModificationsThatNeedToBeDoneInOrder.! !

!Paragraph methodsFor: 'accessing' stamp: 'dmu 4/1/2009 20:01'!
destFormSema: s destFormSema _ s! !

!Paragraph methodsFor: 'converting' stamp: 'ssa 9/4/2009 10:44'!
asForm
	"Answer a Form made up of the bits that represent the receiver's displayable text."
	| theForm oldBackColor oldForeColor |
	textStyle isTTCStyle ifTrue: [
		theForm _  (Form extent: compositionRectangle extent depth: Display depth)
		offset: offset.
	] ifFalse: [
		theForm _ (ColorForm extent: compositionRectangle extent)
			offset: offset;
			colors: (Array
				with: (backColor == nil ifTrue: [Color transparent] ifFalse: [backColor])
				with: (foreColor == nil ifTrue: [Color black] ifFalse: [foreColor])).
	].
	oldBackColor _ backColor.
	oldForeColor _ foreColor.
	backColor _ Color white.
	foreColor _ Color black.
	self displayOn: theForm
		at: 0@0
		clippingBox: theForm boundingBox
		rule: Form over
		fillColor: nil.
	backColor _ oldBackColor.
	foreColor _ oldForeColor.
	^ theForm

"Example:
| p |
p _ 'Abc' asParagraph.
p foregroundColor: Color red backgroundColor: Color black.
p asForm displayOn: Display at: 30@30 rule: Form over"
! !

!Paragraph methodsFor: 'private' stamp: 'dmu 4/1/2009 19:38'!
compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint

	compositionRectangle _ compositionRect copy.
	text _ aText.
	textStyle _ aTextStyle.
	rule _ DefaultRule.
	mask _ nil.		"was DefaultMask "
	marginTabsLevel _ 0.
	destFormSema _ Semaphore forMutualExclusion.
	self destinationForm: Display.
	offset _ aPoint.
	^self composeAll! !

!Paragraph methodsFor: 'private' stamp: 'ssa 4/7/2009 12:39'!
displayOn: aDisplayMedium lines: lineInterval

	| saveDestinationForm |
	destFormSema isNil ifTrue:[self destFormSema: Semaphore forMutualExclusion].
	destFormSema critical: [
		saveDestinationForm _ destinationForm.
		self destinationForm: aDisplayMedium.
		self displayLines: lineInterval.
		destinationForm _ saveDestinationForm
	]! !

!ParagraphEditor methodsFor: 'controlling'!
controlActivity
        "Hacked to supprt MSWScrollBarView - ssa 12/10/97 17:07"
        
        self scrollBarContainsCursor
                ifTrue: [(self view superView isKindOf: MSWScrollBarView)
                                        ifFalse:[self scroll]]
                ifFalse: [self processKeyboard.
                                self processMouseButtons]! !

!ParagraphEditor methodsFor: 'scrolling'!
scrollView: anInteger 
        "Paragraph scrolling uses opposite polarity"
        "Adjusted to keep text from scrolling off the view - ssa 1/15/98 15:22.  The - 30 below is the hack to allow for some empty space to show at the bottom."
        | maximumAmount minimumAmount amount |
        maximumAmount _
                paragraph clippingRectangle top -
                paragraph compositionRectangle top  max: 0.
        minimumAmount _
                paragraph clippingRectangle bottom -
                paragraph compositionRectangle bottom - 30 min: 0.
        amount _
                (anInteger min: maximumAmount) max:
                minimumAmount.
        ^ self scrollBy: amount negated! !

!ParagraphEditor methodsFor: 'scrolling'!
updateMarker
        "Hacked to catch this scrolling 'event'.  ssa 12/5/97 16:22"
        "A variation of computeMarkerRegion--only redisplay the marker in the scrollbar if an actual change has occurred in the positioning of the paragraph."
        self moveMarkerTo: self computeMarkerRegion.

                "A hack to notify the MSWScrollBarController"
        (self view superView isKindOf: MSWScrollBarView)
                ifTrue:[self view superView updateElevator]! !

!ParagraphEditor methodsFor: 'menu messages' stamp: 'ssa 9/15/2009 16:53'!
adjustWidths

	self view topView adjustWidths! !

!ParagraphEditor methodsFor: 'menu messages' stamp: 'ssa 3/1/2010 11:41'!
browseIt
	"Launch a browser for the current selection, if appropriate"

	| aSymbol anEntry brow |

	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].

	self lineSelectAndEmptyCheck: [^ self].
	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].

	self terminateAndInitializeAround:
		[aSymbol first isUppercase
			ifTrue:
				[anEntry _ (Smalltalk
					at: aSymbol
					ifAbsent:
						[ self systemNavigation browseAllImplementorsOf: aSymbol.
						^ nil]).
				anEntry isNil ifTrue: [^ view flash].
				(anEntry isKindOf: Class)
					ifFalse:	[anEntry _ anEntry class].
					[^ self browseClassFromIt]value.  "<<<<<<<<<<<<<<<<<<  ssa added"
				brow _ Preferences browseToolClass new.
				brow setClass: anEntry selector: nil.
				brow class
					openBrowserView: (brow openEditString: nil)
					label: 'System Browser']
			ifFalse:
				[ self systemNavigation browseAllImplementorsOf: aSymbol]]! !

!ParagraphEditor methodsFor: 'menu messages' stamp: 'ssa 1/21/2010 16:27'!
methodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source). "

	self lineSelectAndEmptyCheck: [^ self].
	
	self systemNavigation browseMethodsWithSourceString: self selection string! !

!ParagraphEditor methodsFor: 'editing keys' stamp: 'ssa 1/6/2010 20:32'!
exploreIt: characterStream 
	"Inspect the selection -- invoked via cmd-i.  If there is no current selection, use the current line."

	sensor keyboard.		"flush character"
	self terminateAndInitializeAround: [self exploreIt].
	^ true! !

!ParagraphEditor methodsFor: 'editing keys' stamp: 'ssa 6/1/2010 16:55'!
printIt: characterStream 
	"Print the results of evaluting the selection -- invoked via cmd-p.  If there is no current selection, use the current line.  1/17/96 sw
	 2/29/96 sw: don't call selectLine now, since it's called by doIt"

	sensor keyboard.		"flush character"
		self terminateAndInitializeAround: [self printIt].
	^ true! !

!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'ssa 1/20/2010 11:06'!
cursorDown: characterStream 

	"Private - Move cursor from position in current line to same position in
	next line. If next line too short, put at end. If shift key down,
	select."
	self closeTypeIn: characterStream.
	paragraph isEmpty ifTrue:[Sensor flushKeyboard.  ^true].
	self 
		moveCursor:[:position | self
				sameColumn: position
				newLine:[:line | line + 1]
				forward: true]
		forward: true
		specialBlock:[:dummy | dummy].
	^true! !

!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'ssa 1/20/2010 11:05'!
cursorUp: characterStream 

"Private - Move cursor from position in current line to same position in
prior line. If prior line too short, put at end"

	self closeTypeIn: characterStream.
	paragraph isEmpty ifTrue:[Sensor flushKeyboard.  ^true].
	self
		moveCursor: [:position | self
				sameColumn: position
				newLine:[:line | line - 1]
				forward: false]
		forward: false
		specialBlock:[:dummy | dummy].
	^true! !

!ParagraphEditor methodsFor: 'private' stamp: 'ssa 1/20/2010 10:55'!
sameColumn: start newLine: lineBlock forward: isForward
	"Private - Compute the index in my text
	with the line number derived from lineBlock,"
	" a one argument block accepting the old line number.
	The position inside the line will be preserved as good as possible"
	"The boolean isForward is used in the border case to determine if
	we should move to the beginning or the end of the line."
	| wordStyle column currentLine offsetAtTargetLine targetEOL lines numberOfLines currentLineNumber targetLineNumber |
	wordStyle _ Preferences wordStyleCursorMovement.
	wordStyle
		ifTrue: [
			lines _ paragraph lines.
			numberOfLines := paragraph numberOfLines.
			currentLineNumber  _ paragraph lineIndexOfCharacterIndex: start.
			currentLine _ lines at: (currentLineNumber max: 1)]
		ifFalse: [
			lines _ self lines.
			numberOfLines := lines size.
			currentLine _ lines
				detect:[:lineInterval | lineInterval last >= start]
				ifNone:[lines last].
			currentLineNumber _ currentLine second].
	column _ start - currentLine first.
	targetLineNumber _ ((lineBlock value: currentLineNumber) max: 1) min: numberOfLines.
	offsetAtTargetLine _ (lines at: targetLineNumber) first.
	targetEOL _ (lines at: targetLineNumber) last + (targetLineNumber == numberOfLines ifTrue:[1]ifFalse:[0]).
	targetLineNumber == currentLineNumber
	"No movement or movement failed. Move to beginning or end of line."
		ifTrue:[^isForward
			ifTrue:[targetEOL]
			ifFalse:[offsetAtTargetLine]].
	^offsetAtTargetLine + column min: targetEOL.! !

!ParagraphEditor methodsFor: 'do-its' stamp: 'ssa 8/31/2009 10:30'!
compileSelectionFor: anObject in: evalContext

	| methodNode method |
	methodNode _ [Compiler new
		compileNoPattern: self selection
		in: anObject class
		context: evalContext
		notifying: self
		ifFail: [^nil]]
			on: OutOfScopeNotification
			do: [:ex | ex resume: true].
	method _ methodNode generate: #(0 0 0 0).
	^method copyWithTempNames: methodNode tempNames! !

!ParagraphEditor methodsFor: 'do-its' stamp: 'dmu 9/17/2010 12:00'!
debug: aCompiledMethod receiver: anObject in: evalContext

	| selector guineaPig debugger context |
	selector _ evalContext isNil ifTrue: [#DoIt] ifFalse: [#DoItIn:].
	anObject class addSelectorSilently: selector withMethod: aCompiledMethod.
	guineaPig _ evalContext isNil
		ifTrue: [[anObject DoIt] newProcess]
		ifFalse: [[anObject DoItIn: evalContext] newProcess].
	context _ guineaPig suspendedContextWaitingIfNecessary.
	debugger _ Debugger new
		process: guineaPig
		controller: ((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])
				ifTrue: [ScheduledControllers activeController]
				ifFalse: [nil])
		context: context
		isolationHead: nil.
	debugger openFullNoSuspendLabel: 'Debug it'.
	[debugger interruptedContext method == aCompiledMethod]
		whileFalse: [debugger send].
	anObject class basicRemoveSelector: selector! !

!ParagraphEditor methodsFor: 'do-its' stamp: 'ssa 7/7/2010 12:32'!
debugIt
 
	| method receiver context |
	((Smalltalk includesKey: #Ly) and:[model isKindOf: (Smalltalk at: #LyWorkspace)]) ifTrue:[^model debug: self selection asString notifying:self].
	(model respondsTo: #doItReceiver) 
		ifTrue: 
			[FakeClassPool adopt: model selectedClass.
			receiver _ model doItReceiver.
			context _ model doItContext]
		ifFalse:
			[receiver _ context _ nil].
	self lineSelectAndEmptyCheck: [^self].
	method _ self compileSelectionFor: receiver in: context.
	method notNil ifTrue:
		[self debug: method receiver: receiver in: context].
	FakeClassPool adopt: nil! !

!ParagraphEditor methodsFor: 'do-its' stamp: 'ssa 7/7/2010 12:32'!
evaluate: someCode
	"Treat the current selection as an expression; evaluate it and return the result"
	| result rcvr ctxt |
	someCode isEmpty ifTrue:[^ ''].
 
	(model respondsTo: #doItReceiver) 
		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"
				rcvr _ model doItReceiver.
				ctxt _ model doItContext]
		ifFalse: [rcvr _ ctxt _ nil].
	result _ [((Smalltalk includesKey: #Ly) and:[model isKindOf: (Smalltalk at: #LyWorkspace)]) ifTrue:[model evaluate: someCode notifying:self] ifFalse:[
		rcvr class evaluatorClass new 
			evaluate: someCode readStream
			in: ctxt
			to: rcvr
			notifying: self
			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]
			logged: true].
	] 
		on: OutOfScopeNotification 
		do: [ :ex | ex resume: true].
	FakeClassPool adopt: nil.
	^ result! !

!ParagraphEditor methodsFor: 'do-its' stamp: 'ssa 7/7/2010 12:32'!
evaluateSelection
	"Treat the current selection as an expression; evaluate it and return the result"
	| result rcvr ctxt |
	self lineSelectAndEmptyCheck: [^ ''].
 
	(model respondsTo: #doItReceiver) 
		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"
				rcvr _ model doItReceiver.
				ctxt _ model doItContext]
		ifFalse: [rcvr _ ctxt _ nil].
	result _ [((Smalltalk includesKey: #Ly) and:[model isKindOf: (Smalltalk at: #LyWorkspace)]) ifTrue:[model evaluate: self selection asString notifying:self] ifFalse:[
		rcvr class evaluatorClass new 
			evaluate: self selectionAsStream
			in: ctxt
			to: rcvr
			notifying: self
			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]
			logged: true].
	] 
		on: OutOfScopeNotification 
		do: [ :ex | ex resume: true].
	FakeClassPool adopt: nil.
	^ result! !

!ParagraphEditor methodsFor: 'do-its' stamp: 'ssa 7/7/2010 12:32'!
exploreIt
	| result | 
	((Smalltalk includesKey: #Ly) and:[model isKindOf: (Smalltalk at: #LyWorkspace)]) ifTrue:[^model exploreIt: self selection asString notifying:self].
	result _ self evaluateSelection.
	((result isKindOf: FakeClassPool) or: [result == #failedDoit])
			ifTrue: [view flash]
			ifFalse: [result explore].
! !

!ParagraphEditor methodsFor: 'do-its' stamp: 'ssa 7/7/2010 12:32'!
inspectIt
	"1/13/96 sw: minor fixup"
	| result |
	((Smalltalk includesKey: #Ly) and:[model isKindOf: (Smalltalk at: #LyWorkspace)]) ifTrue:[^model inspectIt: self selection asString notifying:self].
	result _ self evaluateSelection.
	((result isKindOf: FakeClassPool) or: [result == #failedDoit])
			ifTrue: [view flash]
			ifFalse: [result inspect].
! !

!ParagraphEditor methodsFor: 'do-its' stamp: 'ssa 7/7/2010 12:33'!
installAsTest
	| | 
	((Smalltalk includesKey: #Ly) and:[model isKindOf: (Smalltalk at: #LyWorkspace)]) ifTrue:[^model installAsTest: self selection asString notifying:self].
	self halt:'not implemented for Squeak Workspaces yet'! !

!ParagraphEditor methodsFor: 'do-its' stamp: 'ssa 7/7/2010 12:33'!
parseIt
 
	((Smalltalk includesKey: #Ly) and:[model isKindOf: (Smalltalk at: #LyWorkspace)]) ifTrue:[^model parseAndExplore: self selection asString notifying:self].
! !

!ParagraphEditor methodsFor: 'do-its' stamp: 'ssa 7/7/2010 12:33'!
printIt
	"Treat the current text selection as an expression; evaluate it. Insert the 
	description of the result of evaluation after the selection and then make 
	this description the new text selection."
	| result |
	((Smalltalk includesKey: #Ly) and:[model isKindOf: (Smalltalk at: #LyWorkspace)]) ifTrue:[^model printIt: self selection asString notifying:self].
	result _ self evaluateSelection.
	((result isKindOf: FakeClassPool) or: [result == #failedDoit])
			ifTrue: [view flash]
			ifFalse: [self afterSelectionInsertAndSelect: result printString]! !

!ParagraphEditor methodsFor: '*RVM-UI-Generic' stamp: 'ssa 9/8/2009 19:09'!
buttonIt
	"launch a button to evaluate the selection"
	| topView someCode extent |
	someCode _ self selection.
	extent _ (someCode asText asDisplayText extent + (30@20)) max: 80@30.
	topView := RVMStandardSystemView new.
	topView noLabel.
	topView borderWidth:1.
	topView minimumSize: extent .
	topView maximumSize: extent.
	
	topView addSubView: (RVMButtonView label: someCode action:[self evaluate: someCode]).
	topView controller open! !

!ParagraphEditor methodsFor: '*RVM-UI-Generic' stamp: 'ssa 9/8/2009 18:28'!
buttonIt: characterStream 
	"Called when user hits cmd-B.  make a button of the selection"

	sensor keyboard.	
	self buttonIt.
	^ true! !

!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'ssa 1/29/2010 12:18'!
initializeCmdKeyShortcuts
	"Initialize the (unshifted) command-key (or alt-key) shortcut table."

	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"

	"ParagraphEditor initialize"

	| cmdMap cmds |
	cmdMap := Array new: 256 withAll: #noop:.	"use temp in case of a crash"
	cmdMap at: 1 + 1 put: #cursorHome:.	"home key"
	cmdMap at: 4 + 1 put: #cursorEnd:.	"end key"
	cmdMap at: 8 + 1 put: #backspace:.	"ctrl-H or delete key"
	cmdMap at: 11 + 1 put: #cursorPageUp:.	"page up key"
	cmdMap at: 12 + 1 put: #cursorPageDown:.	"page down key"
	cmdMap at: 13 + 1 put: #crWithIndent:.	"cmd-Return"
	cmdMap at: 27 + 1 put: #offerMenuFromEsc:.	"escape key"
	cmdMap at: 28 + 1 put: #cursorLeft:.	"left arrow key"
	cmdMap at: 29 + 1 put: #cursorRight:.	"right arrow key"
	cmdMap at: 30 + 1 put: #cursorUp:.	"up arrow key"
	cmdMap at: 31 + 1 put: #cursorDown:.	"down arrow key"
	cmdMap at: 32 + 1 put: #selectWord:.	"space bar key"
	cmdMap at: 127 + 1 put: #forwardDelete:.	"del key"
	'0123456789-=' 
		do: [:char | cmdMap at: char asciiValue + 1 put: #changeEmphasis:].
	'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].
	cmdMap at: $, asciiValue + 1 put: #shiftEnclose:.
	cmds := #($a #selectAll: $b #browseIt: $c #copySelection: $d #doIt: $e #exploreIt: $f #find: $g #findAgain: $h #setSearchString: $i #inspectIt: $j #doAgainOnce: $k #offerFontMenu: $l #cancel: $m #implementorsOfIt: $n #sendersOfIt: $o #spawnIt: $p #printIt: $q #querySymbol: $r #revert: $s #save: $S saveAs:: $t #tempCommand: $u #align: $v #paste: $w #backWord: $x #cut: $y #swapChars: $z #undo:).
	1 to: cmds size
		by: 2
		do: [:i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].
	CmdActions := cmdMap! !

!ParagraphEditor class methodsFor: '*RVM-UI-Generic' stamp: 'ssa 2/9/2010 05:26'!
initializeShiftCmdKeyShortcuts 
	"Initialize the shift-command-key (or control-key) shortcut table."
	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"
	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 
	capitalized versions of the letters.
	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."

	| cmdMap cmds |

	"shift-command and control shortcuts"
	cmdMap _ Array new: 256 withAll: #noop:.  "use temp in case of a crash"
	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"
	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"
	cmdMap at: ( 8 + 1) put: #forwardDelete:.		"ctrl-H or delete key"
	cmdMap at: (11 + 1) put: #cursorPageUp:.		"page up key"
	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"
	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"
	cmdMap at: (27 + 1) put: #offerMenuFromEsc:.	"escape key"
	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"
	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"
	cmdMap at: (30 + 1) put: #cursorUp:.			"up arrow key"
	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"
	cmdMap at: (32 + 1) put: #selectWord:.			"space bar key"
	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"
	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"
	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"

	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("
	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"
	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."

	"NB: sw 12/9/2001 commented out the idiosyncratic line just below, which was grabbing shift-esc in the text editor and hence which argued with the wish to have shift-esc be a universal gesture for escaping the local context and calling up the desktop menu."  
	"cmdMap at: (27 + 1) put: #shiftEnclose:." 	"ctrl-["

	"'""''(' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose:]."

	cmds _ #(
		$a	argAdvance:
		$b	buttonIt:
		$c	compareToClipboard:
		$d	duplicate:
		$e	methodStringsContainingIt:
		$f	displayIfFalse:
		$g	fileItIn:
		$h	cursorTopHome:
		$i	exploreIt:
		$j	doAgainMany:
		$k	changeStyle:
		$l	outdent:
		$m	selectCurrentTypeIn:
		$n	referencesToIt:
		$p	makeProjectLink:
		$r	indent:
		$s	search:
		$t	displayIfTrue:
		$u	changeLfToCr:
		$v	pasteInitials:
		$w	methodNamesContainingIt:
		$x	makeLowercase:
		$y	makeUppercase:
		$z	makeCapitalized:
	).
	1 to: cmds size by: 2 do: [ :i |
		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).		"plain keys"
		cmdMap at: ((cmds at: i) asciiValue - 32 + 1) put: (cmds at: i + 1).		"shifted keys"
		cmdMap at: ((cmds at: i) asciiValue - 96 + 1) put: (cmds at: i + 1).		"ctrl keys"
	].
	ShiftCmdActions _ cmdMap! !

!ParagraphEditor class methodsFor: '*RVM-UI-Generic' stamp: 'ssa 2/9/2010 05:23'!
initializeTextEditorMenus
	"Initialize the yellow button pop-up menu and corresponding messages."
	"ParagraphEditor initializeTextEditorMenus"

	TextEditorYellowButtonMenu _ SelectionMenu
		labels:
'find...(f)
find again (g)
set search string (h)
do again (j)
undo (z)
copy (c)
cut (x)
paste (v)
paste...
do it (d)
print it (p)
inspect it (i)
explore it (e)
debug it
button it (B)
accept (s)
cancel (l)
show bytecodes
more...'
		lines: #(3 5 9 15 17 19)
		selections: #(find findAgain setSearchString again undo copySelection cut paste pasteRecent doIt printIt inspectIt exploreIt debugIt buttonIt accept cancel showBytecodes shiftedTextPaneMenuRequest).! !

!ParallelRandomBug class methodsFor: 'as yet unclassified' stamp: 'dmu 9/9/2010 00:13'!
test
	| numWorkers |
	numWorkers _ 2.

1 to: numWorkers do: [ :w |
[ 
	| tr |
	tr := Random new.

	10000 timesRepeat: [
	
			(tr next) < 0.0 ifTrue: [self error: 'neg'].
	
	].

] fork
].
! !

!ParallelRandomBug class methodsFor: 'as yet unclassified' stamp: 'dmu 9/9/2010 00:28'!
test2
	| numWorkers randoms |
	numWorkers _ 2.
	randoms _ ( Array new: 2) collect: [:x|Random new].
	
1 to: numWorkers do: [ :w |
[ 
	

	10000 timesRepeat: [
	
			((randoms at: w) next) < 0.0 ifTrue: [self error: 'neg'].
	
	].

] copy fixTemps fork
].
! !

!Parser methodsFor: '*Sly-expression types' stamp: 'dmu 9/16/2010 23:49'!
ensembleExpression
	" %{ elements } => MessageNode(BraceNode asEnsembleOfElements)."

	| elements locations loc more |
	elements _ OrderedCollection new.
	locations _ OrderedCollection new.
	self advance. "swallow the %"
	self advance.
	more _ hereType ~~ #rightBrace.
	[more]
		whileTrue: 
			[loc _ hereMark + requestorOffset.
			self expression
				ifTrue: 
					[elements addLast: parseNode.
					locations addLast: loc]
				ifFalse:
					[^self expected: 'Variable or expression'].
			(self match: #period)
				ifTrue: [more _ hereType ~~ #rightBrace]
				ifFalse: [more _ false]].
	parseNode _ BraceNode new elements: elements sourceLocations: locations.
	(self match: #rightBrace)
		ifFalse: [^self expected: 'Period or right brace'].

	parseNode _ MessageNode new
				receiver: parseNode
				selector: #asEnsembleOfElements
				arguments: #()
				precedence: 1  "unary"
				from: encoder
				sourceRange: (self startOfNextToken to: self endOfLastToken).
	^true! !

!Parser methodsFor: '*Sly-expression types' stamp: 'dmu 8/30/2010 09:42'!
expression
	"Modified for Sly ensemble literals"
	(hereType == #word and: [tokenType == #leftArrow])
		ifTrue: [^ self assignment: self variable].
	hereType == #percent
		ifTrue: [self ensembleExpression]
		ifFalse:[
			hereType == #leftBrace
				ifTrue: [self braceExpression]
				ifFalse: [self primaryExpression ifFalse: [^ false]]].
	(self messagePart: 3 repeat: true)
		ifTrue: [hereType == #semicolon ifTrue: [self cascade]].
	^ true! !

!Parser methodsFor: '*Sly-expression types' stamp: 'ads 1/30/2011 15:21'!
messagePart: level repeat: repeat
	"Changed to support RVM multicore coordinates and  Sly selectors"
	| start receiver selector args precedence words keywordStart |
	[receiver _ parseNode.
	(hereType == #keyword and: [level >= 3])
		ifTrue: 
			[start _ self startOfNextToken.
			selector _ WriteStream on: (String new: 32).
			args _ OrderedCollection new.
			words _ OrderedCollection new.
			[hereType == #keyword]
				whileTrue: 
					[keywordStart _ self startOfNextToken + requestorOffset.
					selector nextPutAll: self advance.
					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 2 repeat: true.
					args addLast: parseNode].
			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector _ sym])
				ifFalse: [ selector _ ((RVMOperations ifNil: [false] ifNotNil: [RVMOperations isMulticoreCoordinate: selector contents]) or:[Sly3AbstractModifier isSlySelector: selector contents])
									 ifTrue:[selector contents asSymbol]
									ifFalse:[self correctSelector: selector contents
										wordIntervals: words
										exprInterval: (start to: self endOfLastToken)
										ifAbort: [ ^ self fail ] ]].
			precedence _ 3]
		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])
				and: [level >= 2])
				ifTrue: 
					[start _ self startOfNextToken.
					selector _ self advance asSymbol.
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 1 repeat: true.
					args _ Array with: parseNode.
					precedence _ 2]
				ifFalse: [hereType == #word
						ifTrue: 
							[start _ self startOfNextToken.
							selector _ self advance.
							args _ #().
							words _ OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
							(Symbol hasInterned: selector ifTrue: [ :sym | selector _ sym])
								ifFalse: [ selector _  ((RVMOperations isMulticoreCoordinate: selector contents) or:[Sly3AbstractModifier isSlySelector: selector contents])
									 ifTrue:[selector contents asSymbol]
									ifFalse:[self correctSelector: selector
													wordIntervals: words
													exprInterval: (start to: self endOfLastToken)
													ifAbort: [ ^ self fail ] ]].
							precedence _ 1]
						ifFalse: [^args notNil]]].
	parseNode _ MessageNode new
				receiver: receiver
				selector: selector
				arguments: args
				precedence: precedence
				from: encoder
				sourceRange: (start to: self endOfLastToken).
	repeat]
		whileTrue: [].
	^true! !

!Parser methodsFor: '*Sly-expression types' stamp: 'dmu 8/30/2010 09:49'!
primaryExpression 
	"Added Sly ensembleExpression type"
	hereType == #word 
		ifTrue: 
			[parseNode _ self variable.
			(parseNode isUndefTemp and: [self interactive])
				ifTrue: [self queryUndefined].
			parseNode nowHasRef.
			^ true].
	hereType == #leftBracket
		ifTrue: 
			[self advance.
			self blockExpression.
			^true].
	hereType == #leftBrace
		ifTrue: 
			[self braceExpression.
			^true].
	hereType == #percent
		ifTrue: 
			[self ensembleExpression.
			^true].
	hereType == #leftParenthesis
		ifTrue: 
			[self advance.
			self expression ifFalse: [^self expected: 'expression'].
			(self match: #rightParenthesis)
				ifFalse: [^self expected: 'right parenthesis'].
			^true].
	(hereType == #string or: [hereType == #number or: [hereType == #literal]])
		ifTrue: 
			[parseNode _ encoder encodeLiteral: self advance.
			^true].
	(here == #- and: [tokenType == #number])
		ifTrue: 
			[self advance.
			parseNode _ encoder encodeLiteral: self advance negated.
			^true].
	^false! !

!Particle methodsFor: 'displaying'!
displayOn: t1 
	self form
		displayOn: t1
		at: location
		rule: Form paint! !

!Particle methodsFor: 'displaying' stamp: 'max 9/17/2010 11:40'!
form
	| fill |
	(formChanged
			or: [form isNil])
		ifTrue: [form := (Form dotOfSize: size) as8BitColorForm.
			fill := (Form dotOfSize: size - 2) as8BitColorForm mapColor: Color black to: color.
			fill mapColor: Color white to: Color transparent.
			fill  displayOn: form
				at: (size // 2) asPoint
				rule: Form paint.
			form mapColor: Color white to: Color transparent.
			formChanged := false].
	^ form! !

!Particle methodsFor: 'accessing'!
area
	^ Rectangle center: location extent: size asPoint! !

!Particle methodsFor: 'accessing'!
color
	^ color! !

!Particle methodsFor: 'accessing'!
location
	^ location! !

!Particle methodsFor: 'accessing'!
size
	^ size! !

!Particle methodsFor: 'accessing'!
velocity
	^ velocity! !

!Particle methodsFor: 'motion and interaction' stamp: 'max 9/18/2010 00:19'!
bounce
	| bounds |
	bounds := homeField area.
	
	((location x < bounds left) or: [location x >= bounds right])
		ifTrue: [velocity := velocity x negated @ velocity y].
	
	((location y < bounds top) or: [location y >= bounds bottom])
		ifTrue: [velocity := velocity x @ velocity y negated].
	
	location := location adhereTo: bounds.
	
	! !

!Particle methodsFor: 'motion and interaction' stamp: 'max 9/17/2010 19:18'!
collideWith: anotherParticle
	"Two axis collision sort"
	anotherParticle color red > color red
		ifTrue: [velocity := velocity x abs negated @ velocity y]
		ifFalse: [velocity := velocity x abs @ velocity y].
	anotherParticle color blue > color blue
		ifTrue: [velocity := velocity x @ velocity y abs negated]
		ifFalse: [velocity := velocity x @ velocity y abs]! !

!Particle methodsFor: 'motion and interaction' stamp: 'max 9/17/2010 11:30'!
go
	running := true.
	[[running] whileTrue: [self step. Processor yield]] fork! !

!Particle methodsFor: 'motion and interaction' stamp: 'max 9/29/2010 12:54'!
moveTo: anotherField 
	anotherField add: self.
	"old" homeField remove: self.
	homeField := anotherField.! !

!Particle methodsFor: 'motion and interaction' stamp: 'max 9/16/2010 17:17'!
particle: aParticle ofSize: itsSize movedTo: aLocation
	"...but if it's not touching me, don't do anything about it."
	((location dist: aLocation) <= (size + itsSize // 2)
		and: [aParticle ~= self])
			ifTrue: [self collideWith: aParticle.
					aParticle collideWith: self]! !

!Particle methodsFor: 'motion and interaction' stamp: 'max 9/22/2010 14:18'!
step
	location := location + velocity.
	homeField
		particle: self
		ofSize: size
		movedTo: location! !

!Particle methodsFor: 'motion and interaction'!
stop
	running := false! !

!Particle methodsFor: 'printing'!
printOn: t1 
	super printOn: t1.
	t1 nextPut: $(.
	self location printOn: t1.
	t1 nextPut: $)! !

!Particle methodsFor: 'initialize-release' stamp: 'max 9/17/2010 11:38'!
initialize
	running := false.
	formChanged := true.
! !

!Particle methodsFor: 'private'!
setColor: t1 size: t2 location: t3 velocity: t4 
	color := t1.
	size := t2.
	location := t3.
	velocity := t4! !

!Particle methodsFor: 'private' stamp: 'max 9/29/2010 14:00'!
setHomeField: aField 
	(aField isNil) ifFalse:
		[(homeField == aField)
			ifFalse: 
				[homeField := aField]]! !

!Particle class methodsFor: 'as yet unclassified' stamp: 'max 9/16/2010 17:37'!
c: aColor s: aSize l: aPoint v: aPointOffset 
	| p |
	p := self new.
	p
		setColor: aColor
		size: aSize
		location: aPoint
		velocity: aPointOffset.
	^ p! !

!ParticleSim methodsFor: 'private' stamp: 'max 9/16/2010 17:03'!
makeBlankForm
	| newForm xMax yMax pen |
	xMax := extent x - 1.
	yMax := extent y - 1.
	newForm := (Form extent: extent depth: 8) fillWhite.
	pen := (Form extent: 1@1 depth: 8) fillColor: Color veryLightGray.
	
	"Draw horizontal grid lines"
	0 to: xMax by: (xMax / fields rowCount) do:
	[:x | newForm 
		drawLine: pen
		from: x@0
		to: x@yMax
		clippingBox: (0@0 corner: extent)
		rule: Form paint 
		fillColor: newForm].
	
	"... and vertical"
	0 to: yMax by: (yMax / fields columnCount) do:
	[:y | newForm 
		drawLine: pen
		from: 0@y
		to: xMax@y
		clippingBox: (0@0 corner: extent)
		rule: Form paint 
		fillColor: newForm].
	
	blankForm := newForm! !

!ParticleSim methodsFor: 'private' stamp: 'max 9/29/2010 12:45'!
setExtent: aPointOffset fields: xAndY 
	"This is an initialization message which must be sent to all new ParticleSim objects."
	| fieldExtent |
	running := false.
	extent := aPointOffset.
	fieldExtent := aPointOffset // xAndY.
	form := Form extent: aPointOffset depth: 8.
	fields := Matrix rows: xAndY x columns: xAndY y.
	
	fields indicesDo:
		 [:x :y | fields at: x at: y put: (Field origin: x@y - (1@1) * fieldExtent extent: fieldExtent)].
		
	fields indicesDo:
		[:x :y  | (fields at: x at: y)
			setNeighborN: (fields at: x at: y - 1 ifInvalid: nil);
			setNeighborNE: (fields at: x + 1 at: y - 1 ifInvalid: nil);
			setNeighborNW: (fields at: x - 1 at: y - 1 ifInvalid: nil);
			setNeighborS: (fields at: x at: y + 1 ifInvalid: nil);
			setNeighborSE: (fields at: x + 1 at: y + 1 ifInvalid: nil);
			setNeighborSW: (fields 	at: x - 1 at: y + 1 ifInvalid: nil);
			setNeighborE: (fields at: x + 1 at: y ifInvalid: nil);
			setNeighborW: (fields at: x - 1 at: y ifInvalid: nil);
			setSimulation: self].
	self makeBlankForm! !

!ParticleSim methodsFor: 'user interface' stamp: 'max 9/18/2010 18:03'!
add: aParticle 
	| loc destinationField |
	loc := aParticle location.
	destinationField := fields
				detect: [:fld | fld area containsPoint: loc].
	aParticle setHomeField: destinationField.
	destinationField add: aParticle
! !

!ParticleSim methodsFor: 'user interface' stamp: 'max 9/18/2010 18:03'!
addRandom: nParticles 
	nParticles timesRepeat: 
		[self add:
			(Particle
				c: Color random
				s: (10 to: 30) atRandom
				l: (0 to: extent x - 1) atRandom @ (0 to: extent y - 1) atRandom
				v: (1 to: 10) atRandom @ (1 to: 10) atRandom)]! !

!ParticleSim methodsFor: 'user interface' stamp: 'max 9/18/2010 18:04'!
clear
	fields do: [:fld | fld particles removeAll]! !

!ParticleSim methodsFor: 'user interface' stamp: 'max 9/17/2010 12:50'!
go
	running := true.
	"[[running] whileTrue: [self refresh. (Delay forMilliseconds: 50) wait]] fork."
	fields do: [:fld | fld go]! !

!ParticleSim methodsFor: 'user interface' stamp: 'max 9/16/2010 16:49'!
openMVCWindow
	| topView |
	canvas := FormView new model: form.
	topView := StandardSystemView new label: 'Particle Simulator';
				 borderWidth: 2;
				 minimumSize: extent;
				 maximumSize: extent;
				 model: self;
				 addSubView: canvas.
	topView controller open! !

!ParticleSim methodsFor: 'user interface' stamp: 'max 9/16/2010 16:49'!
refresh
	blankForm displayOn: form.
	fields do: [:fld | fld displayOn: form].
	canvas displayView! !

!ParticleSim methodsFor: 'user interface' stamp: 'max 9/18/2010 00:28'!
step
	fields do: [:fld | fld step].
	self refresh! !

!ParticleSim methodsFor: 'user interface' stamp: 'max 9/16/2010 16:50'!
stop
	fields do: [:fld | fld stop].
	running := false! !

!ParticleSim methodsFor: 'accessing'!
blankForm
	^ blankForm! !

!ParticleSim methodsFor: 'accessing'!
fields
	^ fields! !

!ParticleSim methodsFor: 'accessing'!
form
	^ form! !

!ParticleSim methodsFor: 'accessing'!
running
	^ running! !

!ParticleSim class methodsFor: 'instance creation'!
demo
	| t1 |
	t1 := self new setExtent: 500 @ 300 fields: 5 @ 3.
	t1 addRandom: 10.
	^ t1! !

!ParticleSim class methodsFor: 'instance creation'!
extent: t1 
	^ self extent: t1 fields: 2 @ 2! !

!ParticleSim class methodsFor: 'instance creation' stamp: 'max 9/16/2010 16:51'!
extent: aPointOffset fields: xAndY 
	^ self new setExtent: aPointOffset fields: xAndY! !

!Pen methodsFor: 'accessing'!
destForm: aForm
        "2/14/97 ssa added for compatibility."
        self flag:#compatibility.

        destForm _ aForm ! !

!Pen methodsFor: 'operations' stamp: 'ssa 11/29/2009 03:27'!
turnToward: aPoint 
	"Aim the receiver at apoint"

	self north; turn: (self penAngleFrom: self location to: aPoint)! !

!Pen methodsFor: 'geometric designs' stamp: 'ssa 2/16/2009 11:50'!
mandala: npoints diameter: d
	"Display restoreAfter: [Pen new mandala: 30 diameter: 400]"
	"On a circle of diameter d, place npoints number of points. Draw all 	possible connecting lines between the circumferential points."
	| l points  |
	"Display fillWhite."
	l _ 3.14 * d / npoints.
	self home; up; turn: -90; go: d // 2; turn: 90; go: 0 - l / 2; down.
	points _ Array new: npoints.
	1 to: npoints do: 
		[:i | 
		points at: i put: location rounded.
		self go: l; turn: 360.0 / npoints].
	npoints // 2
		to: 1
		by: -1
		do: 
			[:i | 
			self color: i.
			1 to: npoints do: 
				[:j | 
				self place: (points at: j).
				self goto: (points at: j + i - 1 \\ npoints + 1)]]
! !

!Pen methodsFor: 'private' stamp: 'ssa 2/6/2009 10:49'!
direction: aFloat
	direction _ aFloat.
! !

!Pen methodsFor: 'functions' stamp: 'ssa 11/29/2009 03:24'!
penAngleFrom:firstPoint to: lastPoint
	| offset x y deg | 
	"return the angle of the vector in Pen degrees (0 = north)"

offset _ lastPoint - firstPoint.

x _ offset x .
y _ offset y. 
x = 0 ifTrue:[ x _ 0.0001].
deg _ (y / x) arcTan radiansToDegrees.
x positive & y positive ifTrue:[ deg _ 90 + deg].
x positive & y negative ifTrue:[ deg _ 90 + deg].
x negative & y positive ifTrue:[ deg _ 270 + deg].
x negative & y negative ifTrue:[ deg _ 270 + deg].

^deg! !

!PluggableButtonView methodsFor: 'accessing' stamp: 'ssa 8/23/2009 13:42'!
label: aStringOrDisplayObject 
	"Label this button with the given String or DisplayObject."

	((aStringOrDisplayObject isKindOf: Paragraph)
	or: [aStringOrDisplayObject isForm])
		ifTrue: [label _ aStringOrDisplayObject]
		ifFalse: [label _ aStringOrDisplayObject asParagraph].
	self centerLabel.
! !

!PluggableButtonView methodsFor: 'displaying' stamp: 'acg 2/23/2000 00:18'!
displayView

	"Displays this switch and its label, if any."

	self clearInside.
	label ifNotNil: [
		(label isKindOf: Paragraph) ifTrue: [
			label foregroundColor: self foregroundColor
				 backgroundColor: self backgroundColor].
		label displayOn: Display
				at: label boundingBox topLeft
				clippingBox: self insetDisplayBox].
	complemented _ false.! !

!PluggableButtonView methodsFor: 'other' stamp: 'ssa 8/22/2009 15:54'!
performAction
	"Inform the model that this button has been pressed. Sent by the controller when this button is pressed."

	(argumentsSelector isKindOf: BlockContext) ifTrue:[^argumentsSelector value].
	argumentsSelector
		ifNil:
			[actionSelector ifNotNil:
				[model perform: actionSelector]]
		ifNotNil:
			[model perform: actionSelector
				withArguments:
					(Array with: (argumentsProvider perform: argumentsSelector))]! !

!PluggableButtonView methodsFor: 'other' stamp: 'ssa 8/23/2009 13:47'!
update: aParameter 

	aParameter == getLabelSelector ifTrue: [
		getLabelSelector ifNotNil: [
			self label: (model perform: getLabelSelector halt ).
			self displayView]].
	self getModelState 
		ifTrue: [self displayComplemented]
		ifFalse: [self displayNormal].
! !

!PluggableFileList methodsFor: 'StandardFileMenu' stamp: 'ssa 4/19/2010 20:06'!
startUpWithCaption: captionOrNil
	"Display the menu, slightly offset from the cursor,
	so that a slight tweak is required to confirm any action."
	^ self startUpWithCaption: captionOrNil at: Sensor cursorPoint! !

!PluggableFileList class methodsFor: 'StandardFileMenu' stamp: 'ssa 10/18/2008 23:10'!
oldFileMenu: aDirectory withPattern: aPattern

	"For compatibility with StandardFileMenu for now, answer a StandardFileMenuResult"
	^(self getFilePathNameDialog)
		resultBlock: self sfmResultBlock;
		directory: aDirectory;
		pattern: aPattern;
		yourself! !

!PluggableListController methodsFor: 'private' stamp: 'di 5/25/1998 10:20'!
changeModelSelection: anInteger
	"Let the view handle this."

	terminateDuringSelect ifTrue: [self controlTerminate].
	view changeModelSelection: anInteger.
	terminateDuringSelect ifTrue: [self controlInitialize].! !

!PluggableListControllerOfMany methodsFor: 'control defaults' stamp: 'ssa 1/1/1970 00:05'!
redButtonActivity
	| selection firstHit turningOn lastSelection pt scrollFlag |
	model okToChange ifFalse: [^ self].
		"Don't change selection if model refuses to unlock"
	firstHit _ true.
	scrollFlag _ false.
	lastSelection _ 0.
	[sensor redButtonPressed] whileTrue: 
		[
selection _ view findSelection: (pt _ sensor cursorPoint).
		selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"
			[pt y < view insetDisplayBox top ifTrue:
				[self scrollView: view list lineGrid.
				scrollFlag _ true.
				selection _ view firstShown].
			pt y > view insetDisplayBox bottom ifTrue:
				[self scrollView: view list lineGrid negated.
				scrollFlag _ true.
				selection _ view lastShown]].
		(selection == nil or: [selection = lastSelection]) ifFalse: 
			[firstHit ifTrue:
				[firstHit _ false.
				turningOn _ (view listSelectionAt: selection) not].
			view selection: selection.
			(view listSelectionAt: selection) == turningOn ifFalse:
				[view displaySelectionBox.
				view listSelectionAt: selection put: turningOn].
			lastSelection _ selection]].
	selection notNil ifTrue:
		["Normal protocol delivers change, so unchange first (ugh)"
		"view listSelectionAt: selection put: (view listSelectionAt: selection) not".
		self changeModelSelection: selection].
	scrollFlag ifTrue: [self moveMarker]! !

!PluggableListView methodsFor: 'model access' stamp: 'ssa 9/2/2009 20:11'!
getList 
	"Answer the list to be displayed."

	| lst |
	getListSelector == nil ifTrue: [^ #()].
	lst _ model perform: getListSelector.
	lst == nil ifTrue: [^ #()].
	^ lst ! !

!PluggableListView methodsFor: 'updating' stamp: 'ssa 11/25/2009 14:42'!
update: aSymbol 
	"Refer to the comment in View|update:."
	"Hacked to support Windoze - ssa"
	aSymbol == getListSelector ifTrue:
		[self list: self getList.
		self displayView.
		self displaySelectionBox].
	aSymbol == getSelectionSelector ifTrue:
		[self moveSelectionBox: self getCurrentSelectionIndex].
	(self superView isKindOf: MSWScrollBarView)
		ifTrue:[self superView updateElevator]! !

!PluggableListView class methodsFor: 'instance creation' stamp: 'ssa 3/24/2010 14:45'!
on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel
	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."

	^ self 
		on: anObject
		list: getListSel
		selected: getSelectionSel
		changeSelected: setSelectionSel
		menu: nil
		keystroke: #arrowKey:from:		"default"
! !

!PluggableListView class methodsFor: 'instance creation' stamp: 'ssa 3/24/2010 14:45'!
on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel
	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."

	^ self 
		on: anObject
		list: getListSel
		selected: getSelectionSel
		changeSelected: setSelectionSel
		menu: getMenuSel
		keystroke: #arrowKey:from:		"default"

! !

!PluggableListView class methodsFor: 'instance creation' stamp: 'ssa 9/4/1998 16:00'!
on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel
	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."
	"Added Windoze wrapper - ssa"

	^ MSWScrollBarView on: (self new
		on: anObject
		list: getListSel
		selected: getSelectionSel
		changeSelected: setSelectionSel
		menu: getMenuSel
		keystroke: keyActionSel)
! !

!PluggableListViewByObject methodsFor: 'accessing' stamp: 'ssa 11/25/2009 12:50'!
changeModelSelection: anInteger
	"Change the model's selected item to be the one at the given index."
	| item |
	setSelectionSelector ifNotNil: [
		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [self objects at: anInteger]).
		model perform: setSelectionSelector with: item].
! !

!PluggableListViewByObject methodsFor: 'accessing' stamp: 'ssa 1/29/2010 13:40'!
getCurrentSelectionIndex
	"Answer the index of the current selection."
	| item |
	getSelectionSelector == nil ifTrue: [^ 0].
	item _ model perform: getSelectionSelector.
	^ self objects indexOf: item ifAbsent:[0]
! !

!PluggableListViewByObject methodsFor: 'accessing' stamp: 'ssa 1/29/2010 13:47'!
labelForItem: anItem
	"Subclasses may want to override"
	^anItem isString ifTrue:[anItem]ifFalse:[anItem printString]! !

!PluggableListViewByObject methodsFor: 'accessing' stamp: 'ssa 6/17/2010 16:40'!
list: arrayOfObjects
	"Set the receivers items to be the given list of objects printStrings."
	"Note: the instance variable 'objects' holds the original list.
	 The instance variable 'list' is a paragraph constructed from
	 this list."

	| oldOffset |
	self scrollCache: (list isNil ifFalse:[list scrollDelta]ifTrue:[0]).
	self objects: arrayOfObjects.
	isEmpty _ arrayOfObjects isEmpty.
	oldOffset _ list isNil ifTrue:[0@0]ifFalse:[list offset].

	"add top and bottom delimiters"
	list _ ListParagraph 
		withArray:
			(Array streamContents: [:s |
				s nextPut: topDelimiter.
				self objects do: [:item | item == nil ifFalse: [s nextPut: (self labelForItem: item)]].
				s nextPut: bottomDelimiter])
		 style: self assuredTextStyle.
	list offset: oldOffset.
	selection _ self getCurrentSelectionIndex.
	self positionList.! !

!PluggableListViewByObject methodsFor: 'accessing' stamp: 'ssa 9/9/2009 11:31'!
objects
	"Answer the value of objects"

	objects isNil ifTrue:[self objects: OrderedCollection new].
	^ objects! !

!PluggableListViewByObject methodsFor: 'accessing' stamp: 'ssa 9/9/2009 11:29'!
objects: anObject
	"Set the value of objects"

	objects _ anObject! !

!PluggableListViewByObject methodsFor: 'accessing' stamp: 'ssa 1/22/2010 14:02'!
scrollCache
	"Answer the value of scrollCache"

	scrollCache isNil ifTrue:[self scrollCache: 0].
	^ scrollCache! !

!PluggableListViewByObject methodsFor: 'accessing' stamp: 'ssa 1/22/2010 14:02'!
scrollCache: anObject
	"Set the value of scrollCache"

	scrollCache _ anObject! !

!PluggableListViewOfMany class methodsFor: 'instance creation' stamp: 'ssa 3/24/2010 14:46'!
on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel
	^ self 
		on: anObject
		list: listSel
		primarySelection: getSelectionSel
		changePrimarySelection: setSelectionSel
		listSelection: getListSel
		changeListSelection: setListSel
		menu: getMenuSel
		keystroke: #arrowKey:from:		"default"! !

!PluggableListViewOfMany class methodsFor: 'instance creation' stamp: 'ssa 8/21/2009 15:22'!
on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel 
	^MSWScrollBarView on: ( self new
		on: anObject
		list: listSel
		primarySelection: getSelectionSel
		changePrimarySelection: setSelectionSel
		listSelection: getListSel
		changeListSelection: setListSel
		menu: getMenuSel
		keystroke: keyActionSel)! !

!PluggableOutline methodsFor: 'menu support' stamp: 'ssa 9/10/2009 14:42'!
inspectSelection

	self selection inspect! !

!PluggableOutline methodsFor: 'menu support' stamp: 'ssa 9/10/2009 14:47'!
menu: aMenu


	aMenu add: 'inspect' action: #inspectSelection.
	aMenu add: 'outline' action: #outlineSelection.
	^ aMenu! !

!PluggableOutline methodsFor: 'menu support' stamp: 'ssa 9/10/2009 14:43'!
outlineSelection

	self selection outline! !

!PluggableOutline methodsFor: 'menu support' stamp: 'ssa 9/10/2009 14:55'!
perform: selector orSendTo: otherTarget
	
	^self perform: selector! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/10/2009 13:29'!
childrenOf: anObject

	^anObject subobjects! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/9/2009 12:02'!
initializeList

	self list do:[:each| self levels at: each put:0]! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/9/2009 12:01'!
levelOf: anItem

	^self levels at: anItem ifAbsent:[0]! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/9/2009 12:01'!
levels
	"Answer the value of levels"

	levels isNil ifTrue:[self levels: Dictionary new].
	^ levels! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/9/2009 12:00'!
levels: anObject
	"Set the value of levels"

	levels _ anObject! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/10/2009 13:39'!
list
	"Answer the value of list"

	list isNil ifTrue:[self list: (OrderedCollection with:self subject )].
	^ list! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/10/2009 13:36'!
list: anObject
	"Set the value of list"

	list _ anObject asOrderedCollection! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/9/2009 11:42'!
openItems
	"Answer the value of openItems"

	openItems isNil ifTrue:[self openItems: Set new].
	^ openItems! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/9/2009 11:42'!
openItems: anObject
	"Set the value of openItems"

	openItems _ anObject! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/9/2009 13:28'!
progenyOf: anObject

	| all |
	all _ (self childrenOf: anObject)copy.
	all isEmpty ifTrue:[^all].
	all copy do:[:each| all addAll: (self progenyOf: each)].
	^all ! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/9/2009 11:18'!
selection
	"Answer the value of selection"

	selection isNil ifTrue:[self selection: nil].
	^ selection! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/9/2009 17:15'!
selection: anObject
	"Set the value of selection"

	selection _ anObject .
	! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 7/7/2010 12:40'!
subject
	"Answer the value of subject"

	subject isNil ifTrue:[self subject: nil].
	^ subject! !

!PluggableOutline methodsFor: 'accessing' stamp: 'ssa 9/10/2009 08:25'!
subject: anObject
	"Set the value of subject"

	subject _ anObject! !

!PluggableOutline methodsFor: 'opening/closing' stamp: 'ssa 9/9/2009 13:02'!
hasChildren: anObject

	^(self childrenOf: anObject) notEmpty ! !

!PluggableOutline methodsFor: 'opening/closing' stamp: 'ssa 9/9/2009 14:07'!
hideChildrenOfSelection

	| kids |
	self openItems remove: self selection.
	kids _ self progenyOf: self selection.
	kids do:[:each| self levels removeKey: each ifAbsent:[].
		self openItems remove: each ifAbsent:[]].
	self list removeAll: kids ifAbsent:[]
! !

!PluggableOutline methodsFor: 'opening/closing' stamp: 'ssa 9/9/2009 11:42'!
isOpen: anItem

	^self openItems includes: anItem! !

!PluggableOutline methodsFor: 'opening/closing' stamp: 'ssa 9/9/2009 12:10'!
showChildrenOfSelection

	| kids nextLevel |
	self openItems add: self selection.
	nextLevel _ (self levelOf: self selection) + 1.
	kids _ self childrenOf: self selection.
	kids isEmpty ifTrue:[^self error:'should never try to show children of an childless object'].
	kids do:[:each| self levels at: each put: nextLevel].
	self list addAll: kids after: self selection! !

!PluggableOutline methodsFor: 'opening/closing' stamp: 'ssa 9/10/2009 07:30'!
toggleSelection

	self selection isNil ifTrue:[^self].
	(self isOpen: self selection)
		ifTrue:[self hideChildrenOfSelection]
		ifFalse:[self showChildrenOfSelection].
	self changed:#list! !

!PluggableOutline methodsFor: 'arrow keys' stamp: 'ssa 9/9/2009 14:47'!
arrowKey: aChar from: view
	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index.  Derived from a Martin Pammer submission, 02/98"

     | keyEvent oldSelection nextSelection max min howMany |

	(#(1 4 11 12 30 31) includes: (keyEvent _ aChar asciiValue)) ifFalse:
		[
			^ self].

     oldSelection := view getCurrentSelectionIndex.
     nextSelection := oldSelection.
     max := view maximumSelection.
     min := view minimumSelection.
     howMany := view numSelectionsInView.	"get this exactly??"

     keyEvent == 31 ifTrue:
		["down-arrow; move down one, wrapping to top if needed"
		nextSelection := oldSelection + 1.
		nextSelection > max ifTrue: [nextSelection _ 1]].

     keyEvent == 30 ifTrue:
		["up arrow; move up one, wrapping to bottom if needed"
		nextSelection := oldSelection - 1.
		nextSelection < 1 ifTrue: [nextSelection _ max]].

     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"
     keyEvent == 4  ifTrue: [nextSelection := max].   "end"
     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection - howMany)].  "page up"
     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany) min: max].  "page down"
     nextSelection = oldSelection  ifFalse:
		[self okToChange
			ifTrue:
				[view changeModelSelection: nextSelection.
				"view controller moveMarker"]]
			! !

!PluggableTextController methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:35'!
selectFrom: start to: stop scroll: scrollCommand
	"Deselect, then select the specified characters inclusive.
	 Be sure the selection is in view."

	(start = self startIndex and: [stop + 1 = self stopIndex]) ifFalse:
		[view superView ifNotNil: [self deselect].
		self selectInvisiblyFrom: start to: stop].
	view superView ifNotNil: [self perform: scrollCommand]! !

!PluggableTextView class methodsFor: 'instance creation' stamp: 'ssa 3/24/2010 14:35'!
on: anObject text: getTextSel accept: setTextSel

	^ self on: anObject
		text: getTextSel
		accept: setTextSel
		readSelection: nil
		menu: nil
! !

!PluggableTextView class methodsFor: 'instance creation' stamp: 'ssa 9/4/1998 16:04'!
on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel
	"Added Windoze wrapper - ssa"

	^ MSWScrollBarView on: (self new on: anObject
		text: getTextSel
		accept: setTextSel
		readSelection: getSelectionSel
		menu: getMenuSel)
! !

!Point methodsFor: 'accessing' stamp: 'ssa 11/16/2008 13:12'!
x: aNumber

	x _ aNumber! !

!Point methodsFor: 'accessing' stamp: 'ssa 11/16/2008 13:12'!
y: aNumber

	y _ aNumber! !

!Point methodsFor: 'arithmetic' stamp: 'ssa 11/27/2009 16:15'!
inverted

	^1 asPoint / self! !

!Point methodsFor: 'comparing' stamp: 'ssa 9/3/2009 07:11'!
maxed

	^(x max: y) asPoint! !

!Point methodsFor: 'comparing' stamp: 'ssa 9/3/2009 07:11'!
mined

	^(x min: y) asPoint! !

!Point methodsFor: 'interpolating' stamp: 'ssa 9/7/2009 21:42'!
zeno
	"(10@10) zeno  #(10@10 5.0@5.0 2.5@2.5 1.25@1.25)"
	"(10@4) zeno  #(10@4 5.0@2.0)"
	"(-10@4) zeno  "
	| steps zx zy minSize |
	steps _ OrderedCollection new.
	zx _ x zeno.
	zy _ y zeno.
	minSize _ zx size min: zy size.
	1 to: minSize do:[:index|
		steps add:(zx at: index)@(zy at: index)].
	^steps asArray! !

!Point methodsFor: 'point functions' stamp: 'ssa 11/16/2008 02:35'!
atRandom

	^x atRandom @ y atRandom! !

!Point methodsFor: 'point functions' stamp: 'ssa 1/30/2009 10:04'!
mandist: aPoint 
	"Answer the Manhattan distance between aPoint and the receiver."

	^(x-aPoint x) abs + (y - aPoint y) abs! !

!Point methodsFor: 'point functions' stamp: 'dmu 4/1/2009 20:49'!
manhattanDist: aPoint 
	"Answer the distance between aPoint and the receiver."

	| p |
	p _ aPoint - self.
	^ p x abs + p y abs! !

!Point methodsFor: 'polar coordinates'!
complexProduct: aPoint

	^((x * aPoint x) - (y * aPoint y)) @ ((x * aPoint y) + (y * aPoint x))! !

!Point methodsFor: 'transforming' stamp: 'ssa 8/25/2009 14:26'!
moveBy: aPoint
	"Alter the receiver by moving it by a Point."

	
	x _ x + aPoint x.
	y _ y + aPoint y.! !

!Point methodsFor: 'transforming' stamp: 'ssa 2/8/2009 20:57'!
wrapAround: aRectangle
	"If the receiver lies outside aRectangle, return the nearest point on the other side of the rectangle, otherwise return self."

	| newX newY |
	newX _ x.
	newY _ y.
	(aRectangle containsPoint: self) ifTrue: [^ self].
	x >= aRectangle right ifTrue:[newX _ aRectangle left].
	x <= aRectangle left ifTrue:[newX _ aRectangle right].
	y >= aRectangle bottom ifTrue:[newY _ aRectangle top].
	y <= aRectangle top ifTrue:[newY _ aRectangle bottom].
	^newX@newY! !

!Point methodsFor: 'truncation and round off' stamp: 'ssa 8/25/2009 14:08'!
ceiling
	"Answer a new Point that is the receiver's x and y ceiling."

	^x ceiling @ y ceiling! !

!Point methodsFor: 'truncation and round off' stamp: 'ssa 8/25/2009 14:07'!
floor
	"Answer a new Point that is the receiver's x and y floor."

	^x floor @ y floor! !

!Point methodsFor: '*Ly' stamp: 'dmu 1/25/2010 14:02'!
minus: arg 
	"Answer a Point that is the difference of the receiver and arg."

	arg isPoint ifTrue: [^ (x - arg x) @ (y - arg y)].
	^ arg adaptToPoint: self andSend: #-! !

!Point methodsFor: '*Ly' stamp: 'dmu 3/16/2010 23:16'!
perturb: n
	| r |
	r _ Random new.
	^ self + ( r next @r next   *  n  - (n / 2.0) )! !

!PointerExplorer methodsFor: 'accessing' stamp: 'ab 8/22/2003 18:51'!
getList
	^Array with: (PointerExplorerWrapper with: rootObject name: rootObject identityHash asString model: self)
! !

!PointerExplorer commentStamp: 'avi 8/21/2004 20:01' prior: 0!
A variant on the ObjectExlorer that works "backwards": like the ObjectExplorer, it shows a tree of objects, but expanding a node won't show the objects which that node references, but rather the objects that reference that node.  Its main use is to track down memory leaks: if you want to know why a particular object is still alive, open a PointerExplorer on it and drill down until you find the root object that's referencing it.  For example, find all the references to the symbol #zot with:

PointerExplorer new openExplorerFor: #zot

For the "name" of the object, the PointerExplorer shows each object's identityHash, to allow the user to identify when two similar objects are identical and notice cycles.!
!PointerExplorerWrapper methodsFor: 'accessing' stamp: 'ssa 9/11/2009 16:23'!
contents
	| objects |
	objects := Utilities pointersTo: item except: (Array with: self with: model).	
	^(objects reject: [:ea | ea class = self class])
		collect: [:ea| self class with: ea name: ea identityHash asString model: item parent: self]! !

!PointerExplorerWrapper methodsFor: 'testing' stamp: 'ab 8/22/2003 18:39'!
hasContents
	^true! !

!PointerExplorerWrapper commentStamp: 'avi 8/21/2004 19:58' prior: 0!
A subclass of ObjectExplorerWrapper for use with PointerExplorer.  #contents is overridden to work backwards: it returns wrappers for the objects pointing to item rather than for the objects that item points to.!
!PointerFinder methodsFor: 'morphic ui' stamp: 'ssa 3/9/2010 16:29'!
menu: aMenu shifted: shifted
	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"
	^SelectionMenu
		labels:
'inpsect
search again'
		lines: #()
		selections: #(inspectObject searchAgain).! !

!PointerFinder methodsFor: 'morphic ui' stamp: 'ssa 3/9/2010 16:37'!
open
	| topView listView |
		topView := StandardSystemView new
				label: 'Pointer FInder'; 
				model: self;
				yourself.
	topView addSubView:(listView := PluggableListView
		on: self
		list: #pointerList
		selected: #pointerListIndex
		changeSelected: #pointerListIndex:
		menu: #menu:shifted:
		keystroke: #arrowKey:from:)
	in:(0@0 extent: 1@1)
	borderWidth:1.
	listView backgroundColor: Color lightMagenta.
	topView controller open! !

!PointerFinder class methodsFor: 'utilities' stamp: 'sd 9/24/2004 20:49'!
pointersTo: anObject
	"Find all occurrences in the system of pointers to the argument anObject."
	"(PointerFinder pointersTo: Browser) inspect."

	^ self pointersTo: anObject except: #()
! !

!PointerFinder class methodsFor: 'utilities' stamp: 'sd 11/20/2005 21:28'!
pointersTo: anObject except: objectsToExclude
	"Find all occurrences in the system of pointers to the argument anObject. 
	Remove objects in the exclusion list from the results."
	
	| results anObj |
	Smalltalk garbageCollect.
	"big collection shouldn't grow, so it's contents array is always the same"
	results := OrderedCollection new: 1000.

	"allObjectsDo: is expanded inline to keep spurious
	 method and block contexts out of the results"
	anObj := self someObject.
	[0 == anObj] whileFalse: [
		anObj isInMemory ifTrue: [
			(anObj pointsTo: anObject) ifTrue: [
				"exclude the results collector and contexts in call chain"
				((anObj ~~ results collector) and:
				 [(anObj ~~ objectsToExclude) and:
				 [(anObj ~~ thisContext) and:
				 [(anObj ~~ thisContext sender) and:
				 [anObj ~~ thisContext sender sender]]]])
					 ifTrue: [ results add: anObj ].
			]].
		anObj := anObj nextObject.
	].
	objectsToExclude do: [ :obj | results removeAllSuchThat: [ :el | el == obj]].

	^ results asArray
! !

!PointerFinder class methodsFor: 'utilities' stamp: 'sd 9/24/2004 20:48'!
pointersToItem: index of: anArray
	"Find all occurrences in the system of pointers to the given element of the given array. 
	This is useful for tracing up a pointer chain from an inspector on the results of a previous 	call of pointersTo:. To find out who points to the second element of the results, one would 	evaluate:

		PointerFinder pointersToItem: 2 of: self

	in the inspector."

	^ self pointersTo: (anArray at: index) except: (Array with: anArray)! !

!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ssa 4/19/2010 20:04'!
startUpWithCaption: captionOrNil
	"Display the menu, slightly offset from the cursor,
	so that a slight tweak is required to confirm any action."
	^ self startUpWithCaption: captionOrNil at: Sensor cursorPoint! !

!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ssa 4/19/2010 20:12'!
startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean
	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released,
	Answer the index of the current selection, or zero if the mouse is not released over  any menu item. Location specifies the desired topLeft of the menu body rectangle. The final argument indicates whether the menu should seize the keyboard focus in order to allow the user to navigate it via the keyboard."

	| maxHeight |
	"self terminateRedundantUIProcessIfAny."
	maxHeight _ Display height*3//4.
	self frameHeight > maxHeight ifTrue:
		[^ self
			startUpSegmented: maxHeight
			withCaption: captionOrNil
			at: location
			allowKeyboard: aBoolean].



	frame ifNil: [self computeForm].
	Cursor normal showWhile:
		[self
			displayAt: location
			withCaption: captionOrNil
			during: [self controlActivity]].
	^ selection! !

!PopUpMenu methodsFor: '*RVM' stamp: 'ssa 3/1/2010 13:43'!
lastStartupTime
	^ LastStartupTime ifNil: [LastStartupTime _ 0] ifNotNil: [LastStartupTime] ! !

!PopUpMenu methodsFor: '*RVM' stamp: 'ssa 3/1/2010 13:43'!
lastStartupTime: t
	LastStartupTime _ t ! !

!PopUpMenu methodsFor: '*RVM' stamp: 'ads 1/30/2011 15:20'!
terminateRedundantUIProcessIfAny
	"kill a redundant UI process if there is one; judge by pop-up time"
	"[self halt] fork"
	|now delta |
	now _ Time millisecondClockValue.
	delta _ now - self lastStartupTime.
	(delta   <= (RVMOperations isRVM ifTrue:[100]ifFalse:[^10]) and: [delta > 0]) ifTrue: [" self lastStartupProcess" 
		Transcript resetSemaphore show: 'terminateRedundantUIProcessIfAny zap!!'; cr.
		Processor thisProcess terminate ].
	self lastStartupTime: now! !

!PositionableStream methodsFor: 'fileIn/Out' stamp: 'StefanMarr 7/14/2011 17:11'!
copyPreamble: preamble from: aStream
	"Look for a changeStamp for this method by peeking backward.
	Write a method preamble, with that stamp if found."
	| terminator methodPos p last75 stamp i |
	terminator _ $!!.

	"Look back to find stamp in old preamble, such as...
	Polygon methodsFor: 'private' stamp: 'di 6/25/97 21:42' prior: 34957598!! "
	methodPos _ aStream position.
	aStream position: (p _ 0 max: methodPos-75).
	last75 _ aStream next: methodPos - p.
	stamp _ String new.
	(i _ last75 findString: 'stamp:' startingAt: 1) > 0 ifTrue:
		[stamp _ (last75 copyFrom: i+8 to: last75 size) copyUpTo: $'].

	"Write the new preamble, with old stamp if any."
	self cr; nextPut: terminator.
	self nextChunkPut: (String streamContents:
		[:strm |
		strm nextPutAll: preamble.
		stamp size > 0 ifTrue:
			[strm nextPutAll: ' stamp: '; print: stamp]]).
	self cr! !

!PositionableStream methodsFor: 'printing' stamp: 'ssa 8/19/2009 20:08'!
printOn: aStream

	aStream nextPutAll:'@',self position printString,' in '.
	^super printOn: aStream! !

!PositionableStream methodsFor: '*packageinfo-base' stamp: 'nk 6/17/2003 07:45'!
untilEnd: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor cursorPoint
		from: 0 to: self size
		during:
			[:bar |
			[self atEnd] whileFalse:
				[bar value: self position.
				aBlock value]].! !

!Preferences class methodsFor: 'get/set' stamp: 'ssa 3/24/2010 15:18'!
enable: aSymbol
	"Shorthand access to enabling a preference of the given name.  If there is none in the image, conjure one up"

	| aPreference |
	aPreference _ self preferenceAt: aSymbol ifAbsent:
		[self addPreference: aSymbol category: 'unclassified' default: false balloonHelp: 'this preference was added idiosyncratically and has no help message.'.
		self preferenceAt: aSymbol].
	aPreference preferenceValue: true! !

!Process methodsFor: 'accessing' stamp: 'dmu 3/8/2010 20:26'!
errorHandler
	"Answer the value of errorHandler"

	errorHandler isNil ifTrue:[self errorHandler: nil].
	^ errorHandler! !

!Process methodsFor: 'accessing' stamp: 'dmu 3/8/2010 20:26'!
errorHandler: anObject
	"Set the value of errorHandler"

	errorHandler _ anObject! !

!Process methodsFor: 'accessing' stamp: 'ssa 2/17/2009 22:34'!
isActiveProcess

	^ suspendedContext isNil and:[myList notNil]! !

!Process methodsFor: 'accessing' stamp: 'dmu 3/8/2010 20:26'!
myList
	"Answer the value of myList"

	myList isNil ifTrue:[self myList: nil].
	^ myList! !

!Process methodsFor: 'accessing' stamp: 'dmu 3/8/2010 20:26'!
myList: anObject
	"Set the value of myList"

	myList _ anObject! !

!Process methodsFor: 'changing process state' stamp: 'ads 2/2/2011 14:51'!
primitiveSuspend
	"Primitive. Stop the process that self represents in such a way 
	that it can be restarted at a later time (by sending #resume).
	ASSUMES self is the active process.
	Essential. See Object documentation whatIsAPrimitive."

	"Debugging code below causes terminated running processes to seem not terminated. -- dmu 3/2/10"
	"(myList isNil and: [RVMOperations isRVM]) ifTrue:[self halt]."
	<primitive: 88>
	self primitiveFailed! !

!Process methodsFor: 'changing process state' stamp: 'dmu 3/24/2010 15:44'!
resume
	"Allow the process that the receiver represents to continue. Put  
	the receiver in line to become the activeProcess. Check for a nil 
	suspendedContext, which indicates a previously terminated Process that 
	would cause a vm crash if the resume attempt were permitted"
	self children do: [:c| c resume].
	suspendedContext ifNil: [^ self primitiveFailed].
	^ self primitiveResume! !

!Process methodsFor: 'changing process state' stamp: 'dmu 1/29/2011 21:18'!
suspend
	"Stop the process that the receiver represents in such a way 
	that it can be restarted at a later time (by sending the receiver the 
	message resume). If the receiver represents the activeProcess, suspend it. 
	Otherwise remove the receiver from the list of waiting processes."
	| aCopyOfMyListWhichIsSafeFromRaces |
	self children do: [:c| c suspend].
	self isActiveProcess ifTrue: [
		self nilMyListUnlessRVM.
		self primitiveSuspend.
	] ifFalse: [
		aCopyOfMyListWhichIsSafeFromRaces _ myList.
		aCopyOfMyListWhichIsSafeFromRaces ifNotNil: [
			aCopyOfMyListWhichIsSafeFromRaces remove: self ifAbsent: [].
			myList _ nil].
	]
! !

!Process methodsFor: 'changing process state' stamp: 'dmu 3/24/2010 15:45'!
terminate 
	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."

	| ctxt unwindBlock |
	self children do: [:c| c terminate].
	self == Processor thisProcess  ifTrue: [
		ctxt _ thisContext.
		[	ctxt _ ctxt findNextUnwindContextUpTo: nil.
			ctxt isNil
		] whileFalse: [
			unwindBlock _ ctxt tempAt: 1.
			unwindBlock ifNotNil: [
				ctxt tempAt: 1 put: nil.
				thisContext terminateTo: ctxt.
				unwindBlock value].
		].
		thisContext terminateTo: nil.
		self nilMyListUnlessRVM.
		self primitiveSuspend.
	] ifFalse: [
	        self suspend.
		myList ifNotNil: [
			myList remove: self ifAbsent: [].
			myList _ nil].
		suspendedContext ifNotNil: [
			ctxt _ self popTo: suspendedContext bottomContext.
			ctxt == suspendedContext bottomContext ifFalse: [
				self debug: ctxt title: 'Unwind error during termination']].
	].
! !

!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:05'!
activateReturn: aContext value: value
	"Activate 'aContext return: value', so execution will return to aContext's sender"
	self suspend.
	^ suspendedContext _ suspendedContext activateReturn: aContext value: value! !

!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:01'!
complete: aContext 
	"Run self until aContext is popped or an unhandled error is raised.  Return self's new top context, unless an unhandled error was raised then return the signaler context (rather than open a debugger)."
	
	| ctxt pair error |
	self suspend.
	ctxt _ suspendedContext.
	suspendedContext _ nil.  "disable this process while running its stack in active process below"
	pair _ ctxt runUntilErrorOrReturnFrom: aContext.
	suspendedContext _ pair first.
	error _ pair second.
	error ifNotNil: [^ error signalerContext].
	^ suspendedContext! !

!Process methodsFor: 'changing suspended state' stamp: 'dmu 11/25/2008 00:21'!
popTo: aContext 
	"Pop self down to aContext by remote returning from aContext's callee.  Unwind blocks will be executed on the way.
	This is done by pushing a new context on top which executes 'aContext callee return' then resuming self until aContext is reached.  This way any errors raised in an unwind block will get handled by senders in self and not by senders in the activeProcess.
	If an unwind block raises an error that is not handled then the popping stops at the error and the signalling context is returned, othewise aContext is returned."

	| callee |
	(Processor isActive: self)
		ifTrue: [^ self error: 'The active process cannot pop contexts'].
	callee _ (self calleeOf: aContext) ifNil: [^ aContext].  "aContext is on top"
	^ self return: callee value: callee receiver! !

!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:04'!
return: aContext value: value
	"Pop thread down to aContext's sender.  Execute any unwind blocks on the way.  See #popTo: comment and #runUntilErrorOrReturnFrom: for more details."
        self suspend.
	suspendedContext == aContext ifTrue: [
		^ suspendedContext _ aContext return: value from: aContext].
	self activateReturn: aContext value: value.
	^ self complete: aContext.
! !

!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:03'!
step
         self suspend.
	^ suspendedContext _ suspendedContext step! !

!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:04'!
stepToCallee
	"Step until top context changes"

	| ctxt |
	self suspend.
	ctxt _ suspendedContext.
	[ctxt == suspendedContext] whileTrue: [
		suspendedContext _ suspendedContext step].
	^ suspendedContext! !

!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:05'!
stepToSendOrReturn
self suspend.
	^ suspendedContext _ suspendedContext stepToSendOrReturn! !

!Process methodsFor: 'debugging' stamp: 'dmu 9/17/2010 12:03'!
debug: context title: title full: bool
	"Open debugger on self with context shown on top"

	| topCtxt |
	topCtxt _ self == Processor thisProcess ifTrue: [thisContext] 
		ifFalse: [
			self suspend.  
			self suspendedContextWaitingIfNecessary].
	(topCtxt hasContext: context) ifFalse: [^ self error: 'context not in process'].
	Transcript cr; show: 'Suspending siblings & progeny'.
	self class semaForSupensions critical:[ self siblings size print.
		self siblingsAndTheirDescendantsDo: [:proc|
			proc == Processor thisProcess ifFalse: [Transcript cr;show:'suspending proc ',proc identityHash printString.
				proc suspend]].
		].
		Transcript cr; show: 'launching debugger'.
	Debugger openOn: self context: context label: title contents: nil fullView: bool.
! !

!Process methodsFor: 'debugging' stamp: 'dmu 9/17/2010 12:03'!
debugWithTitle: title
	"Open debugger on self"

	| context |
	context _ self == Processor thisProcess ifTrue: [thisContext] ifFalse: [ self suspend.  self suspendedContextWaitingIfNecessary].
	self debug: context title: title full: true.
! !

!Process methodsFor: 'printing' stamp: 'ads 1/24/2011 13:03'!
longPrintOn: stream

	| ctxt |
stream nextPutAll: (RVMPrimitivesNeededForBootstrapping printPrefixFor: self).
	super printOn: stream.
	stream cr.
	ctxt _ self suspendedContext.
	[ctxt == nil] whileFalse: [
		stream space.
		ctxt printOn: stream.
		stream cr.
		ctxt _ ctxt sender.
	].
! !

!Process methodsFor: 'signaling' stamp: 'ssa 2/17/2009 22:31'!
pvtSignal: anException list: aList
	"Private. This method is used to signal an exception from another
	process...the receiver must be the active process.  If the receiver 
	was previously waiting on a Semaphore, then return the process
	to the waiting state after signaling the exception and if the Semaphore
	has not been signaled in the interim"

	"Since this method is not called in a normal way, we need to take care
	that it doesn't directly return to the caller (because I believe that could
	have the potential to push an unwanted object on the caller's stack)."

	| blocker |
	self == Processor thisProcess ifFalse: [^self].
	self suspend.
	anException signal.
	blocker := Semaphore new.
	[self suspend.
	suspendedContext := suspendedContext swapSender: nil.
	aList class == Semaphore 
		ifTrue:
			[aList isSignaled
				ifTrue: 
					[aList wait.  "Consume the signal that would have restarted the receiver"
					self resume]
				ifFalse:
					["Add us back to the Semaphore's list (and remain blocked)"
					myList := aList.
					aList add: self]]
		ifFalse: [self resume]] fork.
	blocker wait.


! !

!Process methodsFor: 'signaling' stamp: 'ssa 2/17/2009 22:30'!
signal: anException
	"Signal an exception in the receiver process...if the receiver is currently
	suspended, the exception will get signaled when the receiver is resumed.  If 
	the receiver is blocked on a Semaphore, it will be immediately re-awakened
	and the exception will be signaled; if the exception is resumed, then the receiver
	will return to a blocked state unless the blocking Semaphore has excess signals"

	"If we are the active process, go ahead and signal the exception"
	self == Processor thisProcess ifTrue: [^anException signal].

        self suspend.

	"Add a new method context to the stack that will signal the exception"
	suspendedContext := MethodContext
		sender: suspendedContext
		receiver: self
		method: (self class methodDict at: #pvtSignal:list:)
		arguments: (Array with: anException with: myList).

	"If we are on a list to run, then suspend and restart the receiver 
	(this lets the receiver run if it is currently blocked on a semaphore).  If
	we are not on a list to be run (i.e. this process is suspended), then when the
	process is resumed, it will signal the exception"

	myList ifNotNil: [self suspend; resume].! !

!Process methodsFor: '*RVMBootstrap' stamp: 'dmu 5/9/2009 23:08'!
isRunning
	Processor thisProcess == self ifTrue: [^ true].
	self isActiveProcess ifTrue: [^ true].
	myList ifNil: [^ false].
	^ myList class ~~ Semaphore! !

!Process methodsFor: '*RVMBootstrap' stamp: 'ssa 3/2/2010 18:23'!
nilMyListUnlessRVM
	Processor areRunningProcessesInSchedulerLists ifFalse: [
		"primitiveSuspend will use myList to remove from list and will nil it out"
		myList _ nil.
	]! !

!Process methodsFor: '*RVMBootstrap' stamp: 'dmu 9/17/2010 11:59'!
suspendedContextWaitingIfNecessary
	"In RVM, can suspend some other running process, and so after sending suspend, suspendedContext may still be nil."
	
	[self suspendedContext isNil] whileTrue.
	^ self suspendedContext! !

!Process methodsFor: '*Ly' stamp: 'dmu 9/3/2010 16:30'!
lyDebuggingBlock
	"Answer the value of lyDebuggingBlock"

	lyDebuggingBlock isNil ifTrue:[self lyDebuggingBlock: nil].
	^ lyDebuggingBlock! !

!Process methodsFor: '*Ly' stamp: 'dmu 9/3/2010 16:30'!
lyDebuggingBlock: anObject
	"Set the value of lyDebuggingBlock"

	lyDebuggingBlock _ anObject! !

!Process methodsFor: '*Ly' stamp: 'dmu 3/9/2010 14:59'!
stopIfDebugging: whatIAmAboutToDo
	| |
	self lyDebuggingBlock ifNil: [^ self].
	self lyDebuggingBlock value: whatIAmAboutToDo! !

!Process methodsFor: '*RVM' stamp: 'ssa 2/26/2009 02:57'!
avoidCore: anIndex
	"Force this process to avoid this core (0-55)"
	self coreMask: (self coreMask bitClear: (1 bitShift: anIndex))! !

!Process methodsFor: '*RVM' stamp: 'ssa 2/26/2009 03:49'!
avoidCores: aCollectionOfIndicies
	"Force this process to avoid these cores (0-55)"
	| mask |
	mask _ 0.
	aCollectionOfIndicies do:[:index| mask _ mask bitOr: (1 bitShift: index)].
	self coreMask: (self coreMask bitClear:mask)! !

!Process methodsFor: '*RVM' stamp: 'dmu 2/12/2009 23:15'!
coreMask ^ coreMask! !

!Process methodsFor: '*RVM' stamp: 'dmu 2/12/2009 23:15'!
coreMask: m coreMask _ m! !

!Process methodsFor: '*RVM' stamp: 'dmu 2/12/2009 23:14'!
hostCore ^ hostCore! !

!Process methodsFor: '*RVM' stamp: 'dmu 3/8/2010 20:26'!
hostCore: anObject
	"Set the value of hostCore"

	hostCore _ anObject! !

!Process methodsFor: '*RVM' stamp: 'dmu 4/7/2009 02:41'!
resumeOn: aCore
  self useOnlyCore: aCore.
  self resume! !

!Process methodsFor: '*RVM' stamp: 'ssa 2/26/2009 02:59'!
useAdditionalCore: anIndex
	"Force this process to only urn on this core (0-55)"
	self coreMask: (self coreMask bitOr:(1 bitShift: anIndex))! !

!Process methodsFor: '*RVM' stamp: 'ssa 2/26/2009 03:50'!
useAdditionalCores: aCollectionOfIndicies
	"Allow this process to run on these additional cores (0-55)"
	| mask |
	mask _ 0.
	aCollectionOfIndicies do:[:index| mask _ mask bitOr: (1 bitShift: index)].
	self coreMask: (self coreMask bitOr:mask)! !

!Process methodsFor: '*RVM' stamp: 'dmu 5/5/2009 01:32'!
useOnlyCore: anIndex
	"Force this process to only run on this core (0-55)"
	self coreMask: (1 bitShift: anIndex)! !

!Process methodsFor: '*RVM' stamp: 'ssa 2/26/2009 03:02'!
useOnlyCores: aCollectionOfIndicies
	"Force this process to only run on these cores (0-55)"
	| mask |
	mask _ 0.
	aCollectionOfIndicies do:[:index| mask _ mask bitOr: (1 bitShift: index)].
	self coreMask: mask! !

!Process methodsFor: '*RVM' stamp: 'ads 1/30/2011 15:21'!
useOnlyMainCore
	RVMOperations isRVM ifTrue: [self useOnlyCore: (RVMMonitor getSample; mainRank)]! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 3/24/2010 14:44'!
addChild: aProcess
	self children add: aProcess.
	aProcess parent: self.! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 9/17/2010 11:12'!
beSlyMemberProcess
	self priority: Processor userBackgroundPriority.
	Processor thisProcess addChild: self.
	^ self! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 3/24/2010 14:42'!
children
	"Answer the value of children"

	children isNil ifTrue:[self children: WeakSet new].
	^ children! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 3/24/2010 14:38'!
children: anObject
	"Set the value of children"

	children _ anObject! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 3/25/2010 23:56'!
creatorEnsemble
	"Answer the value of creatorEnsemble"

	creatorEnsemble isNil ifTrue:[self creatorEnsemble: nil].
	^ creatorEnsemble! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 3/25/2010 23:56'!
creatorEnsemble: anObject
	"Set the value of creatorEnsemble"

	creatorEnsemble _ anObject! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 3/25/2010 10:30'!
descendantsDo: blk
	self children do: [:p | blk value: p. p descendantsDo: blk]! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 3/26/2010 12:26'!
myGeneration
	^ self parent ifNil: [{self}] ifNotNil: [self parent children]! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 3/25/2010 10:34'!
myGenerationAndTheirDescendantsDo: blk
	self myGeneration do: [:p | blk value: p. p descendantsDo: blk]! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 3/24/2010 14:38'!
parent
	"Answer the value of parent"

	parent isNil ifTrue:[self parent: nil].
	^ parent! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 3/24/2010 14:38'!
parent: anObject
	"Set the value of parent"

	parent _ anObject! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 3/25/2010 10:34'!
siblings
	^ self myGeneration copyWithout: self! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 3/25/2010 10:32'!
siblingsAndTheirDescendantsDo: blk
	self siblings do: [:p | blk value: p. p descendantsDo: blk]! !

!Process methodsFor: '*SlyBootstrap' stamp: 'dmu 9/17/2010 11:57'!
synchronousSuspend
	"In RVM, can suspend some other running process, and so after sending suspend, suspendedContext may still be nil."
	"Send suspend and don't return till the process is really suspended"
	self suspend.
	[self suspendedContext isNil] whileTrue.! !

!Process class methodsFor: 'instance creation' stamp: 'dmu 3/24/2010 15:46'!
forContext: aContext priority: anInteger 
	"Answer an instance of me that has suspended aContext at priority 
	anInteger."

	| newProcess |
	newProcess _ self new.
	newProcess suspendedContext: aContext.
	newProcess priority: anInteger.
	[newProcess coreMask:(1 bitShift: 27)].
	^newProcess! !

!Process class methodsFor: '*RVM' stamp: 'ssa 2/26/2009 02:45'!
forContext: aContext priority: anInteger coreMask: anIntegerMask
	"Answer an instance of me that has suspended aContext at priority 
	anInteger using this coreMask."

	| newProcess |
	newProcess _ self forContext: aContext priority: anInteger.
	newProcess coreMask:anIntegerMask.
	^newProcess! !

!Process class methodsFor: '*RVMBootstrap' stamp: 'ssa 3/25/2010 15:11'!
semaForSupensions

	SemaForSupensions isNil ifTrue:[SemaForSupensions _ Semaphore forMutualExclusion].
	^SemaForSupensions! !

!Process class methodsFor: 'testing-workaround-warning' stamp: 'sm 4/21/2011 23:43'!
shouldNotBeRedefined
	^ false! !

!ProcessBrowser methodsFor: 'stack list' stamp: 'dmu 11/25/2008 00:22'!
updateStackList: depth 
	| suspendedContext oldHighlight |
	selectedProcess
		ifNil: [^ self changeStackListTo: nil].
	(stackList notNil and: [ stackListIndex > 0 ])
		ifTrue: [oldHighlight _ stackList at: stackListIndex].
	(Processor isActive: selectedProcess)
		ifTrue: [self
				changeStackListTo: (thisContext stackOfSize: depth)]
		ifFalse: [suspendedContext _ selectedProcess suspendedContext.
			suspendedContext
				ifNil: [self changeStackListTo: nil]
				ifNotNil: [self
						changeStackListTo: (suspendedContext stackOfSize: depth)]].
	self
		stackListIndex: (stackList
				ifNil: [0]
				ifNotNil: [stackList indexOf: oldHighlight])! !

!ProcessBrowser class methodsFor: 'process control' stamp: 'ssa 9/3/2008 11:08'!
isUIProcess: aProcess
	^aProcess == ScheduledControllers activeControllerProcess ! !

!ProcessBrowser class methodsFor: 'process control' stamp: 'ssa 6/11/2010 14:35'!
nameAndRulesFor: aProcess 
	"Answer a nickname and two flags: allow-stop, and allow-debug"
	^ [aProcess caseOf: {
		[ProcessorScheduler emergencyProcess] -> [{'emergency evaluator ShftCtrl-A'. false. true}].
		[] -> [{'no process'. false. false}].
		[Smalltalk lowSpaceWatcherProcess] -> [{'the low space watcher'. false. false}].
		[WeakArray runningFinalizationProcess] -> [{'the WeakArray finalization process'. false. false}].
		[Processor thisProcess] -> [{'the UI process'. false. true}].
		[Processor backgroundProcess] -> [{'the idle process'. false. false}].
		[Sensor interruptWatcherProcess] -> [{'the user interrupt watcher'. false. false}].
		[Sensor eventTicklerProcess] -> [{'the event tickler'. false. false}].
		[Project uiProcess] -> [{'the inactive Morphic UI process'. false. false}].
		[Smalltalk
			at: #SoundPlayer
			ifPresent: [:sp | sp playerProcess]] -> [{'the Sound Player'. false. false}].
		[ScheduledControllers
			ifNotNil: [ScheduledControllers activeControllerProcess]] -> [{'the inactive MVC controller process'. false. true}].
		[Smalltalk
			at: #CPUWatcher
			ifPresent: [:cw | cw currentWatcherProcess]] -> [{'the CPUWatcher'. false. false}]}
		 otherwise: 
			[(aProcess priority = Processor timingPriority
					and: [aProcess suspendedContext receiver == Delay])
				ifTrue: [{'the timer interrupt watcher'. false. false}]
				ifFalse: [{aProcess suspendedContext asString. true. true}]]]
		ifError: [:err :rcvr | {aProcess suspendedContext asString. true. true}]! !

!ProcessorScheduler methodsFor: 'accessing' stamp: 'dmu 11/25/2008 00:23'!
activePriority
	"Answer the priority level of the currently running Process."

	^self thisProcess priority! !

!ProcessorScheduler methodsFor: 'process state change' stamp: 'dmu 11/25/2008 00:23'!
terminateActive
	"Terminate the process that is currently running."

	self thisProcess terminate! !

!ProcessorScheduler methodsFor: 'removing' stamp: 'ssa 6/11/2010 14:37'!
removeAllPossible
	"Terminate and remove all processes that you can.
	This should leave the standard set only"
	self terminatableProcesses print do:[:proc| proc terminate]! !

!ProcessorScheduler methodsFor: 'removing' stamp: 'ssa 6/11/2010 14:31'!
terminatableProcesses
	"Answer all current processes that may be user terminated like in the ProcessBrowser"
	"self terminatableProcesses"
	| processList |
	Smalltalk garbageCollectMost. "lose defunct processes"

	processList _ Process allSubInstances
				reject: [:each | each isTerminated].
	processList _ processList
				sortBy: [:a :b | a priority >= b priority].
	processList _ WeakArray withAll: processList.
	^processList select:[:proc| (ProcessBrowser nameAndRulesFor: proc) at: 2]! !

!ProcessorScheduler methodsFor: '*RVMBootstrap' stamp: 'ads 1/24/2011 13:01'!
areRunningProcessesInSchedulerLists
	"Our RVM follows Pallas' MS system and keeps runnable processes in the scheduler lists even when running."
	^RVMPrimitivesNeededForBootstrapping isRVM! !

!ProcessorScheduler methodsFor: '*RVMBootstrap' stamp: 'dmu 11/25/2008 00:26'!
isActive: aProcess
^ aProcess suspendedContext ==  nil! !

!ProcessorScheduler methodsFor: '*RVMBootstrap' stamp: 'dmu 12/7/2008 20:43'!
thisProcess
<primitive: 'primitiveThisProcess' > "must not specify module in order to hit obsolete_named_primitive_table and thus be local"
 ^ self activeProcess! !

!ProcessorScheduler methodsFor: '*Sly3Bootstrap' stamp: 'dmu 9/17/2010 12:18'!
debugMemberProcesses
	self suspendMemberProcesses.
	self memberProcesses do: [:p| p  debug]! !

!ProcessorScheduler methodsFor: '*Sly3Bootstrap' stamp: 'dmu 9/17/2010 11:16'!
memberProcesses
	^Process allInstances select: [:proc | proc creatorEnsemble notNil]! !

!ProcessorScheduler methodsFor: '*Sly3Bootstrap' stamp: 'dmu 2/23/2011 18:05'!
suspendMemberProcesses
	self memberProcesses do: [:p| p ~= self thisProcess ifTrue: [p suspend]]! !

!ProcessorScheduler methodsFor: '*Sly3Bootstrap' stamp: 'dmu 9/17/2010 11:17'!
terminateMemberProcesses
	self memberProcesses do: [:p| p terminate]! !

!ProcessorScheduler methodsFor: '*Sly3Bootstrap' stamp: 'dmu 9/17/2010 11:02'!
userBackgroundPriority
	^ UserBackgroundPriority! !

!ProcessorScheduler methodsFor: '*RVM' stamp: 'ads 1/30/2011 15:21'!
yieldIfFewerCoresThan: n
	RVMOperations coreCount < n    ifTrue: [self yield]! !

!ProcessorScheduler class methodsFor: 'background process' stamp: 'sm 2/24/2011 16:42'!
startUp
	"Install a background process of the lowest possible priority that is always runnable."
	"Details: The virtual machine requires that there is aways some runnable process that can be scheduled; this background process ensures that this is the case."

	Smalltalk installLowSpaceWatcher.
	BackgroundProcess == nil ifFalse: [BackgroundProcess terminate].
	BackgroundProcess _ [self idleProcess] newProcess.
	[BackgroundProcess useOnlyCore: (RVMMonitor getSample; mainRank).].
	BackgroundProcess priority: SystemRockBottomPriority.
	BackgroundProcess name: 'IdleProcess'.
	BackgroundProcess resume.
	self startEmergencyProcess
! !

!ProcessorScheduler class methodsFor: '*RVMBootstrap' stamp: 'ssa 6/11/2010 14:34'!
emergencyProcess
	^ EmergencyProcess! !

!ProcessorScheduler class methodsFor: '*RVMBootstrap' stamp: 'ads 1/24/2011 13:04'!
startEmergencyProcess
	"Bring up an emergency evaluator if the user hits control-shift-a"
	"self startEmergencyProcess"
	"self startEmergencyProcess. RVMPrimitivesNeededForBootstrapping getEmergencySemaphore signal"
	| sema |
	sema _ Semaphore new.
	RVMPrimitivesNeededForBootstrapping setEmergencySemaphore: sema.
	EmergencyProcess ifNotNil: [EmergencyProcess terminate].
	^ EmergencyProcess _ [[sema wait. Transcripter emergencyEvaluator] repeat] forkAt: Processor userInterruptPriority! !

!Project methodsFor: 'initialization' stamp: 'ssa 1/22/2010 14:06'!
backgroundColorForMvcProject
	^ Color r: 1.0 g: 1.0 b: 0.65! !

!Project methodsFor: 'initialization' stamp: 'ssa 9/3/2008 11:08'!
defaultBackgroundColor
	^ self isMorphic
		ifTrue: []
		ifFalse: [self backgroundColorForMvcProject]! !

!Project methodsFor: 'accessing' stamp: 'ssa 9/3/2008 11:21'!
renameTo: newName
	| |
	newName = self name
		ifFalse: [
			version _ nil.
			self changeSet name: newName.
			].! !

!Project methodsFor: 'menu messages' stamp: 'ssa 9/3/2008 11:09'!
enter: returningFlag revert: revertFlag saveForRevert: saveForRevert 
	"Install my ChangeSet, Transcript, and scheduled views as current 
	globals. If returningFlag is true, we will return to the project from 
	whence the current project was entered; don't change its 
	previousProject link in this case. 
	If saveForRevert is true, save the ImageSegment of the project being 
	left. If revertFlag is true, make stubs for the world of the project being 
	left. If revertWithoutAsking is true in the project being left, then 
	always revert."
	| showZoom old forceRevert response seg newProcess |
	self isCurrentProject
		ifTrue: [^ self].
	"Check the guards"
	guards
		ifNotNil: [guards := guards
						reject: [:obj | obj isNil].
			guards
				do: [:obj | obj okayToEnterProject
						ifFalse: [^ self]]].
	CurrentProject world triggerEvent: #aboutToLeaveWorld.
	forceRevert := false.
	CurrentProject rawParameters
		ifNil: [revertFlag
				ifTrue: [^ self inform: 'nothing to revert to']]
		ifNotNil: [saveForRevert
				ifFalse: [forceRevert := CurrentProject projectParameters
								at: #revertWithoutAsking
								ifAbsent: [false]]].
	forceRevert not & revertFlag
		ifTrue: [response := SelectionMenu
						confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs
						trueChoice: 'Revert to saved version'
						falseChoice: 'Cancel'.
			response
				ifFalse: [^ self]].
	revertFlag | forceRevert
		ifTrue: [seg := CurrentProject projectParameters
						at: #revertToMe
						ifAbsent: [^ self inform: 'nothing to revert to']]
		ifFalse: [CurrentProject finalExitActions.
			CurrentProject makeThumbnail.
			returningFlag == #specialReturn
				ifTrue: [ProjectHistory forget: CurrentProject.
					"this guy is irrelevant"
					Project forget: CurrentProject]
				ifFalse: [ProjectHistory remember: CurrentProject]].
	revertFlag | saveForRevert | forceRevert
		ifFalse: [(Preferences valueOfFlag: #projectsSentToDisk)
				ifTrue: [self storeToMakeRoom]].
	CurrentProject abortResourceLoading.
	CurrentProject saveProjectPreferences.
	"Update the display depth and make a thumbnail of the current project"
	CurrentProject displayDepth: Display depth.
	old := CurrentProject.
	"for later"
	"Show the project transition. 
	Note: The project zoom is run in the context of the old project, 
	so that eventual errors can be handled accordingly"
	displayDepth == nil
		ifTrue: [displayDepth := Display depth].
	self installNewDisplay: Display extent depth: displayDepth.
	(showZoom := self showZoom)
		ifTrue: [self displayZoom: CurrentProject parent ~~ self].
	(world isMorph
			and: [world hasProperty: #letTheMusicPlay])
		ifTrue: [world removeProperty: #letTheMusicPlay]
		ifFalse: [Smalltalk
				at: #ScorePlayer
				ifPresentAndInMemory: [:playerClass | playerClass
						allSubInstancesDo: [:player | player pause]]].
	returningFlag == #specialReturn
		ifTrue: [old removeChangeSetIfPossible.
			"keep this stuff from accumulating"
			nextProject := nil]
		ifFalse: [returningFlag
				ifTrue: [nextProject := CurrentProject]
				ifFalse: [previousProject := CurrentProject]].
	CurrentProject saveState.
	CurrentProject isolationHead == self isolationHead
		ifFalse: [self invokeFrom: CurrentProject].
	CurrentProject := self.
	self installProjectPreferences.
	ChangeSet newChanges: changeSet.
	TranscriptStream newTranscript: transcript.
	Sensor flushKeyboard.
	ProjectHistory remember: CurrentProject.
	world isMorph
		ifTrue: []
		ifFalse: [World := nil.
			"Signifies MVC"
			Smalltalk at: #ScheduledControllers put: world].
	saveForRevert
		ifTrue: [Smalltalk garbageCollect.
			"let go of pointers"
			old storeSegment.
			"result _"
			old world isInMemory
				ifTrue: ['Can''t seem to write the project.']
				ifFalse: [old projectParameters at: #revertToMe put: old world xxxSegment clone].
			'Project written.'].
	"original is for coming back in and continuing."
	revertFlag | forceRevert
		ifTrue: [seg clone revert].
	"non-cloned one is for reverting again later"
	self removeParameter: #exportState.
	"Complete the enter: by launching a new process"
	world isMorph
		ifFalse: [newProcess := [ScheduledControllers resetActiveController.
					"in case of walkback in #restore"
					showZoom
						ifFalse: [ScheduledControllers restore].
					ScheduledControllers searchForActiveController] fixTemps newProcess priority: Processor userSchedulingPriority.
			newProcess resume.
			"lose the current process and its referenced morphs"
			Processor terminateActive]! !

!Project methodsFor: 'menu messages' stamp: 'dmu 11/25/2008 00:23'!
enterForEmergencyRecovery
	"This version of enter invokes an absolute minimum of mechanism.
	An unrecoverable error has been detected in an isolated project.
	It is assumed that the old changeSet has already been revoked.
	No new process gets spawned here.  This will happen in the debugger."

	self isCurrentProject ifTrue: [^ self].
	CurrentProject saveState.
	CurrentProject _ self.
	Display newDepthNoRestore: displayDepth.
	Smalltalk newChanges: changeSet.
	TranscriptStream newTranscript: transcript.


	world isMorph
		ifTrue:
			["Entering a Morphic project"
			World _ world.
			world install.
			world triggerOpeningScripts]
		ifFalse:
			["Entering an MVC project"
			World _ nil.
			Smalltalk at: #ScheduledControllers put: world.
			ScheduledControllers restore].
	UIProcess _ Processor thisProcess.
! !

!Project methodsFor: 'release' stamp: 'ssa 9/3/2008 11:09'!
okToChange
	"Answer whether the window in which the project is housed can be dismissed -- which is destructive. We never clobber a project without confirmation"

	| ok |
	self subProjects size  >0 ifTrue:
		[self inform: 
'The project ', self name printString, '
contains sub-projects.  You must remove these
explicitly before removing their parent.'.
		^ false].
	ok _ world isMorph not and: [world scheduledControllers size <= 1].
	ok ifFalse: [self isMorphic ifTrue:
		[]].  "view from elsewhere.  just delete it."
	ok _ (self confirm:
'Really delete the project
', self name printString, '
and all its windows?').
		
	ok ifFalse: [^ false].



	self removeChangeSetIfPossible.
	"do this last since it will render project inaccessible to #allProjects and their ilk"
	ProjectHistory forget: self.
	Project deletingProject: self.
	^ true
! !

!Project class methodsFor: 'utilities' stamp: 'ssa 9/3/2008 11:11'!
addItem: item toMenu: menu selection: action project: aProject
	menu add: item action: action! !

!Project class methodsFor: 'utilities' stamp: 'dmu 11/25/2008 00:24'!
spawnNewProcessAndTerminateOld: terminate

	self spawnNewProcess.
	terminate
		ifTrue: [Processor terminateActive]
		ifFalse: [Processor thisProcess suspend]! !

!ProjectTeam methodsFor: 'searching' stamp: 'ads 12/6/2010 14:26'!
findMethodsWrittenByThisTeamButNotIncludedInPackage: p
	| result systemCats |
	"Convenient for finding methods that don't follow the PackageInfo category-naming scheme."
	result := OrderedCollection new.
	systemCats := p systemCategories.
	((Smalltalk allClasses reject: [:cls | systemCats includes: cls category]) gather: [:cls| {cls. cls class}]) do: [:cls |
		cls organization allMethodSelectors do: [:sel | | mr crs |
			mr := MethodReference new setStandardClass: cls methodSymbol: sel.
			crs := mr changeRecords.
			crs isEmpty ifFalse: [
				(self didProjectMemberCreateChangeRecord: crs first) ifTrue: [
					(p isYourClassExtension: mr category) ifFalse: [
						result add: mr.
					].
				].
			].
		].
	].
	^ result
! !

!ProjectTeam methodsFor: 'timestamps' stamp: 'ads 12/13/2010 19:15'!
timestampFilter
	^ timestampFilter! !

!ProjectTeam methodsFor: 'timestamps' stamp: 'ads 12/13/2010 19:15'!
timestampFilter: aBlock
	timestampFilter := aBlock.! !

!ProjectTeam methodsFor: 'members' stamp: 'ads 12/2/2010 14:59'!
initialsOfNonProjectMembers
	"Just convenient for making sure I haven't left anybody off of the list."
	^ (self packages gather: [:p |
		p extensionMethods gather: [:m | | v |
			v := self oldVersionOf: m.
			v ifNil: [{}]
			ifNotNil: [| tokens |
				tokens := v stamp findTokens: Character separators.
				tokens isEmpty ifTrue: [{}] ifFalse: [{tokens at: 1}]]].
	]) asSet asSortedCollection! !

!ProjectTeam methodsFor: 'members' stamp: 'ads 12/2/2010 14:59'!
initialsOfProjectMembers
	^ initialsOfProjectMembers! !

!ProjectTeam methodsFor: 'members' stamp: 'ads 12/2/2010 14:59'!
initialsOfProjectMembers: aCollectionOfInitials
	initialsOfProjectMembers := aCollectionOfInitials.! !

!ProjectTeam methodsFor: 'versions' stamp: 'ads 12/7/2010 14:22'!
aboutToModifyClass: cls
	"Called from the removal script to help debug problems."
	Transcript show: 'About to modify class: ', cls name; cr.! !

!ProjectTeam methodsFor: 'versions' stamp: 'ads 12/13/2010 19:22'!
didProjectMemberCreateChangeRecord: cr
	| stamp |
	stamp := cr stamp ifNil: [^ false].
	"Not really sure whether it's better to use the timestampFilter or initialsOfProjectMembers. For now let's try the timestampFilter, if present. -- Adam"
	^ timestampFilter
		ifNil: [self initialsOfProjectMembers anySatisfy: [:initials | stamp beginsWith: initials]]
		ifNotNil: [timestampFilter value: cr timeStamp]! !

!ProjectTeam methodsFor: 'versions' stamp: 'ads 12/2/2010 15:33'!
oldVersionOf: aMethodReference
	^ aMethodReference changeRecords detect: [:cr | (self didProjectMemberCreateChangeRecord: cr) not] ifNone: [nil]! !

!ProjectTeam methodsFor: 'versions' stamp: 'ads 1/26/2011 16:16'!
revertPackage: p
	p revertToVersionBeforeTeam: self.! !

!ProjectTeam methodsFor: 'versions' stamp: 'ads 12/5/2010 22:49'!
revertToOldVersionOf: aMethodReference ifNone: noneBlk
	| v |
	v := self oldVersionOf: aMethodReference.
	^ v ifNil: noneBlk ifNotNil: [v fileIn].! !

!ProjectTeam methodsFor: 'versions' stamp: 'ads 12/10/2010 10:13'!
revertToOldVersionOrRemove: aMethodReference
	Transcript show: 'Reverting or removing ', aMethodReference printString; cr.
	^ self revertToOldVersionOf: aMethodReference ifNone: [aMethodReference removeFromSystem]! !

!PrototypeTester methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!
prototype
	"Get a prototype"
	^ prototype copy ! !

!PrototypeTester methodsFor: 'as yet unclassified'!
prototype: aPrototype 
	"Set my prototype"
	prototype := aPrototype copy ! !

!PrototypeTester methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:57'!
result
	"Perform the test the default number of times"
	^ self resultFor: self class defaultRuns ! !

!PrototypeTester commentStamp: 'mjr 8/20/2003 13:09' prior: 0!
I am a simple holder of a prototype object and hand out copies when requested.!
!PrototypeTester class methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 13:08'!
defaultRuns
"the default number of times to test"
	^ 50! !

!PrototypeTester class methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 13:08'!
with: aPrototype
	^self new prototype:aPrototype! !

!Quadrangle methodsFor: 'bordering'!
borderWidthLeft: anInteger1 right: anInteger2 top: anInteger3 bottom: anInteger4
	"Set the border width of the receiver to a Rectangle that represents the 
	left, right, top, and bottom border widths."

	borderWidth _ anInteger1 @ anInteger3 corner: anInteger2 @ anInteger4! !

!RVMAbsScanningStripChartView methodsFor: 'displaying' stamp: 'ssa 10/28/2008 20:29'!
drawOnCanvas
	| color |
	1 to: self count do: [:index | 
			color := self colors at: ((self scaler scale:(self data at: index))  min:  self numberOfColors max:1).
			self scanner
				fill: (self boxes at: index)
				fillColor: color].
	self scanner displayOn: self canvas at: self nextScannerLocation @ 0.
! !

!RVMAbsScanningStripChartView methodsFor: 'displaying' stamp: 'ssa 10/28/2008 20:41'!
redrawOnCanvas
	| color |
	self canvas fillWhite.
	self resetScannerLocation.
	self previousData do:[:oldData|
	1 to: self count do: [:index | 
			color := self colors at: ((self scaler scale:(oldData at: index))  min:  self numberOfColors max:1).
			self scanner
				fill: (self boxes at: index)
				fillColor: color].
	self scanner displayOn: self canvas at: self nextScannerLocation @ 0]! !

!RVMAbsScanningStripChartView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 20:23'!
aspect: aSymbol.
	self scaler: nil.
	super aspect: aSymbol! !

!RVMAbsScanningStripChartView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 20:26'!
scaler
	"Answer the value of scaler"

	scaler isNil ifTrue:[self scaler: (RVMMonitor scalerFor: self aspect)].
	^scaler! !

!RVMAbsScanningStripChartView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 20:23'!
scaler: anObject
	"Set the value of scaler"

	scaler _ anObject! !

!RVMAbsScanningStripChartView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 20:49'!
typeLabel

	^'AbsScan: '! !

!RVMAbsScanningStripChartView methodsFor: 'scaling' stamp: 'ssa 10/28/2008 20:47'!
rescale
	"Reset the scaler and pass the previous data thorugh it to find the min/max.
	Then redraw"
	self scaler resetScaling.
	self previousData do:[:dats| dats do:[:d| scaler scale: d]].
	self scaler resetOutOfRangeDetector.
	self topView newFrame.
	self redrawOnCanvas! !

!RVMAbsScanningStripChartView class methodsFor: 'accessing' stamp: 'ssa 11/4/2008 20:19'!
adjustScaler

	^true! !

!RVMAllCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 16:52'!
coreStats
	"Answer the value of coreStats"

	coreStats isNil ifTrue:[self coreStats: OrderedCollection new].
	^coreStats! !

!RVMAllCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 16:52'!
coreStats: anObject
	"Set the value of coreStats"

	coreStats := anObject! !

!RVMAllCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 16:52'!
rawData
	"Answer the value of rawData"

	rawData isNil ifTrue:[self rawData: nil].
	^rawData! !

!RVMAllCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:11'!
rawData: anObject
	"Set the value of rawData"

	rawData := anObject! !

!RVMAllCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 8/19/2008 11:34'!
initializeFastFrom: data forMessageNames: messageNames
	"data is an array of arrays, each element comprising stats from a single core"
	
	self rawData: data.
	data do:[:each| self coreStats add: (RVMCPUCoreStats newFastFromData: each forMessageNames: messageNames)]

! !

!RVMAllCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 1/1/1970 00:05'!
initializeFastestFrom: data forMessageNames: messageNames
	"data is an array of arrays, each element comprising stats from a single core"
	
	self rawData: data.
	data do:[:each| self coreStats add: (RVMCPUCoreStats newFastestFromData: each forMessageNames: messageNames)]

! !

!RVMAllCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 8/13/2008 17:25'!
initializeFrom: data forMessageNames: messageNames
	"data is an array of arrays, each element comprising stats from a single core"
	
	self rawData: data.
	data do:[:each| self coreStats add: (RVMCPUCoreStats newFromData: each forMessageNames: messageNames)]

! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 08:39'!
allocationsSinceLastReadMostlys
	^self coreStats collect:[:each| each allocationsSinceLastReadMostly]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:53'!
allocationsSinceLastReadWrites
	^self coreStats collect:[:each| each allocationsSinceLastReadWrite]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:52'!
allocationsSinceLasts
	^self coreStats collect:[:each| each allocationsSinceLast]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:19'!
bytecodeCounts
	"RVMMulticoreSample capture bytecodeCounts"
	"Answer the collection of bytecode counts during this sample"
	
	^self coreStats collect:[:each| each bytecodesExecuted]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/15/2008 15:37'!
bytecodesPerMillisecond
	"RVMMulticoreSample capture bytecodesPerMillisecond"
	"Answer the collection of ratios of bytecodes executed per millisecond during this sample"
	
	^self coreStats collect:[:each| each bytecodesPerMillisecond]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:24'!
bytecodesPerSecond
	"RVMMulticoreSample capture bytecodesPerSecond"
	"Answer the collection of ratios of bytecodes executed per second during this sample"
	
	^self coreStats collect:[:each| each bytecodesPerSecond]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 08:39'!
bytesLeftReadMostlys
	^self coreStats collect:[:each| each bytesLeftReadMostly]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:50'!
bytesLeftReadWrites
	^self coreStats collect:[:each| each bytesLeftReadWrite]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:49'!
bytesLefts
	^self coreStats collect:[:each| each bytesLeft]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 08:38'!
bytesUsedReadMostlys
	^self coreStats collect:[:each| each bytesUsedReadMostly]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:48'!
bytesUsedReadWrites
	^self coreStats collect:[:each| each bytesUsedReadWrite]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 1/1/1970 00:07'!
bytesUseds
	^self coreStats collect:[:each| each bytesUsed]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 08:39'!
compactionsSinceLastReadMostlys
	^self coreStats collect:[:each| each compactionsSinceLastReadMostly]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:54'!
compactionsSinceLastReadWrites
	^self coreStats collect:[:each| each compactionsSinceLastReadWrite]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:54'!
compactionsSinceLasts
	^self coreStats collect:[:each| each compactionsSinceLast]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:07'!
contextChangeCounts
	"RVMMulticoreSample capture contextChangeCounts"
	"Answer the collection of contextChanges during this sample"
	
	^self coreStats collect:[:each| each contextChangeCount]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:52'!
cyclesRunWaitRatios
	"RVMMulticoreSample capture cyclesRunWaitRatios"
	"Answer the collection of ratios during this sample"
	
	^self coreStats collect:[:each| each cyclesRunWaitRatio]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:48'!
cyclesRunnings
	"RVMMulticoreSample capture cyclesRunnings"
	"Answer the collection of cyclesRunning counts during this sample"
	
	^self coreStats collect:[:each| each cyclesRunning]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/15/2008 15:41'!
cyclesSinceLasts
	"RVMMulticoreSample capture cyclesSinceLasts"
	"Answer the collection of cyclesSinceLasts counts during this sample"
	
	^self coreStats collect:[:each| each cyclesSinceLast]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:48'!
cyclesWaitings
	"RVMMulticoreSample capture cyclesWaitings"
	"Answer the collection of cyclesWaiting counts during this sample"
	
	^self coreStats collect:[:each| each cyclesWaiting]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/5/2011 12:55'!
gcMilliseconds
	^ self coreStats collect: [:cs| cs gcMilliseconds]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:06'!
interruptCheckCounts
	"RVMMulticoreSample capture yieldCounts"
	"Answer the collection of yields during this sample"
	
	^self coreStats collect:[:each| each interruptCheckCount]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:06'!
millisecondsRunnings
	"RVMMulticoreSample capture millisecondsRunnings"
	"Answer the collection of millisecondsRunning counts during this sample"
	
	^self coreStats collect:[:each| each millisecondsRunning]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:37'!
millisecondsWaitings
	"RVMMulticoreSample capture millisecondsWaitings"
	"Answer the collection of millisecondsWaiting counts during this sample"
	
	^self coreStats collect:[:each| each millisecondsWaiting]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:43'!
msRunWaitRatios
	"RVMMulticoreSample capture msRunWaitRatios"
	"Answer the collection of ratios during this sample"
	
	^self coreStats collect:[:each| each msRunWaitRatio]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/15/2008 15:29'!
msSinceLasts
	"RVMMulticoreSample capture msSinceLasts"
	"Answer the collection of msSinceLasts counts during this sample"
	
	^self coreStats collect:[:each| each msSinceLast]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:03'!
receiveTallySum
	| tallies sum s |
	tallies := self coreStats
				collect: [:each | each receiveTally].
	sum := Array new: (tallies at: 1) rawData size.
	1
		to: sum size
		do: [:i | 
			s := 0.
			1
				to: tallies size
				do: [:j | s := s
								+ ((tallies at: j) rawData
										at: i)].
			sum at: i put: s].
	^ sum! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 3/27/2009 16:53'!
sendTallySums
	"Answer an array with the sum of all my send tallies in order from all my coreStats"
	| sums stats |
	sums _ self coreStats first sendTallySums.
	2 to: self coreStats size do:[:index| 
		stats _ self coreStats at: index.
		sums _ sums + stats sendTallySums].
	^sums! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 3/27/2009 16:27'!
sendTallySumsDictionary
	"Answer a dictionary with the sums of all my send tallies from all my coreStats associated with their name"
	| dict keys values |
	dict _ Dictionary new.
	keys _ RVMCoreMessageTally tallyOrder.
	values _ self sendTallySums.
	keys with: values do:[:key :value| dict at: key put: value].
	^dict! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 3/26/2009 09:55'!
sendTallySumsSorted
	"Answer a sorted collection with the sums of all my send tallies from all my coreStats associated with their name"
	^self sendTallySumsDictionary associations asSortedCollection:[:a :b| a value > b value]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 3/27/2009 17:06'!
sendTallySumsSortedReport
	"Answer a string to be used as a report of the sorted send tally sums"
	| report |
	report _ 'Sorted Send Tallies for all cores',String crlf,'--------------------------',String crlf.
	self sendTallySumsSorted do:[:assoc| report _ report, assoc value printString,'  ',assoc key,String crlf].
	^report! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:07'!
unforcedInterruptCheckCounts
	"RVMMulticoreSample capture yieldCounts"
	"Answer the collection of yields during this sample"
	
	^self coreStats collect:[:each| each unforcedInterruptCheckCount]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/14/2008 17:17'!
yieldCounts
	"RVMMulticoreSample capture yieldCounts"
	"Answer the collection of yields during this sample"
	
	^self coreStats collect:[:each| each yieldCount]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:16'!
yieldFrequencies
	"RVMMulticoreSample capture yieldFrequencies"
	
	^self coreStats collect:[:each| each yieldFrequency]! !

!RVMAllCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:37'!
yieldsPerSecond
	"RVMMulticoreSample capture yieldsPerSecond"
	"Answer the collection of ratios of yields  per second during this sample"
	
	^self coreStats collect:[:each| each yieldsPerSecond]! !

!RVMAllCPUCoreStats methodsFor: 'DNU hacks' stamp: 'ssa 3/27/2009 17:26'!
doesNotUnderstand: aMessage
	"Hack DNU to install measurement mesages for tally aspects"
	
	| code tallyAspect |
	(aMessage selector first: 5) = 'sumOf' ifTrue:[
		tallyAspect _ aMessage selector last: aMessage selector - 5.
		tallyAspect at: 1 put: tallyAspect first asLowercase.
	(RVMMulticoreSample coreTallyAspects includes: tallyAspect)
		ifFalse:[^super doesNotUnderstand: aMessage].
	code _ aMessage selector,'
	"Answer the sum for this tally aspect from all cores"
	^self sendTallySumsDictionary at: #',tallyAspect.
	self class compile: code classified: 'tallying' notifying: nil.
	^self perform: aMessage selector].
	^super doesNotUnderstand: aMessage! !

!RVMAllCPUCoreStats class methodsFor: 'instance creation' stamp: 'ssa 8/19/2008 11:33'!
newFastFrom: data forMessageNames: messageNames
	"Answer a new instance of me using this data, which is a collection of arrays of core stats"
	| stats |
	stats := self new.
	stats initializeFastFrom: data forMessageNames: messageNames.
	^stats! !

!RVMAllCPUCoreStats class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:05'!
newFastestFrom: data forMessageNames: messageNames
	"Answer a new instance of me using this data, which is a collection of arrays of core stats"
	| stats |
	stats := self new.
	stats initializeFastestFrom: data forMessageNames: messageNames.
	^stats! !

!RVMAllCPUCoreStats class methodsFor: 'instance creation' stamp: 'ssa 8/13/2008 17:26'!
newFrom: data forMessageNames: messageNames
	"Answer a new instance of me using this data, which is a collection of arrays of core stats"
	| stats |
	stats := self new.
	stats initializeFrom: data forMessageNames: messageNames.
	^stats! !

!RVMAspectLabelController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:25'!
aspectFromUser
	| menu answer |
	menu := CustomMenu new.
	self view aspects
		do: [:aspect | menu add: aspect action: aspect].
	answer := menu startUp: self view aspect withCaption: 'Select the aspect to monitor' at: Sensor cursorPoint.
	answer isNil ifTrue:[^self].
	self view aspect: answer.
	self view displayView.
	self view topView newFrame! !

!RVMAspectLabelController methodsFor: 'controlling' stamp: 'ssa 9/19/2008 11:55'!
controlActivity
	Cursor menu show.
	super controlActivity! !

!RVMAspectLabelController methodsFor: 'controlling' stamp: 'ssa 9/19/2008 11:55'!
controlTerminate
	Cursor normal show.
	super controlTerminate! !

!RVMAspectLabelController methodsFor: 'controlling' stamp: 'ssa 9/13/2008 16:19'!
yellowButtonActivity

	self aspectFromUser.
! !

!RVMAspectLabelView methodsFor: 'displaying' stamp: 'ssa 10/21/2008 11:31'!
displayView
	| labelRect labelText labelForm |
self uncache.
	labelText := self label asDisplayText.
	labelText foregroundColor: self foregroundColor
			backgroundColor: self backgroundColor.
	labelForm := labelText
			 asParagraph asForm.
	labelRect := self insetDisplayBox.
	Display fill: labelRect fillColor: self backgroundColor.	
	labelForm displayOn: Display at: labelRect leftCenter - labelForm boundingBox leftCenter + (2@0) clippingBox: labelRect
			rule: Form paint fillColor: nil.
	"Display border: (self insetDisplayBox insetBy: 1)width: 1 fillColor: self backgroundColor negated."
! !

!RVMAspectLabelView methodsFor: 'updating' stamp: 'ssa 9/17/2008 14:17'!
update: aSymbol

	aSymbol  = self getAspectSelector ifTrue:[self displayView ].
	super update: aSymbol! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/19/2008 12:51'!
aspect

	^self getAspectSelector isSymbol 
		ifTrue:[self model perform: self getAspectSelector]
		ifFalse:["assume a block"
			self getAspectSelector value]! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/17/2008 14:14'!
aspect: aSymbol
	self setAspectSelector isSymbol
		ifTrue:[self model perform: self setAspectSelector with: aSymbol]
		ifFalse:["assume a block"
			self setAspectSelector value: aSymbol].
! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/17/2008 13:15'!
aspects
	^self getAspectsSelector isSymbol 
		ifTrue:[self model perform: self getAspectsSelector]
		ifFalse:["assume a block"
			self getAspectsSelector value]! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:06'!
backgroundColor

	^Color white! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 16:36'!
foregroundColor

	^Color black! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 16:14'!
getAspectSelector
	"Answer the value of getAspectSelector"

	getAspectSelector isNil ifTrue:[self getAspectSelector: #aspect].
	^ getAspectSelector! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 16:13'!
getAspectSelector: anObject
	"Set the value of getAspectSelector"

	getAspectSelector _ anObject! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 16:14'!
getAspectsSelector
	"Answer the value of getAspectsSelector"

	getAspectsSelector isNil ifTrue:[self getAspectsSelector: #aspects].
	^ getAspectsSelector! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 16:13'!
getAspectsSelector: anObject
	"Set the value of getAspectsSelector"

	getAspectsSelector _ anObject! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/17/2008 14:18'!
label

	^self aspect! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 16:25'!
lastAspect
	"Answer the value of lastAspect"

	lastAspect isNil ifTrue:[self lastAspect: #foo].
	^ lastAspect! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 16:25'!
lastAspect: anObject
	"Set the value of lastAspect"

	lastAspect _ anObject! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 16:14'!
setAspectSelector
	"Answer the value of setAspectSelector"

	setAspectSelector isNil ifTrue:[self setAspectSelector: #aspect:].
	^ setAspectSelector! !

!RVMAspectLabelView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 16:13'!
setAspectSelector: anObject
	"Set the value of setAspectSelector"

	setAspectSelector _ anObject! !

!RVMAspectLabelView methodsFor: 'controller access' stamp: 'ssa 9/13/2008 16:16'!
defaultControllerClass

	^RVMAspectLabelController! !

!RVMAspectLabelView class methodsFor: 'instance creation' stamp: 'ssa 9/17/2008 13:27'!
on: anObject
	"Answer a label view that will send #aspect to this object to find its label"
	| view |
	view := self new.
	view model: anObject.
	^view! !

!RVMAspectLabelView class methodsFor: 'instance creation' stamp: 'ssa 9/17/2008 14:04'!
on: anObject getAllAspectsWith: getAspectsSelector getCurrentAspectWith: getAspectSelector setNewAspectWith: setAspectSelector
	"Answer an aspect view that can probe and change the aspect of its aspectee.
	Note 'selector' arguments can be symbols or blocks"
	| view |
	view := self new.
	view model: anObject.
	view getAspectsSelector: getAspectsSelector.
	view getAspectSelector: getAspectSelector.
	view setAspectSelector: setAspectSelector.
	^view! !

!RVMAspectLabelView class methodsFor: 'examples' stamp: 'ssa 9/17/2008 13:31'!
example
	"RVMAspectLabelView example"
	| topView view |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 100@25.
	topView maximumSize: 200@50.
	view _ self on: view 
		getAllAspectsWith: [{ #foo. #bar. #baz. #waz }] 
		getCurrentAspectWith: #lastAspect 
		setNewAspectWith: #lastAspect:.
	view model: view.
	topView addSubView: view.
	topView label: 'Aspect Button'.
	topView controller open! !

!RVMAspectLabelView class methodsFor: 'examples' stamp: 'ssa 9/17/2008 13:31'!
exampleMany
	"RVMAspectLabelView exampleMany"
	| topView view1 view2 view3 |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 100@75.
	topView maximumSize: 200@100.
	view1 _ self on: view1 
		getAllAspectsWith: [{ #foo. #bar. #baz. #waz }] 
		getCurrentAspectWith: #lastAspect 
		setNewAspectWith: #lastAspect:.
	view1 on: view1.
	view2 _ self on: view2 
		getAllAspectsWith: [{ #foo. #bar. #baz. #waz }] 
		getCurrentAspectWith: #lastAspect 
		setNewAspectWith: #lastAspect:.
	view2 on: view2.
	view3 _ self on: view3 
		getAllAspectsWith: [{ #foo. #bar. #baz. #waz }] 
		getCurrentAspectWith: #lastAspect 
		setNewAspectWith: #lastAspect:.
	view3 on: view3.
	topView addSubView: view1.
	topView addSubView: view2 below: view1.
	topView addSubView: view3 below: view2.
	topView label: 'Aspect Button'.
	topView controller open! !

!RVMAspectLabelView class methodsFor: 'examples' stamp: 'ssa 9/17/2008 13:32'!
exampleWithColorButton
	"RVMAspectLabelView exampleWithColorButton"
	| topView view colorButton |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 100@25.
	topView maximumSize: 200@50.
	view _ self on: view 
		getAllAspectsWith: [{ #foo. #bar. #baz. #waz }] 
		getCurrentAspectWith: #lastAspect 
		setNewAspectWith: #lastAspect:.
	view model: view.
	colorButton _ RVMColorButtonView new.
	topView addSubView: view in: (0@0 extent: 5/6 @ 1) borderWidth:0.
	topView addSubView: colorButton in: (5/6@0 extent: 1/6@1) borderWidth:0.
	topView label: 'Aspect Button'.
	topView controller open! !

!RVMAspectTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:44'!
aspect
	"Answer the value of aspect"

	aspect isNil ifTrue:[self aspect: #bytesUseds].
	^ aspect! !

!RVMAspectTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:03'!
aspect: anObject
	"Set the value of aspect"

	aspect _ anObject.
	aspect notNil ifTrue:[self scaler: (RVMMonitor scalerFor:aspect)]! !

!RVMAspectTrace methodsFor: 'accessing' stamp: 'ssa 10/3/2008 23:17'!
aspectLabel

	^self aspect! !

!RVMAspectTrace methodsFor: 'updating' stamp: 'ssa 1/1/1970 00:26'!
addData
	"Assume a single valued data source"
	self add:(RVMMonitor lastSample perform: self aspect)! !

!RVMAspectTrace methodsFor: 'user interface' stamp: 'ssa 1/1/1970 00:29'!
allView
	
		^self aspectColorMuteView! !

!RVMAspectTrace methodsFor: 'user interface' stamp: 'ssa 1/1/1970 00:32'!
aspectButton
	"Answer an aspect button connect to my aspect"
	^RVMAspectLabelView on: self 
		getAllAspectsWith: [RVMMulticoreSample systemAspects] 
		getCurrentAspectWith: #aspect 
		setNewAspectWith: #aspect:! !

!RVMAspectTrace methodsFor: 'user interface' stamp: 'ssa 1/1/1970 00:46'!
aspectColorMuteView
	"Answer a view showing my color and aspect"
	| view |
	view _ RVMView new.
	view model: self.
	view addSubView: self  muteButton in: (0@0 extent: (1/10) @ 1) borderWidth:1.
	view addSubView: self colorButton in: ((1/10)@0 extent: (1/10) @ 1) borderWidth:1.
	view addSubView: self aspectButton in: ((2/10)@0 extent: (8/10) @ 1) borderWidth:1.
	^view! !

!RVMAspectTrace methodsFor: 'user interface' stamp: 'ssa 1/1/1970 00:37'!
aspectColorView
	"Answer a view showing my color and aspect"
	| view |
	view _ RVMView new.
	view addSubView: self  colorButton in: (0@0 extent: (1/10) @ 1) borderWidth:1.
	view addSubView: self aspectButton in: ((1/10)@0 extent: (9/10) @ 1) borderWidth:1.
	^view! !

!RVMAspectTrace class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:35'!
aspect: aSymbol size: anInteger color: aColor
	| trace |
	trace _ self new.
	trace
		scaler: RVMDataScaler new automatic;
		rawData: (RVMCircularCollection new: anInteger);
		color: aColor;
		aspect: aSymbol.
	^trace! !

!RVMAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:51'!
exampleInstance
	"RVMAspectTrace exampleInstance"
	^self aspect: #bytecodeCountsAverage size: 100 color: Color blue! !

!RVMAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:46'!
exampleView1
	"RVMAspectTrace exampleView1"
	
	RVMStripChartView openOnTrace: self exampleInstance! !

!RVMAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:31'!
exampleView2
	"RVMAspectTrace exampleView2"
	
	self exampleInstance aspectColorView demo! !

!RVMAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:35'!
exampleView3
	"RVMAspectTrace exampleView3"
	
	self exampleInstance aspectButton demo! !

!RVMAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:25'!
exampleView4
	"RVMAspectTrace exampleView4"
	
	| traces |
	traces _ OrderedCollection new.
	RVMMulticoreSample systemAspects do:[:aspect|
		traces add:(self aspect: aspect size: 100 color: Color random)].
	RVMStripChartView openOnTraces: traces! !

!RVMAspectTrace class methodsFor: 'examples' stamp: 'dmu 9/17/2010 15:34'!
exampleView8
	"RVMAspectTrace exampleView8"
	
	| traces |
	traces _ OrderedCollection new.
	traces add:(self  aspect: #numberOfRunningProcesses size: 100 color: Color random).
	RVMStripChartView openOnTraces: traces! !

!RVMAspectTrace class methodsFor: 'common uses' stamp: 'ssa 1/1/1970 01:18'!
monitorAllSystemAspects
	"RVMAspectTrace monitorAllSystemAspects"
	
	| traces colors |
	colors _ (Color wheel: RVMMulticoreSample systemAspects size saturation: 1.0 brightness: 0.7) readStream.
	traces _ OrderedCollection new.
	RVMMulticoreSample systemAspects do:[:aspect|
		traces add:(self aspect: aspect size: 100 color: colors next)].
	RVMStripChartView openOnTraces: traces titled:'All system aspects'! !

!RVMAspectTrace class methodsFor: 'common uses' stamp: 'ssa 1/1/1970 00:07'!
monitorAspects: someAspects 
	"RVMAspectTrace monitorAspects: #(bytecodeCountsAverage  bytecodesPerSecondAverage yieldCountsAverage)"
	
	| traces colors |
	colors _ (Color wheel: someAspects size saturation: 1.0 brightness: 0.7) readStream.
	traces _ OrderedCollection new.
	someAspects do:[:aspect|
		traces add:(self aspect: aspect size: 100 color: colors next)].
	RVMStripChartView openOnTraces: traces titled:'Selected system aspects'! !

!RVMBarrier methodsFor: 'as yet unclassified' stamp: 'dmu 1/21/2010 18:49'!
initialize
	interlock _ Semaphore new.
	interlock signal.
	waitSema _ Semaphore new.
	signalsNeededToPass _ 0! !

!RVMBarrier methodsFor: 'as yet unclassified' stamp: 'dmu 1/21/2010 19:14'!
signal
	interlock critical: [
		signalsNeededToPass _ signalsNeededToPass - 1.
		signalsNeededToPass < 0 ifTrue: [self error: 'oops'].
		signalsNeededToPass = 0 ifTrue: [waitSema signal]
	]! !

!RVMBarrier methodsFor: 'as yet unclassified' stamp: 'dmu 1/21/2010 14:23'!
signalsNeededToPass: n
	signalsNeededToPass _ n! !

!RVMBarrier methodsFor: 'as yet unclassified' stamp: 'dmu 1/21/2010 18:32'!
wait
	waitSema wait! !

!RVMBarrier methodsFor: 'as yet unclassified' stamp: 'dmu 1/21/2010 18:24'!
waitSema ^ waitSema! !

!RVMBootstrapPackage methodsFor: 'as yet unclassified' stamp: 'sm 3/11/2011 23:53'!
moreModificationsByTheRenaissanceTeam1
	^ {
{ 'Debugger'. 'defaultReceiverInspector' }.
{ 'Debugger'. 'defaultContextVariablesInspector' }.
{ 'OpaqueForm' }.
{ 'PluggableListViewByObject' }.
{ 'TextBlockDoIt' }.


{ 'Behavior'. 'setInstanceFormat:' }.
{ 'Behavior'. 'subobjects' }.
{ 'Behavior'. 'withAllSubclasses' }.
{ 'BlockContext'. 'asString' }.
{ 'BlockContext'. 'untilFalse:' }.
{ 'Boolean'. 'haltIfTrue' }.
{ 'Boolean'. 'mustBeBoolean' }.
{ 'Boolean'. 'mustBeBooleanIn:' }.
{ 'Browser'. 'classListIndex:' }.
{ 'Browser'. 'createInstVarAccessors' }.
{ 'Browser'. 'defineMessage:notifying:' }.
{ 'Browser'. 'metaClassOrganizer:' }.
{ 'ChangeList'. 'selectChangesMatching' }.
{ 'ChangeList'. 'selectSuchThat' }.
{ 'ChangeList'. 'selectedChanges' }.
{ 'ChangeList'. 'spawnSelections' }.
{ 'ChangeList'. 'spawnSuchThat:titled:' }.
{ 'ChangeList'. 'togglePrimaryListIndex:' }.
{ 'ChangeSet'. 'postscript' }.
{ 'ChangeSet'. 'postscript:' }.
{ 'ChangeSet'. 'preamble' }.
{ 'ChangeSet'. 'preamble:' }.
{ 'ChangeSet'. 'revertable' }.
{ 'ChangeSet'. 'structures:' }.
{ 'ChangeSet'. 'superclasses:' }.
{ 'ChangeSorter'. 'moveClassesToOtherMatching' }.
{ 'CharacterScanner'. 'scanCharactersFrom:to:in:rightX:stopConditions:displaying:' }.
{ 'ClassCommentVersionsBrowser'. 'scanVersionsOf:' }.
{ 'ClassDescription'. 'allMethodsInCategory:' }.
{ 'ClassDescription'. 'instanceVariablesString' }.
{ 'CodeHolder'. 'addContentsTogglesTo:' }.
{ 'Collection'. 'atRandom' }.
{ 'Collection'. 'removeAll:ifAbsent:' }.
{ 'Collection'. 'subobjects' }.
{ 'ColorForm'. 'setExtent:depth:' }.
{ 'CompiledMethod'. 'symbolic' }.
{ 'CompiledMethod'. 'timeStamp' }.
{ 'ContextPart'. 'errorReportOn:' }.
{ 'ContextPart'. 'unwindTo:' }.
{ 'Controller'. 'lastActivityTime' }.
{ 'Controller'. 'lastActivityTime:' }.
{ 'CustomMenu'. 'arguments' }.
{ 'CustomMenu'. 'invokeOn:orSendTo:' }.
{ 'CustomMenu'. 'selections' }.
{ 'CustomMenu'. 'startUp:withCaption:at:' }.
{ 'CustomMenu'. 'targets' }.
{ 'Debugger'. 'buildMVCDebuggerViewLabel:minSize:' }.
{ 'Debugger'. 'codeView' }.
{ 'Debugger'. 'contextStack' }.
{ 'Debugger'. 'contextStack:' }.
{ 'Debugger'. 'contextStackIndex' }.
{ 'Debugger'. 'contextStackIndex:' }.
{ 'Debugger'. 'contextStackList:' }.
{ 'Debugger'. 'contextStackMenu:shifted:' }.
{ 'Debugger'. 'contextStackTop' }.
{ 'Debugger'. 'contextStackTop:' }.
{ 'Debugger'. 'customButtonSpecs' }.
{ 'Debugger'. 'debugAt:' }.
{ 'Debugger'. 'errorWasInUIProcess' }.
{ 'Debugger'. 'errorWasInUIProcess:' }.
{ 'Debugger'. 'expandStack' }.
{ 'Debugger'. 'interruptedController' }.
{ 'Debugger'. 'interruptedController:' }.
{ 'Debugger'. 'interruptedProcess' }.
{ 'Debugger'. 'interruptedProcess:' }.
{ 'Debugger'. 'isolationHead:' }.
{ 'Debugger'. 'labelForContext:' }.
{ 'Debugger'. 'openFullNoSuspendLabel:' }.
{ 'Debugger'. 'pcRange' }.
{ 'Debugger'. 'proceedValue' }.
{ 'Debugger'. 'process:controller:context:isolationHead:' }.
{ 'Debugger'. 'receiverInspector' }.
{ 'Debugger'. 'resetContext:' }.
{ 'Debugger'. 'resumeProcess:' }.
{ 'Debugger'. 'savedCursor' }.
{ 'Debugger'. 'savedCursor:' }.
{ 'Debugger'. 'selectedContext' }.
{ 'Debugger'. 'selectingPC' }.
{ 'Debugger'. 'selectingPC:' }.
{ 'Debugger'. 'sourceMap:' }.
{ 'Debugger'. 'tempNames' }.
{ 'Debugger'. 'terminateInterruptedProcessIfSoleOwner' }.
{ 'Debugger'. 'theMethodNode' }.
{ 'Debugger'. 'updateInspectorToObject:' }.
{ 'Debugger'. 'updateInspectors' }.
{ 'Dictionary'. 'subobjects' }.
{ 'DisplayMedium'. 'border:width:fillColor:clippingBox:' }.
{ 'DisplayMedium'. 'outlined' }.
{ 'DisplayObject'. 'displayOn:at:' }.
{ 'DisplayScreen'. 'clippingTo:do:' }.
{ 'DisplayScreen'. 'outline:while:width:halftone:' }.
{ 'DisplayScreen'. 'setExtent:depth:' }.
{ 'DisplayText'. 'asParagraphWithStyle:' }.
{ 'DisplayText'. 'isEmpty' }.
{ 'DisplayText'. 'numberOfLines' }.
{ 'EventSensor'. 'fetchMoreEvents' }.
{ 'EventSensor'. 'flushNonKbdEvents' }.
{ 'EventSensor'. 'nextEvent' }.
{ 'EventSensor'. 'primGetNextEvent:' }.
{ 'EventSensor'. 'primKbdNext' }.
{ 'EventSensor'. 'primMouseButtons' }.
{ 'EventSensor'. 'processEvent:' }.
{ 'EventSensor'. 'processKeyboardEvent:' }.
{ 'False'. 'haltIfFalse' }.
{ 'FileList'. 'fullFileListMenu:shifted:' }.
{ 'Form'. 'bottomLeft' }.
{ 'Form'. 'bottomRight' }.
{ 'Form'. 'displayTranslucentOn:at:clippingBox:' }.
{ 'Form'. 'eraseInside:' }.
{ 'Form'. 'fill:rule:fillColor:clippingBox:' }.
{ 'Form'. 'leftCenter' }.
{ 'Form'. 'paintBits:at:clippingBox:translucent:' }.
{ 'Form'. 'rightCenter' }.
{ 'Form'. 'rotateBy:smoothing:' }.
{ 'FormView'. 'defaultRule' }.
{ 'InfiniteForm'. 'hasNonStandardPalette' }.
{ 'InputSensor'. 'waitClick' }.
{ 'Inspector'. 'fieldListMenu:' }.
{ 'Inspector'. 'locateSelection' }.
{ 'Inspector'. 'selectionIndex:' }.
{ 'Inspector'. 'selectionUpdateTime' }.
{ 'Inspector'. 'selectionUpdateTime:' }.
{ 'InstructionStream'. 'skipBackBeforeJump' }.
{ 'LinkedList'. 'asOrderedCollection' }.
{ 'ListController'. 'processKeyboard' }.
{ 'ListView'. 'clippingBox' }.
{ 'ListView'. 'findSelection:' }.
{ 'ListView'. 'isEmpty' }.
{ 'ListView'. 'textStyle:' }.
{ 'ListView'. 'update:' }.
{ 'Matrix'. 'removeAll' }.
{ 'Message'. 'selector:' }.
{ 'MethodHolder'. 'doItReceiver' }.
{ 'Number'. 'asPointWithinRectangleWithExtent:' }.
{ 'Number'. 'atRandom' }.
{ 'Number'. 'floatPrecisionForDecimalPlaces:' }.
{ 'Number'. 'inverted' }.
{ 'Number'. 'pi' }.
{ 'Number'. 'printShowingMax3Digits' }.
{ 'Object'. 'allInstanceVariableValuesPlusIndexed' }.
{ 'Object'. 'asExplorerString' }.
{ 'Object'. 'asObjectCoordinate' }.
{ 'Object'. 'changed:with:from:' }.
{ 'Object'. 'hasInstanceVariables' }.
{ 'Object'. 'inspect' }.
{ 'Object'. 'isArray' }.
{ 'Object'. 'isBoolean' }.
{ 'Object'. 'isEnsemble' }.
{ 'Object'. 'locate' }.
{ 'Object'. 'outlineString' }.
{ 'Object'. 'printDirectlyToDisplay' }.
{ 'Object'. '~==' }.
{ 'OpaqueForm'. 'colormapIfNeededFor:' }.
{ 'OpaqueForm'. 'figure' }.
{ 'OpaqueForm'. 'offset' }.
{ 'OpaqueForm'. 'shape' }.
{ 'OpaqueForm'. 'valueAt:' }.
{ 'OrderedCollection'. 'addAll:after:' }.
{ 'OrderedCollection'. 'inspectorClass' }.
{ 'ParagraphEditor'. 'adjustWidths' }.
{ 'ParagraphEditor'. 'browseIt' }.
{ 'ParagraphEditor'. 'compileSelectionFor:in:' }.
{ 'ParagraphEditor'. 'cursorUp:' }.
{ 'ParagraphEditor'. 'evaluate:' }.
{ 'ParagraphEditor'. 'evaluateSelection' }.
{ 'ParagraphEditor'. 'exploreIt:' }.
{ 'ParagraphEditor'. 'inspectIt' }.
{ 'ParagraphEditor'. 'installAsTest' }.
{ 'ParagraphEditor'. 'printIt:' }.
{ 'Pen'. 'direction:' }.
{ 'Pen'. 'penAngleFrom:to:' }.
{ 'Pen'. 'turnToward:' }.
}! !

!RVMBootstrapPackage methodsFor: 'as yet unclassified' stamp: 'sm 3/11/2011 22:23'!
moreModificationsByTheRenaissanceTeam2
	^ {

{ 'PluggableButtonView'. 'label:' }.
{ 'PluggableButtonView'. 'performAction' }.
{ 'PluggableButtonView'. 'update:' }.
{ 'PluggableFileList'. 'startUpWithCaption:' }.
{ 'PluggableListControllerOfMany'. 'redButtonActivity' }.
{ 'PluggableListView'. 'update:' }.
{ 'PluggableListViewByObject'. 'labelForItem:' }.
{ 'PluggableListViewByObject'. 'list:' }.
{ 'PluggableListViewByObject'. 'objects:' }.
{ 'Point'. 'floor' }.
{ 'Point'. 'inverted' }.
{ 'Point'. 'manhattanDist:' }.
{ 'Point'. 'mined' }.
{ 'Point'. 'x:' }.
{ 'Point'. 'zeno' }.
{ 'PointerFinder'. 'menu:shifted:' }.
{ 'PointerFinder'. 'open' }.
{ 'PositionableStream'. 'printOn:' }.
{ 'Project'. 'enter:revert:saveForRevert:' }.
{ 'Rectangle'. 'asRandomPoint' }.
{ 'Rectangle'. 'displayOn:withBorderWidths:' }.
{ 'Rectangle'. 'displayWithBorderWidths:' }.
{ 'Rectangle'. 'height:' }.
{ 'Rectangle'. 'intersect:' }.
{ 'Rectangle'. 'moveBy:' }.
{ 'Rectangle'. 'newRectButtonPressedDo:' }.
{ 'Rectangle'. 'newRectFrom:' }.
{ 'Rectangle'. 'origin:' }.
{ 'Rectangle'. 'subDivideBy:' }.
{ 'Rectangle'. 'subDivideRoundedBy:' }.
{ 'Rectangle'. 'topRight:' }.
{ 'Rectangle'. 'width:' }.
{ 'ScreenController'. 'appearanceMenu' }.
{ 'ScreenController'. 'closeAllUnlockedWindows' }.
{ 'ScreenController'. 'closeTopWindow' }.
{ 'ScreenController'. 'controlActivity' }.
{ 'ScreenController'. 'exploreViewFromUser' }.
{ 'ScreenController'. 'isControlWanted' }.
{ 'ScreenController'. 'openMenu' }.
{ 'ScreenController'. 'openProcessBrowser' }.
{ 'ScreenController'. 'preventClosing' }.
{ 'ScreenController'. 'restoreDisplay' }.
{ 'ScreenController'. 'windowMenu' }.
{ 'SequenceableCollection'. 'asCircularCollection' }.
{ 'SequenceableCollection'. 'groupsOfNoMoreThan:atATimeDo:' }.
{ 'SequenceableCollection'. 'rotateBackward' }.
{ 'SequenceableCollection'. 'rotateForward' }.
{ 'SequenceableCollection'. 'with:with:do:' }.
{ 'SequenceableCollection'. 'with:with:withIndexDo:' }.
{ 'SequenceableCollection'. 'with:withIndexDo:' }.
{ 'SequenceableCollection'. 'without:collect:' }.
{ 'SequenceableCollection'. 'without:select:' }.
{ 'SmalltalkImage'. 'forceChangesToDisk' }.
{ 'StandardFileStream'. 'nextPut:' }.
{ 'StandardSystemController'. 'blueButtonActivity' }.
{ 'StandardSystemController'. 'blueButtonMenu' }.
{ 'StandardSystemController'. 'closeAndUnscheduleIfOkWithModelNoTerminate' }.
{ 'StandardSystemController'. 'closeForReal' }.
{ 'StandardSystemController'. 'preventClosing:' }.
{ 'StandardSystemController'. 'status' }.
{ 'StandardSystemView'. 'cacheBitsAsTwoTone' }.
{ 'StandardSystemView'. 'closingGuardIcon' }.
{ 'StandardSystemView'. 'displayLabelBackground:' }.
{ 'StandardSystemView'. 'displayView' }.
{ 'StandardSystemView'. 'initialFrame' }.
{ 'StandardSystemView'. 'setUpdatablePanesFrom:' }.
{ 'StrikeFont'. 'characterToGlyphMap:' }.
{ 'StrikeFont'. 'emphasis' }.
{ 'StrikeFont'. 'maxWidth:' }.
{ 'StrikeFont'. 'pointSize:' }.
{ 'StrikeFont'. 'raster:' }.
{ 'StrikeFont'. 'subscript:' }.
{ 'StrikeFont'. 'superscript:' }.
{ 'StrikeFont'. 'type' }.
{ 'StrikeFont'. 'xOffset:' }.
{ 'StrikeFont'. 'xTable:' }.
{ 'String'. 'asParagraphWithStyle:' }.
{ 'String'. 'withoutFirst:' }.
{ 'String'. 'withoutLast:' }.
{ 'StringHolderView'. 'displayContents:' }.
{ 'StringHolderView'. 'textStyle:' }.
{ 'SystemDictionary'. 'forceChangesToDisk' }.
{ 'SystemDictionary'. 'majorShrinkClassesToLeave' }.
{ 'SystemDictionary'. 'presumedSentMessages' }.
{ 'SystemDictionary'. 'recolorWindows' }.
{ 'Text'. 'asParagraphWithStyle:' }.
{ 'Text'. 'bold' }.
{ 'Text'. 'font:' }.
{ 'Text'. 'fontName:pointSize:' }.
{ 'Text'. 'italic' }.
{ 'Text'. 'makeUnderlineFrom:to:' }.
{ 'Text'. 'makeUnderlinedFrom:to:' }.
{ 'Text'. 'underline' }.
{ 'TextBlockDoIt'. 'actOnClickFor:' }.
{ 'TextBlockDoIt'. 'actionBlock' }.
{ 'True'. 'haltIfTrue' }.
{ 'View'. 'addSubView:below:' }.
{ 'View'. 'addSubView:toRightOf:' }.
{ 'View'. 'allSubViews' }.
{ 'View'. 'borderColor:' }.
{ 'View'. 'boundingBox:' }.
{ 'View'. 'displayTransformation:' }.
{ 'View'. 'isRVMView' }.
{ 'View'. 'moveLeft' }.
{ 'View'. 'moveRight' }.
{ 'View'. 'setDefaultBackgroundColor' }.
{ 'View'. 'shorter' }.
{ 'View'. 'stretchFrame:startingWith:' }.
{ 'View'. 'taller' }.

}! !

!RVMBootstrapPackage methodsFor: 'as yet unclassified' stamp: 'sm 3/11/2011 23:07'!
moreModificationsByTheRenaissanceTeam3
	^ {
{ 'Behavior'. 'allSubclasses' }.
{ 'Behavior'. 'archiveVersion' }.
{ 'Behavior'. 'compile:notifying:trailer:' }.
{ 'BlockContext'. 'asContext' }.
{ 'BlockContext'. 'loopExit' }.
{ 'BlockContext'. 'value:value:value:value:value:' }.
{ 'BlockNode'. 'returnSelfIfNoOther' }.
{ 'Boolean'. 'haltIfFalse' }.
{ 'Browser'. 'classOrganizer' }.
{ 'Browser'. 'classOrganizer:' }.
{ 'Browser'. 'defineMessageFrom:notifying:' }.
{ 'Browser'. 'lastClassSelected' }.
{ 'Browser'. 'lastClassSelected:' }.
{ 'Browser'. 'metaClassIndicated:' }.
{ 'Browser'. 'metaClassOrganizer' }.
{ 'Browser'. 'setClass:selector:' }.
{ 'Browser'. 'systemOrganizer' }.
{ 'ChangeList'. 'changeList:' }.
{ 'ChangeList'. 'changeListMenu:' }.
{ 'ChangeList'. 'scanRecords:' }.
{ 'ChangeList'. 'spawnChangesMatching' }.
{ 'ChangeList'. 'spawnSuchThat' }.
{ 'ChangeRecord'. 'match:' }.
{ 'ChangeRecord'. 'methodClassNameSafe' }.
{ 'ChangeRecord'. 'methodSelectorSafe' }.
{ 'ChangeSet'. 'changeRecords' }.
{ 'ChangeSet'. 'changeRecords:' }.
{ 'ChangeSet'. 'checkForConversionMethods' }.
{ 'ChangeSet'. 'editPostscript' }.
{ 'ChangeSet'. 'fileOutClassDefinition:on:' }.
{ 'ChangeSet'. 'isolatedProject:' }.
{ 'ChangeSet'. 'isolationSet' }.
{ 'ChangeSet'. 'revertable:' }.
{ 'ChangeSorter'. 'classListKey:from:' }.
{ 'ChangeSorter'. 'classListMenu:shifted:' }.
{ 'ChangeSorter'. 'copyClassesToOtherMatching' }.
{ 'Character'. 'isCharacter' }.
{ 'CharacterScanner'. 'destX:' }.
{ 'CodeHolder'. 'addModelItemsToWindowMenu:' }.
{ 'CodeHolder'. 'offerWhatToShowMenu' }.
{ 'ContextPart'. 'runSimulated:contextAtEachStep:' }.
{ 'ControlManager'. 'activeControllerNoTerminate:andProcess:' }.
{ 'ControlManager'. 'reset' }.
{ 'ControlManager'. 'restore:below:without:' }.
{ 'Controller'. 'initialize' }.
{ 'Debugger'. 'buildMVCNotifierViewLabel:message:minSize:' }.
{ 'Debugger'. 'contextStackIndex:oldContextWas:' }.
{ 'Debugger'. 'contextVariablesInspector' }.
{ 'Debugger'. 'contextVariablesInspector:' }.
{ 'Debugger'. 'externalInterrupt' }.
{ 'Debugger'. 'failedProject' }.
{ 'Debugger'. 'failedProject:' }.
{ 'Debugger'. 'installListFontInto:' }.
{ 'Debugger'. 'isolationHead' }.
{ 'Debugger'. 'newStack:' }.
{ 'Debugger'. 'openNotifierContents:label:' }.
{ 'Debugger'. 'optionalButtonPairs' }.
{ 'Debugger'. 'otherButtonSpecs' }.
{ 'Debugger'. 'receiverInspector:' }.
{ 'Debugger'. 'release' }.
{ 'Debugger'. 'sourceMap' }.
{ 'Debugger'. 'step' }.
{ 'Debugger'. 'tempNames:' }.
{ 'Debugger'. 'theMethodNode:' }.
{ 'Debugger'. 'toggleContextStackIndex:' }.
{ 'Debugger'. 'windowIsClosing' }.
{ 'DictionaryInspector'. 'dictionaryMenu:' }.
{ 'DisplayMedium'. 'border:width:rule:fillColor:clippingBox:' }.
{ 'DisplayMedium'. 'border:widthRectangle:rule:fillColor:clippingBox:' }.
{ 'DisplayObject'. 'followCursor' }.
{ 'DisplayScreen'. 'boundingBox' }.
{ 'DisplayScreen'. 'clippingBox:' }.
{ 'DisplayScreen'. 'copyFrom:' }.
{ 'DisplayScreen'. 'fullScreen' }.
{ 'DisplayScreen'. 'outline:do:while:width:halftone:' }.
{ 'DualChangeSorter'. 'open' }.
{ 'EventSensor'. 'flushAllButDandDEvents' }.
{ 'EventSensor'. 'primKbdPeek' }.
{ 'EventSensor'. 'primMousePt' }.
{ 'EventSensor'. 'queueEvent:' }.
{ 'FileList'. 'fileContentsMenu:shifted:' }.
{ 'FileList'. 'fileSelectedMenu:' }.
{ 'Float'. 'absPrintOn:base:digitCount:' }.
{ 'Form'. 'asOpaqueForm' }.
{ 'Form'. 'bottomCenter' }.
{ 'Form'. 'displayBox' }.
{ 'Form'. 'displayOn:at:clippingBox:rule:fillColor:' }.
{ 'Form'. 'erase' }.
{ 'Form'. 'nextLifeGeneration' }.
{ 'Form'. 'nextLifeGenerationBlueBook' }.
{ 'Form'. 'scaledToSize:' }.
{ 'Form'. 'topCenter' }.
{ 'Form'. 'topLeft' }.
{ 'Form'. 'topRight' }.
{ 'Form'. 'wrapAround:' }.
{ 'FormView'. 'defaultControllerClass' }.
{ 'FormView'. 'displayView' }.
{ 'HierarchyBrowser'. 'setClass:selector:' }.
{ 'InfiniteForm'. 'depth' }.
{ 'Inspector'. 'exploreSelection' }.
{ 'Inspector'. 'inspectorKey:from:' }.
{ 'Inspector'. 'timeOfLastListUpdate:' }.
{ 'LargePositiveInteger'. 'printOn:' }.
{ 'LinkedList'. 'hasContentsInExplorer' }.
{ 'ListView'. 'isEmpty:' }.
{ 'ListView'. 'textStyle' }.
{ 'ListView'. 'totalContentHeight' }.
{ 'Matrix'. 'postCopy' }.
{ 'Matrix'. 'preMultiplyByMatrix:' }.
{ 'Message'. 'arguments:' }.
{ 'Message'. 'sentTo:' }.
{ 'MethodContext'. 'asContext' }.
{ 'Number'. 'printShowingDecimalPlaces:' }.
{ 'Number'. 'zeno' }.
{ 'Object'. 'allInstanceVariableValues' }.
{ 'Object'. 'archiveVersion' }.
{ 'Object'. 'defaultBackgroundColor' }.
{ 'Object'. 'display' }.
{ 'Object'. 'explore' }.
{ 'Object'. 'hasContents' }.
{ 'Object'. 'isCharacter' }.
{ 'Object'. 'isObject' }.
{ 'Object'. 'print' }.
{ 'Object'. 'printStringUpTo:' }.
{ 'Object'. 'subobjects' }.
{ 'Object'. 'update:with:from:' }.
{ 'OpaqueForm'. 'colorForm' }.
{ 'OpaqueForm'. 'colorForm:' }.
{ 'OpaqueForm'. 'computeBoundingBox' }.
{ 'OpaqueForm'. 'displayOn:at:clippingBox:rule:fillColor:' }.
{ 'OpaqueForm'. 'displayOn:transformation:clippingBox:align:with:rule:fillColor:' }.
{ 'OpaqueForm'. 'setFigure:shape:' }.
{ 'OpaqueForm'. 'storeOn:' }.
{ 'OpaqueForm'. 'valueAt:put:' }.
{ 'PackageInfo'. 'removeFromSystem' }.

}! !

!RVMBootstrapPackage methodsFor: 'as yet unclassified' stamp: 'sm 3/11/2011 22:47'!
moreModificationsByTheRenaissanceTeam4
	^ {

{ 'Paragraph'. 'asForm' }.
{ 'ParagraphEditor'. 'cursorDown:' }.
{ 'ParagraphEditor'. 'debugIt' }.
{ 'ParagraphEditor'. 'exploreIt' }.
{ 'ParagraphEditor'. 'methodSourceContainingIt' }.
{ 'ParagraphEditor'. 'parseIt' }.
{ 'ParagraphEditor'. 'printIt' }.
{ 'ParagraphEditor'. 'sameColumn:newLine:forward:' }.
{ 'Pen'. 'mandala:diameter:' }.
{ 'PluggableListView'. 'getList' }.
{ 'PluggableListViewByObject'. 'changeModelSelection:' }.
{ 'PluggableListViewByObject'. 'getCurrentSelectionIndex' }.
{ 'PluggableListViewByObject'. 'objects' }.
{ 'PluggableListViewByObject'. 'scrollCache' }.
{ 'PluggableListViewByObject'. 'scrollCache:' }.
{ 'Point'. 'atRandom' }.
{ 'Point'. 'ceiling' }.
{ 'Point'. 'mandist:' }.
{ 'Point'. 'maxed' }.
{ 'Point'. 'moveBy:' }.
{ 'Point'. 'wrapAround:' }.
{ 'Point'. 'y:' }.
{ 'PopUpMenu'. 'startUpWithCaption:' }.
{ 'PopUpMenu'. 'startUpWithCaption:at:allowKeyboard:' }.
{ 'Project'. 'backgroundColorForMvcProject' }.
{ 'Project'. 'defaultBackgroundColor' }.
{ 'Project'. 'okToChange' }.
{ 'Project'. 'renameTo:' }.
{ 'RVMBootstrapPackage'. 'moreModificationsByTheRenaissanceTeam1' }.
{ 'RVMBootstrapPackage'. 'moreModificationsByTheRenaissanceTeam2' }.
{ 'RVMBootstrapPackage'. 'trickyModificationsManuallyCollected' }.
{ 'Rectangle'. 'corner:' }.
{ 'Rectangle'. 'display' }.
{ 'Rectangle'. 'extent:' }.
{ 'Rectangle'. 'fastMoveBy:' }.
{ 'Rectangle'. 'moveTo:' }.
{ 'Rectangle'. 'scaleByRect:' }.
{ 'Rectangle'. 'selfMerge:' }.
{ 'Rectangle'. 'size' }.
{ 'ScreenController'. 'recolorWindows' }.
{ 'SequenceableCollection'. 'is:after:' }.
{ 'SequenceableCollection'. 'shuffled' }.
{ 'SmalltalkImage'. 'saveAs:' }.
{ 'SmalltalkImage'. 'snapshot:andQuit:embedded:' }.
{ 'SmalltalkImage'. 'sourcesName' }.
{ 'StandardFileMenu'. 'oldFileFrom:withPattern:' }.
{ 'StandardSystemController'. 'close' }.
{ 'StandardSystemController'. 'closeAndUnscheduleIfOkWithModel' }.
{ 'StandardSystemController'. 'isClosed' }.
{ 'StandardSystemController'. 'preventClosing' }.
{ 'StandardSystemController'. 'redButtonActivity' }.
{ 'StandardSystemController'. 'togglePreventClosing' }.
{ 'StandardSystemView'. 'displayClosingGuardBoxIfNeeded' }.
{ 'StandardSystemView'. 'displayLabelBoxes' }.
{ 'StrikeFont'. 'ascent:' }.
{ 'StrikeFont'. 'derivativeFonts' }.
{ 'StrikeFont'. 'derivativeFonts:' }.
{ 'StrikeFont'. 'descent:' }.
{ 'StrikeFont'. 'glyphs:' }.
{ 'StrikeFont'. 'maxAscii:' }.
{ 'StrikeFont'. 'minAscii:' }.
{ 'StrikeFont'. 'raster' }.
{ 'StrikeFont'. 'strikeLength' }.
{ 'StrikeFont'. 'strikeLength:' }.
{ 'StrikeFont'. 'subscript' }.
{ 'StrikeFont'. 'superscript' }.
{ 'StrikeFont'. 'type:' }.
{ 'StrikeFont'. 'xOffset' }.
{ 'String'. 'asSmalltalkObject' }.
{ 'StringHolderView'. 'askBeforeDiscardingEdits' }.
{ 'StringHolderView'. 'changeTextStyle:' }.
{ 'StringHolderView'. 'defaultTextStyle' }.
{ 'StringHolderView'. 'editString:' }.
{ 'StringHolderView'. 'initialize' }.
{ 'StringHolderView'. 'textStyle' }.
{ 'Symbol'. 'asKeyword' }.
{ 'SystemDictionary'. 'majorShrinkClassesToZap' }.
{ 'SystemDictionary'. 'updateAllWindowColors' }.
{ 'Text'. 'emphasizeFrom:to:with:' }.
{ 'Text'. 'fontNumber:' }.
{ 'Text'. 'makeItalicFrom:to:' }.
{ 'Text'. 'underlined' }.
{ 'TextBlockDoIt'. 'actionBlock:' }.
{ 'TranscriptStream'. 'openLabel:' }.
{ 'VersionsBrowser'. 'scanVersionsOf:class:meta:category:selector:' }.
{ 'View'. 'addSubView:above:' }.
{ 'View'. 'addSubView:in:borderWidth:' }.
{ 'View'. 'addSubView:toLeftOf:' }.
{ 'View'. 'borderColor' }.
{ 'View'. 'demo' }.
{ 'View'. 'demoSized:' }.
{ 'View'. 'insetDisplayBox:' }.
{ 'View'. 'insideColor' }.
{ 'View'. 'moveBy:' }.
{ 'View'. 'moveDown' }.
{ 'View'. 'moveFrom:' }.
{ 'View'. 'moveUp' }.
{ 'View'. 'narrower' }.
{ 'View'. 'subViews:' }.
{ 'View'. 'subViewsSatisfying:' }.
{ 'View'. 'transformUsing:' }.
{ 'View'. 'viewport:' }.
{ 'View'. 'wider' }.
{ 'Workspace'. 'addModelItemsToWindowMenu:' }.


}! !

!RVMBootstrapPackage methodsFor: 'as yet unclassified' stamp: 'StefanMarr 7/14/2011 17:13'!
moreModificationsByTheRenaissanceTeam5
	^ {
"Stefan: the next one is a fix for long Author names:"
{'PositionableStream'. 'copyPreamble:from:'}.

"Stefan: now other stuff, uncategorized"

{ 'ChangeList class'. 'browseRecords:' }.
{ 'ChangeList class'. 'browseRecords:titled:' }.
{ 'ChangeList class'. 'fileReaderServicesForFile:suffix:' }.
{ 'ChangeList class'. 'open:name:multiSelect:' }.
{ 'ChangeList class'. 'services' }.
{ 'ChangeSorter class'. 'fileIntoNewChangeSet:' }.
{ 'Color class'. 'colorChart' }.
{ 'Color class'. 'colorChart:' }.
{ 'Color class'. 'fromUser' }.
{ 'Controller class'. 'initialize' }.
{ 'Debugger class'. 'openNoForkSuspendOn:context:label:contents:fullView:selectingOtherIndex:' }.
{ 'Debugger class'. 'openNoSuspendOn:context:label:contents:fullView:' }.
{ 'Debugger class'. 'openOn:context:label:contents:fullView:' }.
{ 'Delay class'. 'startUp' }.
{ 'FileDirectory class'. 'startUp' }.
{ 'FileStream class'. 'concreteStream' }.
{ 'FileStream class'. 'fileIn:' }.
{ 'Form class'. 'dotOfSize:color:' }.
{ 'Form class'. 'fromBinaryStream:' }.
{ 'FormView class'. 'open:named:' }.
{ 'HierarchyBrowser class'. 'newFor:' }.
{ 'HierarchyBrowser class'. 'newFor:labeled:' }.
{ 'ImageReadWriter class'. 'understandsImageFormat:' }.
{ 'Inspector class'. 'newFrom:' }.
{ 'Inspector class'. 'openOn:withEvalPane:withLabel:valueViewClass:' }.
{ 'MessageSet class'. 'openMessageList:name:autoSelect:' }.
{ 'OpaqueForm class'. 'makeStar' }.
{ 'ParagraphEditor class'. 'initializeCmdKeyShortcuts' }.
{ 'PluggableFileList class'. 'oldFileMenu:withPattern:' }.
{ 'PluggableListView class'. 'on:list:selected:changeSelected:' }.
{ 'PluggableListView class'. 'on:list:selected:changeSelected:menu:' }.
{ 'PluggableListViewOfMany class'. 'on:list:primarySelection:changePrimarySelection:listSelection:changeListSelection:menu:' }.
{ 'PluggableListViewOfMany class'. 'on:list:primarySelection:changePrimarySelection:listSelection:changeListSelection:menu:keystroke:' }.
{ 'PluggableTextView class'. 'on:text:accept:' }.
{ 'ProcessBrowser class'. 'isUIProcess:' }.
{ 'Project class'. 'addItem:toMenu:selection:project:' }.
{ 'RealEstateAgent class'. 'assignCollapsePointFor:' }.
{ 'RealEstateAgent class'. 'maximumUsableArea' }.
{ 'RealEstateAgent class'. 'screenTopSetback' }.
{ 'RealEstateAgent class'. 'scrollBarSetback' }.
{ 'RunArray class'. 'scanFrom:' }.
{ 'SelectionMenu class'. 'labels:lines:selectors:' }.
{ 'StandardFileMenu class'. 'oldFileFrom:withPattern:' }.
{ 'StandardFileMenu class'. 'oldFileMenu:withPattern:' }.
{ 'StandardFileMenu class'. 'oldFileStreamFrom:withPattern:' }.
{ 'StandardFileMenu class'. 'oldFileStreamWithPattern:' }.
{ 'StandardFileMenu class'. 'oldFileWithPattern:' }.
{ 'StandardSystemView class'. 'model:label:minimumSize:' }.
{ 'Symbol class'. 'readFrom:' }.
{ 'TextStyle class'. 'mvcPromptForFont:' }.
{ 'TextStyle class'. 'mvcPromptForStyle:andSendTo:withSelector:' }.
{ 'Transcripter class'. 'emergencyEvaluator' }.
{ 'Utilities class'. 'exploreViewFromUser' }.
{ 'Utilities class'. 'informUserDuring:' }.
{ 'Utilities class'. 'pointersTo:except:' }.

{ 'RVMBootstrapPackage'. 'moreModificationsByTheRenaissanceTeam3' }.
{ 'RVMBootstrapPackage'. 'moreModificationsByTheRenaissanceTeam4' }.
{ 'RVMBootstrapPackage'. 'moreModificationsByTheRenaissanceTeam5' }.

{ 'OpaqueForm class'. 'figure:shape:' }.
{ 'OpaqueForm class'. 'shape:' }.


}! !

!RVMBootstrapPackage methodsFor: 'as yet unclassified' stamp: 'ads 2/4/2011 12:24'!
revertToVersionBeforeTeam: team
	"DO NOT RUN THIS METHOD ON MULTIPLE CORES!!!!!!!!!! Only on one core."
	
	"Also, notice that the stuff in this method is ALMOST exactly the same as the stuff in
	 trickyModificationsThatNeedToBeDoneInOrder (but in reverse order, since we're removing).
	 In the long run, we should be able to eliminate the duplication. But the current RVM image contains some weird
	 stuff, like methods that existed in Squeak 3.7 and were changed by the Renaissance team but somehow the image
	 doesn't contain a copy of the old version of the method. So for now, we have this big ugly method. -- Adam, Dec. 2010"

	team revertToOldVersionOrRemove: (ProcessorScheduler class methodNamed: #emergencyProcess).
	team revertToOldVersionOrRemove: (ProcessorScheduler class methodNamed: #startEmergencyProcess).
	team revertToOldVersionOrRemove: (ProcessorScheduler class methodNamed: #startUp).
	team revertToOldVersionOrRemove: (ProcessBrowser class methodNamed: #nameAndRulesFor:).
	team aboutToModifyClass: ProcessorScheduler.
	Object subclass: #ProcessorScheduler
		instanceVariableNames: 'quiescentProcessLists activeProcess'
		classVariableNames: 'BackgroundProcess HighIOPriority LowIOPriority SystemBackgroundPriority SystemRockBottomPriority TimingPriority UserBackgroundPriority UserInterruptPriority UserSchedulingPriority'
		poolDictionaries: ''
		category: 'Kernel-Processes'.

	team revertToOldVersionOrRemove: (Debugger methodNamed: #fullyExpandStack).
	team revertToOldVersionOrRemove: (Process methodNamed: #debug:title:full:).
	team revertToOldVersionOrRemove: (Process methodNamed: #resume).
	team revertToOldVersionOrRemove: (Process methodNamed: #suspend).
	team revertToOldVersionOrRemove: (Process methodNamed: #terminate).
	team revertToOldVersionOrRemove: (Process class methodNamed: #semaForSupensions).
	team revertToOldVersionOrRemove: (Process methodNamed: #children).
	team revertToOldVersionOrRemove: (Process methodNamed: #children:).
	team revertToOldVersionOrRemove: (Process methodNamed: #parent).
	team revertToOldVersionOrRemove: (Process methodNamed: #parent:).
	team revertToOldVersionOrRemove: (Process methodNamed: #creatorEnsemble).
	team revertToOldVersionOrRemove: (Process methodNamed: #creatorEnsemble:).
	team aboutToModifyClass: Process.
	Link subclass: #Process
		instanceVariableNames: 'suspendedContext priority myList errorHandler name'
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Kernel-Processes'.

	team revertToOldVersionOrRemove: (TranscriptStream class methodNamed: #showInConsole).
	team revertToOldVersionOrRemove: (TranscriptStream class methodNamed: #showInConsole:).
	team aboutToModifyClass: TranscriptStream.
	WriteStream subclass: #TranscriptStream
		instanceVariableNames: ''
		classVariableNames: 'AccessSema'
		poolDictionaries: ''
		category: 'Collections-Streams'.

	"Safe."
	team aboutToModifyClass: Collection.
	Object subclass: #Collection
		instanceVariableNames: ''
		classVariableNames: 'MutexForPicking RandomForPicking'
		poolDictionaries: ''
		category: 'Collections-Abstract'.

	"Safe. I don't even understand why they bothered or why the Squeak image had this variable."
	team aboutToModifyClass: AnimatedGIFReadWriter.
	GIFReadWriter subclass: #AnimatedGIFReadWriter
		instanceVariableNames: 'forms offsets delays comments'
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Graphics-Files'.

	"Safe. The methods that use the new cursors are already gone."
	team revertToOldVersionOrRemove: (Cursor class methodNamed: #initialize).
	team aboutToModifyClass: Cursor.
	Form subclass: #Cursor
		instanceVariableNames: ''
		classVariableNames: 'BlankCursor BottomLeftCursor BottomRightCursor CornerCursor CrossHairCursor CurrentCursor DownCursor MarkerCursor MenuCursor MoveCursor NormalCursor OriginCursor ReadCursor ResizeLeftCursor ResizeTopCursor ResizeTopLeftCursor ResizeTopRightCursor RightArrowCursor SquareCursor TopLeftCursor TopRightCursor UpCursor WaitCursor WebLinkCursor WriteCursor XeqCursor'
		poolDictionaries: ''
		category: 'Graphics-Display Objects'.

	"Safe. Only called by code that's part of the RVM packages."
	team aboutToModifyClass: DisplayScreen.
	Form subclass: #DisplayScreen
		instanceVariableNames: 'clippingBox extraRegions'
		classVariableNames: 'DeferringUpdates DisplayChangeSignature ScreenSave'
		poolDictionaries: ''
		category: 'Graphics-Display Objects'.

	team revertToOldVersionOrRemove: (Controller methodNamed: #controlLoop).
	team revertToOldVersionOrRemove: (Controller methodNamed: #killCounter).
	team revertToOldVersionOrRemove: (Controller methodNamed: #killCounter:).
	team revertToOldVersionOrRemove: (Controller methodNamed: #lastProcessRunningMe).
	team revertToOldVersionOrRemove: (Controller methodNamed: #lastProcessRunningMe:).
	team aboutToModifyClass: Controller.
	Object subclass: #Controller
		instanceVariableNames: 'model view sensor lastActivityTime'
		classVariableNames: 'MinActivityLapse'
		poolDictionaries: ''
		category: 'Kernel-ST80 Remnants'.

	team revertToOldVersionOrRemove: (Paragraph methodNamed: #displayOn:lines:).
	team revertToOldVersionOrRemove: (Paragraph methodNamed: #compositionRectangle:text:style:offset:).
	team revertToOldVersionOrRemove: (Paragraph methodNamed: #destFormSema:).
	team aboutToModifyClass: Paragraph.
	DisplayText subclass: #Paragraph
		instanceVariableNames: 'clippingRectangle compositionRectangle destinationForm rule mask marginTabsLevel lines lastLine'
		classVariableNames: ''
		poolDictionaries: 'TextConstants'
		category: 'ST80-Support'.

	team revertToOldVersionOrRemove: (ControlManager methodNamed: #restore).
	team revertToOldVersionOrRemove: (StandardSystemView methodNamed: #deEmphasizeLabel).
	team revertToOldVersionOrRemove: (StandardSystemView methodNamed: #emphasizeLabel).
	team revertToOldVersionOrRemove: (StandardSystemView methodNamed: #displayEmphasized).
	team revertToOldVersionOrRemove: (StandardSystemView methodNamed: #displayDeEmphasized).
	team revertToOldVersionOrRemove: (StandardSystemView methodNamed: #critical:).
	team revertToOldVersionOrRemove: (StandardSystemView methodNamed: #resetDisplayInterlock).
	team revertToOldVersionOrRemove: (StandardSystemView methodNamed: #displayInterlock).
	team revertToOldVersionOrRemove: (StandardSystemView methodNamed: #displayInterlock:).
	team aboutToModifyClass: StandardSystemView.
	View subclass: #StandardSystemView
		instanceVariableNames: 'labelFrame labelText isLabelComplemented savedSubViews minimumSize maximumSize collapsedViewport expandedViewport labelBits windowBits bitsValid updatablePanes'
		classVariableNames: 'CacheBits LabelStyle'
		poolDictionaries: ''
		category: 'ST80-Support'.

	"Requires the removal of displayInterlock from StandardSystemView, see above."
	team aboutToModifyClass: Mutex.
	Mutex removeFromSystem.
	SystemOrganization removeCategoryIfEmpty: 'RVMBootstrap'.

	team revertToOldVersionOrRemove: (ChangeList class methodNamed: #getRecentLocatorWithPrompt:).
	team revertToOldVersionOrRemove: (ClassDescription methodNamed: #classComment:stamp:).
	team revertToOldVersionOrRemove: (ClassDescription methodNamed: #printMethodChunk:withPreamble:on:moveSource:toFile:).
	team revertToOldVersionOrRemove: (CompiledMethod methodNamed: #putSource:fromParseNode:inFile:withPreamble:).
	team revertToOldVersionOrRemove: (RemoteString methodNamed: #string:onFileNumber:).
	team revertToOldVersionOrRemove: (RemoteString methodNamed: #text).
	team revertToOldVersionOrRemove: (SmalltalkImage methodNamed: #assureStartupStampLogged).
	team revertToOldVersionOrRemove: (SmalltalkImage methodNamed: #logChange:).
	team revertToOldVersionOrRemove: (SystemDictionary methodNamed: #snapshot:andQuit:embedded:).
	team revertToOldVersionOrRemove: (SystemDictionary methodNamed: #writeRecentCharacters:toFileNamed:).
	team revertToOldVersionOrRemove: (StandardSourceFileArray class methodNamed: #install).
	team revertToOldVersionOrRemove: (StandardFileStream class methodNamed: #resetAllInterlocks).
	team revertToOldVersionOrRemove: (StandardFileStream methodNamed: #resetInterlock).
	team revertToOldVersionOrRemove: (StandardFileStream methodNamed: #safelyDo:).
	team revertToOldVersionOrRemove: (StandardFileStream methodNamed: #interlock).
	team revertToOldVersionOrRemove: (StandardFileStream methodNamed: #interlock:).
	team aboutToModifyClass: StandardFileStream.
	FileStream subclass: #StandardFileStream
		instanceVariableNames: 'name fileID buffer1'
		classVariableNames: 'Registry'
		poolDictionaries: ''
		category: 'System-Files'.

	"Safe. There are no users of the VersionString class variable."	
	team aboutToModifyClass: SystemDictionary.
	IdentityDictionary subclass: #SystemDictionary
		instanceVariableNames: 'cachedClassNames'
		classVariableNames: 'LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore MemoryHogs ShutDownList SpecialSelectors StartUpList StartupStamp'
		poolDictionaries: ''
		category: 'System-Support'.

	"Safe. The methods using this are all in the RVM category."
	team aboutToModifyClass: PopUpMenu.
	Object subclass: #PopUpMenu
		instanceVariableNames: 'labelString font lineArray frame form marker selection'
		classVariableNames: 'CacheMenuForms MenuStyle'
		poolDictionaries: ''
		category: 'Tools-Menus'.


	"team revertToOldVersionOrRemove: (Debugger methodNamed: #installListFontInto:)."

	team revertToOldVersionOrRemove: (Process methodNamed: #nilMyListUnlessRVM).
	team revertToOldVersionOrRemove: (ProcessorScheduler methodNamed: #areRunningProcessesInSchedulerLists).
	team revertToOldVersionOrRemove: (ProcessBrowser methodNamed: #updateStackList:).
	team revertToOldVersionOrRemove: (Process methodNamed: #popTo:).
	team revertToOldVersionOrRemove: (ProcessorScheduler methodNamed: #isActive:).

	team revertToOldVersionOrRemove: (BlockContext methodNamed: #valueUnpreemptively).
	team revertToOldVersionOrRemove: (CPUWatcher methodNamed: #debugProcess:).
	team revertToOldVersionOrRemove: (ControlManager methodNamed: #inActiveControllerProcess).
	team revertToOldVersionOrRemove: (ControlManager methodNamed: #interruptName:).
	team revertToOldVersionOrRemove: (ControlManager methodNamed: #resetActiveController).
	team revertToOldVersionOrRemove: (ControlManager methodNamed: #scheduleActiveNoTerminate:).
	team revertToOldVersionOrRemove: (ControlManager methodNamed: #searchForActiveController).
	team revertToOldVersionOrRemove: (Debugger methodNamed: #debug).
	team revertToOldVersionOrRemove: (Debugger class methodNamed: #context:isolationHead:).
	team revertToOldVersionOrRemove: (Debugger class methodNamed: #openContext:label:contents:).
	team revertToOldVersionOrRemove: (Process methodNamed: #debugWithTitle:).
	team revertToOldVersionOrRemove: (Process methodNamed: #pvtSignal:list:).
	team revertToOldVersionOrRemove: (Process methodNamed: #signal:).
	team revertToOldVersionOrRemove: (ProcessorScheduler methodNamed: #activePriority).
	team revertToOldVersionOrRemove: (ProcessorScheduler methodNamed: #terminateActive).
	team revertToOldVersionOrRemove: (Project methodNamed: #enterForEmergencyRecovery).
	team revertToOldVersionOrRemove: (Project class methodNamed: #spawnNewProcessAndTerminateOld:).
	team revertToOldVersionOrRemove: (SyntaxError class methodNamed: #open:).
	team revertToOldVersionOrRemove: (SystemDictionary methodNamed: #handleUserInterrupt).
	team revertToOldVersionOrRemove: (UnhandledError methodNamed: #devDefaultAction).
	"aaa - There's no old version for spyEvery:on: in the current image. Blecch."
	team revertToOldVersionOrRemove: (ProcessorScheduler methodNamed: #thisProcess).

	team revertToOldVersionOrRemove: (Process methodNamed: #isRunning).
	team revertToOldVersionOrRemove: (Process methodNamed: #synchronousSuspend).

	team revertToOldVersionOrRemove: (Debugger class methodNamed: #openInterrupt:onProcess:).
	team revertToOldVersionOrRemove: (MessageTally methodNamed: #spyEvery:onProcess:forMilliseconds:).
	team revertToOldVersionOrRemove: (ParagraphEditor methodNamed: #debug:receiver:in:).
	team revertToOldVersionOrRemove: (Process methodNamed: #suspendedContextWaitingIfNecessary).

	team revertToOldVersionOrRemove: (ContextPart methodNamed: #contextStackIn:).
	team revertToOldVersionOrRemove: (ContextPart methodNamed: #stackOfSize:in:).
	team revertToOldVersionOrRemove: (ContextPart methodNamed: #senderOrSlyInvokerAndProcessIn:).
	team revertToOldVersionOrRemove: (ContextPart methodNamed: #senderOrSlyInvokerIn:).

	team revertToOldVersionOrRemove: (Object methodNamed: #primitiveGetExtraPreheaderWord:).
	team revertToOldVersionOrRemove: (Object methodNamed: #primitiveSetExtraPreheaderWord:).
	team revertToOldVersionOrRemove: (Object methodNamed: #primitiveSetExtraWordSelector:).

	team revertToOldVersionOrRemove: (Process methodNamed: #beSlyMemberProcess).
	team revertToOldVersionOrRemove: (Process methodNamed: #addChild:).
	team revertToOldVersionOrRemove: (Process methodNamed: #myGenerationAndTheirDescendantsDo:).
	team revertToOldVersionOrRemove: (Process methodNamed: #siblingsAndTheirDescendantsDo:).
	team revertToOldVersionOrRemove: (Process methodNamed: #descendantsDo:).
	team revertToOldVersionOrRemove: (Process methodNamed: #myGeneration).
	team revertToOldVersionOrRemove: (Process methodNamed: #siblings).

	team revertToOldVersionOrRemove: (ProcessorScheduler methodNamed: #debugMemberProcesses).
	team revertToOldVersionOrRemove: (ProcessorScheduler methodNamed: #suspendMemberProcesses).
	team revertToOldVersionOrRemove: (ProcessorScheduler methodNamed: #terminateMemberProcesses).
	team revertToOldVersionOrRemove: (ProcessorScheduler methodNamed: #memberProcesses).
	team revertToOldVersionOrRemove: (ProcessorScheduler methodNamed: #userBackgroundPriority).

	team revertToOldVersionOrRemove: (TranscriptStream methodNamed: #toggleShowInConsole).
	team revertToOldVersionOrRemove: (TranscriptStream class methodNamed: #toggleShowInConsole).
	team revertToOldVersionOrRemove: (TranscriptStream methodNamed: #showInConsoleSwitch).
	team revertToOldVersionOrRemove: (TranscriptStream methodNamed: #showInConsole).
	team revertToOldVersionOrRemove: (TranscriptStream methodNamed: #showInConsole:).

	team revertToOldVersionOrRemove: (Object methodNamed: #longPrintOn:).
	team revertToOldVersionOrRemove: (Behavior methodNamed: #longPrintOn:).
	team revertToOldVersionOrRemove: (Process methodNamed: #longPrintOn:).
	team revertToOldVersionOrRemove: (MethodContext methodNamed: #printOn:).
	team revertToOldVersionOrRemove: (Inspector methodNamed: #selectionPrintString).
	team revertToOldVersionOrRemove: (Controller methodNamed: #interActivityPause).
	team revertToOldVersionOrRemove: (ContextPart methodNamed: #tempsAndValues).
	team revertToOldVersionOrRemove: (CompiledMethod methodNamed: #longPrintOn:indent:).
	team revertToOldVersionOrRemove: (BlockContext methodNamed: #printOn:).

	team revertToOldVersionOrRemove: (BitBlt methodNamed: #copyBits).
	team revertToOldVersionOrRemove: (BitBlt methodNamed: #drawFrom:to:withFirstPoint:).
	team revertToOldVersionOrRemove: (BitBlt methodNamed: #drawLoopX:Y:).
	team aboutToModifyClass: RVMPrimitivesNeededForBootstrapping.
	RVMPrimitivesNeededForBootstrapping removeFromSystem.
	SystemOrganization removeCategoryIfEmpty: 'RVMBootstrap'.
	team aboutToModifyClass: RVMObject.
	RVMObject removeFromSystem.
	SystemOrganization removeCategoryIfEmpty: 'RVMBootstrap'.
	team aboutToModifyClass: RenaissanceTransporter.
	RenaissanceTransporter removeFromSystem.
	SystemOrganization removeCategoryIfEmpty: 'RVMBootstrap'.
	team aboutToModifyClass: RVMBootstrapPackage.
	RVMBootstrapPackage removeFromSystem.
	SystemOrganization removeCategoryIfEmpty: 'RVMBootstrap'.
	
	team revertToOldVersionOrRemove: (Process methodNamed: #errorHandler).
	team revertToOldVersionOrRemove: (Process methodNamed: #errorHandler:).
	team revertToOldVersionOrRemove: (Process methodNamed: #myList).
	team revertToOldVersionOrRemove: (Process methodNamed: #myList:).
	team revertToOldVersionOrRemove: (Process methodNamed: #activateReturn:value:).
	team revertToOldVersionOrRemove: (Process methodNamed: #complete:).
	team revertToOldVersionOrRemove: (Process methodNamed: #isActiveProcess).
	team revertToOldVersionOrRemove: (Process methodNamed: #primitiveSuspend).
	team revertToOldVersionOrRemove: (Process methodNamed: #return:value:).
	team revertToOldVersionOrRemove: (Process methodNamed: #step).
	team revertToOldVersionOrRemove: (Process methodNamed: #stepToCallee).
	team revertToOldVersionOrRemove: (Process methodNamed: #stepToSendOrReturn).

	team revertToOldVersionOrRemove: (BlockContext methodNamed: #forkWith:).
	team revertToOldVersionOrRemove: (BlockContext methodNamed: #newProcessWith:).
	team revertToOldVersionOrRemove: (Process class methodNamed: #forContext:priority:).
	
	team revertToOldVersionOrRemove: (Transcripter methodNamed: #readEvalPrint).
	team revertToOldVersionOrRemove: (ProcessorScheduler methodNamed: #removeAllPossible).
	team revertToOldVersionOrRemove: (ProcessorScheduler methodNamed: #terminatableProcesses).
	
	team revertToOldVersionOrRemove: (BitBlt methodNamed: #OLDcopyBits).
	team revertToOldVersionOrRemove: (BitBlt methodNamed: #copyBitsLocally).
	team revertToOldVersionOrRemove: (BitBlt methodNamed: #copyBitsOnMain).
	team revertToOldVersionOrRemove: (BitBlt methodNamed: #drawLoopLocallyX:Y:).
	team revertToOldVersionOrRemove: (BitBlt methodNamed: #globalDrawLoopX:Y:).
	team revertToOldVersionOrRemove: (BitBlt methodNamed: #localDrawLoopX:Y:).
	
! !

!RVMBootstrapPackage methodsFor: 'as yet unclassified' stamp: 'sm 5/25/2011 20:10'!
trickyModificationsManuallyCollected
	^ {
		{ 'SystemDictionary'. 'logError:inContext:onConsoleAndQuitWithSaving:' }.
		
		{ 'BitBlt'. 'localDrawLoopX:Y:' }.
		{ 'BitBlt'. 'globalDrawLoopX:Y:' }.
		{ 'BitBlt'. 'drawLoopLocallyX:Y:' }.
		{ 'BitBlt'. 'copyBitsOnMain' }.
		{ 'BitBlt'. 'copyBitsLocally' }.
		{ 'BitBlt'. 'OLDcopyBits' }.
		{ 'BitBlt class'. 'exampleColorMap' }.
		
		"Changes to Name Processes"
		"TODO: STEFAN find a better way to manage these changes, don't want to change method category"
		{ 'WeakArray class'. 'restartFinalizationProcess' }.
		{ 'SystemDictionary'. 'installLowSpaceWatcher' }.
		{ 'InputSensor'. 'installInterruptWatcher' }.
		{ 'EventSensor'. 'installEventTickler' }.
		{ 'Delay class'. 'startTimerInterruptWatcher' }.
		{ 'CPUWatcher class'. 'startMonitoringPeriod:rate:threshold:' }.
		"{ 'Controller'. 'controlLoop' }." "Was included already later"

		"STEFAN: other base system changes where I do not know how to handle it better."
		{ 'Integer'. 'atRandom' }.
		{ 'Integer'. 'hasContentsInExplorer' }.
		{ 'Integer'. 'printeth' }.
		{ 'Array'. 'asRunArray' }.
		{ 'Array'. 'isArray' }.
		{ 'Association'. 'outlineString' }.

		{ 'ProcessorScheduler'. 'terminatableProcesses' }.
		{ 'ProcessorScheduler'. 'removeAllPossible' }.
		{ 'Transcripter'. 'readEvalPrint' }.

		{ 'Process class'. 'forContext:priority:' }.
		{ 'BlockContext'. 'newProcessWith:' }.
		{ 'BlockContext'. 'forkWith:' }.

		{ 'Process'. 'stepToSendOrReturn' }.
		{ 'Process'. 'stepToCallee' }.
		{ 'Process'. 'step' }.
		{ 'Process'. 'return:value:' }.
		{ 'Process'. 'primitiveSuspend' }.
		{ 'Process'. 'isActiveProcess' }.
		{ 'Process'. 'complete:' }.
		{ 'Process'. 'activateReturn:value:' }.
		{ 'Process'. 'myList:' }.
		{ 'Process'. 'myList' }.
		{ 'Process'. 'errorHandler:' }.
		{ 'Process'. 'errorHandler' }.

		{ 'RVMObject' }.
		{ 'RVMPrimitivesNeededForBootstrapping' }.
		{ 'RVMPrimitivesNeededForBootstrapping class'. 'getCoreHolding:' }.
		{ 'RVMPrimitivesNeededForBootstrapping class'. 'getEmergencySemaphore' }.
		{ 'RVMPrimitivesNeededForBootstrapping class'. 'getReadWriteOf:' }.
		{ 'RVMPrimitivesNeededForBootstrapping class'. 'isRVM' }.
		{ 'RVMPrimitivesNeededForBootstrapping class'. 'primitivGetCoreHolding:' }.
		{ 'RVMPrimitivesNeededForBootstrapping class'. 'printPrefixFor:' }.
		{ 'RVMPrimitivesNeededForBootstrapping class'. 'setEmergencySemaphore:' }.
		{ 'BitBlt'. 'drawLoopX:Y:' }.
		{ 'BitBlt'. 'drawFrom:to:withFirstPoint:' }.
		{ 'BitBlt'. 'copyBits' }.
			
		{ 'BlockContext'. 'printOn:' }.
		{ 'CompiledMethod'. 'longPrintOn:indent:' }.
		{ 'ContextPart'. 'tempsAndValues' }.
		{ 'Controller'. 'interActivityPause' }.
		{ 'Inspector'. 'selectionPrintString' }.
		{ 'MethodContext'. 'printOn:' }.
		{ 'Process'. 'longPrintOn:' }.
		{ 'Behavior'. 'longPrintOn:' }.
		{ 'Object'. 'longPrintOn:' }.

		{ 'TranscriptStream'. 'showInConsole:' }.
		{ 'TranscriptStream'. 'showInConsole' }.
		{ 'TranscriptStream'. 'showInConsoleSwitch' }.
		{ 'TranscriptStream class'. 'toggleShowInConsole' }.
		{ 'TranscriptStream'. 'toggleShowInConsole' }.

		{ 'ProcessorScheduler'. 'userBackgroundPriority' }.
		{ 'ProcessorScheduler'. 'memberProcesses' }.
		{ 'ProcessorScheduler'. 'terminateMemberProcesses' }.
		{ 'ProcessorScheduler'. 'suspendMemberProcesses' }.
		{ 'ProcessorScheduler'. 'debugMemberProcesses' }.

		{ 'Process'. 'siblings' }.
		{ 'Process'. 'myGeneration' }.
		{ 'Process'. 'descendantsDo:' }.
		{ 'Process'. 'siblingsAndTheirDescendantsDo:' }.
		{ 'Process'. 'myGenerationAndTheirDescendantsDo:' }.
		{ 'Process'. 'addChild:' }.
		{ 'Process'. 'beSlyMemberProcess' }.

		{ 'Object'. 'primitiveSetExtraWordSelector:' }.
		{ 'Object'. 'primitiveSetExtraPreheaderWord:' }.
		{ 'Object'. 'primitiveGetExtraPreheaderWord:' }.

		{ 'ContextPart'. 'senderOrSlyInvokerIn:' }.
		{ 'ContextPart'. 'senderOrSlyInvokerAndProcessIn:' }.
		{ 'ContextPart'. 'stackOfSize:in:' }.
		{ 'ContextPart'. 'contextStackIn:' }.

		{ 'Process'. 'suspendedContextWaitingIfNecessary' }.
		{ 'ParagraphEditor'. 'debug:receiver:in:' }.
		{ 'MessageTally'. 'spyEvery:onProcess:forMilliseconds:' }.
		{ 'Debugger class'. 'openInterrupt:onProcess:' }.

		{ 'Process'. 'synchronousSuspend' }.
		{ 'Process'. 'isRunning' }.

		{ 'ProcessorScheduler'. 'thisProcess' }.
		{ 'MessageTally'. 'spyEvery:on:' }.
		{ 'UnhandledError'. 'devDefaultAction' }.
		{ 'SystemDictionary'. 'handleUserInterrupt' }.
		{ 'SyntaxError class'. 'open:' }.
		{ 'Project class'. 'spawnNewProcessAndTerminateOld:' }.
		{ 'Project'. 'enterForEmergencyRecovery' }.
		{ 'ProcessorScheduler'. 'terminateActive' }.
		{ 'ProcessorScheduler'. 'activePriority' }.
		{ 'Process'. 'signal:' }.
		{ 'Process'. 'pvtSignal:list:' }.
		{ 'Process'. 'debugWithTitle:' }.
		{ 'Debugger class'. 'openContext:label:contents:' }.
		{ 'Debugger class'. 'context:isolationHead:' }.
		{ 'Debugger'. 'debug' }.
		{ 'ControlManager'. 'searchForActiveController' }.
		{ 'ControlManager'. 'scheduleActiveNoTerminate:' }.
		{ 'ControlManager'. 'resetActiveController' }.
		{ 'ControlManager'. 'interruptName:' }.
		{ 'ControlManager'. 'inActiveControllerProcess' }.
		{ 'CPUWatcher'. 'debugProcess:' }.
		{ 'BlockContext'. 'valueUnpreemptively' }.

		{ 'ProcessorScheduler'. 'isActive:' }.
		{ 'Process'. 'popTo:' }.
		{ 'ProcessBrowser'. 'updateStackList:' }.
		{ 'ProcessorScheduler'. 'areRunningProcessesInSchedulerLists' }.
		{ 'Process'. 'nilMyListUnlessRVM' }.

		"{ 'Debugger'. 'installListFontInto:' }."


		{ 'PopUpMenu' }.

		{ 'SystemDictionary' }.

		{ 'StandardFileStream' }.
		{ 'StandardFileStream'. 'interlock:' }.
		{ 'StandardFileStream'. 'interlock' }.
		{ 'StandardFileStream'. 'safelyDo:' }.
		{ 'StandardFileStream'. 'resetInterlock' }.
		{ 'StandardFileStream class'. 'resetAllInterlocks' }.
		{ 'StandardSourceFileArray class'. 'install' }.
		{ 'SystemDictionary'. 'writeRecentCharacters:toFileNamed:' }.
		{ 'SystemDictionary'. 'snapshot:andQuit:embedded:' }.
		{ 'SmalltalkImage'. 'logChange:' }.
		{ 'SmalltalkImage'. 'assureStartupStampLogged' }.
		{ 'RemoteString'. 'text' }.
		{ 'RemoteString'. 'string:onFileNumber:' }.
		{ 'CompiledMethod'. 'putSource:fromParseNode:inFile:withPreamble:' }.
		{ 'ClassDescription'. 'printMethodChunk:withPreamble:on:moveSource:toFile:' }.
		{ 'ClassDescription'. 'classComment:stamp:' }.
		{ 'ChangeList class'. 'getRecentLocatorWithPrompt:' }.

		{ 'Mutex' }.
		{ 'Mutex'. 'critical:' }.
		{ 'Mutex'. 'initialize' }.
		{ 'Mutex class'. 'forMutualExclusion' }.

		{ 'StandardSystemView' }.
		{ 'StandardSystemView'. 'displayInterlock:' }.
		{ 'StandardSystemView'. 'displayInterlock' }.
		{ 'StandardSystemView'. 'resetDisplayInterlock' }.
		{ 'StandardSystemView'. 'critical:' }.
		{ 'StandardSystemView'. 'displayDeEmphasized' }.
		{ 'StandardSystemView'. 'displayEmphasized' }.
		{ 'StandardSystemView'. 'emphasizeLabel' }.
		{ 'StandardSystemView'. 'deEmphasizeLabel' }.
		{ 'ControlManager'. 'restore' }.

		{ 'Paragraph' }.
		{ 'Paragraph'. 'destFormSema:' }.
		{ 'Paragraph'. 'compositionRectangle:text:style:offset:' }.
		{ 'Paragraph'. 'displayOn:lines:' }.

		{ 'Controller' }.
		{ 'Controller'. 'lastProcessRunningMe:' }.
		{ 'Controller'. 'lastProcessRunningMe' }.
		{ 'Controller'. 'killCounter:' }.
		{ 'Controller'. 'killCounter' }.
		{ 'Controller'. 'controlLoop' }.

		{ 'DisplayScreen' }.

		{ 'Cursor' }.
		{ 'Cursor class'. 'initialize' }.

		{ 'AnimatedGIFReadWriter' }.
		
		{ 'Collection' }.
		
		{ 'TranscriptStream' }.
		{ 'TranscriptStream class'. 'showInConsole:' }.
		{ 'TranscriptStream class'. 'showInConsole' }.

		{ 'Process' }.
		{ 'Process'. 'creatorEnsemble:' }.
		{ 'Process'. 'creatorEnsemble' }.
		{ 'Process'. 'parent:' }.
		{ 'Process'. 'parent' }.
		{ 'Process'. 'children:' }.
		{ 'Process'. 'children' }.
		{ 'Process class'. 'semaForSupensions' }.
		{ 'Process'. 'terminate' }.
		{ 'Process'. 'suspend' }.
		{ 'Process'. 'resume' }.
		{ 'Process'. 'debug:title:full:' }.
		{ 'Debugger'. 'fullyExpandStack' }.

		{ 'ProcessorScheduler' }.
		{ 'ProcessBrowser class'. 'nameAndRulesFor:' }.
		{ 'ProcessorScheduler class'. 'startUp' }.
		{ 'ProcessorScheduler class'. 'startEmergencyProcess' }.
		{ 'ProcessorScheduler class'. 'emergencyProcess' }.
		
		{ 'RVMBootstrapPackage' }.
		{ 'RVMBootstrapPackage'. 'trickyModificationsThatNeedToBeDoneInOrder' }.
		{ 'RVMBootstrapPackage'. 'revertToVersionBeforeTeam:' }.

		{ 'RenaissanceTransporter' }.
		{ 'RenaissanceTransporter'. 'initialize' }.
		{ 'RenaissanceTransporter'. 'initializePackage' }.
		{ 'RenaissanceTransporter'. 'initializePreambleAndPostscript' }.
		{ 'RenaissanceTransporter'. 'initializeTeam' }.
		{ 'RenaissanceTransporter'. 'revert' }.
		{ 'RenaissanceTransporter class'. 'transportersForFileOutMenu' }. 
	}! !

!RVMBootstrapPackage methodsFor: 'as yet unclassified' stamp: 'sm 3/11/2011 22:09'!
trickyModificationsThatNeedToBeDoneInOrder
	| trickyStuff |
	trickyStuff := OrderedCollection new.
	trickyStuff addAll: self trickyModificationsManuallyCollected.
	trickyStuff addAll: self moreModificationsByTheRenaissanceTeam1.
	trickyStuff addAll: self moreModificationsByTheRenaissanceTeam2.
	trickyStuff addAll: self moreModificationsByTheRenaissanceTeam3.
	trickyStuff addAll: self moreModificationsByTheRenaissanceTeam4.
	trickyStuff addAll: self moreModificationsByTheRenaissanceTeam5.
	^ trickyStuff.! !

!RVMButtonController methodsFor: 'basic control sequence' stamp: 'ssa 1/1/1970 01:12'!
redButtonActivity

	| aborted lastAborted |
	self view displayPressed.
	lastAborted _ false.
	aborted _ true.
	[Sensor redButtonPressed] whileTrue:[
		aborted _ (self view insetDisplayBox containsPoint: Sensor cursorPoint) not.
		aborted & lastAborted not ifTrue:[self view displayView.
									lastAborted _ true].
		aborted not & lastAborted ifTrue:[self view displayPressed.
									lastAborted _ false]].
	self view displayView.
	aborted ifFalse:[self view performAction]! !

!RVMButtonController methodsFor: 'controlling' stamp: 'ssa 10/3/2008 20:53'!
controlInitialize
	self view style ~~ #raisedGray ifTrue:[Cursor action show].
	super controlInitialize! !

!RVMButtonController methodsFor: 'controlling' stamp: 'ssa 9/19/2008 12:04'!
controlTerminate
	Cursor normal show.
	super controlTerminate! !

!RVMButtonView methodsFor: 'displaying' stamp: 'ssa 9/19/2008 12:19'!
displayAction
	"Let the controller indicate action available"
	self displayLabel.
! !

!RVMButtonView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 16:03'!
displayLabel
	| labelRect labelText labelForm |
	labelText := self label asDisplayText .
	labelText foregroundColor: Color black
			backgroundColor: Color transparent.
	labelForm := labelText asParagraph asForm.
	labelForm width > self insetDisplayBox width ifTrue:[labelForm _ labelForm scaledToSize:self insetDisplayBox width@labelForm height].
	labelForm height > self insetDisplayBox height ifTrue:[labelForm _ labelForm scaledToSize: labelForm width@self insetDisplayBox height].
	labelRect := self insetDisplayBox.
	Display fill: self insetDisplayBox fillColor: Color white.
	labelForm displayOn: Display at: labelRect center - labelForm boundingBox center clippingBox: labelRect
			rule: Form paint fillColor: nil.
! !

!RVMButtonView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 03:09'!
displayLabelDark
	| labelRect labelText labelForm |
	labelText := self label asDisplayText .
	labelText foregroundColor: Color black
			backgroundColor: Color transparent.
	labelForm := labelText asParagraph asForm.
	labelForm width > self insetDisplayBox width ifTrue:[labelForm _ labelForm scaledToSize:self insetDisplayBox width@labelForm height].
	labelForm height > self insetDisplayBox height ifTrue:[labelForm _ labelForm scaledToSize: labelForm width@self insetDisplayBox height].
	labelRect := self insetDisplayBox.
	Display fill: self insetDisplayBox fillColor: self baseColorDark.
	labelForm displayOn: Display at: labelRect center - labelForm boundingBox center clippingBox: labelRect
			rule: Form erase fillColor: nil.
! !

!RVMButtonView methodsFor: 'displaying' stamp: 'ssa 9/19/2008 12:22'!
displayOutline

	self displayLabel.
	Display border: (self insetDisplayBox insetBy: 1)width: 1 fillColor: Color black.! !

!RVMButtonView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 03:02'!
displayPressed
	self displayLabelDark.
	Display border: (self insetDisplayBox insetBy: 0@0) width:2 fillColor: self baseColor.
	Display border: (self insetDisplayBox insetBy: 2@2) width:2 fillColor: self baseColor  darker.
	Display border: (self insetDisplayBox insetBy: 4@4) width:2 fillColor: self baseColor darker darker.
	Display border: (self insetDisplayBox insetBy: 6@6) width:2 fillColor: self baseColor darker darker darker.
! !

!RVMButtonView methodsFor: 'displaying' stamp: 'ssa 3/24/2010 17:07'!
displayRaisedGray
	self displayRaisedWhiteLabel.
	self displayRaisedLabel.
	Display border: (self insetDisplayBox insetBy: 0@0) widthRectangle: (1@1 corner: 0@0) rule: Form paint fillColor: self baseColor.
	Display border: (self insetDisplayBox insetBy: 0@0) widthRectangle: (0@0 corner: 1@1) rule: Form paint fillColor: self baseColor darker darker darker.
	
	Display border: (self insetDisplayBox insetBy: 1@1) widthRectangle: (1@1 corner: 0@0) rule: Form paint fillColor: self baseColor lighter.
	Display border: (self insetDisplayBox insetBy: 1@1) widthRectangle: (0@0 corner: 1@1) rule: Form paint fillColor: self baseColor darker  darker.
	
	Display border: (self insetDisplayBox insetBy: 2@2) widthRectangle: (1@1 corner: 0@0) rule: Form paint fillColor: self baseColor lighter lighter.
	Display border: (self insetDisplayBox insetBy: 2@2) widthRectangle: (0@0 corner: 1@1) rule: Form paint fillColor: self baseColor darker.
	
	Display border: (self insetDisplayBox insetBy: 3@3) widthRectangle: (1@1 corner: 0@0) rule: Form paint fillColor: self baseColor lighter.
	Display border: (self insetDisplayBox insetBy: 3@3) widthRectangle: (0@0 corner: 1@1) rule: Form paint fillColor: self baseColor .
! !

!RVMButtonView methodsFor: 'displaying' stamp: 'ssa 2/22/2010 15:34'!
displayRaisedLabel
	| labelRect labelText labelForm |
	labelText := self label asDisplayText .

	labelText foregroundColor: Color black
			backgroundColor: Color transparent.
	labelForm := labelText asParagraph asForm.
	labelForm width > self insetDisplayBox width ifTrue:[labelForm _ labelForm scaledToSize:self insetDisplayBox width@labelForm height].
	labelForm height > self insetDisplayBox height ifTrue:[labelForm _ labelForm scaledToSize: labelForm width@self insetDisplayBox height].
	labelRect := self insetDisplayBox.
	"Display fill: self insetDisplayBox fillColor: self baseColor."
	labelForm displayOn: Display at: labelRect center - labelForm boundingBox center - (0@3)clippingBox: labelRect
			rule: Form paint fillColor: nil.
! !

!RVMButtonView methodsFor: 'displaying' stamp: 'ssa 2/22/2010 15:37'!
displayRaisedWhiteLabel
	| labelRect labelText labelForm |
	labelText := self label asDisplayText .

	labelText foregroundColor: self  baseColor lighter lighter
			backgroundColor: Color transparent.
	labelForm := labelText asParagraph asForm.
	labelForm width > self insetDisplayBox width ifTrue:[labelForm _ labelForm scaledToSize:self insetDisplayBox width@labelForm height].
	labelForm height > self insetDisplayBox height ifTrue:[labelForm _ labelForm scaledToSize: labelForm width@self insetDisplayBox height].
	labelRect := self insetDisplayBox.
	Display fill: self insetDisplayBox fillColor: self baseColor.
	labelForm displayOn: Display at: labelRect center - labelForm boundingBox center - (0@3)+(1@1)clippingBox: labelRect
			rule: Form paint fillColor: nil.
! !

!RVMButtonView methodsFor: 'displaying' stamp: 'ssa 9/19/2008 12:15'!
displayView
	self style == #raisedGray ifTrue:[self displayRaisedGray].
	self style == #outline ifTrue:[self displayOutline].
	self style == #action ifTrue:[self displayAction].
	! !

!RVMButtonView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:03'!
action
	"Answer the value of action, a block to execute when the button is released"

	action isNil ifTrue:[self action: [self inform:'no action defined yet']].
	^ action! !

!RVMButtonView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:02'!
action: anObject
	"Set the value of action"

	action _ anObject! !

!RVMButtonView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 02:47'!
baseColor
	^Color gray lighter lighter lighter! !

!RVMButtonView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 03:02'!
baseColorDark
	^Color gray ! !

!RVMButtonView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:42'!
label
	"Answer the value of label"

	label isNil ifTrue:[self label: 'not labeled yet'].
	^ label! !

!RVMButtonView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:02'!
label: anObject
	"Set the value of label"

	label _ anObject! !

!RVMButtonView methodsFor: 'accessing' stamp: 'ssa 9/19/2008 12:14'!
style
	"Answer the value of style. how I should display myself.
	Current options are #raisedGray, #outline, #action"

	style isNil ifTrue:[self style: #raisedGray].
	^ style! !

!RVMButtonView methodsFor: 'accessing' stamp: 'ssa 9/19/2008 12:13'!
style: anObject
	"Set the value of style"

	style _ anObject! !

!RVMButtonView methodsFor: 'actions' stamp: 'ssa 1/1/1970 00:10'!
performAction

	self action copy value! !

!RVMButtonView methodsFor: 'controller access' stamp: 'ssa 1/1/1970 00:25'!
defaultControllerClass

	^RVMButtonController! !

!RVMButtonView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:27'!
example
	"RVMButtonView example"
	| topView |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 50@25.
	topView maximumSize: 200@200.
	topView addSubView: (self label:'Flash' action:[Display reverse reverse]).
	topView label: 'RVMButtonView test'.
	topView controller open! !

!RVMButtonView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 02:59'!
exampleGC
	"RVMButtonView exampleGC"
	| topView |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 50@25.
	topView maximumSize: 200@200.
	topView addSubView: (self label:'GC' action:[Smalltalk garbageCollect print]).
	topView label: 'RVMButtonView test'.
	topView controller open! !

!RVMButtonView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:43'!
exampleLong
	"RVMButtonView exampleLong"
	| topView |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 50@25.
	topView maximumSize: 200@200.
	topView addSubView: (self label:'Flash the display by reversing twice' action:[Display reverse reverse]).
	topView label: 'RVMButtonView test'.
	topView controller open! !

!RVMButtonView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 01:43'!
exampleTall
	"RVMButtonView exampleTall"
	| topView |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 50@25.
	topView maximumSize: 200@200.
	topView addSubView: (self label:'	Flash 
	the 
	display 
	by 
	reversing 
	twice' action:[Display reverse reverse]).
	topView label: 'RVMButtonView test'.
	topView controller open! !

!RVMButtonView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:30'!
label: aString action: aBlock

	| v |
	v _ self new.
	v label: aString.
	v action: aBlock.
	^v  ! !

!RVMButtonView class methodsFor: 'instance creation' stamp: 'ssa 9/19/2008 12:21'!
label: aString style: aSymbol action: aBlock

	| v |
	v _ self new.
	v label: aString.
	v style: aSymbol.
	v action: aBlock.
	^v  ! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:07'!
cyclesSinceLastQuery
	"Answer the value of cyclesSinceLastQuery"

	cyclesSinceLastQuery isNil ifTrue:[self cyclesSinceLastQuery: 0].
	^cyclesSinceLastQuery! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:07'!
cyclesSinceLastQuery: anObject
	"Set the value of cyclesSinceLastQuery"

	cyclesSinceLastQuery := anObject! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'dmu 1/5/2011 12:48'!
gcMilliseconds
	^ self memorySystemStats gcMilliseconds! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 18:22'!
memorySystemStats
	"Answer the value of memorySystemStats"

	memorySystemStats isNil ifTrue:[self memorySystemStats: RVMMemorySystemStats new].
	^memorySystemStats! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:07'!
memorySystemStats: anObject
	"Set the value of memorySystemStats"

	memorySystemStats := anObject! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:49'!
messageNames
	"Answer the value of messageNames"

	messageNames isNil ifTrue:[self messageNames: nil].
	^messageNames! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:49'!
messageNames: anObject
	"Set the value of messageNames"

	messageNames := anObject! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:08'!
millisecondsSinceLastQuery
	"Answer the value of millisecondsSinceLastQuery"

	millisecondsSinceLastQuery isNil ifTrue:[self millisecondsSinceLastQuery: 0].
	^millisecondsSinceLastQuery! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:07'!
millisecondsSinceLastQuery: anObject
	"Set the value of millisecondsSinceLastQuery"

	millisecondsSinceLastQuery := anObject! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:58'!
myRank
	"Answer the value of myRank"

	myRank isNil ifTrue:[self myRank: nil].
	^myRank! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:58'!
myRank: anObject
	"Set the value of myRank"

	myRank := anObject! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:58'!
myX
	"Answer the value of myX"

	myX isNil ifTrue:[self myX: nil].
	^myX! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:58'!
myX: anObject
	"Set the value of myX"

	myX := anObject! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:58'!
myY
	"Answer the value of myY"

	myY isNil ifTrue:[self myY: nil].
	^myY! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:58'!
myY: anObject
	"Set the value of myY"

	myY := anObject! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 11/16/2008 15:54'!
objectTableStats
	"Answer the value of objectTableStats"

	objectTableStats isNil ifTrue:[self objectTableStats: RVMObjectTableStats new].
	^objectTableStats! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 11/16/2008 15:54'!
objectTableStats: anObject
	"Set the value of objectTableStats"

	objectTableStats := anObject! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:49'!
rawData
	"Answer the value of rawData"

	rawData isNil ifTrue:[self rawData: nil].
	^rawData! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
rawData: anObject
	"Set the value of rawData"

	rawData := anObject! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:12'!
receiveTally
	"Answer the value of receiveTally"

	receiveTally isNil ifTrue:[self receiveTally: nil].
	^receiveTally! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:12'!
receiveTally: anObject
	"Set the value of receiveTally"

	receiveTally := anObject! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 18:20'!
sendTallies
	"Answer the value of sendTallies"

	sendTallies isNil ifTrue:[self sendTallies: OrderedCollection new].
	^sendTallies! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:07'!
sendTallies: anObject
	"Set the value of sendTallies"

	sendTallies := anObject! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 18:11'!
squeakInterpreterStats
	"Answer the value of squeakInterpreterStats"

	squeakInterpreterStats isNil ifTrue:[self squeakInterpreterStats: RVMSqueakInterpreterStats new].
	^squeakInterpreterStats! !

!RVMCPUCoreStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:07'!
squeakInterpreterStats: anObject
	"Set the value of squeakInterpreterStats"

	squeakInterpreterStats := anObject! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 8/19/2008 11:22'!
initializeCoreStatsFrom: data
	| valueMap objectMap target |
	valueMap := { 
				'x' -> #myX:.
				'y' -> #myY:.
				'rank' -> #myRank:.
				}.
	objectMap := {
				'sendTalliesByCore' -> #initializeSendTalliesFrom:.
				'receiveTallies' -> #initializeReceiveTalliesFrom:.			
				}.
	target := self.
				
	self processMap: valueMap into: target forData: data.
	self processMap: objectMap into: target forData: data.! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'dmu 1/1/1970 01:09'!
initializeFastCoreStatsFrom: data

	self myX: (data at: 2).
	self myY: (data at: 4).
	self myRank: (data at: 6).
	
	self initializeFastSendTalliesFrom: (data at: 8).
	self initializeFastReceiveTalliesFrom: (data at: 10).
	
	! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 11/16/2008 15:47'!
initializeFastFrom: data
	"This implementations assumes order dependency in the array for speed.  
	
	Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| target |
	self rawData: data.
	target := self.
	target millisecondsSinceLastQuery: (data at: 2).
	target cyclesSinceLastQuery: (data at: 4).
	target initializeFastCoreStatsFrom: (data at: 6).
	target initializeFastMemorySystemStatsFrom: (data at: 8).
	target initializeFastSqueakInterpreterStatsFrom: (data at: 10).
	target initializeFastObjectTableStatsFrom: (data at: 12).
! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 1/1/1970 00:06'!
initializeFastMemorySystemStatsFrom: data
	"This implementations assumes order dependency in the array for speed.  
	
	Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| target |
	target := self memorySystemStats.
	target gcCount: (data at: 2).
	target gcMilliseconds: (data at: 4).
	target gcCycles: (data at: 6).
	self  initializeFastReadWriteHeapStatsFrom: (data at: 8).
	self initializeFastReadMostlyHeapStatsFrom: (data at: 10).
	! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 11/16/2008 15:53'!
initializeFastObjectTableStatsFrom: data
	"This implementations assumes order dependency in the array for speed.
	
	Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| target |
	target := self objectTableStats.
	target allocatedEntryCount: (data at: 2).
	target entryCount: (data at: 4).
	target allocationsSinceLastQuery: (data at: 6).
	target entriesFreedSinceLastQuery: (data at: 8).
	! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 1/1/1970 00:54'!
initializeFastReadMostlyHeapStatsFrom: data
	"This implementations assumes order dependency in the array for speed.
	
	Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	|  target |
	target := self memorySystemStats readMostlyHeapStats.
	target bytesUsed: (data at: 2).
	target bytesLeft: (data at: 4).
	target allocationsSinceLastQuery: (data at: 4).
	target compactionsSinceLastQuery: (data at: 8).
	! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 1/1/1970 00:54'!
initializeFastReadWriteHeapStatsFrom: data
	"This implementations assumes order dependency in the array for speed.
	
	Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	|  target |
	target := self memorySystemStats readWriteHeapStats.
	target bytesUsed: (data at: 2).
	target bytesLeft: (data at: 4).
	target allocationsSinceLastQuery: (data at: 4).
	target compactionsSinceLastQuery: (data at: 8).
	! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 8/19/2008 11:21'!
initializeFastReceiveTalliesFrom: data
	"data looks like #(395 0 0 1041 1 520 0 0 0 121 0 1 0 1 0 1 28741 10 1 0)
	number of elements based on number of messages tallied"
	
	self receiveTally: (RVMCoreMessageTally fastForData: data)! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 3/25/2009 14:19'!
initializeFastSendTalliesFrom: data
	"data USED TO looks like 
		#('send_tallies' #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
		'send_tallies' #(4 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 11 0 0 0) 
		... as many as we have cores being used)
		number of elements based on number of messages tallied"
	"NOW DATA LOOKS LIKE #(0 0 0 4290 0 0 0 0 0 4840 0 0 55 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 11 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 322 0 0)"
	
	"OLD CODE
	2 to: data size by: 2 do:[:index|
		self sendTallies add: (RVMCoreMessageTally fastForData: (data at: index))]"
	
	"NEW CODE"
	self sendTallies add: (RVMCoreMessageTally fastForData: data )! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 9/9/2008 22:40'!
initializeFastSqueakInterpreterStatsFrom: data
	"This implementations assumes order dependency in the array for speed.  
	
	Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	|  target |
	target := self squeakInterpreterStats.
	target bytecodesExecuted: (data at: 2).
	target yieldCount: (data at: 4).
"	target millisecondsRunning: (data at: 6).
	target millisecondsWaiting: (data at: 8)."
	target cyclesRunning: (data at: 6).
	target cyclesWaiting: (data at: 8).
	target contextChangeCount: (data at: 10).
	target interruptCheckCount: (data at: 12).
	target unforcedInterruptCheckCount: (data at: 14)
	! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 1/1/1970 00:07'!
initializeFastestCoreStatsFrom: data
	"skip the tallies for speed"
	self myX: (data at: 2).
	self myY: (data at: 4).
	self myRank: (data at: 6).
	
"	self initializeFastSendTalliesFrom: (data at: 8).
	self initializeFastReceiveTalliesFrom: (data at: 10)."
	
	! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 11/16/2008 15:48'!
initializeFastestFrom: data
	"This implementations assumes order dependency in the array for speed.  
	
	Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| target |
	self rawData: data.
	target := self.
	target millisecondsSinceLastQuery: (data at: 2).
	target cyclesSinceLastQuery: (data at: 4).
	target initializeFastestCoreStatsFrom: (data at: 6).
	target initializeFastMemorySystemStatsFrom: (data at: 8).
	target initializeFastSqueakInterpreterStatsFrom: (data at: 10).
	target initializeFastObjectTableStatsFrom: (data at: 12).
	! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 11/16/2008 15:48'!
initializeFrom: data
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap objectMap target |
	self rawData: data.
	valueMap := { 
				'millisecs' -> #millisecondsSinceLastQuery:.
				'cycles' -> #cyclesSinceLastQuery:.
				}.
	objectMap := {
				'coreStats' -> #initializeCoreStatsFrom:.
				'memorySystemStats' -> #initializeMemorySystemStatsFrom:.
				'interpreterStats' -> #initializeSqueakInterpreterStatsFrom:.
				'objectTableStats' -> #initializeFastObjectTableStatsFrom:.
				}.
	target := self.
				
	self processMap: valueMap into: target forData: data.
	self processMap: objectMap into: target forData: data.! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 1/1/1970 00:04'!
initializeMemorySystemStatsFrom: data
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap target |
	self rawData: data.
	valueMap := { 
				'gcCount' -> #gcCount:.
				'gcMilliseconds' -> #gcMilliseconds:.
				'gcCycles' -> #gcCycles:.
				'readWriteHeapStats' -> #initializeReadWriteHeapStatsFrom:.
				'readMostlyHeapStats' -> #initializeReadMostlyHeapStatsFrom:.
				}.

	target := self memorySystemStats.
				
	self processMap: valueMap into: target forData: data.
! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 11/16/2008 15:50'!
initializeObjectTableStatsFrom: data
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap objectMap target |
	valueMap := { 
				'allocatedEntryCount[rank]' -> #allocatedEntryCount:.
				'entryCount[rank]' -> #entryCount:.
				'allocationsSinceLastQuery[rank]' -> #allocationsSinceLastQuery:.
				'entriesFreedSinceLastQuery[rank]' -> #entriesFreedSinceLastQuery:.
				}.
	objectMap := {}.
	target := self objectTableStats.
				
	self processMap: valueMap into: target forData: data.
	self processMap: objectMap into: target forData: data.! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 1/1/1970 00:54'!
initializeReadMostlyHeapStatsFrom: data
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap  target |
	valueMap := { 
				'bytesUsed()' -> #bytesUsed:.
				'bytesLeft()' -> #bytesLeft:.
				'allocationsSinceLastQuery' -> #allocationsSinceLastQuery:.
				'compactionsSinceLastQuery' -> #compactionsSinceLastQuery:.
				}.
	target := self memorySystemStats readMostlyHeapStats.
				
	self processMap: valueMap into: target forData: data.
! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 1/1/1970 00:54'!
initializeReadWriteHeapStatsFrom: data
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap  target |
	valueMap := { 
				'bytesUsed()' -> #bytesUsed:.
				'bytesLeft()' -> #bytesLeft:.
				'allocationsSinceLastQuery' -> #allocationsSinceLastQuery:.
				'compactionsSinceLastQuery' -> #compactionsSinceLastQuery:.
				}.
	target := self memorySystemStats readWriteHeapStats.
				
	self processMap: valueMap into: target forData: data.
! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 8/13/2008 18:21'!
initializeReceiveTalliesFrom: data
	"data looks like #(395 0 0 1041 1 520 0 0 0 121 0 1 0 1 0 1 28741 10 1 0)
	number of elements based on number of messages tallied"
	
	self receiveTally: (RVMCoreMessageTally forMessageNames: self messageNames andData: data)! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 8/19/2008 11:31'!
initializeSendTalliesFrom: data
	"data looks like 
		#('send_tallies' #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
		'send_tallies' #(4 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 11 0 0 0) 
		... as many as we have cores being used)
		number of elements based on number of messages tallied"
	
	| tally |
	data do:[:each|
		each = 'sendTallies' ifFalse:[
			tally := RVMCoreMessageTally forMessageNames: self messageNames andData: each.
			self sendTallies add: tally]]! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'ssa 9/9/2008 22:24'!
initializeSqueakInterpreterStatsFrom: data
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap target |
	self rawData: data.
	valueMap := { 
				'bytecodesExecuted' -> #bytecodesExecuted:.
				'yieldCount' -> #yieldCount:.
				'contextChangeCount' -> #contextChangeCount:.
				"'millisecondsRunning' -> #millisecondsRunning:."
				"'millisecondsWaiting' -> #millisecondsWaiting:."
				'cyclesRunning' -> #cyclesRunning:.
				'cyclesWaiting' -> #cyclesWaiting:.
				'contextChangeCount' -> #contextChangeCount:.
				'interruptCheckCount' -> #interruptCheckCount:.
				'unforcedInterruptCheckCount' -> #unforcedInterruptCheckCount:.
				}.

	target := self squeakInterpreterStats.
				
	self processMap: valueMap into: target forData: data.
! !

!RVMCPUCoreStats methodsFor: 'initialize' stamp: 'dmu 8/15/2008 21:03'!
processMap: map into: targetObject forData: data
				
	| index datum |
	map do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[
			assoc key = 'receiveTallies' ifFalse:[self error:'Can''t find ',assoc key,' in sample data']].
		datum := data at: index + 1.
		targetObject perform: assoc value with: datum].
! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:52'!
allocationsSinceLast
	^self allocationsSinceLastReadWrite + self allocationsSinceLastReadMostly! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:56'!
allocationsSinceLastReadMostly
	^self memorySystemStats readMostlyHeapStats allocationsSinceLastQuery! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:56'!
allocationsSinceLastReadWrite
	^self memorySystemStats readWriteHeapStats allocationsSinceLastQuery! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:18'!
bytecodesExecuted
	"Answer the count of bytecodes executed during this sample"
	
	^self squeakInterpreterStats bytecodesExecuted! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 9/17/2010 15:18'!
bytecodesPerMillisecond
	"Answer the ratio of bytecodes executed per ms during this sample"
	
	^(self squeakInterpreterStats bytecodesExectued / (1 max: self millisecondsSinceLastQuery) asFloat ) rounded! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 9/17/2010 15:18'!
bytecodesPerSecond
	"Answer the ratio of bytecodes executed per second during this sample"
	self millisecondsSinceLastQuery = 0 ifTrue:[^0].
	
	^(self squeakInterpreterStats bytecodesExecuted / (1 max: self millisecondsSinceLastQuery) asFloat * 1000) rounded! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:49'!
bytesLeft
	^self bytesLeftReadWrite + self bytesLeftReadMostly! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:49'!
bytesLeftReadMostly
	^self memorySystemStats readMostlyHeapStats bytesLeft ! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:49'!
bytesLeftReadWrite
	^self memorySystemStats readWriteHeapStats bytesLeft ! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:45'!
bytesUsed
	^self bytesUsedReadWrite + self bytesUsedReadMostly! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:44'!
bytesUsedReadMostly
	^self memorySystemStats readMostlyHeapStats bytesUsed ! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 1/1/1970 00:54'!
bytesUsedReadWrite
	^self memorySystemStats readWriteHeapStats bytesUsed ! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:54'!
compactionsSinceLast
	^self compactionsSinceLastReadWrite + self compactionsSinceLastReadMostly! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:57'!
compactionsSinceLastReadMostly
	^self memorySystemStats readMostlyHeapStats compactionsSinceLastQuery! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:56'!
compactionsSinceLastReadWrite
	^self memorySystemStats readWriteHeapStats compactionsSinceLastQuery! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:08'!
contextChangeCount
	"Answer the count of yields  during this sample"
	
	^self squeakInterpreterStats contextChangeCount! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:53'!
cyclesRunWaitRatio
	"Answer the ratio between my cyclesRunning and cyclesWaiting"
	
	^self squeakInterpreterStats cyclesRunWaitRatio! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:46'!
cyclesRunning
	"Answer the count of cycles spent running during this sample"
	
	^self squeakInterpreterStats cyclesRunning! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/15/2008 15:41'!
cyclesSinceLast
	"Answer the count of cycles since last sample"
	
	^self cyclesSinceLastQuery! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:46'!
cyclesWaiting
	"Answer the count of cycles spect waiting during this sample"
	
	^self squeakInterpreterStats cyclesWaiting! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:06'!
interruptCheckCount
	"Answer the count of yields  during this sample"
	
	^self squeakInterpreterStats interruptCheckCount! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:34'!
millisecondsRunning
	"Answer the count of ms spent running during this sample"
	
	^self squeakInterpreterStats millisecondsRunning! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:53'!
millisecondsWaiting
	"Answer the count of ms spect waiting during this sample"
	
	^self squeakInterpreterStats millisecondsWaiting! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:43'!
msRunWaitRatio
	"Answer the ratio between my msRunning and msWaiting"
	
	^self squeakInterpreterStats msRunWaitRatio! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/15/2008 15:27'!
msSinceLast
	"Answer the count of ms since last sample"
	
	^self millisecondsSinceLastQuery! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 3/27/2009 16:55'!
sendTallySums
	"Answer an array with the sum of all my send tallies in order"
	| sums tally |
	self sendTallies isEmpty ifTrue:[^#()].
	sums _ self sendTallies first talliesInOrder.
	2 to: self sendTallies size do:[:index| 
		tally _ self sendTallies at: index.
		sums _ sums + tally talliesInOrder].
	^sums! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:06'!
unforcedInterruptCheckCount
	"Answer the count of yields  during this sample"
	
	^self squeakInterpreterStats unforcedInterruptCheckCount! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'ssa 8/14/2008 17:16'!
yieldCount
	"Answer the count of yields  during this sample"
	
	^self squeakInterpreterStats yieldCount! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:17'!
yieldFrequency
	
	^self squeakInterpreterStats yieldFrequency! !

!RVMCPUCoreStats methodsFor: 'measuring' stamp: 'dmu 9/17/2010 15:19'!
yieldsPerSecond
	"Answer the ratio of yields per second during this sample"
	
	^(self squeakInterpreterStats yieldCount / (1 max: self millisecondsSinceLastQuery) asFloat * 1000) rounded! !

!RVMCPUCoreStats class methodsFor: 'instance creation' stamp: 'ssa 8/19/2008 10:57'!
newFastFromData: data forMessageNames: messageNames

	| stats |
	stats := self new.
	stats messageNames: messageNames.
	stats initializeFastFrom: data.
	^stats! !

!RVMCPUCoreStats class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:05'!
newFastestFromData: data forMessageNames: messageNames

	| stats |
	stats := self new.
	stats messageNames: messageNames.
	stats initializeFastestFrom: data.
	^stats! !

!RVMCPUCoreStats class methodsFor: 'instance creation' stamp: 'ssa 8/13/2008 17:49'!
newFromData: data forMessageNames: messageNames

	| stats |
	stats := self new.
	stats messageNames: messageNames.
	stats initializeFrom: data.
	^stats! !

!RVMCanvasController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:16'!
redButtonActivity
	"Move the offset of the view, effectively scrolling the canvas."
	| startPoint delta oldOffset |
	Cursor crossHair show.
	startPoint _ Sensor cursorPoint.
	oldOffset _ self view offset.
	[Sensor redButtonPressed] whileTrue:[delta _ Sensor cursorPoint - startPoint.
		self view offset: oldOffset + delta.
		self view displayView].
	Cursor normal show
	! !

!RVMCanvasController methodsFor: 'controlling' stamp: 'ssa 10/8/2008 19:05'!
yellowButtonActivity
	! !

!RVMCanvasView methodsFor: 'drawing' stamp: 'ssa 1/1/1970 00:10'!
drawCanvas
	"This is the main drawing method. Subclasses will override to do their own drawing"
	self  marker destForm: self canvas.
	self drawCross! !

!RVMCanvasView methodsFor: 'drawing' stamp: 'ssa 1/1/1970 00:10'!
drawCross
	| box |
	box _ self canvas boundingBox.
	self drawLineFrom: box topLeft to: box bottomRight color: Color blue.
	self drawLineFrom: box topRight to: box bottomLeft color: Color red.
	! !

!RVMCanvasView methodsFor: 'drawing' stamp: 'ssa 1/1/1970 00:22'!
drawLineFrom: beginPoint to: endPoint color: aColor 
	"Draw a line on the canvas in canvas coordinates"
	
	Marker
		color: aColor;
		place: beginPoint;
		goto: endPoint! !

!RVMCanvasView methodsFor: 'drawing' stamp: 'ssa 1/1/1970 00:33'!
eraseCanvas
	self canvas fillWhite! !

!RVMCanvasView methodsFor: 'controller access' stamp: 'ssa 1/1/1970 00:29'!
defaultControllerClass

	^RVMCanvasController! !

!RVMCanvasView methodsFor: 'accessing' stamp: 'dmiu 4/18/2011 13:32'!
canvas
	"Answer the value of canvas"
	canvas isNil ifTrue:[self canvas: (ColorForm extent: self extent  - (0@2) depth: (8 min: Display depth)).
		self drawCanvas].
	^ canvas! !

!RVMCanvasView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:02'!
canvas: anObject
	"Set the value of canvas"

	canvas _ anObject! !

!RVMCanvasView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:25'!
defaultOffset

	^0@0! !

!RVMCanvasView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:05'!
dirty
	"Answer the value of dirty"

	dirty isNil ifTrue:[self dirty: true].
	^ dirty! !

!RVMCanvasView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:02'!
dirty: anObject
	"Set the value of dirty"

	dirty _ anObject! !

!RVMCanvasView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:32'!
extent
	"Answer the value of extent"

	extent isNil ifTrue:[self extent: self insetDisplayBox extent].
	^ extent! !

!RVMCanvasView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:40'!
extent: aPoint
	"Set the value of extent"

	extent _ aPoint
	! !

!RVMCanvasView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:11'!
marker

	^self class marker! !

!RVMCanvasView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:25'!
offset
	"Answer the value of offset"

	offset isNil ifTrue:[self offset: self defaultOffset].
	^ offset! !

!RVMCanvasView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:31'!
offset: aPoint
	"Set the value of offset"

	offset _ aPoint min: 0@0 max: self insetDisplayBox extent - self canvas extent! !

!RVMCanvasView methodsFor: 'displaying' stamp: 'ssa 10/21/2008 11:31'!
displayView
	"Display my canvas at my offset.
	Subclasses should not override this method but should draw on the canvas instead"
	self okToDisplay ifFalse:[^self].
	self uncache.
	self canvas displayOn: Display at: self insetDisplayBox origin + self offset clippingBox: self insetDisplayBox.
! !

!RVMCanvasView methodsFor: 'framing' stamp: 'ssa 1/1/1970 00:30'!
newFrame
	"My frame has changed.  Default is to do nothing special"! !

!RVMCanvasView class methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:20'!
marker
	"Answer the default form to draw with, a 1 pixel black dot."
	Marker isNil ifTrue:[Marker _ Pen new.
		Marker defaultNib:1].
	^Marker! !

!RVMCanvasView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:13'!
example
	"RVMCanvasView example"
	| topView |
	topView _ StandardSystemView new.
	topView label:'CanvasView test'.
	topView minimumSize: 200@200.
	topView borderWidth:2.
	topView addSubView: self new.
	topView controller open! !

!RVMCanvasView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:17'!
example2
	"RVMCanvasView example2"
	| topView view |
	topView _ RVMStandardSystemView new.
	topView label:'CanvasView test'.
	topView minimumSize: 200@50.
	topView borderWidth:2.
	view _ self new.
	view extent: 500@50.
	topView addSubView: view.
	topView controller open! !

!RVMCheckBoxController methodsFor: 'basic control sequence' stamp: 'ssa 11/15/2008 11:04'!
clearView

	Display fill: self view insetDisplayBox fillColor: Color white! !

!RVMCheckBoxController methodsFor: 'basic control sequence' stamp: 'ssa 11/15/2008 11:04'!
redButtonActivity

	| aborted lastAborted |
	self view displayPressed.
	lastAborted _ false.
	aborted _ true.
	[Sensor redButtonPressed] whileTrue:[
		aborted _ (self view insetDisplayBox containsPoint: Sensor cursorPoint) not.
		aborted & lastAborted not ifTrue:[self clearView.  
									self view displayView.
									lastAborted _ true].
		aborted not & lastAborted ifTrue:[self clearView.
									self view displayPressed.
									lastAborted _ false]].
	self clearView.
	self view displayView.
	aborted ifFalse:[self view performAction]! !

!RVMCheckBoxController methodsFor: 'basic control sequence' stamp: 'ssa 10/19/2008 00:09'!
yellowButtonActivity
! !

!RVMCheckBoxController methodsFor: 'controlling' stamp: 'ssa 9/19/2008 12:20'!
controlActivity
	"Cursor action show."
	super controlActivity! !

!RVMCheckBoxController methodsFor: 'controlling' stamp: 'ssa 9/19/2008 12:05'!
controlTerminate
	Cursor normal show.
	super controlTerminate! !

!RVMCheckBoxOnlyView methodsFor: 'displaying' stamp: 'ssa 5/4/2010 15:36'!
checkBoxForm
	"Answer the check(ed) box based on the current state "
	
	^self checkBoxFormX! !

!RVMCheckBoxOnlyView methodsFor: 'displaying' stamp: 'ssa 5/4/2010 15:36'!
checkBoxFormNotCircle
	"Answer the check(ed) box based on the current state "
	
	^self checked ifTrue:[self clearCircle]ifFalse:[self notSign]! !

!RVMCheckBoxOnlyView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 01:05'!
checkBoxFormOnOff
	"Answer the check(ed) box based on the current state "
	
	| msg msgText |
	msg _ self checked ifTrue:[
		'O
N'] ifFalse:['O
F
F'].
	msgText _ msg asDisplayText.
	^msgText 
			 asParagraph asForm scaledToSize:(self insetDisplayBox extent min: msgText boundingBox extent).
! !

!RVMCheckBoxOnlyView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 00:56'!
checkBoxFormX
	"Answer the check(ed) box based on the current state "
	
	| box marker |

	box _ Form extent: self insetDisplayBox width asPoint depth: Display depth.
	"box border: box boundingBox width:2  fillColor: Color gray."
	self checked ifFalse:[^box].
	"box fill: (box boundingBox insetBy: 2) fillColor: Color gray lighter lighter."
	marker _ Form extent:2@2 depth: Display depth.
	marker fillColor: Color gray.
	box drawLine:  marker
		from: box boundingBox origin
		to: box boundingBox corner
		clippingBox: box boundingBox
		rule: Form over
		fillColor: nil.
	box drawLine:  marker
		from: box boundingBox topRight - (2@0)
		to: box boundingBox bottomLeft - (2@0)
		clippingBox: box  boundingBox 
		rule: Form over
		fillColor: nil.
		
	^box! !

!RVMCheckBoxOnlyView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 00:12'!
checkedCircle
^Form
	extent: 10@10
	depth: 1
	fromArray: #( 1056964608 1635778560 3250585600 2185232384 2185232384 2487222272 2285895680 3368026112 1635778560 1056964608)
	offset: 0@0! !

!RVMCheckBoxOnlyView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 00:12'!
clearCircle
	^ Form
		extent: 10 @ 10
		depth: 1
		fromArray: #(1056964608 1635778560 3233808384 2151677952 2151677952 2151677952 2151677952 3233808384 1635778560 1056964608 )
		offset: 0 @0! !

!RVMCheckBoxOnlyView methodsFor: 'displaying' stamp: 'ssa 11/11/2008 22:42'!
displayContents

	| checkBoxForm box |
	self okToDisplay ifFalse:[^self].
	checkBoxForm _ self checkBoxForm.
	checkBoxForm _ checkBoxForm scaledToSize:(self insetDisplayBox extent min: checkBoxForm boundingBox extent).
	box _ checkBoxForm boundingBox.
	box _ box align: box center with: self insetDisplayBox center.
	Display fill: self insetDisplayBox fillColor: Color white.
	checkBoxForm displayOn: Display at: box  origin ! !

!RVMCheckBoxOnlyView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 00:12'!
notSign
^Form
	extent: 10@10
	depth: 1
	fromArray: #( 1056964608 1635778560 3250585600 2202009600 2252341248 2353004544 2554331136 4039114752 1635778560 1056964608)
	offset: 0@0! !

!RVMCheckBoxView methodsFor: 'updating' stamp: 'ssa 10/19/2008 00:43'!
hear: aSpeaker
	"Some object I am listening to is speaking"
self checked:nil.
self displayView! !

!RVMCheckBoxView methodsFor: 'updating' stamp: 'ssa 11/13/2008 10:44'!
performAction
	"I've been clicked, switch state and act"
	self checked ifTrue:[self performUncheckAction]ifFalse:[self performCheckAction].
	self checked: nil.
	self displayView! !

!RVMCheckBoxView methodsFor: 'updating' stamp: 'ssa 11/13/2008 10:46'!
performCheckAction

	self checkAction isSymbol ifTrue:[self model perform: self checkAction] ifFalse:[self checkAction value]! !

!RVMCheckBoxView methodsFor: 'updating' stamp: 'ssa 11/13/2008 10:46'!
performUncheckAction

	self uncheckAction isSymbol ifTrue:[self model perform: self uncheckAction] ifFalse:[self uncheckAction value]! !

!RVMCheckBoxView methodsFor: 'updating' stamp: 'ssa 10/19/2008 00:56'!
update: aSelector

	super update: aSelector.
	self checked: nil.
	self displayView! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 2/22/2010 15:39'!
baseColor
	^Color gray lighter lighter lighter! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 03:16'!
checkAction
	"Answer the value of checkAction"

	checkAction isNil ifTrue:[self checkAction: [self inform:'box just checked']].
	^ checkAction! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 03:15'!
checkAction: anObject
	"Set the value of checkAction"

	checkAction _ anObject! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 11/16/2008 00:12'!
checkBoxForm
	"Answer the value of checkBoxForm"

	^self checkState ifTrue:[self checkedBoxForm]ifFalse:[self uncheckedBoxForm]! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 11/13/2008 10:43'!
checkState
	"Answer the value of checked the state of my checkbox"

	^self checkStateAction isSymbol ifTrue:[self model perform: self checkStateAction]
		ifFalse:[self checkStateAction value]! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 03:19'!
checkStateAction
	"Answer the value of checkStateAction"

	checkStateAction isNil ifTrue:[self checkStateAction: [false]].
	^ checkStateAction! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 03:18'!
checkStateAction: anObject
	"Set the value of checkStateAction"

	checkStateAction _ anObject! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 11/13/2008 10:42'!
checked
	"Answer the value of checked the state of my checkbox"

	checked isNil ifTrue:[self checked: self checkState].
	^ checked! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 03:15'!
checked: anObject
	"Set the value of checked"

	checked _ anObject! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 11/16/2008 00:09'!
checkedBoxForm
	"Answer the value of checkedBoxForm"

	checkedBoxForm isNil ifTrue:[self checkedBoxForm: self buildCheckedBoxForm].
	^ checkedBoxForm! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 11/16/2008 00:09'!
checkedBoxForm: anObject
	"Set the value of checkedBoxForm"

	checkedBoxForm _ anObject! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 03:17'!
label
	"Answer the value of label"

	label isNil ifTrue:[self label: 'no label yet'].
	^ label! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 03:15'!
label: anObject
	"Set the value of label"

	label _ anObject! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 11/16/2008 00:03'!
labelForm
	"Answer the value of labelForm"

	labelForm isNil ifTrue:[self labelForm: self buildLabelForm].
	^ labelForm! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 11/16/2008 00:03'!
labelForm: anObject
	"Set the value of labelForm"

	labelForm _ anObject! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 03:17'!
uncheckAction
	"Answer the value of uncheckAction"

	uncheckAction isNil ifTrue:[self uncheckAction: [self inform:'box just UNchecked']].
	^ uncheckAction! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 03:15'!
uncheckAction: anObject
	"Set the value of uncheckAction"

	uncheckAction _ anObject! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 11/16/2008 00:10'!
uncheckedBoxForm
	"Answer the value of uncheckedBoxForm"

	uncheckedBoxForm isNil ifTrue:[self uncheckedBoxForm: self buildUncheckedBoxForm].
	^ uncheckedBoxForm! !

!RVMCheckBoxView methodsFor: 'accessing' stamp: 'ssa 11/16/2008 00:09'!
uncheckedBoxForm: anObject
	"Set the value of uncheckedBoxForm"

	uncheckedBoxForm _ anObject! !

!RVMCheckBoxView methodsFor: 'displaying' stamp: 'ssa 2/23/2010 15:40'!
buildCheckedBoxForm
	"Answer the check(ed) box "
	
	| box marker |
	box _ Form extent: 15@15 depth: Display depth .
	box fillColor: self baseColor lighter lighter.
	box border: box boundingBox width:1  fillColor: Color black.
	marker _ Form extent:2@2.
	marker fillColor: Color black.
	box drawLine:  marker
		from: box boundingBox origin
		to: box boundingBox corner
		clippingBox: box boundingBox
		rule: Form over
		fillColor: nil.
	box drawLine:  marker
		from: box boundingBox topRight - (2@0)
		to: box boundingBox bottomLeft - (2@0)
		clippingBox: box  boundingBox 
		rule: Form over
		fillColor: nil.
		
	^box! !

!RVMCheckBoxView methodsFor: 'displaying' stamp: 'ssa 11/16/2008 00:01'!
buildLabelForm
	"Answer the label form"
	
	|  labelText  |
	labelText := ('  ',self label ) asDisplayText .
	labelText foregroundColor: Color black
			backgroundColor: Color transparent.
	^labelText "asParagraph asForm"
! !

!RVMCheckBoxView methodsFor: 'displaying' stamp: 'ssa 2/23/2010 15:40'!
buildUncheckedBoxForm
	"Answer the uncheck(ed) box"
	
	| box |
	box _ Form extent: 15@15 depth: Display depth .
	box fillColor:self baseColor lighter lighter.
	box border: box boundingBox width:1  fillColor: Color black.

	^box! !

!RVMCheckBoxView methodsFor: 'displaying' stamp: 'ssa 2/23/2010 15:34'!
buildUnderLabelForm
	"Answer the under label form"
	
	|  labelText  |
	labelText := ('  ',self label ) asDisplayText .
	labelText foregroundColor: self baseColor lighter lighter
			backgroundColor: Color transparent.
	^labelText "asParagraph asForm"
! !

!RVMCheckBoxView methodsFor: 'displaying' stamp: 'ssa 2/23/2010 15:39'!
displayContents

	|   box theLabelForm theCheckBoxForm underLabelForm |
	theCheckBoxForm _ self checkBoxForm.
	theLabelForm _ self buildLabelForm.
	underLabelForm _ self buildUnderLabelForm.
	box _ 0@0 extent: theCheckBoxForm width + theLabelForm width @ (theCheckBoxForm height max: theLabelForm height).
	box _ box align: box leftCenter with: self insetDisplayBox leftCenter + (4@1).
	Display fill: self insetDisplayBox fillColor: self baseColor.
	theCheckBoxForm displayOn: Display at: box  origin clippingBox: self insetDisplayBox  rule: Form over fillColor:nil.
	underLabelForm displayOn: Display at: box origin + (theCheckBoxForm width @ -2)+(1@1) clippingBox: self insetDisplayBox rule: Form over fillColor:nil.
	theLabelForm displayOn: Display at: box origin + (theCheckBoxForm width @ -2) clippingBox: self insetDisplayBox rule: Form over fillColor:nil.
	! !

!RVMCheckBoxView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 04:10'!
displayPressed

	self displayContents.
	Display border:( self  insetDisplayBox insetBy: 2@2) width: 2 fillColor: Color gray! !

!RVMCheckBoxView methodsFor: 'displaying' stamp: 'ssa 11/15/2008 15:49'!
displayView
	self okToDisplay ifFalse:[^self].
	self uncache.
	self displayContents! !

!RVMCheckBoxView methodsFor: 'controller access' stamp: 'ssa 1/1/1970 03:21'!
defaultControllerClass

	^RVMCheckBoxController! !

!RVMCheckBoxView class methodsFor: 'examples' stamp: 'ssa 11/13/2008 10:05'!
example
	"RVMCheckBoxView example"
	"Note we are using this class as a test model for this method.  See examplePoint for a more normal usage"
	| topView |
	topView := RVMStandardSystemView new.
	self testState: true.
	topView borderWidth:1.
	topView minimumSize: 100@25.
	topView maximumSize: 200@200.
	topView addSubView: (self on: self label: 'test' checkState: [self testState] whenChecked: [self testState: true] whenUnchecked: [self testState: false]).
	topView label: 'RVMCheckBoxView test'.
	topView controller open! !

!RVMCheckBoxView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 05:23'!
examplePoint
	"RVMCheckBoxView examplePoint"
	| topView model |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 100@25.
	topView maximumSize: 200@200.
	model _ 0@0.
	topView addSubView: (self on: model label: 'test' checkState: [model x = 1] whenChecked: [model x: 1] whenUnchecked: [model x:0]).
	topView label: 'RVMCheckBoxView test'.
	topView controller open! !

!RVMCheckBoxView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 05:24'!
exampleTwin
	"RVMCheckBoxView exampleTwin"
	"Note we are using this class as a test model for this method.  See examplePoint for a more normal usage"
	| topView v |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 100@50.
	topView maximumSize: 200@200.
	topView addSubView: (v _ self on: self label: 'test' checkState: [self testState] whenChecked: [self testState: true] whenUnchecked: [self testState: false]).
	topView addSubView: (self on: self label: 'test' checkState: [self testState] whenChecked: [self testState: true] whenUnchecked: [self testState: false]) below: v.
	topView label: 'RVMCheckBoxView test'.
	topView controller open! !

!RVMCheckBoxView class methodsFor: 'instance creation' stamp: 'ssa 5/12/2010 10:22'!
on: aModel label: aString checkState: getterBlock whenChecked: checkedBlock whenUnchecked: uncheckedBlock

	^self on: aModel label: aString checkState: getterBlock whenChecked: checkedBlock whenUnchecked: uncheckedBlock monitor: false! !

!RVMCheckBoxView class methodsFor: 'instance creation' stamp: 'ssa 5/12/2010 10:21'!
on: aModel label: aString checkState: getterBlock whenChecked: checkedBlock whenUnchecked: uncheckedBlock monitor: updateFromRVMMonitor

	| v |
	v _ self new.
	v model: aModel.
	v label: aString.
	v checkStateAction: getterBlock.
	v checkAction: checkedBlock.
	v uncheckAction: uncheckedBlock.
	updateFromRVMMonitor ifTrue:[RVMMonitor inform: v].
	^v! !

!RVMCheckBoxView class methodsFor: 'testing' stamp: 'ssa 1/1/1970 04:22'!
testState

	TestState isNil ifTrue:[TestState _ true].
	^TestState! !

!RVMCheckBoxView class methodsFor: 'testing' stamp: 'ssa 1/1/1970 04:25'!
testState: aValue

	TestState _ aValue.
	self changed:#testState! !

!RVMCircularCollection methodsFor: 'add/remove elements' stamp: 'ssa 1/1/1970 00:03'!
add: anObject
	"Add this object to my collection, increment the lastIndex, adjust if there is a rollover."
	self begin = 0 ifTrue:[ "I have no elements, add the first one"
		self begin:1.
		self end: 1]
	ifFalse:[ "I have elements, add one more and adjust if needed"
		self numberOfElements = self size
			ifTrue:["need to rollover the first element"
				self begin = self size "adjust begin and end"
					ifTrue:[self begin: 1.
						self end: self size]
					ifFalse:[self end: self begin.
						self begin: self begin + 1]]
			ifFalse:["no rollover needed"
				self end: (self end + 1 min: self size)]].
	self array at: self end put: anObject.
	self incrementElements
				
				! !

!RVMCircularCollection methodsFor: 'add/remove elements' stamp: 'ssa 1/1/1970 00:41'!
removeAll
	self begin: 0.
	self end: 0.
	self array:nil.
	self numberOfElements:0! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 1/1/1970 00:53'!
array
	"Answer the value of array"

	array isNil ifTrue:[self array: (Array new: self size)].
	^ array! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 1/1/1970 00:38'!
array: anObject
	"Set the value of array"

	array _ anObject! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 1/1/1970 01:03'!
begin
	"Answer the value of begin"

	begin isNil ifTrue:[self begin: 0].
	^ begin! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 1/1/1970 01:02'!
begin: anObject
	"Set the value of begin"

	begin _ anObject! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 1/1/1970 00:04'!
decrementElements

	self numberOfElements: ((self numberOfElements - 1) max: 0)! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 1/1/1970 01:03'!
end
	"Answer the value of end"

	end isNil ifTrue:[self end: 0].
	^ end! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 1/1/1970 01:02'!
end: anObject
	"Set the value of end"

	end _ anObject! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 1/1/1970 01:12'!
incrementElements

	self numberOfElements: ((self numberOfElements + 1) min: self size)! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 1/1/1970 01:03'!
numberOfElements
	"Answer the value of numberOfElements"

	numberOfElements isNil ifTrue:[self numberOfElements: 0].
	^ numberOfElements! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 1/1/1970 01:02'!
numberOfElements: anObject
	"Set the value of numberOfElements"

	numberOfElements _ anObject! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 10/18/2008 21:37'!
realIndexFor: index
	"Answer the loop adjusted index value"
	| realIndex |
	index >  self size ifTrue:[realIndex _ index \\ self size]
			ifFalse:[realIndex _ index].
	realIndex _ realIndex - 1 + self begin.
	realIndex > self size ifTrue:[realIndex _ realIndex - self size].
	^realIndex
! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 1/1/1970 00:52'!
size
	"Answer the value of size"

	size isNil ifTrue:[self size: 10].
	^ size! !

!RVMCircularCollection methodsFor: 'private' stamp: 'ssa 1/1/1970 00:04'!
size: aNumber
	"Set the value of size"

	| contents oldSize |
	size = aNumber ifTrue:[^self].
	self isEmpty 
		ifTrue:[size _ aNumber.
			self array:nil; numberOfElements:0]
		ifFalse:[contents _ self asOrderedCollection.
			oldSize _ contents size.
			size _ aNumber.
			self begin:0;end:0;numberOfElements:0.
			self array: (Array new: size).
			1 to: (size min: oldSize) do:[:index|
				self add: (contents at: index)]].
		! !

!RVMCircularCollection methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:14'!
at: index

	^self array at: (self realIndexFor: index)! !

!RVMCircularCollection methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:15'!
at: index put: anObject

	self array at: (self realIndexFor: index) put: anObject! !

!RVMCircularCollection methodsFor: 'accessing' stamp: 'ssa 10/18/2008 22:00'!
atRandom

	^self at: self numberOfElements atRandom! !

!RVMCircularCollection methodsFor: 'accessing' stamp: 'ssa 10/26/2008 15:27'!
first

	^self at:1! !

!RVMCircularCollection methodsFor: 'accessing' stamp: 'ssa 10/26/2008 15:28'!
last

	^self at:self numberOfElements! !

!RVMCircularCollection methodsFor: 'accessing' stamp: 'ssa 10/18/2008 21:29'!
nextIndex
	"Answer the value of nextIndex"

	nextIndex isNil ifTrue:[self nextIndex: 1].
	^ nextIndex! !

!RVMCircularCollection methodsFor: 'accessing' stamp: 'ssa 10/18/2008 21:40'!
nextIndex: anInteger
	"Set the value of nextIndex"
	anInteger > self size ifTrue:[^nextIndex _ 1].
	nextIndex _ anInteger! !

!RVMCircularCollection methodsFor: 'converting' stamp: 'ssa 1/1/1970 00:40'!
asArray

	^self asOrderedCollection asArray! !

!RVMCircularCollection methodsFor: 'converting' stamp: 'ssa 10/28/2008 19:41'!
asCircularCollection
^self! !

!RVMCircularCollection methodsFor: 'converting' stamp: 'ssa 1/1/1970 00:20'!
asOrderedCollection

	| oc |
	oc _ OrderedCollection new.
	self do:[:each| oc add: each].
	^oc! !

!RVMCircularCollection methodsFor: 'enumerating' stamp: 'ssa 1/1/1970 00:18'!
collect: aBlock
	"Iterate over my elements in order and answer the results"
	| results |
	results _ self class new: self size.
	self do:[:each| results add: (aBlock value: each)].
	^results! !

!RVMCircularCollection methodsFor: 'enumerating' stamp: 'ssa 1/1/1970 00:13'!
do: aBlock
	"Iterate over my elements in order"
	1 to: self numberOfElements do:[:index|
		aBlock value:(self at: index)]! !

!RVMCircularCollection methodsFor: 'testing' stamp: 'ssa 5/28/2010 16:55'!
atEnd
	"Acting like an infinite stream"
	^false! !

!RVMCircularCollection methodsFor: 'testing' stamp: 'ssa 1/1/1970 00:55'!
isEmpty

	^self numberOfElements = 0! !

!RVMCircularCollection methodsFor: 'testing' stamp: 'ssa 1/1/1970 00:55'!
isFull

	^self numberOfElements = self size! !

!RVMCircularCollection methodsFor: 'printing' stamp: 'ssa 10/3/2008 21:17'!
printOn: aStream

	super printOn: aStream.
	aStream nextPutAll: ' size:',self size printString,' numberOfElements:',self numberOfElements printString! !

!RVMCircularCollection methodsFor: 'stream emulation' stamp: 'ssa 10/18/2008 21:31'!
next
	"Answer the next element in line, then advance the nextIndex"
	| item |
	self isEmpty ifTrue:[self error:'Empty Collection'].
	item _ self at: self nextIndex.
	self nextIndex: self nextIndex + 1.
	^item! !

!RVMCircularCollection class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:19'!
new: anInteger

	| collection |
	collection _ self new.
	collection size: anInteger.
	^collection! !

!RVMCircularCollection class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:42'!
new: anInteger withAll: aCollection

	| collection |
	collection _ self new: anInteger.
	aCollection do:[:each| collection add: each].
	^collection! !

!RVMCircularCollection class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:42'!
withAll: aCollection

	^self new: aCollection size withAll: aCollection! !

!RVMCircularCollection class methodsFor: 'tests' stamp: 'ssa 1/1/1970 00:36'!
testAdd
	"RVMCircularCollection testAdd"
	
	| cc bag |
	cc _ self new: 10.
	5 timesRepeat:[cc add: 1].
	bag _ cc asOrderedCollection asBag.
	bag size = 5 & ((bag occurrencesOf: 1) = 5 ) ifTrue:['passed' print]ifFalse:['failed' print]! !

!RVMCircularCollection class methodsFor: 'tests' stamp: 'ssa 1/1/1970 00:39'!
testCollect
	"RVMCircularCollection testCollect"
	
	| cc results |
	cc _ self new: 5.
	1 to: 20 do:[:each| cc add: each].
	results _ cc collect:[:each|  each].
	results asArray = #(16 17 18 19 20)
		 ifTrue:['passed' print]ifFalse:['failed' print]! !

!RVMCircularCollection class methodsFor: 'tests' stamp: 'ssa 1/1/1970 00:38'!
testDo
	"RVMCircularCollection testDo"
	
	| cc total |
	cc _ self new: 5.
	1 to: 20 do:[:each| cc add: each].
	total _ 0.
	cc do:[:each| total _ total + each].
	total = #(20 19 18 17 16) sum
		 ifTrue:['passed' print]ifFalse:['failed' print]! !

!RVMCircularCollection class methodsFor: 'tests' stamp: 'ssa 1/1/1970 00:54'!
testResize
	"RVMCircularCollection testResize"
	
	| cc |
	cc _ self new: 5.
	1 to: 20 do:[:each| cc add: each].
	cc size: 2.
	cc asArray = #(16 17)
		 ifTrue:['passed' print]ifFalse:['failed' print]! !

!RVMCircularCollection class methodsFor: 'tests' stamp: 'ssa 1/1/1970 00:35'!
testRollover
	"RVMCircularCollection testRollover"
	
	| cc |
	cc _ self new: 10.
	1 to: 20 do:[:each| cc add: each].
	cc asOrderedCollection asArray = #(11 12 13 14 15 16 17 18 19 20)
		 ifTrue:['passed' print]ifFalse:['failed' print]! !

!RVMColorButtonController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:50'!
colorFromUser
	"Displays a color palette of colors, waits for a mouse click, and returns the selected color. Any pixel on the Display can be chosen, not just those in the color palette."

	| d startPt save tr oldColor c here s |
	d _ Display depth.
	((Color colorChart == nil) or: [Color colorChart depth ~= Display depth]) 
		ifTrue: [Color colorChart:(Color oldColorPaletteForDepth: d extent: (2 * 144)@80)].
	startPt _ Sensor cursorPoint.

	save _ Form fromDisplay: (startPt extent: Color colorChart extent).
	Color colorChart displayAt: startPt.
	tr _ Color colorChart extent - (50@19) corner: Color colorChart extent.
	tr _ tr translateBy: startPt.

	oldColor _ nil.
	[Sensor anyButtonPressed] whileTrue: [
		c _ Display colorAt: (here _ Sensor cursorPoint).
		(tr containsPoint: here)
			ifFalse: [Display fill: (0@61+startPt extent: 20@19) fillColor: c]
			ifTrue: [
				c _ Color transparent.
				Display fill: (0@61+startPt extent: 20@19) fillColor: Color white].
		c = oldColor ifFalse: [
			Display fillWhite: (20@61 + startPt extent: 135@19).
			c isTransparent
				ifTrue: [s _ 'transparent']
				ifFalse: [s _ c shortPrintString.
						s _ s copyFrom: 7 to: s size - 1].
			s displayAt: 20@61 + startPt.
			oldColor _ c]].
	save displayAt: startPt.
	Sensor waitNoButton.
	^ c
! !

!RVMColorButtonController methodsFor: 'controlling' stamp: 'ssa 9/19/2008 11:56'!
controlActivity
	Cursor menu show.
	super controlActivity! !

!RVMColorButtonController methodsFor: 'controlling' stamp: 'ssa 9/19/2008 11:56'!
controlTerminate
	Cursor normal show.
	super controlTerminate! !

!RVMColorButtonController methodsFor: 'controlling' stamp: 'ssa 9/13/2008 16:06'!
yellowButtonActivity

	view color: self colorFromUser.
	view display! !

!RVMColorButtonView methodsFor: 'controller access' stamp: 'ssa 9/13/2008 15:58'!
defaultControllerClass

	^RVMColorButtonController! !

!RVMColorButtonView methodsFor: 'displaying' stamp: 'ssa 10/21/2008 11:31'!
displayView
	self uncache.
	Display fill: self insetDisplayBox fillColor: self color.
	"Display border: (self insetDisplayBox insetBy: 1)width: 1 fillColor: self color negated."! !

!RVMColorButtonView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 21:29'!
color
	"Answer the value of color"

	color isNil ifTrue:[color_(self colorSetter isSymbol
						ifTrue:[model perform: self colorGetter]
						ifFalse:[self colorGetter value])].
	^ color! !

!RVMColorButtonView methodsFor: 'accessing' stamp: 'ssa 9/17/2008 14:05'!
color: anObject
	"Set the value of color"

	color _ anObject.
	self colorSetter isSymbol
		ifTrue:[model perform: self colorSetter with: anObject]
		ifFalse:[self colorSetter value: anObject]! !

!RVMColorButtonView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 21:21'!
colorGetter
	"Answer the value of colorGetter"

	colorGetter isNil ifTrue:[self colorGetter: #color].
	^ colorGetter! !

!RVMColorButtonView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 21:20'!
colorGetter: anObject
	"Set the value of colorGetter"

	colorGetter _ anObject! !

!RVMColorButtonView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 21:21'!
colorSetter
	"Answer the value of colorSetter"

	colorSetter isNil ifTrue:[self colorSetter: #color:].
	^ colorSetter! !

!RVMColorButtonView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 21:20'!
colorSetter: anObject
	"Set the value of colorSetter"

	colorSetter _ anObject! !

!RVMColorButtonView class methodsFor: 'examples' stamp: 'ssa 9/13/2008 22:03'!
example
	"RVMColorButtonView example"
	| topView |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 50@50.
	topView maximumSize: 100@100.
	topView addSubView: self exampleInstance.
	topView label: 'ColorButton'.
	topView controller open! !

!RVMColorButtonView class methodsFor: 'examples' stamp: 'ssa 9/17/2008 13:58'!
exampleInstance

	^self on: nil colorGetter:[Color random] colorSetter:[:color| color print]! !

!RVMColorButtonView class methodsFor: 'instance creation' stamp: 'ssa 9/17/2008 13:57'!
on: aModel colorGetter: getterSelector colorSetter: setterSelector

	| view |
	view _ self new.
	view model: aModel.
	view colorGetter: getterSelector.
	view colorSetter: setterSelector.
	^view! !

!RVMColorScaleController methodsFor: 'controlling' stamp: 'ssa 11/4/2008 20:13'!
redButtonActivity
	self view usesScaler ifTrue:[
	(self view adjustScaleBox  containsPoint: Sensor cursorPoint) ifTrue:[Sensor waitNoButton.
		self spawnScaleAdjuster]]! !

!RVMColorScaleController methodsFor: 'controlling' stamp: 'ssa 5/12/2010 10:19'!
spawnScaleAdjuster

	| scaler maxView minView topView resetScaleButton setToObservedButton autoScaleCheckBox height |
	scaler _ self view scaler.
	maxView _ RVMValueEditorView  on: scaler valueGetter: [scaler max] valueSetter:[:v|scaler setMax:v. self view model redrawOnCanvas; displayView] label:'max: '.
	maxView lockGetter:#maxLocked; lockSetter:#maxLocked:.
	minView _ RVMValueEditorView  on: scaler valueGetter: [scaler min] valueSetter:[:v|scaler setMin:v.  self view model redrawOnCanvas; displayView] label:'min: '.
	minView lockGetter:#minLocked; lockSetter:#minLocked:.
	resetScaleButton _ RVMButtonView label:'Reset scale to default' action:[scaler resetScaling.  self view model redrawOnCanvas; displayView].
	setToObservedButton _ RVMButtonView label:'Set scale to observed values' action:[scaler setRangeToObserved.  self view model redrawOnCanvas; displayView].
	autoScaleCheckBox _ RVMCheckBoxView on: scaler label: 'Automatic Scaling' checkState: [scaler automaticScaling] whenChecked: [scaler automatic.  self view model redrawOnCanvas; displayView] whenUnchecked: [scaler manual. self view model redrawOnCanvas; displayView] monitor: true.

	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView addSubView: minView.
	topView addSubView: maxView below:  minView.
	topView addSubView: resetScaleButton below:  maxView.
	topView addSubView: setToObservedButton below:  resetScaleButton.
	topView addSubView: autoScaleCheckBox below:  setToObservedButton.
	RVMMonitor forgetAll:{resetScaleButton. setToObservedButton. autoScaleCheckBox}.
	topView label: self view aspect.
	height _ topView subViews size * 26.
	topView minimumSize:200@height.
	topView maximumSize: 200@height.
	topView controller open! !

!RVMColorScaleController methodsFor: 'controlling' stamp: 'ssa 5/4/2010 15:41'!
yellowButtonActivity
	self spawnScaleAdjuster! !

!RVMColorScaleView methodsFor: 'controller access' stamp: 'ssa 11/4/2008 14:28'!
defaultControllerClass

	^RVMColorScaleController! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 14:26'!
adjustScaleBox
	"Answer the value of adjustScaleBox"

	adjustScaleBox isNil ifTrue:[self adjustScaleBox: self insetDisplayBox].
	^ adjustScaleBox! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 14:25'!
adjustScaleBox: anObject
	"Set the value of adjustScaleBox"

	adjustScaleBox _ anObject! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 07:42'!
aspect
	^self aspectSource value! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/9/2008 11:42'!
aspectLabel
	"Answer the value of aspectLabel"

	aspectLabel isNil ifTrue:[self aspectLabel: (Form extent: 1@1)].
	^ aspectLabel! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 19:13'!
aspectLabel: anObject
	"Set the value of aspectLabel"

	aspectLabel _ anObject! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 07:42'!
aspectSource
	"Answer the value of aspectSource"

	aspectSource isNil ifTrue:[self aspectSource: [#bytesUseds]].
	^ aspectSource! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 07:41'!
aspectSource: anObject
	"Set the value of aspectSource"

	aspectSource _ anObject! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 06:26'!
colors
	^self colorsSource value! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 06:25'!
colorsSource
	"Answer the value of colorsSource"

	colorsSource isNil ifTrue:[self colorsSource: [Color hotColdShades: 25]].
	^ colorsSource! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 06:25'!
colorsSource: anObject
	"Set the value of colorsSource"

	colorsSource _ anObject! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:02'!
horizontal
	self orientation:#horizontal! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 08:27'!
orientation
	"Answer the value of orientation"

	orientation isNil ifTrue:[self orientation: #vertical].
	^ orientation! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 06:30'!
orientation: anObject
	"Set the value of orientation"

	orientation _ anObject! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 06:20'!
scaler
	^self scalerSource value! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 06:19'!
scalerSource
	"Answer the value of scalerSource"

	scalerSource isNil ifTrue:[self scalerSource: [RVMDataScaler exampleInstance]].
	^ scalerSource! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 06:19'!
scalerSource: anObject
	"Set the value of scalerSource"

	scalerSource _ anObject! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 20:11'!
usesScaler
	"Answer the value of usesScaler"

	usesScaler isNil ifTrue:[self usesScaler: false].
	^ usesScaler! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 20:11'!
usesScaler: anObject
	"Set the value of usesScaler"

	usesScaler _ anObject! !

!RVMColorScaleView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:02'!
vertical
	self orientation:#vertical! !

!RVMColorScaleView methodsFor: 'listening' stamp: 'ssa 1/1/1970 00:55'!
hear: something
	self drawFastCanvas.
	self displayView! !

!RVMColorScaleView methodsFor: 'drawing' stamp: 'ssa 11/4/2008 13:44'!
adjustScaleIcon
^((ColorForm
	extent: 16@31
	depth: 8
	fromArray: #( 0 0 0 0 0 0 169614364 622594560 0 0 1694498815 4294913536 0 0 1845490943 4294915840 0 0 0 3506384384 0 0 0 3506386688 73 1677721600 0 3657379328 163 3642490880 0 3506386688 9716 4287692800 172 4110364160 46591 4294913536 208 4110366464 4259839 4294936576 0 3506384384 8973264 4106150400 0 3657381632 6558618 3942664503 0 3506384384 154 3942645760 0 3657381632 154 3942645760 25700 3808374272 154 3942645760 60415 4294915840 154 3942645760 18761 3808374272 154 3942645760 0 3506386688 2424986 3942648357 0 3657379328 11304867 3947480869 0 3506386688 7798783 4294948096 0 3506384384 1300991 4294925056 217 4294915840 25855 4291821568 145 3959369216 199 4098424832 0 3657381632 118 2432696320 0 3506384384 28 620756992 0 3506386688 0 0 0 3657379328 0 0 1541003737 4110366464 0 0 1694498815 4294913536 0 0 321795886 1227753984 0 0 0 0)
	offset: 0@0)
	colorsFromArray: #(#(1.0 1.0 1.0) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0)  ))! !

!RVMColorScaleView methodsFor: 'drawing' stamp: 'ssa 11/4/2008 14:14'!
adjustScaleIconHorizontal
^((ColorForm
	extent: 31@16
	depth: 8
	fromArray: #( 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967040 4280755235 606282787 606282787 606282787 606282787 606282787 606282787 606600960 4280615169 16843009 16843009 16843009 16843009 16843009 16843009 19201792 4279173377 320014867 269488906 319427073 303237651 318837002 320014864 17760000 4280615169 4294967295 387186687 4294909697 251658239 4278852095 4294967050 19201792 4280615184 4294967295 4294967295 4294909713 251658239 4294967295 4294967050 19136256 4280615169 4294967295 4294967295 4294967295 4294967295 4294967295 4294967050 19201792 4280753933 4294967295 4294967295 4294967295 4294967295 4294967295 4294967072 522649344 4294967295 4294967295 4294967295 603979775 4294905615 4294967295 4294967295 4294967040 4294967295 4294967295 4280556050 251658239 4294911764 371261439 4294967295 4294967040 4294967295 4294967077 419496203 4294967295 4294967054 16847630 4294967295 4294967040 4294967295 4294909706 16843024 286331153 286331153 16843024 420478975 4294967040 4294967295 4294905368 268501267 202116108 202116120 16843028 505806847 4294967040 4294967295 4294967295 253100305 654311423 4294967043 17440767 4294967295 4294967040 4294967295 4294967295 4294910490 536870911 4294905623 505872383 4294967295 4294967040 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967040)
	offset: 0@0)
	colorsFromArray: #(#(1.0 1.0 1.0) #(0.0 0.0 0.0) #(1.0 1.0 1.0) #(0.5 0.5 0.5) #(1.0 0.0 0.0) #(0.0 1.0 0.0) #(0.0 0.0 1.0) #(0.0 1.0 1.0) #(1.0 1.0 0.0) #(1.0 0.0 1.0) #(0.125 0.125 0.125) #(0.25 0.25 0.25) #(0.375 0.375 0.375) #(0.625 0.625 0.625) #(0.75 0.75 0.75) #(0.875 0.875 0.875) #(0.031 0.031 0.031) #(0.063 0.063 0.063) #(0.094 0.094 0.094) #(0.156 0.156 0.156) #(0.188 0.188 0.188) #(0.219 0.219 0.219) #(0.282 0.282 0.282) #(0.313 0.313 0.313) #(0.344 0.344 0.344) #(0.407 0.407 0.407) #(0.438 0.438 0.438) #(0.469 0.469 0.469) #(0.531 0.531 0.531) #(0.562 0.562 0.562) #(0.593 0.593 0.593) #(0.656 0.656 0.656) #(0.687 0.687 0.687) #(0.718 0.718 0.718) #(0.781 0.781 0.781) #(0.812 0.812 0.812) #(0.844 0.844 0.844) #(0.906 0.906 0.906) #(0.937 0.937 0.937) #(0.969 0.969 0.969) #(0.0 0.0 0.0) #(0.0 0.199 0.0) #(0.0 0.4 0.0) #(0.0 0.599 0.0) #(0.0 0.8 0.0) #(0.0 1.0 0.0) #(0.0 0.0 0.199) #(0.0 0.199 0.199) #(0.0 0.4 0.199) #(0.0 0.599 0.199) #(0.0 0.8 0.199) #(0.0 1.0 0.199) #(0.0 0.0 0.4) #(0.0 0.199 0.4) #(0.0 0.4 0.4) #(0.0 0.599 0.4) #(0.0 0.8 0.4) #(0.0 1.0 0.4) #(0.0 0.0 0.599) #(0.0 0.199 0.599) #(0.0 0.4 0.599) #(0.0 0.599 0.599) #(0.0 0.8 0.599) #(0.0 1.0 0.599) #(0.0 0.0 0.8) #(0.0 0.199 0.8) #(0.0 0.4 0.8) #(0.0 0.599 0.8) #(0.0 0.8 0.8) #(0.0 1.0 0.8) #(0.0 0.0 1.0) #(0.0 0.199 1.0) #(0.0 0.4 1.0) #(0.0 0.599 1.0) #(0.0 0.8 1.0) #(0.0 1.0 1.0) #(0.199 0.0 0.0) #(0.199 0.199 0.0) #(0.199 0.4 0.0) #(0.199 0.599 0.0) #(0.199 0.8 0.0) #(0.199 1.0 0.0) #(0.199 0.0 0.199) #(0.199 0.199 0.199) #(0.199 0.4 0.199) #(0.199 0.599 0.199) #(0.199 0.8 0.199) #(0.199 1.0 0.199) #(0.199 0.0 0.4) #(0.199 0.199 0.4) #(0.199 0.4 0.4) #(0.199 0.599 0.4) #(0.199 0.8 0.4) #(0.199 1.0 0.4) #(0.199 0.0 0.599) #(0.199 0.199 0.599) #(0.199 0.4 0.599) #(0.199 0.599 0.599) #(0.199 0.8 0.599) #(0.199 1.0 0.599) #(0.199 0.0 0.8) #(0.199 0.199 0.8) #(0.199 0.4 0.8) #(0.199 0.599 0.8) #(0.199 0.8 0.8) #(0.199 1.0 0.8) #(0.199 0.0 1.0) #(0.199 0.199 1.0) #(0.199 0.4 1.0) #(0.199 0.599 1.0) #(0.199 0.8 1.0) #(0.199 1.0 1.0) #(0.4 0.0 0.0) #(0.4 0.199 0.0) #(0.4 0.4 0.0) #(0.4 0.599 0.0) #(0.4 0.8 0.0) #(0.4 1.0 0.0) #(0.4 0.0 0.199) #(0.4 0.199 0.199) #(0.4 0.4 0.199) #(0.4 0.599 0.199) #(0.4 0.8 0.199) #(0.4 1.0 0.199) #(0.4 0.0 0.4) #(0.4 0.199 0.4) #(0.4 0.4 0.4) #(0.4 0.599 0.4) #(0.4 0.8 0.4) #(0.4 1.0 0.4) #(0.4 0.0 0.599) #(0.4 0.199 0.599) #(0.4 0.4 0.599) #(0.4 0.599 0.599) #(0.4 0.8 0.599) #(0.4 1.0 0.599) #(0.4 0.0 0.8) #(0.4 0.199 0.8) #(0.4 0.4 0.8) #(0.4 0.599 0.8) #(0.4 0.8 0.8) #(0.4 1.0 0.8) #(0.4 0.0 1.0) #(0.4 0.199 1.0) #(0.4 0.4 1.0) #(0.4 0.599 1.0) #(0.4 0.8 1.0) #(0.4 1.0 1.0) #(0.599 0.0 0.0) #(0.599 0.199 0.0) #(0.599 0.4 0.0) #(0.599 0.599 0.0) #(0.599 0.8 0.0) #(0.599 1.0 0.0) #(0.599 0.0 0.199) #(0.599 0.199 0.199) #(0.599 0.4 0.199) #(0.599 0.599 0.199) #(0.599 0.8 0.199) #(0.599 1.0 0.199) #(0.599 0.0 0.4) #(0.599 0.199 0.4) #(0.599 0.4 0.4) #(0.599 0.599 0.4) #(0.599 0.8 0.4) #(0.599 1.0 0.4) #(0.599 0.0 0.599) #(0.599 0.199 0.599) #(0.599 0.4 0.599) #(0.599 0.599 0.599) #(0.599 0.8 0.599) #(0.599 1.0 0.599) #(0.599 0.0 0.8) #(0.599 0.199 0.8) #(0.599 0.4 0.8) #(0.599 0.599 0.8) #(0.599 0.8 0.8) #(0.599 1.0 0.8) #(0.599 0.0 1.0) #(0.599 0.199 1.0) #(0.599 0.4 1.0) #(0.599 0.599 1.0) #(0.599 0.8 1.0) #(0.599 1.0 1.0) #(0.8 0.0 0.0) #(0.8 0.199 0.0) #(0.8 0.4 0.0) #(0.8 0.599 0.0) #(0.8 0.8 0.0) #(0.8 1.0 0.0) #(0.8 0.0 0.199) #(0.8 0.199 0.199) #(0.8 0.4 0.199) #(0.8 0.599 0.199) #(0.8 0.8 0.199) #(0.8 1.0 0.199) #(0.8 0.0 0.4) #(0.8 0.199 0.4) #(0.8 0.4 0.4) #(0.8 0.599 0.4) #(0.8 0.8 0.4) #(0.8 1.0 0.4) #(0.8 0.0 0.599) #(0.8 0.199 0.599) #(0.8 0.4 0.599) #(0.8 0.599 0.599) #(0.8 0.8 0.599) #(0.8 1.0 0.599) #(0.8 0.0 0.8) #(0.8 0.199 0.8) #(0.8 0.4 0.8) #(0.8 0.599 0.8) #(0.8 0.8 0.8) #(0.8 1.0 0.8) #(0.8 0.0 1.0) #(0.8 0.199 1.0) #(0.8 0.4 1.0) #(0.8 0.599 1.0) #(0.8 0.8 1.0) #(0.8 1.0 1.0) #(1.0 0.0 0.0) #(1.0 0.199 0.0) #(1.0 0.4 0.0) #(1.0 0.599 0.0) #(1.0 0.8 0.0) #(1.0 1.0 0.0) #(1.0 0.0 0.199) #(1.0 0.199 0.199) #(1.0 0.4 0.199) #(1.0 0.599 0.199) #(1.0 0.8 0.199) #(1.0 1.0 0.199) #(1.0 0.0 0.4) #(1.0 0.199 0.4) #(1.0 0.4 0.4) #(1.0 0.599 0.4) #(1.0 0.8 0.4) #(1.0 1.0 0.4) #(1.0 0.0 0.599) #(1.0 0.199 0.599) #(1.0 0.4 0.599) #(1.0 0.599 0.599) #(1.0 0.8 0.599) #(1.0 1.0 0.599) #(1.0 0.0 0.8) #(1.0 0.199 0.8) #(1.0 0.4 0.8) #(1.0 0.599 0.8) #(1.0 0.8 0.8) #(1.0 1.0 0.8) #(1.0 0.0 1.0) #(1.0 0.199 1.0) #(1.0 0.4 1.0) #(1.0 0.599 1.0) #(1.0 0.8 1.0) #(1.0 1.0 1.0)  ))! !

!RVMColorScaleView methodsFor: 'drawing' stamp: 'ssa 1/1/1970 00:04'!
drawCanvas
	self canvas fillWhite.
	self orientation = #vertical
		ifTrue:[self drawVertical]
		ifFalse:[self drawHorizontal]! !

!RVMColorScaleView methodsFor: 'drawing' stamp: 'ssa 1/1/1970 01:14'!
drawColorBarHorizontalIn: aRectangle
	| w r |
	w _ aRectangle width  / self colors size.
	r _ aRectangle origin extent: w@aRectangle height.
	self colors do: [:c |
		self canvas fill: r rounded fillColor: c.
		r _ r translateBy: w@0].
! !

!RVMColorScaleView methodsFor: 'drawing' stamp: 'ssa 1/1/1970 00:07'!
drawColorBarVerticalIn: aRectangle
	| h r |
	h _ aRectangle height / self colors size.
	r _ aRectangle origin extent: aRectangle width@h.
	self colors do: [:c |
		self canvas fill: r rounded fillColor: c.
		r _ r translateBy: 0@h].
! !

!RVMColorScaleView methodsFor: 'drawing' stamp: 'ssa 1/1/1970 00:51'!
drawFastCanvas
	self orientation = #vertical
		ifTrue:[self drawFastVertical]
		ifFalse:[self drawFastHorizontal]! !

!RVMColorScaleView methodsFor: 'drawing' stamp: 'ssa 11/4/2008 20:12'!
drawFastHorizontal
	"Display in horizontal style, text labels only for speed"
	|  maxLabel minLabel midLabel box ticLength margin  bigBox leftX midX adjustIcon loc |
	self aspectLabel fillWhite displayOn: self canvas.
	self aspectLabel:self aspect asDisplayText.
	maxLabel _ self scaler max printShowingMax3Digits asDisplayText.
	minLabel _ self scaler min printShowingMax3Digits asDisplayText.
	midLabel _ (self scaler range / 2 + self scaler min) printShowingMax3Digits asDisplayText.
	maxLabel foregroundColor: Color black backgroundColor: Color transparent.
	midLabel foregroundColor: Color black backgroundColor: Color transparent.
	minLabel foregroundColor: Color black backgroundColor: Color transparent.
	bigBox _ self canvas boundingBox.
	box _ bigBox origin+ (0@11) corner: bigBox corner.
	ticLength _ 4.
	margin _ 2.
	leftX _ box topLeft x + 2.
	midX _ box center x.
	self aspectLabel align: self aspectLabel boundingBox bottomCenter with: box bottomCenter.
	self aspectLabel displayOn: self canvas.
	maxLabel align: maxLabel boundingBox topRight with: box topRight + (-2@ticLength+margin).
	maxLabel displayOn: self canvas.
	midLabel align: midLabel boundingBox topCenter with: box topCenter + (0@ticLength+margin).
	midLabel displayOn: self canvas.
	minLabel align: minLabel boundingBox topLeft with: box topLeft +(0@ticLength+margin).
	minLabel displayOn: self canvas.
	self usesScaler ifTrue:[
	adjustIcon _ self adjustScaleIconHorizontal.
	adjustIcon displayOn: self canvas at: (loc _  ((leftX+midX//2)@(bigBox center y + 4)) - adjustIcon boundingBox center).
	self adjustScaleBox: (loc + self insetDisplayBox origin extent: adjustIcon  extent)]! !

!RVMColorScaleView methodsFor: 'drawing' stamp: 'ssa 11/4/2008 20:12'!
drawFastVertical
	"Display in vertical style, only the text labels for speed"
	|  maxLabel minLabel midLabel box ticLength margin  bigBox eraser1 eraser2 eraser3 eraser topY midY adjustIcon loc |
	eraser _ '           '.
	eraser1 _ eraser asDisplayText.
	eraser2 _ eraser asDisplayText.
	eraser3 _ eraser asDisplayText.
	eraser1 foregroundColor: Color white backgroundColor: Color white.
	eraser2 foregroundColor: Color white backgroundColor: Color white.
	eraser3 foregroundColor: Color white backgroundColor: Color white.
	self aspectLabel fillWhite displayOn: self canvas.
	self aspectLabel:(self aspect asDisplayText asParagraph asForm rotateBy: #left centerAt: 0@0).
	maxLabel _ self scaler max printShowingMax3Digits asDisplayText.
	minLabel _ self scaler min printShowingMax3Digits asDisplayText.	
	midLabel _ (self scaler range / 2 + self scaler min) printShowingMax3Digits asDisplayText.
	maxLabel foregroundColor: Color black backgroundColor: Color transparent.
	midLabel foregroundColor: Color black backgroundColor: Color transparent.
	minLabel foregroundColor: Color black backgroundColor: Color transparent.
	bigBox _ self canvas boundingBox.
	box _ bigBox origin + (self aspectLabel width@0)  extent: 40@bigBox height.
	ticLength _ 4.
	margin _ 2.
	topY _ box topRight y + 2 .
	midY _ box center y.
	self aspectLabel align: self  aspectLabel boundingBox leftCenter with: bigBox leftCenter.
	self aspectLabel displayOn: self canvas.
	eraser1 align: eraser1 boundingBox topRight with: box topRight - (ticLength+margin+1@0).
	eraser1 displayOn: self canvas.
	maxLabel align: maxLabel boundingBox topRight with: box topRight - (ticLength+margin+1@0).
	maxLabel displayOn: self canvas.
	eraser2 align: eraser2 boundingBox rightCenter with: box rightCenter - (ticLength+margin+1@0).
	eraser2 displayOn: self canvas.
	midLabel align: midLabel boundingBox rightCenter with: box rightCenter - (ticLength+margin+1@0).
	midLabel displayOn: self canvas.
	eraser3 align: eraser3 boundingBox bottomRight with: box bottomRight -(ticLength+margin+1@0).
	eraser3 displayOn: self canvas.
	minLabel align: minLabel boundingBox bottomRight with: box bottomRight -(ticLength+margin+1@0).
	minLabel displayOn: self canvas.
	self usesScaler ifTrue:[
	adjustIcon _ self adjustScaleIcon.
	adjustIcon displayOn: self canvas at: (loc _ (bigBox topCenter x @ (topY+midY//2)) - adjustIcon boundingBox center).
	self adjustScaleBox: (loc + self insetDisplayBox origin extent: adjustIcon  extent)]! !

!RVMColorScaleView methodsFor: 'drawing' stamp: 'ssa 11/4/2008 20:12'!
drawHorizontal
	"Display in horizontal style"
	|  maxLabel minLabel midLabel box ticLength margin  topY leftX rightX bigBox midX adjustIcon loc |
	self aspectLabel asParagraph asForm  fillWhite displayOn: self canvas.
	self aspectLabel:self aspect asDisplayText.
	maxLabel _ self scaler max printShowingMax3Digits asDisplayText.
	minLabel _ self scaler min printShowingMax3Digits asDisplayText.
	midLabel _ (self scaler range / 2 + self scaler min) printShowingMax3Digits asDisplayText.
	maxLabel foregroundColor: Color black backgroundColor: Color transparent.
	midLabel foregroundColor: Color black backgroundColor: Color transparent.
	minLabel foregroundColor: Color black backgroundColor: Color transparent.
	bigBox _ self canvas boundingBox.
	box _ bigBox origin+ (0@11) corner: bigBox corner.
	self drawColorBarHorizontalIn: (bigBox origin + (0@1) extent:  bigBox width@10).
	ticLength _ 4.
	margin _ 2.
	self aspectLabel align: self aspectLabel boundingBox bottomCenter with: box bottomCenter.
	self aspectLabel displayOn: self canvas.
	maxLabel align: maxLabel boundingBox topRight with: box topRight + (-2@ticLength+margin).
	maxLabel displayOn: self canvas.
	midLabel align: midLabel boundingBox topCenter with: box topCenter + (0@ticLength+margin).
	midLabel displayOn: self canvas.
	minLabel align: minLabel boundingBox topLeft with: box topLeft +(0@ticLength+margin).
	minLabel displayOn: self canvas.
	leftX _ box topLeft x + 2.
	midX _ box center x.
	rightX _ box topRight x - 2.
	topY _ box topRight y  + margin.
	self canvas fill: (leftX@topY corner: rightX @(topY+1)) fillColor: Color black.	
	self canvas fill: (leftX@topY extent: 1@ticLength) fillColor: Color black.
	self canvas fill: (midX+leftX//2@topY extent: 1@ticLength) fillColor: Color black.
	self canvas fill: (midX@topY extent: 1@ticLength) fillColor: Color black.
	self canvas fill: (midX+rightX//2@topY extent: 1@ticLength) fillColor: Color black.
	self canvas fill: (rightX@topY extent: 1@ticLength) fillColor: Color black.
	self usesScaler ifTrue:[
	adjustIcon _ self adjustScaleIconHorizontal.
	adjustIcon displayOn: self canvas at: (loc _  ((leftX+midX//2)@(bigBox center y + 4)) - adjustIcon boundingBox center).
	
	self adjustScaleBox: (loc + self insetDisplayBox origin extent: adjustIcon  extent)]! !

!RVMColorScaleView methodsFor: 'drawing' stamp: 'ssa 11/4/2008 20:12'!
drawVertical
	"Display in vertical style"
	|  maxLabel minLabel midLabel box ticLength margin  topY midY bottomY leftX rightX bigBox adjustIcon loc |
	self aspectLabel fillWhite displayOn: self canvas.
	self aspectLabel:(self aspect asDisplayText asParagraph asForm rotateBy: #left centerAt: 0@0).
	maxLabel _ self scaler max printShowingMax3Digits asDisplayText.
	minLabel _ self scaler min printShowingMax3Digits asDisplayText.	
	midLabel _ (self scaler range / 2 + self scaler min) printShowingMax3Digits asDisplayText.
	maxLabel foregroundColor: Color black backgroundColor: Color transparent.
	midLabel foregroundColor: Color black backgroundColor: Color transparent.
	minLabel foregroundColor: Color black backgroundColor: Color transparent.
	bigBox _ self canvas boundingBox.
	box _ bigBox origin + (aspectLabel width@0)  extent: 40@bigBox height.
	self drawColorBarVerticalIn: (box topRight extent:  10@bigBox height).
	ticLength _ 4.
	margin _ 2.
	self aspectLabel align: self aspectLabel boundingBox leftCenter with: bigBox leftCenter.
	self aspectLabel displayOn: self canvas.
	maxLabel align: maxLabel boundingBox topRight with: box topRight - (ticLength+margin+1@0).
	maxLabel displayOn: self canvas.
	midLabel align: midLabel boundingBox rightCenter with: box rightCenter - (ticLength+margin+1@0).
	midLabel displayOn: self canvas.
	minLabel align: minLabel boundingBox bottomRight with: box bottomRight -(ticLength+margin+1@0).
	minLabel displayOn: self canvas.
	topY _ box topRight y + 2 .
	midY _ box center y.
	bottomY _ box bottomRight y - 3.
	leftX _ box topRight x - ticLength - margin.
	rightX _ box corner x - margin.
	self canvas fill: (rightX - 1@topY corner: rightX@bottomY) fillColor: Color black.	
	self canvas fill: (leftX@topY extent: ticLength@1) fillColor: Color black.
	self canvas fill: (leftX@(topY+midY//2) extent: ticLength@1) fillColor: Color black.
	self canvas fill: (leftX@midY extent: ticLength@1) fillColor: Color black.
	self canvas fill: (leftX@(midY+bottomY//2) extent: ticLength@1) fillColor: Color black.
	self canvas fill: (leftX@bottomY extent: ticLength@1) fillColor: Color black.
	self usesScaler ifTrue:[
	adjustIcon _ self adjustScaleIcon.
	adjustIcon displayOn: self canvas at: (loc _( bigBox topCenter x @ (topY+midY//2)) - adjustIcon boundingBox center).
	self adjustScaleBox: (loc + self insetDisplayBox origin extent: adjustIcon  extent)]! !

!RVMColorScaleView methodsFor: 'framing' stamp: 'ssa 1/1/1970 01:30'!
newFrame
	self canvas: nil.
	self extent: self insetDisplayBox extent.
	self drawCanvas.
	self displayView! !

!RVMColorScaleView class methodsFor: 'instance creation' stamp: 'ssa 11/4/2008 20:16'!
aspectSource: aspectBlock scalerSource: aBlock colorsSource: colorBlock orientation: aSymbol forView: aView adjustScaler: aBoolean
	"Answer a new view.  Use these blocks to access the scaler and colors it will need to display.
	Orientation is #vertical or #horizontal"
	| v |
	v _ self new.
	v aspectSource: aspectBlock.
	v scalerSource: aBlock.
	v colorsSource: colorBlock.
	v orientation: aSymbol.
	v model: aView.
	v usesScaler: aBoolean.
	^v! !

!RVMColorScaleView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:02'!
exampleHorizontal
	"RVMColorScaleView exampleHorizontal"
	self new horizontal demo! !

!RVMColorScaleView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:03'!
exampleVertical
	"RVMColorScaleView exampleVertical"
	self new vertical demo! !

!RVMColoredDataScaler methodsFor: 'privatizing' stamp: 'ssa 9/17/2008 13:01'!
privatize
	"Install a copy of my current scaler so changes to it won't effect others."
	self scaler: self scaler deepCopy! !

!RVMColoredDataScaler methodsFor: 'accessing' stamp: 'ssa 9/17/2008 12:56'!
aspect

	^self scaler aspect! !

!RVMColoredDataScaler methodsFor: 'accessing' stamp: 'ssa 9/17/2008 14:22'!
aspect: aSymbol
	"Swap in a new default scaler for this aspect if different from my current aspect."

	| defaultScaler |
	aSymbol == self aspect ifTrue:[^self].  "no need to change"
	defaultScaler _ RVMMonitor scalerFor: aSymbol.
	self scaler: defaultScaler  "use the shared scaler until user asks for private copy".
! !

!RVMColoredDataScaler methodsFor: 'accessing' stamp: 'ssa 9/13/2008 22:22'!
color
	"Answer the value of color"

	color isNil ifTrue:[self color: Color blue].
	^ color! !

!RVMColoredDataScaler methodsFor: 'accessing' stamp: 'ssa 9/13/2008 22:22'!
color: anObject
	"Set the value of color"

	color _ anObject! !

!RVMColoredDataScaler methodsFor: 'accessing' stamp: 'ssa 9/17/2008 14:23'!
lastObserved

	^self scaler lastObserved! !

!RVMColoredDataScaler methodsFor: 'accessing' stamp: 'ssa 9/17/2008 13:02'!
max

	^self scaler max! !

!RVMColoredDataScaler methodsFor: 'accessing' stamp: 'ssa 9/17/2008 13:02'!
max: aValue

	^self scaler max: aValue! !

!RVMColoredDataScaler methodsFor: 'accessing' stamp: 'ssa 9/17/2008 13:02'!
min

	^self scaler min! !

!RVMColoredDataScaler methodsFor: 'accessing' stamp: 'ssa 9/17/2008 13:02'!
min: aValue

	^self scaler min: aValue! !

!RVMColoredDataScaler methodsFor: 'accessing' stamp: 'ssa 9/17/2008 14:24'!
scale: someData

	^self scaler scale: someData! !

!RVMColoredDataScaler methodsFor: 'accessing' stamp: 'ssa 9/13/2008 22:35'!
scaler
	"Answer the value of scaler"

	scaler isNil ifTrue:[self scaler: RVMDataScaler exampleInstance].
	^ scaler! !

!RVMColoredDataScaler methodsFor: 'accessing' stamp: 'ssa 9/13/2008 22:35'!
scaler: anObject
	"Set the value of scaler"

	scaler _ anObject! !

!RVMColoredDataScaler methodsFor: 'user interface' stamp: 'ssa 9/17/2008 13:05'!
open

	RVMColoredDataScalerView openOn: self.
! !

!RVMColoredDataScaler methodsFor: 'delegation' stamp: 'ssa 9/17/2008 13:03'!
doesNotUnderstand: aMessage
	"See if my scaler understands it."
	Transcript cr;show:'delegating: ',aMessage printString.
	^self scaler perform: aMessage selector withArguments: aMessage arguments! !

!RVMColoredDataScaler class methodsFor: 'instance creation' stamp: 'ssa 9/19/2008 12:35'!
aspect: aSymbol 
	^self aspect: aSymbol color: Color random! !

!RVMColoredDataScaler class methodsFor: 'instance creation' stamp: 'ssa 9/14/2008 20:58'!
aspect: aSymbol color: aColor

	| scaler |
	scaler _ self new.
	scaler scaler: (RVMMonitor scalerFor: aSymbol).
	scaler color: aColor.
	^scaler! !

!RVMColoredDataScaler class methodsFor: 'instance creation' stamp: 'ssa 9/13/2008 22:37'!
aspect: aSymbol min: minValue max: maxValue color: aColor

	| scaler |
	scaler _ self aspect: aSymbol min: minValue max: maxValue.
	scaler color: aColor.
	^scaler! !

!RVMColoredDataScaler class methodsFor: 'examples' stamp: 'ssa 9/17/2008 14:03'!
exampleInstance
	| cs |
	cs _ self new.
	cs scaler:RVMDataScaler exampleInstance.
	cs color: Color blue.
	^cs! !

!RVMColoredDataScalerView methodsFor: 'subView access' stamp: 'ssa 9/17/2008 13:30'!
aspectView
	"Answer a subview on my aspect, the symbol name for the aspect of the data sample I am scaling"
	^RVMAspectLabelView on: self model 
		getAllAspectsWith: [RVMMulticoreSample aspects] 
		getCurrentAspectWith: #aspect 
		setNewAspectWith: #aspect:.! !

!RVMColoredDataScalerView methodsFor: 'subView access' stamp: 'ssa 1/1/1970 01:02'!
autoscaleHardenView
	"Answer a subview showing the autoscale/harden/privatize buttons"
	| view autoscaleButton hardenButton privatizeButton |
	view _ RVMView new.
	autoscaleButton _ RVMButtonView label:'A' style:#action action:[self model scaler setRangeToObserved].
	hardenButton _ RVMButtonView label:'H' style:#action action:[self model scaler harden].
	privatizeButton _ RVMButtonView label:'P' style:#action action:[self model privatize].
	view addSubView: autoscaleButton.
	view addSubView: hardenButton below: autoscaleButton.
	view addSubView: privatizeButton below: hardenButton.
	^view! !

!RVMColoredDataScalerView methodsFor: 'subView access' stamp: 'ssa 9/17/2008 13:59'!
colorButton
	"Answer a subview that shows the color to use to display my data"
	^RVMColorButtonView on: self model 
		colorGetter:#color
		colorSetter: #color:! !

!RVMColoredDataScalerView methodsFor: 'subView access' stamp: 'ssa 1/1/1970 01:16'!
initializeSubViews
	"Add the subviews required to provide a UI for my model, a ColoredDataScaler."
	self addSubView: self aspectView in: (0@0 extent: 5/10 @ (1/2)) borderWidth:0.
	self addSubView: self valueView in: (0@(1/2 )extent: 5/10 @ (1/2)) borderWidth:0.
	self addSubView: self autoscaleHardenView  in: (5/10@0 extent: 1/10@1) borderWidth:0.
	self addSubView: self minMaxView  in: (6/10@0 extent: 4/10@1) borderWidth:1.
! !

!RVMColoredDataScalerView methodsFor: 'subView access' stamp: 'ssa 9/17/2008 14:00'!
minMaxView
	"Answer a subview showing the min/max settings for the data sample I am scaling"
	^RVMMinMaxView on: self model getMin: #min setMin: #min: getMax: #max setMax: #max:! !

!RVMColoredDataScalerView methodsFor: 'subView access' stamp: 'ssa 9/17/2008 13:56'!
valueView
	"Answer a subview that will show the last observed value"
	^RVMValueView on: self model valueGetterOnly:#lastObserved! !

!RVMColoredDataScalerView methodsFor: 'model access' stamp: 'ssa 9/17/2008 13:09'!
model: aColoredDataScaler
	"Set my model and initialize my subviews"
	super model: aColoredDataScaler.
	self initializeSubViews! !

!RVMColoredDataScalerView class methodsFor: 'instance creation' stamp: 'ssa 9/17/2008 13:07'!
on: aColoredDataScaler
	"Answer a new view on this scaler"
	| view |
	view _ self new.
	view model: aColoredDataScaler.
	^view! !

!RVMColoredDataScalerView class methodsFor: 'instance creation' stamp: 'ssa 9/19/2008 12:37'!
onAspect: aSymbol
	^self on: (RVMColoredDataScaler aspect: aSymbol)! !

!RVMColoredDataScalerView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 01:17'!
openOn: aColoredDataScaler
	"RVMColoredDataScalerView openOn: RVMColoredDataScaler exampleInstance"
	"Open a new view on this scaler"
	| topView |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 200@40.
	topView maximumSize: 300@80.
	topView addSubView: (self on: aColoredDataScaler).
	topView label: 'Aspect Data Scaler'.
	topView controller open! !

!RVMColoredDataScalerView class methodsFor: 'instance creation' stamp: 'ssa 9/19/2008 12:35'!
openOnAspect: aSymbol
	"RVMColoredDataScalerView openOnAspect:#bytesUsed"
	self openOn: (RVMColoredDataScaler aspect: aSymbol)! !

!RVMCoreAspectTrace methodsFor: 'accessing' stamp: 'ssa 10/3/2008 23:21'!
aspectLabel

	^'#',self coreIndex printString,' ',self aspect! !

!RVMCoreAspectTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:27'!
coreIndex
	"Answer the value of coreIndex"

	coreIndex isNil ifTrue:[self coreIndex: 1].
	^ coreIndex! !

!RVMCoreAspectTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:27'!
coreIndex: anObject
	"Set the value of coreIndex"

	coreIndex _ anObject! !

!RVMCoreAspectTrace methodsFor: 'updating' stamp: 'ssa 11/17/2008 17:09'!
addData
	"Assume a multi valued data source"
	self add:((RVMMonitor lastSample perform: self aspect) at: self coreIndex + 1)! !

!RVMCoreAspectTrace methodsFor: 'user interface' stamp: 'ssa 1/1/1970 00:46'!
allView
	"Answer a view showing my color and aspect"
	| view |
	view _ RVMView new.
	view model: self.
	view addSubView: self  muteButton in: (0@0 extent: (1/10) @ 1) borderWidth:1.
	view addSubView: self  coreIndexButton in: (1/10@0 extent: (1/10) @ 1) borderWidth:1.
	view addSubView: self  colorButton in: (2/10@0 extent: (1/10) @ 1) borderWidth:1.
	view addSubView: self aspectButton in: ((3/10)@0 extent: (7/10) @ 1) borderWidth:1.
	^view! !

!RVMCoreAspectTrace methodsFor: 'user interface' stamp: 'ssa 1/1/1970 00:20'!
aspectButton
	"Answer an aspect button connect to my aspect"
	^RVMAspectLabelView on: self 
		getAllAspectsWith: [RVMMulticoreSample coreAspects] 
		getCurrentAspectWith: #aspect 
		setNewAspectWith: #aspect:.! !

!RVMCoreAspectTrace methodsFor: 'user interface' stamp: 'ssa 1/1/1970 00:34'!
coreIndexButton
	"Answer an aspect button connect to my aspect"
	^RVMCoreIndexView on: self 
		getCoreIndex:#coreIndex
		setCoreIndex: #coreIndex:
		getAvailableIndicies: [RVMMonitor lastSample  groupStats groupSize]! !

!RVMCoreAspectTrace class methodsFor: 'common uses' stamp: 'ssa 1/1/1970 01:14'!
monitorAllCoreAspectsForCore: anInteger
	"RVMCoreAspectTrace monitorAllCoreAspectsForCore: 1"
	
	| traces colors |
	colors _ (Color wheel: RVMMulticoreSample coreAspects size saturation: 1.0 brightness: 0.7) readStream.
	traces _ OrderedCollection new.
	RVMMulticoreSample coreAspects do:[:aspect|
		traces add:(self coreIndex: anInteger aspect: aspect size: 100 color: colors next)].
	RVMStripChartView openOnTraces: traces titled:'All core aspects for core #',anInteger printString! !

!RVMCoreAspectTrace class methodsFor: 'common uses' stamp: 'ssa 1/1/1970 00:21'!
monitorAllCoreAspectsForCoreFromUser
	"RVMCoreAspectTrace monitorAllCoreAspectsForCoreFromUser"
	
	
	self monitorAllCoreAspectsForCore: RVMMonitor coreIndexFromUser! !

!RVMCoreAspectTrace class methodsFor: 'common uses' stamp: 'ssa 1/1/1970 01:21'!
monitorAspects: someAspects forCore: anInteger
	"RVMCoreAspectTrace monitorAspects: #(bytecodeCounts bytesUseds) forCore:  1"
	
	| traces colors |
	colors _ (Color wheel: someAspects size saturation: 1.0 brightness: 0.7) readStream.
	traces _ OrderedCollection new.
	someAspects do:[:aspect|
		traces add:(self coreIndex: anInteger aspect: aspect size: 100 color: colors next)].
	RVMStripChartView openOnTraces: traces titled:'Selected aspects for core #',anInteger printString! !

!RVMCoreAspectTrace class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 01:32'!
coreIndex: anIndex aspect: aSymbol size: anInteger color: aColor

	| trace |
	trace _ self aspect: aSymbol size: anInteger color: aColor.
	trace coreIndex: anIndex.
	^trace! !

!RVMCoreAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:44'!
exampleInstance
	"RVMCoreAspectTrace exampleInstance"
	^self coreIndex: 1 aspect: #bytesUseds size: 100 color: Color blue! !

!RVMCoreAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:16'!
exampleView1
	"RVMCoreAspectTrace exampleView1"
	
	RVMStripChartView openOnTrace: self exampleInstance! !

!RVMCoreAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:24'!
exampleView2
	"RVMCoreAspectTrace exampleView2"
	
	| traces |
	traces _ OrderedCollection new.
	traces add:(self coreIndex: 1 aspect: #bytecodeCounts size: 200 color: Color blue).
	traces add:(self coreIndex: 1 aspect: #bytesUseds size: 200 color: Color red).
	traces add:(self coreIndex: 1 aspect: #yieldCounts size: 200 color: Color green).
	RVMStripChartView openOnTraces: traces! !

!RVMCoreAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:07'!
exampleView3
	"RVMCoreAspectTrace exampleView3"
	
	| traces |
	traces _ OrderedCollection new.
	1 to:  4 do:[:core|
		traces add:(self coreIndex: core aspect: #bytecodeCounts size: 100 color: Color random).
		traces add:(self coreIndex: core aspect: #bytesUseds size: 100 color: Color random).
		traces add:(self coreIndex: core aspect: #yieldCounts size: 100 color: Color random)].
	RVMStripChartView openOnTraces: traces! !

!RVMCoreAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:38'!
exampleView4
	"RVMCoreAspectTrace exampleView4"
	
	self exampleInstance aspectColorView demo! !

!RVMCoreAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:36'!
exampleView5
	"RVMCoreAspectTrace exampleView5"
	
	self exampleInstance allView demo! !

!RVMCoreAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:06'!
exampleView6
	"RVMCoreAspectTrace exampleView6"
	
	| traces |
	traces _ OrderedCollection new.
	1 to: 10 do:[:core|
		traces add:(self coreIndex: core aspect: #bytecodeCounts size: 100 color: Color random).
		traces add:(self coreIndex: core aspect: #bytesUseds size: 100 color: Color random).
		traces add:(self coreIndex: core aspect: #yieldCounts size: 100 color: Color random)].
	RVMStripChartView openOnTraces: traces! !

!RVMCoreAspectTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:09'!
exampleView7
	"RVMCoreAspectTrace exampleView7"
	
	| traces |
	traces _ OrderedCollection new.
	RVMMulticoreSample coreAspects do:[:aspect|
		traces add:(self coreIndex: 1 aspect: aspect size: 100 color: Color random)].
	RVMStripChartView openOnTraces: traces! !

!RVMCoreIndexController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:14'!
controlActivity
	Cursor menu show.
	super controlActivity! !

!RVMCoreIndexController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:14'!
controlTerminate
	Cursor normal show.
	super controlTerminate! !

!RVMCoreIndexController methodsFor: 'controlling' stamp: 'ssa 11/17/2008 17:10'!
yellowButtonActivity

	| currentIndex maxIndex newIndex |
	currentIndex _ self view coreIndex.
	maxIndex _ self view availableIndicies.
	[newIndex _ FillInTheBlank request:'Enter a new core index between 0 and ',(maxIndex - 1)printString,':' initialAnswer: currentIndex printString.
	(newIndex isEmpty or:[(newIndex asNumber between: 0 and: maxIndex - 1) not])] whileTrue.
	newIndex asNumber = currentIndex ifTrue:[^self].
	self view coreIndex: newIndex asNumber.
	self view displayView
	! !

!RVMCoreIndexView methodsFor: 'displaying' stamp: 'ssa 11/16/2008 00:36'!
displayView
	| labelRect labelText labelForm |
	self okToDisplay ifFalse:[^self].
	self uncache.
	labelText := self label asDisplayText.
	labelText foregroundColor: self foregroundColor
			backgroundColor: self backgroundColor.
	labelForm := labelText
			 asParagraph asForm scaledToSize:(self insetDisplayBox extent min: labelText boundingBox extent).
	labelRect := self insetDisplayBox.
	Display fill: labelRect fillColor: self backgroundColor.	
	labelForm displayOn: Display at: labelRect center - labelForm boundingBox center clippingBox: labelRect
			rule: Form paint fillColor: nil.
	"Display border: (self insetDisplayBox insetBy: 1)width: 1 fillColor: self backgroundColor negated."
! !

!RVMCoreIndexView methodsFor: 'controller access' stamp: 'ssa 1/1/1970 00:14'!
defaultControllerClass

	^RVMCoreIndexController! !

!RVMCoreIndexView methodsFor: 'updating' stamp: 'ssa 11/16/2008 00:24'!
hear: something

	self displayView! !

!RVMCoreIndexView methodsFor: 'updating' stamp: 'ssa 1/1/1970 00:12'!
update: aSymbol

	aSymbol  = self getCoreIndex ifTrue:[self displayView ].
	super update: aSymbol! !

!RVMCoreIndexView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:18'!
availableIndicies
	"Answer the number of indices available"
	^self getAvailableIndicies isSymbol 
		ifTrue:[self model perform: self getAvailableIndicies]
		ifFalse:["assume a block"
			self getAvailableIndicies value]! !

!RVMCoreIndexView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:11'!
coreIndex

	^self getCoreIndex isSymbol 
		ifTrue:[self model perform: self getCoreIndex]
		ifFalse:["assume a block"
			self getCoreIndex value]! !

!RVMCoreIndexView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:11'!
coreIndex: aValue
	self setCoreIndex isSymbol
		ifTrue:[self model perform: self setCoreIndex with: aValue]
		ifFalse:["assume a block"
			self setCoreIndex value: aValue].
! !

!RVMCoreIndexView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:18'!
getAvailableIndicies
	"Answer the value of getAvailableIndicies"

	getAvailableIndicies isNil ifTrue:[self getAvailableIndicies: [RVMMonitor lastSample  groupStats groupSize]].
	^ getAvailableIndicies! !

!RVMCoreIndexView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:17'!
getAvailableIndicies: anObject
	"Set the value of getAvailableIndicies"

	getAvailableIndicies _ anObject! !

!RVMCoreIndexView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:07'!
getCoreIndex
	"Answer the value of getCoreIndex"

	getCoreIndex isNil ifTrue:[self getCoreIndex: #coreIndex].
	^ getCoreIndex! !

!RVMCoreIndexView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:06'!
getCoreIndex: anObject
	"Set the value of getCoreIndex"

	getCoreIndex _ anObject! !

!RVMCoreIndexView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:31'!
label

	^self coreIndex printString! !

!RVMCoreIndexView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:07'!
setCoreIndex
	"Answer the value of setCoreIndex"

	setCoreIndex isNil ifTrue:[self setCoreIndex: #coreIndex:].
	^ setCoreIndex! !

!RVMCoreIndexView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:06'!
setCoreIndex: anObject
	"Set the value of setCoreIndex"

	setCoreIndex _ anObject! !

!RVMCoreIndexView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:30'!
example
	"RVMCoreIndexView example"
	self exampleInstance demo! !

!RVMCoreIndexView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:30'!
exampleInstance
	"RVMCoreIndexView exampleInstance"
	^self on: RVMCoreAspectTrace exampleInstance
		getCoreIndex:#coreIndex
		setCoreIndex: #coreIndex:
		getAvailableIndicies: [RVMMonitor lastSample  groupStats groupSize]! !

!RVMCoreIndexView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:28'!
on: aModel getCoreIndex: getter setCoreIndex: setter getAvailableIndicies: maxIndexGetter

	| view |
	view _ self new.
	view model: aModel;
		getCoreIndex: getter;
		setCoreIndex: setter;
		getAvailableIndicies: maxIndexGetter.
	^view! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
aboutToWriteReadMostlyMemoryMessage
	"Answer the tally for this message."
	^aboutToWriteReadMostlyMemoryMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
aboutToWriteReadMostlyMemoryMessage: aValue
	"Answer the tally for this message."
	aboutToWriteReadMostlyMemoryMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
aboutToWriteReadMostlyMemoryResponse
	"Answer the tally for this message."
	^aboutToWriteReadMostlyMemoryResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
aboutToWriteReadMostlyMemoryResponse: aValue
	"Answer the tally for this message."
	aboutToWriteReadMostlyMemoryResponse _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
addObjectFromSnapshotMessage
	"Answer the tally for this message."
	^addObjectFromSnapshotMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
addObjectFromSnapshotMessage: aValue
	"Answer the tally for this message."
	addObjectFromSnapshotMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
allocateOrRecycleContextJustTestingMessage
	"Answer the tally for this message."
	^allocateOrRecycleContextJustTestingMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
allocateOrRecycleContextJustTestingMessage: aValue
	"Answer the tally for this message."
	allocateOrRecycleContextJustTestingMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
allocateOrRecycleContextMessage
	"Answer the tally for this message."
	^allocateOrRecycleContextMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
allocateOrRecycleContextMessage: aValue
	"Answer the tally for this message."
	allocateOrRecycleContextMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
broadcastInterpreterBoolMessage
	"Answer the tally for this message."
	^broadcastInterpreterBoolMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
broadcastInterpreterBoolMessage: aValue
	"Answer the tally for this message."
	broadcastInterpreterBoolMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
broadcastInterpreterDoublewordMessage
	"Answer the tally for this message."
	^broadcastInterpreterDoublewordMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
broadcastInterpreterDoublewordMessage: aValue
	"Answer the tally for this message."
	broadcastInterpreterDoublewordMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
broadcastInterpreterWordMessage
	"Answer the tally for this message."
	^broadcastInterpreterWordMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
broadcastInterpreterWordMessage: aValue
	"Answer the tally for this message."
	broadcastInterpreterWordMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 3/26/2009 10:05'!
determineTalliesInOrder
	"Answer an array of tallies in the order they appear in the sample"
	^self tallyOrder collect:[:label| self perform: label]! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
doAllRootsHereMessage
	"Answer the tally for this message."
	^doAllRootsHereMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
doAllRootsHereMessage: aValue
	"Answer the tally for this message."
	doAllRootsHereMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
doAllRootsThereMessage
	"Answer the tally for this message."
	^doAllRootsThereMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
doAllRootsThereMessage: aValue
	"Answer the tally for this message."
	doAllRootsThereMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
doAllRootsThereResponse
	"Answer the tally for this message."
	^doAllRootsThereResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
doAllRootsThereResponse: aValue
	"Answer the tally for this message."
	doAllRootsThereResponse _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapMessage
	"Answer the tally for this message."
	^enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapMessage: aValue
	"Answer the tally for this message."
	enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapResponse
	"Answer the tally for this message."
	^enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapResponse: aValue
	"Answer the tally for this message."
	enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapResponse _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapMessage
	"Answer the tally for this message."
	^enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapMessage: aValue
	"Answer the tally for this message."
	enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapResponse
	"Answer the tally for this message."
	^enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapResponse: aValue
	"Answer the tally for this message."
	enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapResponse _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
enforceCoherenceBeforeSenderStoresIntoAllHeapsMessage
	"Answer the tally for this message."
	^enforceCoherenceBeforeSenderStoresIntoAllHeapsMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
enforceCoherenceBeforeSenderStoresIntoAllHeapsMessage: aValue
	"Answer the tally for this message."
	enforceCoherenceBeforeSenderStoresIntoAllHeapsMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
enforceCoherenceBeforeSenderStoresIntoAllHeapsResponse
	"Answer the tally for this message."
	^enforceCoherenceBeforeSenderStoresIntoAllHeapsResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
enforceCoherenceBeforeSenderStoresIntoAllHeapsResponse: aValue
	"Answer the tally for this message."
	enforceCoherenceBeforeSenderStoresIntoAllHeapsResponse _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
flushByMethodMessage
	"Answer the tally for this message."
	^flushByMethodMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
flushByMethodMessage: aValue
	"Answer the tally for this message."
	flushByMethodMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
flushFreeContextsMessage
	"Answer the tally for this message."
	^flushFreeContextsMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
flushFreeContextsMessage: aValue
	"Answer the tally for this message."
	flushFreeContextsMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
flushInterpreterCachesMessage
	"Answer the tally for this message."
	^flushInterpreterCachesMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
flushInterpreterCachesMessage: aValue
	"Answer the tally for this message."
	flushInterpreterCachesMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
flushMethodCacheMessage
	"Answer the tally for this message."
	^flushMethodCacheMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
flushMethodCacheMessage: aValue
	"Answer the tally for this message."
	flushMethodCacheMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
flushSelectiveMessage
	"Answer the tally for this message."
	^flushSelectiveMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
flushSelectiveMessage: aValue
	"Answer the tally for this message."
	flushSelectiveMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
hereIsARootResponse
	"Answer the tally for this message."
	^hereIsARootResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
hereIsARootResponse: aValue
	"Answer the tally for this message."
	hereIsARootResponse _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
initiateBarrierMessage
	"Answer the tally for this message."
	^initiateBarrierMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
initiateBarrierMessage: aValue
	"Answer the tally for this message."
	initiateBarrierMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
loadFunctionFromPluginMessage
	"Answer the tally for this message."
	^loadFunctionFromPluginMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
loadFunctionFromPluginMessage: aValue
	"Answer the tally for this message."
	loadFunctionFromPluginMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
loadFunctionFromPluginResponse
	"Answer the tally for this message."
	^loadFunctionFromPluginResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
loadFunctionFromPluginResponse: aValue
	"Answer the tally for this message."
	loadFunctionFromPluginResponse _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
newValueForOopMessage
	"Answer the tally for this message."
	^newValueForOopMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
newValueForOopMessage: aValue
	"Answer the tally for this message."
	newValueForOopMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
noMoreRootsResponse
	"Answer the tally for this message."
	^noMoreRootsResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
noMoreRootsResponse: aValue
	"Answer the tally for this message."
	noMoreRootsResponse _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
rawData
	"Answer the tally for this message."
	^rawData! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
rawData: aValue
	"Answer the tally for this message."
	rawData _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
recycleContextIfPossibleMessage
	"Answer the tally for this message."
	^recycleContextIfPossibleMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
recycleContextIfPossibleMessage: aValue
	"Answer the tally for this message."
	recycleContextIfPossibleMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
respondToBarrierMessage
	"Answer the tally for this message."
	^respondToBarrierMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
respondToBarrierMessage: aValue
	"Answer the tally for this message."
	respondToBarrierMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
returnContextMessage
	"Answer the tally for this message."
	^returnContextMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
returnContextMessage: aValue
	"Answer the tally for this message."
	returnContextMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
runPrimitiveJustTestingMessage
	"Answer the tally for this message."
	^runPrimitiveJustTestingMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
runPrimitiveJustTestingMessage: aValue
	"Answer the tally for this message."
	runPrimitiveJustTestingMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
runPrimitiveMessage
	"Answer the tally for this message."
	^runPrimitiveMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
runPrimitiveMessage: aValue
	"Answer the tally for this message."
	runPrimitiveMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
runPrimitiveResponse
	"Answer the tally for this message."
	^runPrimitiveResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
runPrimitiveResponse: aValue
	"Answer the tally for this message."
	runPrimitiveResponse _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
sampleOneCoreMessage
	"Answer the tally for this message."
	^sampleOneCoreMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
sampleOneCoreMessage: aValue
	"Answer the tally for this message."
	sampleOneCoreMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
sampleOneCoreResponse
	"Answer the tally for this message."
	^sampleOneCoreResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
sampleOneCoreResponse: aValue
	"Answer the tally for this message."
	sampleOneCoreResponse _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
scanCompactOrMakeFreeObjectsMessage
	"Answer the tally for this message."
	^scanCompactOrMakeFreeObjectsMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
scanCompactOrMakeFreeObjectsMessage: aValue
	"Answer the tally for this message."
	scanCompactOrMakeFreeObjectsMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
scanCompactOrMakeFreeObjectsResponse
	"Answer the tally for this message."
	^scanCompactOrMakeFreeObjectsResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
scanCompactOrMakeFreeObjectsResponse: aValue
	"Answer the tally for this message."
	scanCompactOrMakeFreeObjectsResponse _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 3/26/2009 10:05'!
talliesInOrder
	"Answer an array of tallies in the order they appear in the sample"
	^self talliesInOrderCache! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 3/26/2009 10:05'!
talliesInOrderCache
	"Answer the value of talliesInOrderCache"

	talliesInOrderCache isNil ifTrue:[self talliesInOrderCache: self determineTalliesInOrder].
	^ talliesInOrderCache! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 3/26/2009 10:04'!
talliesInOrderCache: anObject
	"Set the value of talliesInOrderCache"

	talliesInOrderCache _ anObject! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 3/26/2009 10:16'!
tallyOrder
	"Answer an array of tally names in the order they appear in the sample"
	"RVMMulticoreSample primitiveCapture at: 8"
	^self class tallyOrder! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
updateEnoughInterpreterToTransferControlJustTestingMessage
	"Answer the tally for this message."
	^updateEnoughInterpreterToTransferControlJustTestingMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
updateEnoughInterpreterToTransferControlJustTestingMessage: aValue
	"Answer the tally for this message."
	updateEnoughInterpreterToTransferControlJustTestingMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
updateEnoughInterpreterToTransferControlJustTestingResponse
	"Answer the tally for this message."
	^updateEnoughInterpreterToTransferControlJustTestingResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
updateEnoughInterpreterToTransferControlJustTestingResponse: aValue
	"Answer the tally for this message."
	updateEnoughInterpreterToTransferControlJustTestingResponse _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
updateEnoughInterpreterToTransferControlMessage
	"Answer the tally for this message."
	^updateEnoughInterpreterToTransferControlMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
updateEnoughInterpreterToTransferControlMessage: aValue
	"Answer the tally for this message."
	updateEnoughInterpreterToTransferControlMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
updateWholeInterpreterMessage
	"Answer the tally for this message."
	^updateWholeInterpreterMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
updateWholeInterpreterMessage: aValue
	"Answer the tally for this message."
	updateWholeInterpreterMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
verifyInterpreterAndHeapMessage
	"Answer the tally for this message."
	^verifyInterpreterAndHeapMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
verifyInterpreterAndHeapMessage: aValue
	"Answer the tally for this message."
	verifyInterpreterAndHeapMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
wroteReadMostlyMemoryMessage
	"Answer the tally for this message."
	^wroteReadMostlyMemoryMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
wroteReadMostlyMemoryMessage: aValue
	"Answer the tally for this message."
	wroteReadMostlyMemoryMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
zapUnusedPortionOfHeapMessage
	"Answer the tally for this message."
	^zapUnusedPortionOfHeapMessage! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
zapUnusedPortionOfHeapMessage: aValue
	"Answer the tally for this message."
	zapUnusedPortionOfHeapMessage _ aValue! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
zapUnusedPortionOfHeapResponse
	"Answer the tally for this message."
	^zapUnusedPortionOfHeapResponse! !

!RVMCoreMessageTally methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:22'!
zapUnusedPortionOfHeapResponse: aValue
	"Answer the tally for this message."
	zapUnusedPortionOfHeapResponse _ aValue! !

!RVMCoreMessageTally class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:00'!
fastForData: data
	"Answer a new instance of me initialized to tally these messages"
	| tally |
	tally := self new.
	tally rawData: data.
	tally allocateOrRecycleContextMessage: (data at: 1).
	tally allocateOrRecycleContextJustTestingMessage: (data at: 2).
	tally recycleContextIfPossibleMessage: (data at: 3).
	tally flushInterpreterCachesMessage: (data at: 4).
	tally flushMethodCacheMessage: (data at: 5).
	tally flushByMethodMessage: (data at: 6).
	tally flushSelectiveMessage: (data at: 7).
	tally addObjectFromSnapshotMessage: (data at: 8).
	tally updateWholeInterpreterMessage: (data at: 9).
	tally updateEnoughInterpreterToTransferControlMessage: (data at: 10).
	tally updateEnoughInterpreterToTransferControlJustTestingMessage: (data at: 11).
	tally updateEnoughInterpreterToTransferControlJustTestingResponse: (data at: 12).
	tally zapUnusedPortionOfHeapMessage: (data at: 13).
	tally zapUnusedPortionOfHeapResponse: (data at: 14).
	tally verifyInterpreterAndHeapMessage: (data at: 15).
	tally doAllRootsThereMessage: (data at: 16).
	tally doAllRootsThereResponse: (data at: 17).
	tally doAllRootsHereMessage: (data at: 18).
	tally hereIsARootResponse: (data at: 19).
	tally newValueForOopMessage: (data at: 20).
	tally noMoreRootsResponse: (data at: 21).
	tally scanCompactOrMakeFreeObjectsMessage: (data at: 22).
	tally scanCompactOrMakeFreeObjectsResponse: (data at: 23).
	tally returnContextMessage: (data at: 24).
	tally runPrimitiveMessage: (data at: 25).
	tally runPrimitiveJustTestingMessage: (data at: 26).
	tally runPrimitiveResponse: (data at: 27).
	tally loadFunctionFromPluginMessage: (data at: 28).
	tally loadFunctionFromPluginResponse: (data at: 29).
	tally broadcastInterpreterDoublewordMessage: (data at: 30).
	tally broadcastInterpreterWordMessage: (data at: 31).
	tally broadcastInterpreterBoolMessage: (data at: 32).
	tally sampleOneCoreMessage: (data at: 33).
	tally sampleOneCoreResponse: (data at: 34).
	tally initiateBarrierMessage: (data at: 35).
	tally respondToBarrierMessage: (data at: 36).
	tally aboutToWriteReadMostlyMemoryMessage: (data at: 37).
	tally aboutToWriteReadMostlyMemoryResponse: (data at: 38).
	tally wroteReadMostlyMemoryMessage: (data at: 39).
	tally flushFreeContextsMessage: (data at: 40).
	tally enforceCoherenceBeforeSenderStoresIntoAllHeapsMessage: (data at: 41).
	tally enforceCoherenceBeforeSenderStoresIntoAllHeapsResponse: (data at: 42).
	tally enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapMessage: (data at: 43).
	tally enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapResponse: (data at: 44).
	tally enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapMessage: (data at: 45).
	tally enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapResponse: (data at: 46).
	^tally! !

!RVMCoreMessageTally class methodsFor: 'instance creation' stamp: 'dmu 1/1/1970 00:02'!
forMessageNames: aCollectionOfMessageNames andData: data
	"Answer a new instance of me initialized to tally these messages"
	| tally |
	tally := self new.
	tally rawData: data.
	1 to: data size do:[:index|
		tally perform:((aCollectionOfMessageNames at: index),':') asSymbol with:(data at: index)].
	^tally! !

!RVMCoreMessageTally class methodsFor: 'code generation' stamp: 'ssa 3/26/2009 10:14'!
adaptToNewTallyMessages
	"RVMCoreMessageTally adaptToNewTallyMessages"
	"Change this class to work with the new messages"
	"BE SURE TO UPDATE tallyOrder MESSAGE IF THE TALLY ORDER CHANGES"
	
| messageNames code index |
messageNames _ (RVMMulticoreSample primitiveCapture at: 8) asOrderedCollection.
messageNames add: 'rawData'.

RVMObject subclass: #RVMCoreMessageTally
	instanceVariableNames: messageNames asArray
	classVariableNames: ''
	poolDictionaries: ''
	category: 'RVM-Monitoring'.

code _ 'fastForData: data
	"Answer a new instance of me initialized to tally these messages"
	| tally |
	tally := self new.
	tally rawData: data.
	'.
index _ 0.
messageNames remove: 'rawData'.
messageNames do:[:messageName| index _ index + 1.
	code _ code, 'tally ',messageName,': (data at: ',index printString,').
	'].
code _ code,'^tally'.
RVMCoreMessageTally class compile: code classified:'instance creation' notifying:nil.

RVMCoreMessageTally removeCategory: 'accessing'.
messageNames do:[:selector|
	code _ selector,'
	"Answer the tally for this message."
	^',selector.
	RVMCoreMessageTally  compile: code classified:'accessing' notifying:nil.	
	code _ selector,': aValue
	"Answer the tally for this message."
	',selector,' _ aValue'.
	RVMCoreMessageTally  compile: code classified:'accessing' notifying:nil].	
! !

!RVMCoreMessageTally class methodsFor: 'accessing' stamp: 'ssa 3/26/2009 10:15'!
tallyOrder
	"Answer an array of tally names in the order they appear in the sample"
	"RVMMulticoreSample primitiveCapture at: 8"
	^#(#allocateOrRecycleContextMessage
	#allocateOrRecycleContextJustTestingMessage
	#recycleContextIfPossibleMessage
	#flushInterpreterCachesMessage
	#flushMethodCacheMessage
	#flushByMethodMessage
	#flushSelectiveMessage
	#addObjectFromSnapshotMessage
	#updateWholeInterpreterMessage
	#updateEnoughInterpreterToTransferControlMessage
	#updateEnoughInterpreterToTransferControlJustTestingMessage
	#updateEnoughInterpreterToTransferControlJustTestingResponse
	#zapUnusedPortionOfHeapMessage
	#zapUnusedPortionOfHeapResponse
	#verifyInterpreterAndHeapMessage
	#doAllRootsThereMessage
	#doAllRootsThereResponse
	#doAllRootsHereMessage
	#hereIsARootResponse
	#newValueForOopMessage
	#noMoreRootsResponse
	#scanCompactOrMakeFreeObjectsMessage
	#scanCompactOrMakeFreeObjectsResponse
	#returnContextMessage
	#runPrimitiveMessage
	#runPrimitiveJustTestingMessage
	#runPrimitiveResponse
	#loadFunctionFromPluginMessage
	#loadFunctionFromPluginResponse
	#broadcastInterpreterDoublewordMessage
	#broadcastInterpreterWordMessage
	#broadcastInterpreterBoolMessage
	#sampleOneCoreMessage
	#sampleOneCoreResponse
	#initiateBarrierMessage
	#respondToBarrierMessage
	#aboutToWriteReadMostlyMemoryMessage
	#aboutToWriteReadMostlyMemoryResponse
	#wroteReadMostlyMemoryMessage
	#flushFreeContextsMessage
	#enforceCoherenceBeforeSenderStoresIntoAllHeapsMessage
	#enforceCoherenceBeforeSenderStoresIntoAllHeapsResponse
	#enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapMessage
	#enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapResponse
	#enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapMessage
	#enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapResponse)
! !

!RVMDataScaler methodsFor: 'private' stamp: 'ssa 11/4/2008 15:50'!
setMax: aValue
	"No side effects"
	max _ aValue.
	self range:nil! !

!RVMDataScaler methodsFor: 'private' stamp: 'ssa 11/4/2008 15:50'!
setMin: aValue
	"No side effects"
	min _ aValue.
	
	self range:nil! !

!RVMDataScaler methodsFor: 'scaling data' stamp: 'ssa 11/4/2008 15:08'!
adjustMax
	"Adjust my max based on my observedMax"
	| newMax |
	self maxLocked ifTrue:[^self].
	newMax _ self max max: self observedMax.
	self max = newMax ifTrue:[^self].
	self outOfRangeDetected: true.
	self max: newMax! !

!RVMDataScaler methodsFor: 'scaling data' stamp: 'ssa 11/4/2008 15:09'!
adjustMin
	"Adjust my min based on my observedMin"
	| newMin |
	self minLocked ifTrue:[^self].
	newMin _ self min min: self observedMin.
	self min = newMin ifTrue:[^self].
	self outOfRangeDetected: true.
	self min: newMin! !

!RVMDataScaler methodsFor: 'scaling data' stamp: 'ssa 1/1/1970 00:40'!
automatic
	"Set to automatic scaling mode.
	This mode expands the min/max over time to adapt to the data being observed.
	Send the message #resetScaling to flush historical min/max and rescale."
	
	self automaticScaling: true.
	self resetScaling! !

!RVMDataScaler methodsFor: 'scaling data' stamp: 'ssa 1/1/1970 00:40'!
manual
	"Turn off automatic scaling mode.
	Stops adapting min/max"
	
	self automaticScaling: false.
! !

!RVMDataScaler methodsFor: 'scaling data' stamp: 'ssa 10/6/2008 16:28'!
resetObservations
	"Reset my memory of min/max observations and my min/max as well once the first data value is observed."
	self observedMin:nil.
	self observedMax: nil.! !

!RVMDataScaler methodsFor: 'scaling data' stamp: 'ssa 1/1/1970 00:15'!
resetOutOfRangeDetector
	"Reset my out of range detector"
	self outOfRangeDetected: false.! !

!RVMDataScaler methodsFor: 'scaling data' stamp: 'ssa 10/6/2008 16:29'!
resetScaling
	"Reset my memory of min/max observations and my min/max as well once the first data value is observed."
	min _ nil.
	max _  nil.
	observedMin _ nil.
	observedMax _  nil.
	range _ nil! !

!RVMDataScaler methodsFor: 'scaling data' stamp: 'ssa 10/7/2008 17:35'!
scale: someData
	"Answer a number between 0-100 representing the percentage location of this data between my min and max"
	
	self lastObserved: someData.
	self observedMin:(self observedMin min: someData).
	self observedMax:(self observedMax max: someData).
	someData <= self min ifTrue:[^0].
	someData >= self max ifTrue:[^100].
	^someData - self min * 100.0 /  self range ! !

!RVMDataScaler methodsFor: 'scaling data' stamp: 'ssa 1/1/1970 01:10'!
setRangeToObserved
	"Set my min and max to what I have observed in my data scaling"
	
	min _ self observedMin.
	max _ self observedMax.
	self range: nil
	! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 9/13/2008 19:57'!
aspect
	"Answer the value of aspect"

	aspect isNil ifTrue:[self aspect: #notDefinedYet].
	^ aspect! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 9/13/2008 19:56'!
aspect: anObject
	"Set the value of aspect"

	aspect _ anObject! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:39'!
automaticScaling
	"Answer the value of automaticScaling"

	automaticScaling isNil ifTrue:[self automaticScaling: false].
	^ automaticScaling! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:39'!
automaticScaling: anObject
	"Set the value of automaticScaling"

	automaticScaling _ anObject! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 9/14/2008 21:33'!
lastObserved
	"Answer the value of lastObserved"

	lastObserved isNil ifTrue:[self lastObserved: 0].
	^ lastObserved! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 9/14/2008 21:33'!
lastObserved: anObject
	"Set the value of lastObserved"

	lastObserved _ anObject! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 10/3/2008 20:08'!
max
	"Answer the value of max"

	max isNil ifTrue:[^1].
	^ max! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 9/19/2008 10:53'!
max: aNumber
	"Set the value of max"

	max _ min isNil ifTrue:[aNumber] ifFalse:[aNumber max: self min].
	self range:nil! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:20'!
maxLocked
	"Answer the value of maxLocked"

	maxLocked isNil ifTrue:[self maxLocked: false].
	^ maxLocked! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:20'!
maxLocked: anObject
	"Set the value of maxLocked"

	maxLocked _ anObject! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 10/6/2008 20:22'!
min
	"Answer the value of min"
	self pinAtZero ifTrue:[^0].
	min isNil ifTrue:[self min: 100000000].
	^ min! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 9/19/2008 10:53'!
min: aNumber
	"Set the value of min"

	min _ max isNil ifTrue:[aNumber] ifFalse:[aNumber min: self max].
	self range:nil! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:20'!
minLocked
	"Answer the value of minLocked"

	minLocked isNil ifTrue:[self minLocked: false].
	^ minLocked! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:20'!
minLocked: anObject
	"Set the value of minLocked"

	minLocked _ anObject! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 9/13/2008 19:45'!
observedMax
	"Answer the value of observedMax"

	observedMax isNil ifTrue:[self observedMax: -10000000000].
	^ observedMax! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:43'!
observedMax: aNumber
	"Set the value of observedMax"

	observedMax _ aNumber.
	self automaticScaling ifTrue:[self adjustMax]! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 9/13/2008 19:45'!
observedMin
	"Answer the value of observedMin"

	observedMin isNil ifTrue:[self observedMin:  10000000000].
	^ observedMin! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:44'!
observedMin: aNumber
	"Set the value of observedMin"

	observedMin _ aNumber.
	self automaticScaling ifTrue:[self adjustMin]! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:14'!
outOfRangeDetected
	"Answer the value of outOfRangeDetected"

	outOfRangeDetected isNil ifTrue:[self outOfRangeDetected: false].
	^ outOfRangeDetected! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 10/2/2008 19:12'!
outOfRangeDetected: anObject
	"Set the value of outOfRangeDetected"

	outOfRangeDetected _ anObject! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 10/6/2008 20:22'!
pinAtZero
	"Answer the value of pinAtZero"

	pinAtZero isNil ifTrue:[self pinAtZero: false].
	^ pinAtZero! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 10/6/2008 20:21'!
pinAtZero: anObject
	"Set the value of pinAtZero"

	pinAtZero _ anObject! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 10/6/2008 20:50'!
pinMinAtZero	

	self pinAtZero: true! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:52'!
range
	"Answer the value of range"

	range isNil ifTrue:[self range: (self max - self min)].
	^ range! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:52'!
range: anObject
	"Set the value of range"

	range _ anObject! !

!RVMDataScaler methodsFor: 'accessing' stamp: 'ssa 10/6/2008 20:50'!
unpinMinAtZero	

	self pinAtZero: false! !

!RVMDataScaler methodsFor: 'data generation' stamp: 'ssa 9/13/2008 19:33'!
atRandom
	"Answer a random data value in my range."
	^ self range atRandom + self min! !

!RVMDataScaler methodsFor: 'autocoding' stamp: 'ssa 9/13/2008 20:13'!
harden
	"Compile a method into RVMMonitor that will reproduce a scaler like me."
	RVMMonitor autocodeScalerMethodForScaler: self! !

!RVMDataScaler methodsFor: 'user interface' stamp: 'ssa 9/13/2008 22:38'!
open

	| cs |
	cs _ RVMColoredDataScaler new.
	cs scaler: self.
	cs color: Color random.
	cs open! !

!RVMDataScaler methodsFor: 'printing' stamp: 'ssa 10/6/2008 16:19'!
printOn: aStream

	super printOn: aStream.
	aStream nextPutAll: 'min:',self min printString,' max:',self max printString! !

!RVMDataScaler class methodsFor: 'examples' stamp: 'ssa 9/13/2008 17:59'!
example1
	"RVMDataScaler example1"
	
	| scaler |
	scaler _ self min: 5 max: 15.
	1 to: 20 do:[:value|
		Transcript cr;show: 'value: ',value printString,' => scaled: ',(scaler scale: value) printString]! !

!RVMDataScaler class methodsFor: 'examples' stamp: 'ssa 9/13/2008 18:00'!
example2
	"RVMDataScaler example2"
	
	| scaler |
	scaler _ self min: 0.5 max: 1.5.
	0.1 to: 2.0  by: 0.1 do:[:value|
		Transcript cr;show: 'value: ',value printString,' => scaled: ',(scaler scale: value) printString]! !

!RVMDataScaler class methodsFor: 'examples' stamp: 'ssa 9/13/2008 18:02'!
example3
	"RVMDataScaler example3"
	
	| scaler |
	scaler _ self min: -5 max: -1.
	-7  to: 0  by: 1 do:[:value|
		Transcript cr;show: 'value: ',value printString,' => scaled: ',(scaler scale: value) printString]! !

!RVMDataScaler class methodsFor: 'examples' stamp: 'ssa 9/13/2008 18:02'!
example4
	"RVMDataScaler example4"
	
	| scaler |
	scaler _ self min: -5 max: 5.
	-7  to: 7 by: 1 do:[:value|
		Transcript cr;show: 'value: ',value printString,' => scaled: ',(scaler scale: value) printString]! !

!RVMDataScaler class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:48'!
exampleInstance
	"RVMDataScaler exampleInstance"
	
	^self aspect: #bytesUseds min: 0 max: 100000! !

!RVMDataScaler class methodsFor: 'instance creation' stamp: 'ssa 9/13/2008 19:57'!
aspect: aSymbol min: minValue max: maxValue
	"Answer a new data scaler with this range."
	| scaler |
	scaler _ self new.
	scaler aspect: aSymbol.
	scaler min: minValue.
	scaler max: maxValue.
	^scaler! !

!RVMDataScaler class methodsFor: 'instance creation' stamp: 'ssa 9/13/2008 19:58'!
min: minValue max: maxValue
	"Answer a new data scaler with this range."
	
	^self aspect: nil min: minValue max: maxValue! !

!RVMDynamicScoper commentStamp: 'dmu 8/9/2011 11:41' prior: 0!
I implement dynamic scoping; crucial for multithreaded apps, by added instance variables to Process on demand.!
!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/11/2011 21:53'!
addAccessMessage: selectorToAdd sending: selectorToSend
	| methodText |
	(self class methodDictionary includesKey: selectorToAdd) ifTrue: [^ self].
	methodText _ selectorToAdd, '   ^ Processor thisProcess ', selectorToSend.
	self class compileSilently: methodText classified: self createdMethodCategory! !

!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/9/2011 18:21'!
addProcessAccessMethod: accessSelector
	| mungedAccessSelector mungedInstanceVariable methodText |
	mungedAccessSelector _ self munge: accessSelector.
	(Process methodDictionary includesKey: mungedAccessSelector) ifTrue: [^ self].
	mungedInstanceVariable _ mungedAccessSelector.
	methodText _ mungedAccessSelector, '  "created by ', self className, '>addProcessAccessMethod:"  ^', mungedInstanceVariable.
	Process compileSilently: methodText classified: self createdMethodCategory! !

!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/11/2011 22:59'!
addProcessAssignmentMethod: assignmentSelector
	| mungedAssignmentSelector mungedInstanceVariable methodText |
	mungedAssignmentSelector _ self munge: assignmentSelector.
	mungedInstanceVariable _ mungedAssignmentSelector copyFrom: 1 to: mungedAssignmentSelector size - 1.
	(Process methodDictionary includesKey: mungedAssignmentSelector) ifTrue: [^ self].
	methodText _ mungedAssignmentSelector, ' x   "created by ', self className, '>addProcessAssignmentMethod:"  ',  mungedInstanceVariable, ' :=  x'.
	Process compileSilently: methodText classified: self createdMethodCategory! !

!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/9/2011 15:24'!
addProcessInstanceVariable: variableName
	| mungedName |
	mungedName _ self munge: variableName.
	(Process  allInstVarNames includes: mungedName) ifTrue: [^ self].
	Process addInstVarName: mungedName! !

!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/11/2011 21:54'!
addRegistrationMessage: selectorToAdd sending: selectorToSend
	| methodText |
	(self class methodDictionary includesKey: selectorToAdd) ifTrue: [^ self].
	methodText _ selectorToAdd, ' x     Processor thisProcess ',  selectorToSend, ' x'.
	self class compileSilently: methodText classified: self createdMethodCategory! !

!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/9/2011 18:53'!
computeAccessAndAssignmentSelectorsFrom: selector into: resultBlock
	| selectorWithoutPrefix assignmentSelector accessSelector |
	selectorWithoutPrefix _ self stripPrefixFrom:  selector.
	self ensureSingleArgument: selectorWithoutPrefix.
	assignmentSelector _ selectorWithoutPrefix.
	accessSelector _ selectorWithoutPrefix copyFrom: 1 to: selectorWithoutPrefix size - 1.
	resultBlock value: accessSelector asSymbol value: assignmentSelector asSymbol! !

!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/11/2011 21:52'!
createAndRunRegistrationMessage: aMessage
	| assignmentSelector accessSelector |
	self computeAccessAndAssignmentSelectorsFrom: aMessage selector into: [:acc :agn | accessSelector _ acc.  assignmentSelector _ agn].
	self addProcessInstanceVariable: accessSelector.
	self addProcessAccessMethod: accessSelector.
	self addProcessAssignmentMethod: assignmentSelector.

	self addRegistrationMessage: aMessage selector sending: (self munge: assignmentSelector).
	self addAccessMessage: accessSelector sending: (self munge: accessSelector).

	^ self perform: aMessage selector with: aMessage argument! !

!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/9/2011 18:38'!
createdMethodCategory
	^ '*created-by-', self className! !

!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/9/2011 14:55'!
doesNotUnderstand: aMessage
	| selector |
	selector _ aMessage selector.
	(selector beginsWith: self prefix) ifFalse: [^ super doesNotUnderstand: aMessage].
	^ self createAndRunRegistrationMessage: aMessage! !

!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/9/2011 12:00'!
ensureSingleArgument: aSelector
	(aSelector indexOf: $:) = aSelector size ifFalse: [self error: 'expecting a one-arg keyword']! !

!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/9/2011 18:37'!
munge: identifierOrKeyword
	| asCreated |
	asCreated _ 'AsCreatedBy', self name.
	^ (
		identifierOrKeyword last = $:
	 		ifTrue: [ (identifierOrKeyword copyFrom: 1 to: identifierOrKeyword size - 1), asCreated, ':' ]
			ifFalse: [ identifierOrKeyword, asCreated ]
	) asSymbol! !

!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/9/2011 12:05'!
prefix ^'register'! !

!RVMDynamicScoper class methodsFor: 'as yet unclassified' stamp: 'dmu 8/9/2011 12:05'!
stripPrefixFrom: dnuSelector
	^ (dnuSelector copyFrom: self prefix size + 1 to: dnuSelector size) withFirstCharacterDownshifted! !

!RVMExperiment class methodsFor: 'as yet unclassified' stamp: 'dmu 1/1/1970 00:04'!
do: aBlock
| ms s |
RVMMulticoreSample capture.
ms := Time millisecondsToRun: aBlock.
s := RVMMulticoreSample capture.
Transcript cr; show: 'ms: '; show: ms; show: ' yields: '; show: s yieldCounts sum; show: ' bytecodes: '; show: s bytecodeCounts sum;
show: ' total/unforced interruptCheckCounts: '; show: s interruptCheckCounts sum; show: '/'; show: s unforcedInterruptCheckCounts sum; cr;
show: 'receive tallies: ', s receiveTallySum printString! !

!RVMExperiment class methodsFor: 'as yet unclassified' stamp: 'dmu 1/1/1970 00:14'!
testCompiler
self do: [Benchmark new testCompiler]! !

!RVMGlobalHeapStats methodsFor: 'testing' stamp: 'ssa 7/21/2008 10:09'!
isGlobal

	^true! !

!RVMGlobalHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:09'!
scope
	"Answer my scope"
	^'Global'! !

!RVMGridLocationController methodsFor: 'controlling' stamp: 'ssa 11/16/2008 02:19'!
redButtonActivity
	| point grid box coord cellSize |
	point _ Sensor cursorPoint.
	grid _ RVMMonitor extent.
	box _ self view insetDisplayBox.
	cellSize _ box extent // grid + 1.
	coord _ (point - box origin  //(cellSize))+1.
	self view point: coord.
	view displayView.
	! !

!RVMGridLocationController methodsFor: 'controlling' stamp: 'ssa 11/15/2008 16:11'!
yellowButtonActivity
! !

!RVMGridLocationView methodsFor: 'displaying' stamp: 'ssa 11/16/2008 01:29'!
displayView
	| gridExtent point boxes box dot |
	self canvas extent > self insetDisplayBox extent ifTrue:[self canvas:nil; canvas].
	self okToDisplay ifFalse:[^self].
	point _ self point.
	self uncache.
	self canvas displayOn: Display at:self insetDisplayBox origin.
	gridExtent _ self gridExtent.
	dot _ Form extent:1@1.
	dot fillBlack.
	boxes _ self insetDisplayBox subDivideBy:  gridExtent.
	1 to: gridExtent x do:[:x|
		1 to: gridExtent y do:[:y|
			point = (x@y)  ifTrue:[box _ boxes at: y-1*gridExtent x+x.
				Display fill: (box origin - (0@1) extent:box extent)rounded  fillColor: Color black].
			(point = (0@0)) & ((x@y)=(1@1))  ifTrue:[box _ boxes at: y-1*gridExtent x+x..
				Display fill: box rounded fillColor: Color red].
			(point > (gridExtent)) & ((x@y)=(gridExtent))  ifTrue:[box _ boxes at: y-1*gridExtent x+x..
				Display fill: box rounded fillColor: Color red].
			]]! !

!RVMGridLocationView methodsFor: 'displaying' stamp: 'ssa 11/15/2008 23:46'!
drawGridOnCanvas
	| gridExtent boxes dot leftX rightX boxHeight boxWidth lineY lineX topY bottomY |
	self canvas fillWhite.
	gridExtent _ self gridExtent.
	dot _ Form extent:1@1.
	dot fillBlack.
	leftX _ self canvas boundingBox origin x.
	rightX _ self canvas boundingBox corner x.
	topY _ self canvas boundingBox origin y.
	bottomY _ self canvas boundingBox corner y.
	boxes _ self canvas boundingBox subDivideBy:  gridExtent.
	boxHeight _ boxes first height.
	boxWidth _ boxes first width  .
	lineY _ topY + boxHeight -2.
	lineX _ leftX + boxWidth  .
	1 to: gridExtent x do:[:x|
		x > (gridExtent x - 2) ifFalse:[
		self canvas drawLine: dot from: (leftX@lineY)  to: rightX@lineY clippingBox: self canvas boundingBox rule: Form paint fillColor: Color black.
		lineY _ lineY + boxHeight].
		1 to: gridExtent y do:[:y|
			y > (gridExtent y - 1) ifFalse:[
				self canvas drawLine: dot from: lineX@topY to: lineX@bottomY clippingBox: self canvas boundingBox rule: Form paint fillColor: Color black.
				lineX _ lineX + boxWidth].
			]]! !

!RVMGridLocationView methodsFor: 'updating' stamp: 'ssa 11/16/2008 00:56'!
hear: something
	self displayView! !

!RVMGridLocationView methodsFor: 'updating' stamp: 'ssa 11/16/2008 00:32'!
newFrame

	self canvas: nil.
	self canvas! !

!RVMGridLocationView methodsFor: 'accessing' stamp: 'ssa 11/15/2008 18:03'!
canvas
	"Answer the value of canvas"

	canvas isNil ifTrue:[self canvas: (Form extent: self insetDisplayBox extent).
		self drawGridOnCanvas].
	^ canvas! !

!RVMGridLocationView methodsFor: 'accessing' stamp: 'ssa 11/15/2008 18:02'!
canvas: anObject
	"Set the value of canvas"

	canvas _ anObject! !

!RVMGridLocationView methodsFor: 'accessing' stamp: 'ssa 11/13/2008 12:31'!
extentGetter
	"Answer the value of extentGetter"

	extentGetter isNil ifTrue:[self extentGetter: [8@7]].
	^ extentGetter! !

!RVMGridLocationView methodsFor: 'accessing' stamp: 'ssa 11/13/2008 12:30'!
extentGetter: anObject
	"Set the value of extentGetter"

	extentGetter _ anObject! !

!RVMGridLocationView methodsFor: 'accessing' stamp: 'ssa 11/13/2008 13:05'!
gridExtent

	^self extentGetter isSymbol ifTrue:[self model perform: self extentGetter] ifFalse:[self extentGetter value]! !

!RVMGridLocationView methodsFor: 'accessing' stamp: 'ssa 11/13/2008 12:37'!
point

	^self pointGetter isSymbol ifTrue:[self model perform: self pointGetter] ifFalse:[self pointGetter value]! !

!RVMGridLocationView methodsFor: 'accessing' stamp: 'ssa 11/16/2008 02:20'!
point: aPoint
	self pointSetter isSymbol ifTrue:[self model perform: self pointSetter with: aPoint] ifFalse:[self pointSetter value: aPoint]! !

!RVMGridLocationView methodsFor: 'accessing' stamp: 'ssa 11/13/2008 12:31'!
pointGetter
	"Answer the value of pointGetter"

	pointGetter isNil ifTrue:[self pointGetter: [self extent atRandom]].
	^ pointGetter! !

!RVMGridLocationView methodsFor: 'accessing' stamp: 'ssa 11/13/2008 12:30'!
pointGetter: anObject
	"Set the value of pointGetter"

	pointGetter _ anObject! !

!RVMGridLocationView methodsFor: 'accessing' stamp: 'ssa 11/13/2008 12:32'!
pointSetter
	"Answer the value of pointSetter"

	pointSetter isNil ifTrue:[self pointSetter: ["do nothing by default"]].
	^ pointSetter! !

!RVMGridLocationView methodsFor: 'accessing' stamp: 'ssa 11/13/2008 12:30'!
pointSetter: anObject
	"Set the value of pointSetter"

	pointSetter _ anObject! !

!RVMGridLocationView methodsFor: 'controller access' stamp: 'ssa 11/15/2008 16:10'!
defaultControllerClass

	^RVMGridLocationController! !

!RVMGridLocationView class methodsFor: 'instance creation' stamp: 'ssa 11/13/2008 12:47'!
on: aModel pointGetter: pointGetterBlockOrSelector pointSetter: pointSetterBlockOrSelector extentGetter: extentGetterBlockOrSelector

	| v |
	v _ self new.
	v model: aModel.
	v pointGetter: pointGetterBlockOrSelector.
	v pointSetter: pointSetterBlockOrSelector.
	v extentGetter: extentGetterBlockOrSelector.
	^v	! !

!RVMGroupLocatorController methodsFor: 'controlling' stamp: 'ssa 11/27/2008 11:36'!
changeObjectsSourceSourceTo: aString
Cursor wait showWhile:[
	self view objectsSourceSource: aString.
	self view changed:#objectsSourceSource]! !

!RVMGroupLocatorController methodsFor: 'controlling' stamp: 'ssa 11/27/2008 09:45'!
redButtonActivity

	self view hear:nil! !

!RVMGroupLocatorController methodsFor: 'controlling' stamp: 'ssa 11/27/2008 11:33'!
yellowButtonActivity
	| menu action choices |
	self view topView dontDisplayWhile:[
	menu := CustomMenu new.
	menu add:'Inspect View' action:[self view inspect].
	menu addLine.
	choices _ {'Object withAllSubclasses'. 
			'View withAllSubclasses'.
			'Number allSubclasses'.
			#line.
			'String allInstances'.
			'Array allInstances'.
			'Collection allSubInstances' }.
	choices do:[:choice|
		choice = #line ifTrue:[menu addLine]
			ifFalse:[menu add: choice action:choice]].
	
	action := menu startUp: nil withCaption: '' at: Sensor cursorPoint].
	(action isKindOf: BlockContext) ifTrue:[^action value].
	action notNil ifTrue:[self changeObjectsSourceSourceTo: action]! !

!RVMGroupLocatorView methodsFor: 'framing' stamp: 'ssa 11/27/2008 09:33'!
newFrame
	self boxes: nil.
	self canvas:nil.
	self backgroundCanvas:nil.
	self drawOnCanvas.
	Display fill: self insetDisplayBox fillColor: Color white.
	self displayView! !

!RVMGroupLocatorView methodsFor: 'drawing' stamp: 'ssa 11/27/2008 14:42'!
drawBackgroundCanvas
	| alt count lighter rowWidth |
	rowWidth _ RVMMonitor extent x  .
	alt _ false.
	count _ 0.
	lighter _ Color black lighter lighter.
	self boxes do:[:r| self backgroundCanvas fill: r  fillColor: (alt ifTrue:[Color black]ifFalse:[lighter]). "self backgroundCanvas border: r width: 1 fillColor: Color gray."
	alt _ alt not.
	count _ count + 1.
	rowWidth odd ifFalse:[count = rowWidth ifTrue:[alt _ alt not. count _ 0]]].
! !

!RVMGroupLocatorView methodsFor: 'drawing' stamp: 'ssa 3/31/2009 18:06'!
drawLocations
	| dot coreExtent amt index rect pt dotSize realRect label  |
	coreExtent _ RVMMonitor extent.
	dotSize _(self boxes first width // ((self countsPerCore size // self boxes size)max:1))min:self boxes first width //2 max:1.
	dot _ Form dotOfSize: dotSize color: self color.
	0 to: coreExtent x - 1 do:[:x|
		0 to: coreExtent y - 1 do:[:y|
			amt _ self countsPerCore occurrencesOf: (index _ y*coreExtent x+x).
			rect _ (realRect _ self boxes at: index + 1) insetBy: dot offset abs.
			label _ amt printString asDisplayText .
			label foregroundColor: Color red backgroundColor: Color transparent.
			label displayOn: self canvas at: realRect origin - (0@3) clippingBox: realRect rule: Form paint fillColor: Color red.
			"amt  timesRepeat:[pt _ rect asRandomPoint.
				dot displayOn: self canvas at: pt clippingBox: realRect rule: Form paint fillColor:nil]"].
		]! !

!RVMGroupLocatorView methodsFor: 'drawing' stamp: 'ssa 11/27/2008 09:19'!
drawOnCanvas
	self backgroundCanvas displayOn: self canvas at: 0@0.
	self drawLocations! !

!RVMGroupLocatorView methodsFor: 'displaying' stamp: 'ssa 11/27/2008 09:24'!
displayView
	"Display my canvas at my offset.
	Subclasses should not override this method but should draw on the canvas instead"
	self drawOnCanvas.
	self okToDisplay ifFalse:[^self].
	self uncache.
	self canvas displayOn: Display at: self insetDisplayBox center - self canvas center clippingBox: self insetDisplayBox.
! !

!RVMGroupLocatorView methodsFor: 'listening' stamp: 'ssa 11/27/2008 09:31'!
hear: something
	"Update my display"
	self countsPerCore: nil.
	self drawOnCanvas.
	self displayView! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 09:35'!
backgroundCanvas
	"Answer the value of backgroundCanvas"

	backgroundCanvas isNil ifTrue:[self backgroundCanvas: (Form extent: self insetDisplayBox extent depth: Display depth).  self drawBackgroundCanvas].
	^ backgroundCanvas! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 09:08'!
backgroundCanvas: anObject
	"Set the value of backgroundCanvas"

	backgroundCanvas _ anObject! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 09:30'!
boxes
	"Answer the value of boxes"

	boxes isNil ifTrue:[self boxes: ((self insetDisplayBox subDivideRoundedBy: RVMMonitor extent) collect:[:r| r translateBy: self insetDisplayBox origin negated])].
	^ boxes! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 09:08'!
boxes: anObject
	"Set the value of boxes"

	boxes _ anObject! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 09:35'!
canvas
	"Answer the value of canvas"

	canvas isNil ifTrue:[self canvas:  (Form extent: self insetDisplayBox extent depth: Display depth)].
	^ canvas! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 09:08'!
canvas: anObject
	"Set the value of canvas"

	canvas _ anObject! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 12:27'!
changeColorTo: aColor
	"Set the value of color"

	self color: aColor.
	self hear:nil! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 12:15'!
color
	"Answer the value of color"

	color isNil ifTrue:[self color: Color red].
	^ color! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 12:15'!
color: anObject
	"Set the value of color"

	color _ anObject! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ads 1/30/2011 15:20'!
countsPerCore
	"Answer the value of countsPerCore"
	countsPerCore isNil ifTrue:[self countsPerCore: (self objects asOrderedCollection  collect:[:obj| RVMOperations isRVM ifFalse:[RVMMonitor coreCount atRandom - 1]ifTrue:[RVMOperations getCoreHolding:obj]]) asBag].
	^ countsPerCore! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 09:14'!
countsPerCore: aBag
	"Set the value of countsPerCore, a Bag of coreIndicies with occurenceCounts showing how many of my objects reside in each core"

	countsPerCore _ aBag! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 09:16'!
objects
	"Answer my colection of objects to locate."
	^self objectsSource isSymbol ifTrue:[self model perform: self objectsSource] ifFalse:[self objectsSource value]! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 09:16'!
objectsSource
	"Answer the value of objectsSource, a Block that returns a collection of objects to locate.
	Can also be a SYmbol, a message selector to send to my model"

	objectsSource isNil ifTrue:[self objectsSource: [String allInstances]].
	^ objectsSource! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 09:17'!
objectsSource: aBlockOrSymbol
	"Set the value of objectsSource"

	objectsSource _ aBlockOrSymbol! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 10:34'!
objectsSourceSource

	| code |
	self objectsSource isSymbol ifTrue:[^self objectsSource printString].
	code _ self objectsSource decompile printString.
	(code beginsWith:'{[') &(code endsWith:']}') ifTrue:[code _ code copyFrom: 3 to: code size - 2].
	^code! !

!RVMGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 11:34'!
objectsSourceSource: aText

	| value aString |
	aString _ aText asString.
	( aString withBlanksTrimmed beginsWith:'#')
		ifTrue:[value _  Compiler new evaluate: aString in: nil to: nil
						notifying: nil ifFail: [^ false].
				self model perform: value.  "test to make sure it works before installing"]
		ifFalse:[value _ Compiler new evaluate: '[',aString,']' in: nil to: nil
						notifying: nil ifFail: [^ false]].
	self objectsSource:value.
	self hear:nil.
	^true "tell the editor its OK"! !

!RVMGroupLocatorView methodsFor: 'controller access' stamp: 'ssa 11/27/2008 09:57'!
defaultControllerClass

	^RVMGroupLocatorController! !

!RVMGroupLocatorView class methodsFor: 'instance creation' stamp: 'ssa 11/27/2008 09:57'!
on: aModel objectsSource: aBlockOrSelector
	"(RVMGroupLocatorView on: Smalltalk objectsSource:#values) demo"
	"(RVMGroupLocatorView on: nil objectsSource:[String allInstances]) demo"
	
	| v |
	v _ self new.
	v model: aModel.
	v objectsSource: aBlockOrSelector.
	^v! !

!RVMGroupLocatorView class methodsFor: 'instance creation' stamp: 'ssa 11/27/2008 14:10'!
openOn: aModel objectsSource: aBlockOrSelector labeled: aString
	"RVMGroupLocatorView openOn: Smalltalk objectsSource:#allClasses labeled:'All Classes'"
	"RVMGroupLocatorView openOn: nil objectsSource:[Array allInstances] labeled: 'All Arrays'"
	| topView v |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 150@150.
	topView maximumSize: 800@800.
	v := self on: aModel objectsSource: aBlockOrSelector.
	v borderWidth:1.
	topView addSubView: v  viewport:(0@0 extent: 150@150).
	topView label: aString.
	topView controller open! !

!RVMGroupLocatorView class methodsFor: 'instance creation' stamp: 'ssa 11/27/2008 13:36'!
openWithSourceEditorOn: aModel objectsSource: aBlockOrSelector
	"RVMGroupLocatorView openWithSourceEditorOn: Smalltalk objectsSource:#values"
	"RVMGroupLocatorView openWithSourceEditorOn: nil objectsSource:[Array allInstances]"
	| topView v ptv cbv |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 150@170.
	topView maximumSize: 400@425.
	v := self on: aModel objectsSource: aBlockOrSelector.
	v borderWidth:1.
	ptv _ PluggableTextView on: v text:#objectsSourceSource accept:#objectsSourceSource:.
	ptv borderWidth:1.
	cbv _ RVMColorButtonView on: v colorGetter:#color colorSetter:#changeColorTo:.
	cbv borderWidth:1.
	topView addSubView: v  viewport:(0@0 extent: 150@150).
	topView addSubView: cbv  viewport:(0@150 extent:20@20).
	topView addSubView: ptv  viewport:(20@150 extent:130@20).
	topView label: 'Group Locator'.
	topView controller open! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:05'!
coreIndices
	"Answer a collection of points that give my core indicies as row@column"
	| points |
	points _ OrderedCollection new.
	1 to: self height do:[:h|
		1 to: self width do:[:w|
			h*w-1 + w > self groupSize ifTrue:[^points  "handle odd last row case"].
			points add: w@h]].
	^points! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'ssa 11/13/2008 09:41'!
extent
	"Answer the dimensions of my tile grid"
	^self width @ self height! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:56'!
groupSize  ^ groupSize! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:56'!
groupSize: x groupSize _ x! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:01'!
height ^ height! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:01'!
height: x height _ x! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:55'!
mainRank  ^ mainRank! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:57'!
mainRank: x mainRank _ x! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:55'!
mainX  ^ mainX! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:57'!
mainX: x mainX _ x! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:55'!
mainY  ^ mainY! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:57'!
mainY: y mainY _ y! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:56'!
remaining  ^ remaining! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:57'!
remaining: r remaining _ r! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:00'!
width ^ width! !

!RVMGroupStats methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:01'!
width: x width _ x! !

!RVMGroupStats methodsFor: 'initialize-release' stamp: 'ssa 8/19/2008 10:56'!
initializeFastFrom: data

	self mainX:(data at: 2).
	self mainY: (data at: 4).
	self mainRank: (data at: 6).
	self width: (data at: 8).
	self height: (data at: 10).
	self groupSize: (data at: 12).
	self remaining: (data at: 14).
	! !

!RVMGroupStats methodsFor: 'initialize-release' stamp: 'dmu 8/15/2008 22:07'!
initializeFrom: data
1 to: data size by: 2 do: [:i|
	self perform: ((data at: i), ':') asSymbol with: (data at: i + 1)
	]! !

!RVMHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:06'!
allocationsSinceLastQuery
	"Answer the number of object allocations since the last query"
	allocationsSinceLastQuery isNil ifTrue:[^0].
	^allocationsSinceLastQuery! !

!RVMHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:07'!
allocationsSinceLastQuery: count
	"Set the number of object allocations since the last query"
	allocationsSinceLastQuery := count! !

!RVMHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:04'!
bytesLeft
	"Answer the number of bytes left in this heap"
	bytesLeft isNil ifTrue:[^0].
	^bytesLeft! !

!RVMHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:05'!
bytesLeft: count
	"Set the number of bytes left in this heap"
	bytesLeft := count! !

!RVMHeapStats methodsFor: 'acessing' stamp: 'ssa 10/4/2008 08:38'!
bytesUsed
	"Answer the number of bytes used in this heap"
	bytesUsed isNil ifTrue:[^0].
	^bytesUsed ! !

!RVMHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:04'!
bytesUsed: count
	"Set the number of bytes used in this heap"
	bytesUsed := count! !

!RVMHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:06'!
compactionsSinceLastQuery
	"Answer the number of object compactions since the last query"
	compactionsSinceLastQuery isNil ifTrue:[^0].
	^compactionsSinceLastQuery! !

!RVMHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:07'!
compactionsSinceLastQuery: count
	"Set the number of object compactions since the last query"
	compactionsSinceLastQuery := count! !

!RVMHeapStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:27'!
readWrite
	"Answer the value of readWrite"

	readWrite isNil ifTrue:[self readWrite: true].
	^ readWrite! !

!RVMHeapStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:27'!
readWrite: anObject
	"Set the value of readWrite"

	readWrite _ anObject! !

!RVMHeapStats class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:27'!
newReadMostly

	^self new readWrite: false ! !

!RVMHeapStats class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:28'!
newReadWrite

	^self new readWrite: true! !

!RVMKiviatController methodsFor: 'control activity' stamp: 'ads 1/30/2011 23:31'!
addCoreAspect
	| menu selectedAspect |
	self view topView dontDisplayWhile:[
menu := CustomMenu new.
 RVMMulticoreSample coreAspects do:[:aspect|
			menu add:  aspect action: aspect].
			selectedAspect := menu startUp: nil withCaption: 'Select a core aspect to monitor' at: Sensor cursorPoint.
			selectedAspect notNil ifTrue:[ self view addAspect: selectedAspect]].
			self view drawOnCanvas.
			self view displayView
			! !

!RVMKiviatController methodsFor: 'control activity' stamp: 'ssa 10/20/2008 10:26'!
changeRescaleCounter
	| result |
	self view dontDisplayWhile:[
	result _ FillInTheBlank request:'How many samples between rescaling?' initialAnswer: self view rescaleCounterDefault printString.
	result isNil ifFalse:[result _ result asNumber max:0.
	self view rescaleCounterDefault:result]].
	self view displayView! !

!RVMKiviatController methodsFor: 'control activity' stamp: 'ssa 10/7/2008 19:52'!
inspectView

self view inspect! !

!RVMKiviatController methodsFor: 'control activity' stamp: 'ssa 11/11/2008 17:37'!
redButtonActivity
	
	((self view adjustScaleBox translateBy: self view insetDisplayBox origin)  containsPoint: Sensor cursorPoint) ifTrue:[Sensor waitNoButton.
		self spawnScaleAdjuster]! !

!RVMKiviatController methodsFor: 'control activity' stamp: 'ssa 10/7/2008 18:55'!
removeAspect
	| menu selectedAspect |
	self view topView dontDisplayWhile:[
menu := CustomMenu new.
 self view aspects do:[:aspect|
			menu add:  aspect action: aspect].
			selectedAspect := menu startUp: nil withCaption: 'Select aspect to remove:' at: Sensor cursorPoint.
			selectedAspect notNil ifTrue:[ self view removeAspect: selectedAspect].
			].
			self view drawOnCanvas.
			self view displayView
! !

!RVMKiviatController methodsFor: 'control activity' stamp: 'ssa 10/7/2008 19:06'!
rescale

	self view resetScaling.
	self view displayView! !

!RVMKiviatController methodsFor: 'control activity' stamp: 'ssa 10/20/2008 09:06'!
yellowButtonActivity
	| menu answer onlyOne maxed |
	onlyOne _ self view aspectCount = 1.
	maxed _ self view aspectCount = 4.
	self view topView dontDisplayWhile:[
	menu := CustomMenu new.
	menu add:'Inspect View' action:#inspectView.
	menu add:'Rescale' action:#rescale.
	menu add:'Change Rescale Counter' action:#changeRescaleCounter.
 	onlyOne ifTrue:[menu add: 'Change aspect' action: #changeAspect.
 		menu addLine].
	maxed ifFalse:[
 		menu add: 'Add core aspect' action: #addCoreAspect].
	onlyOne ifFalse:[menu addLine.
 		menu add: 'Remove aspect' action: #removeAspect.].
	answer := menu startUp: nil withCaption: '' at: Sensor cursorPoint].
	answer notNil ifTrue:[self perform: answer]! !

!RVMKiviatController methodsFor: 'menu messages' stamp: 'ssa 10/7/2008 19:38'!
changeAspect

	| menu answer newAspect |
self view topView dontDisplayWhile:[
		menu := CustomMenu new.
	menu add: 'Core aspects' action: #core.
	menu add: 'Test aspects' action: #testCore.
	answer := menu startUp: nil withCaption: 'What kind of aspect would you like to monitor?' at: Sensor cursorPoint.
	answer isNil ifTrue:[^self].
	newAspect _ RVMMulticoreSample aspectFromUserUnder: answer.
	newAspect isNil ifTrue:[^self].
	self view aspect = newAspect ifTrue:[^self].
	self view aspect: newAspect].
	self view resetScaling.
	self view drawOnCanvas.
	self view displayView! !

!RVMKiviatController methodsFor: 'menu messages' stamp: 'ssa 5/12/2010 10:20'!
spawnScaleAdjuster

	|  maxView minView topView resetScaleButton setToObservedButton autoScaleCheckBox height scalerIndex result |
	(self view scalers size  = 1 or:[self view commonScale])ifFalse:[result _ (PopUpMenu labelArray:self view aspects) startUpWithCaption:'Adjust the scale of which aspect?'.
		result = 0 ifTrue:[^self].
		scalerIndex _ result]ifTrue:[scalerIndex _ 1].
	maxView _ RVMValueEditorView  on: (view scalerAt: scalerIndex) valueGetter: [(view scalerAt: scalerIndex) max] valueSetter:[:v|(view scalerAt: scalerIndex) setMax:v. view drawOnCanvas; displayView] label:'max: '.
	maxView lockGetter:#maxLocked; lockSetter:#maxLocked:.
	minView _ RVMValueEditorView  on: (view scalerAt: scalerIndex) valueGetter: [(view scalerAt: scalerIndex) min] valueSetter:[:v|(view scalerAt: scalerIndex) setMin:v.  view drawOnCanvas; displayView] label:'min: '.
	minView lockGetter:#minLocked; lockSetter:#minLocked:.
	resetScaleButton _ RVMButtonView label:'Reset scale to default' action:[(view scalerAt: scalerIndex) resetScaling.  view drawOnCanvas; displayView.  minView hear:nil.  maxView hear:nil].
	setToObservedButton _ RVMButtonView label:'Set scale to observed values' action:[(view scalerAt: scalerIndex) setRangeToObserved.  view drawOnCanvas; displayView.  minView hear:nil.  maxView hear:nil].
	autoScaleCheckBox _ RVMCheckBoxView on: (view scalerAt: scalerIndex) label: 'Automatic Scaling' checkState: [(view scalerAt: scalerIndex) automaticScaling] whenChecked: [(view scalerAt: scalerIndex) automatic.  view drawOnCanvas; displayView.  minView hear:nil.  maxView hear:nil] whenUnchecked: [(view scalerAt: scalerIndex) manual. view drawOnCanvas; displayView.  minView hear:nil.  maxView hear:nil] monitor: true.

	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView addSubView: minView.
	topView addSubView: maxView below:  minView.
	topView addSubView: resetScaleButton below:  maxView.
	topView addSubView: setToObservedButton below:  resetScaleButton.
	topView addSubView: autoScaleCheckBox below:  setToObservedButton.
	RVMMonitor forgetAll:{resetScaleButton. setToObservedButton. autoScaleCheckBox}.
	topView label: (view aspects at: scalerIndex).
	height _ topView subViews size * 26.
	topView minimumSize:200@height.
	topView maximumSize: 200@height.
	self scalerAdjusters add: topView.
	topView controller open! !

!RVMKiviatController methodsFor: 'accessing' stamp: 'ssa 11/11/2008 18:32'!
scalerAdjusters
	"Answer the value of scalerAdjusters"

	scalerAdjusters isNil ifTrue:[self scalerAdjusters: OrderedCollection new].
	^ scalerAdjusters! !

!RVMKiviatController methodsFor: 'accessing' stamp: 'ssa 11/11/2008 18:31'!
scalerAdjusters: anObject
	"Set the value of scalerAdjusters"

	scalerAdjusters _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ads 1/30/2011 23:31'!
adjustScaleBox
	"Answer the value of adjustScaleBox"
	
	adjustScaleBox isNil ifTrue:[self adjustScaleBox: self insetDisplayBox].
	^ adjustScaleBox! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 17:20'!
adjustScaleBox: anObject
	"Set the value of adjustScaleBox"

	adjustScaleBox _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 11:22'!
aspect
	"Answer the value of aspect"

	aspect isNil ifTrue:[self aspect: #test0to100].
	^ aspect! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 17:23'!
aspect: anObject
	"Set the value of aspect"

	aspect _ anObject.
	self lastAverage: nil.
	self lastTotal: nil.
	self topView == self ifFalse:[self topView relabel: anObject asString]! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 17:22'!
aspectCount

	^1! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/10/2008 18:39'!
backgroundCanvas
	"Answer the value of backgroundCanvas"

	backgroundCanvas isNil ifTrue:[ self backgroundCanvas:(ColorForm extent: self canvasExtent depth:8).
		self spokePens do:[:pen| pen destForm: backgroundCanvas].
		self drawBackgroundCanvas.].
	^ backgroundCanvas! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 13:53'!
backgroundCanvas: anObject
	"Set the value of backgroundCanvas"

	backgroundCanvas _ anObject
! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 11/12/2008 13:08'!
blinker
	"Answer the value of blinker"

	blinker isNil ifTrue:[self blinker: true].
	self blinker: blinker not.
	^ blinker! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 11/12/2008 13:08'!
blinker: anObject
	"Set the value of blinker"

	blinker _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/10/2008 18:39'!
canvas
	"Answer the value of canvas"

	canvas isNil ifTrue:[self canvas: (ColorForm extent: self canvasExtent depth:8)].
	^ canvas! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:11'!
canvas: anObject
	"Set the value of canvas"

	canvas _ anObject.
	self webPen destForm: anObject.
	self spokePens:nil! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/8/2008 18:00'!
canvasExtent
	"Answer the extent of my canvas"
	^self insetDisplayBox extent  ! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 13:38'!
center

	^self canvas center! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 17:08'!
centerMargin
	"the distance from center to the start of a spoke"
	^20! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 14:13'!
diameter
	"Answer the smallest square diameter for this view's box"
	^self canvas height < self canvas width
		ifTrue:[self canvas height- (self labelRowCount * 10)]
		ifFalse:[self canvas width - 20]! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 14:17'!
drawingBackground
	"Answer the value of drawingBackground"

	drawingBackground isNil ifTrue:[self drawingBackground: false].
	^ drawingBackground! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 14:17'!
drawingBackground: anObject
	"Set the value of drawingBackground"

	drawingBackground _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/8/2008 18:52'!
firstDisplay
	"Answer the value of firstDisplay"

	firstDisplay isNil ifTrue:[self firstDisplay: false].
	^ firstDisplay! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/8/2008 15:13'!
firstDisplay: anObject
	"Set the value of firstDisplay"

	firstDisplay _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 01:18'!
labelRowCount
	"How many rows of labels will I have?"
	^2! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 02:25'!
lastAverage
	"Answer the value of lastAverage"

	lastAverage isNil ifTrue:[self lastAverage: 0].
	^ lastAverage! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 02:25'!
lastAverage: anObject
	"Set the value of lastAverage"

	lastAverage _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 02:25'!
lastTotal
	"Answer the value of lastTotal"

	lastTotal isNil ifTrue:[self lastTotal: 0].
	^ lastTotal! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 02:25'!
lastTotal: anObject
	"Set the value of lastTotal"

	lastTotal _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:37'!
majorTicLength
	
	^8! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:35'!
majorTicSpacing

	^self spokeLength / (self numberOfMajorTics - 1) asFloat! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:36'!
minorTicLength
	
	^4! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:36'!
minorTicSpacing

	^self majorTicSpacing /( self numberOfMinorTics + 1)! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:38'!
numberOfMajorTics

	^3! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:37'!
numberOfMinorTics

	^1! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 13:56'!
radius
	"Answer the smallest radius for this view's box"
	^self diameter // 2! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/20/2008 10:25'!
rescaleCounter
	"Answer the value of rescaleCounter"

	rescaleCounter isNil ifTrue:[self rescaleCounter: self rescaleCounterDefault].
	^ rescaleCounter! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 15:02'!
rescaleCounter: anObject
	"Set the value of rescaleCounter"

	rescaleCounter _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/20/2008 10:25'!
rescaleCounterDefault
	"Answer the value of rescaleCounterDefault"

	rescaleCounterDefault isNil ifTrue:[self rescaleCounterDefault: 10].
	^ rescaleCounterDefault! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/20/2008 10:25'!
rescaleCounterDefault: anObject
	"Set the value of rescaleCounterDefault"

	rescaleCounterDefault _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 11:25'!
scaler
	"Answer the value of scaler"

	scaler isNil ifTrue:[self scaler: RVMDataScaler new automatic].
	^ scaler! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 11:22'!
scaler: anObject
	"Set the value of scaler"

	scaler _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 22:07'!
spokeColor
	"Answer the value of spokeColor"

	spokeColor isNil ifTrue:[self spokeColor: Color gray lighter lighter].
	^ spokeColor! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 13:21'!
spokeColor: anObject
	"Set the value of spokeColor"

	spokeColor _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:30'!
spokeLength

	^self radius - self centerMargin - 5! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 11:25'!
spokePens
	"Answer the value of spokePens"

	spokePens isNil ifTrue:[self spokePens: self initializeSpokePens].
	^ spokePens! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 11:22'!
spokePens: anObject
	"Set the value of spokePens"

	spokePens _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 13:21'!
webColor
	"Answer the value of webColor"

	webColor isNil ifTrue:[self webColor: Color blue].
	^ webColor! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 13:21'!
webColor: anObject
	"Set the value of webColor"

	webColor _ anObject! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 17:06'!
webPen
	"Answer the value of webPen"

	webPen isNil ifTrue:[self webPen: Pen new.
		webPen color: self webColor.
		webPen defaultNib:2.
		webPen  combinationRule: Form over.
		webPen destForm: self canvas].
	^ webPen! !

!RVMKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 13:29'!
webPen: anObject
	"Set the value of webPen"

	webPen _ anObject! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'ssa 11/11/2008 17:19'!
adjustScaleIcon
^((ColorForm
	extent: 16@31
	depth: 8
	fromArray: #( 0 0 0 0 0 0 169614364 622594560 0 0 1694498815 4294913536 0 0 1845490943 4294915840 0 0 0 3506384384 0 0 0 3506386688 73 1677721600 0 3657379328 163 3642490880 0 3506386688 9716 4287692800 172 4110364160 46591 4294913536 208 4110366464 4259839 4294936576 0 3506384384 8973264 4106150400 0 3657381632 6558618 3942664503 0 3506384384 154 3942645760 0 3657381632 154 3942645760 25700 3808374272 154 3942645760 60415 4294915840 154 3942645760 18761 3808374272 154 3942645760 0 3506386688 2424986 3942648357 0 3657379328 11304867 3947480869 0 3506386688 7798783 4294948096 0 3506384384 1300991 4294925056 217 4294915840 25855 4291821568 145 3959369216 199 4098424832 0 3657381632 118 2432696320 0 3506384384 28 620756992 0 3506386688 0 0 0 3657379328 0 0 1541003737 4110366464 0 0 1694498815 4294913536 0 0 321795886 1227753984 0 0 0 0)
	offset: 0@0)
	colorsFromArray: #(#(1.0 1.0 1.0) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0)  ))! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'ssa 11/11/2008 17:34'!
drawAdjustScaleIcon
	| adjustIcon origin |
.
	adjustIcon _ self adjustScaleIcon.
	origin _ self backgroundCanvas boundingBox leftCenter - adjustIcon boundingBox leftCenter + (4@0).
	adjustIcon displayOn: self backgroundCanvas at: origin.
	self adjustScaleBox:(origin extent: adjustIcon extent)! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'ssa 11/11/2008 17:18'!
drawBackgroundCanvas
	self drawingBackground: true.
	self backgroundCanvas fillWhite.
	self drawSpokes.
	self drawAdjustScaleIcon.
	self drawingBackground: false
	! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'ssa 11/11/2008 23:07'!
drawCounterOnCanvas
	|  counterLabel |
	self scaler automaticScaling ifFalse:[^self].
	counterLabel _ ('rescale
in: ',self rescaleCounter printString ) asDisplayText.
	counterLabel displayOn: self canvas at: self canvas boundingBox bottomRight -(counterLabel width@90).
! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'ssa 10/7/2008 15:29'!
drawLabelsOnCanvas
	
	| minLabel maxLabel  aspectLabel avgLabel totalLabel start |
	aspectLabel _ self aspect asString asDisplayText.
	aspectLabel foregroundColor: self webColor backgroundColor: Color transparent.
	aspectLabel displayOn: self canvas at:  (2 @ -4).
	minLabel _ ('min: ',self scaler min printShowingMax3Digits) asDisplayText.
	maxLabel _ ('max: ',self scaler max printShowingMax3Digits) asDisplayText.
	minLabel foregroundColor: self webColor backgroundColor: Color transparent.
	maxLabel foregroundColor: self webColor backgroundColor: Color transparent.
	minLabel displayOn: self canvas at: 0@((aspectLabel height //2)-2)clippingBox: self canvas boundingBox rule: Form paint fillColor:nil.
	maxLabel displayOn: self canvas at: 0@(start _ maxLabel height) clippingBox: self canvas boundingBox rule: Form paint fillColor:nil.
	avgLabel _ ('avg: ',self lastAverage printShowingMax3Digits) asDisplayText.
	totalLabel _ ('total: ',self lastTotal printShowingMax3Digits) asDisplayText.
	avgLabel foregroundColor: self webColor backgroundColor: Color transparent.
	totalLabel foregroundColor: self webColor backgroundColor: Color transparent.
	totalLabel displayOn: self canvas at: 0@(start _start +(totalLabel height - 6)) clippingBox: self canvas boundingBox rule: Form paint fillColor:nil.
	avgLabel displayOn: self canvas at: 0@( start + (maxLabel height - 6)) clippingBox: self canvas boundingBox rule: Form paint fillColor:nil.

! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'ssa 10/6/2008 14:16'!
drawMajorTicUsing: pen

	pen turn:90; go: self majorTicLength/2;turn:180;down;go:self majorTicLength;up;
			turn:180; go: self majorTicLength/2;turn:-90! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'ssa 10/6/2008 14:16'!
drawMinorTicUsing: pen

	pen turn:90; go: self minorTicLength/2;turn:180;down;go:self minorTicLength;up;
			turn:180; go: self minorTicLength/2;turn:-90! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'ssa 10/8/2008 19:16'!
drawOnCanvas
	self drawingBackground ifTrue:[^self].
	self backgroundCanvas displayOn: self canvas at: 0@0.
	self drawCounterOnCanvas.
	self drawWeb.
	self drawLabelsOnCanvas.
! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'ssa 11/17/2008 13:25'!
drawSpokes

	| pen label labelOffsets labelOffset mainIndex oldColor |
	mainIndex _ RVMMonitor mainRank + 1.
	1 to: self spokePens size do:[:index|
		pen _ self spokePens at: index.
		oldColor _ pen color.
		index = mainIndex ifTrue:[pen color: Color red].
		pen destForm: self backgroundCanvas.
		pen place: self center.
		pen up; go: self centerMargin.
		pen down;go: self spokeLength;up.
		label _ (index - 1) printString asDisplayText asParagraph asForm.
		self diameter < 300 ifTrue:[label _ label scaledToSize: 11@11].
		labelOffsets _ {0@label height negated.  0@0. label width negated@0.  label extent negated}.
		labelOffset _ labelOffsets at: ((index - 1// (self spokePens size / 4) + 1) min:4).
		label displayOn: self backgroundCanvas at: pen location + labelOffset clippingBox: self backgroundCanvas boundingBox rule: Form paint fillColor: nil.
		self drawTicsUsing: pen.
		pen color: oldColor]
		! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'ssa 10/6/2008 11:54'!
drawTicsUsing: pen

	pen up;place: self center;go:self centerMargin.
	self drawMajorTicUsing: pen.
	self numberOfMajorTics - 1 timesRepeat:[
		self numberOfMinorTics timesRepeat:[
			pen go: self minorTicSpacing.
			self drawMinorTicUsing: pen].
		pen go: self minorTicSpacing.
		self drawMajorTicUsing: pen].
	! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'ssa 10/7/2008 14:18'!
drawWeb
	self drawingBackground ifTrue:[^self].
	self placeSpokePens.
	self webPen color: self webColor.
	self webPen up;place: self spokePens first location;down.
	self spokePens do:[:pen|
		self webPen goto: pen location].
	self webPen goto: self spokePens first location;up
	! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'dmu 8/23/2010 17:39'!
placeSpokePens

	| data tot |
	data _ RVMMonitor lastSample perform: self aspect.
	tot _ 0.
	self spokePens size = data size ifFalse: [self resetAfterCoreCountChange].
	data with: self spokePens do:[:datum :pen|
		tot _ tot + datum.
		pen up;place: self center;go:self centerMargin.
		pen go:(self spokeLength /100.0*(self scaler scale: datum))].
	self lastTotal: tot.
	self lastAverage: tot / data size! !

!RVMKiviatView methodsFor: 'drawing' stamp: 'dmu 8/23/2010 17:38'!
resetAfterCoreCountChange
	self spokePens: nil. backgroundCanvas _ nil! !

!RVMKiviatView methodsFor: 'framing' stamp: 'ssa 10/8/2008 15:20'!
firstFrame
	! !

!RVMKiviatView methodsFor: 'framing' stamp: 'ssa 10/8/2008 19:20'!
newFrame
	self canvas:nil.
	self backgroundCanvas:nil.
	self drawOnCanvas.
	Display fill: self insetDisplayBox fillColor: Color white.
	self displayView! !

!RVMKiviatView methodsFor: 'scaling' stamp: 'ssa 10/8/2008 18:52'!
resetScaling

	self scaler resetScaling.
! !

!RVMKiviatView methodsFor: 'initialize-release' stamp: 'ssa 10/6/2008 16:42'!
initializeSpokePens

	| pens numberOfSpokes spacing center pen |
	pens _ OrderedCollection new.
	numberOfSpokes _ RVMMonitor coreCount.
	spacing _ 360 / numberOfSpokes asFloat.
	center _ self insetDisplayBox center.
	numberOfSpokes timesRepeat:[
		pen _ Pen new.
		pen defaultNib:1.
		pen  combinationRule: Form over.
		pen color: self spokeColor.
		pen place: center.
		pen north.
		pen turn: pens size * spacing.
		pens add: pen].
	^pens! !

!RVMKiviatView methodsFor: 'initialize-release' stamp: 'ssa 11/11/2008 21:41'!
release
	"self controller scalerAdjusters do:[:each| each topView controller closeAndUnscheduleNoTerminate].	
	self controller scalerAdjusters: nil."
	super release! !

!RVMKiviatView methodsFor: 'displaying' stamp: 'ssa 11/12/2008 13:16'!
displayView
	"Display my canvas at my offset.
	Subclasses should not override this method but should draw on the canvas instead"
	self firstDisplay  ifFalse:[self firstDisplay:true.
		self drawOnCanvas].
	self okToDisplay ifFalse:[^self].
	self uncache.
	self canvas displayOn: Display at: self insetDisplayBox center - self canvas center clippingBox: self insetDisplayBox.
	self blinker  ifTrue:[(Form dotOfSize:5) displayOn: Display at: self insetDisplayBox center]
! !

!RVMKiviatView methodsFor: 'controller access' stamp: 'ssa 10/6/2008 13:35'!
defaultControllerClass
	^RVMKiviatController! !

!RVMKiviatView methodsFor: 'listening' stamp: 'dmu 2/6/2009 22:35'!
hear: something
	"Update my traces and redisplay"
	self firstDisplay ifFalse:[^self].
	self rescaleCounter: self rescaleCounter - 1.
	self rescaleCounter = 0 ifTrue:[self rescaleCounter:nil.  
		self resetScaling.]. 
	self drawingBackground ifTrue:[^self].
	self drawOnCanvas.
	self displayView! !

!RVMKiviatView commentStamp: '<historical>' prior: 0!
I'm a kiviat chart for displaying core aspect data!
!RVMKiviatView class methodsFor: 'examples' stamp: 'ssa 10/6/2008 16:00'!
example
	"RVMKiviatView example"
	self openOnAspect: #bytesUseds! !

!RVMKiviatView class methodsFor: 'instance creation' stamp: 'ssa 10/7/2008 13:58'!
openOnAspect: aSymbol
	"RVMKiviatView example"
	
	| topView v |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 300@250.
	topView maximumSize: 600@500.
	v := self new.
	v borderWidth:1.
	v aspect: aSymbol.
	topView addSubView: v.
	topView label: v aspect.
	topView controller open! !

!RVMLabelView methodsFor: 'displaying' stamp: 'ssa 9/14/2008 20:45'!
displayView
	| labelRect labelText labelForm |
	labelText := self label asDisplayText .

	labelText foregroundColor: self backgroundColor
			backgroundColor: self foregroundColor.
	labelForm := labelText
			 asParagraph asForm scaledToSize:(self insetDisplayBox extent min: labelText boundingBox extent).
	labelRect := self insetDisplayBox.
	Display fill: labelRect fillColor: self foregroundColor.
	labelForm displayOn: Display at: labelRect center - labelForm boundingBox center clippingBox: labelRect
			rule: Form paint fillColor: labelText foregroundColor.
! !

!RVMLabelView methodsFor: 'accessing' stamp: 'ssa 8/26/2008 22:55'!
label
	"Answer the value of label"

	label isNil ifTrue:[^'no label yet'].
	^label! !

!RVMLabelView methodsFor: 'accessing' stamp: 'ssa 8/26/2008 22:54'!
label: anObject
	"Set the value of label"

	label := anObject! !

!RVMLabelView class methodsFor: 'instance creation' stamp: 'ssa 8/26/2008 23:02'!
label: aString

	| view |
	view := self new.
	view label: aString.
	^view! !

!RVMLocalHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:31'!
failedFetchRequestsSinceLastQuery
	"Answer how many fetch requests failed since the last query"
	failedFetchRequestsSinceLastQuery isNil ifTrue:[^0].
	^failedFetchRequestsSinceLastQuery! !

!RVMLocalHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:29'!
failedFetchRequestsSinceLastQuery: count
	"Set how many fetch requests failed since the last query"
	failedFetchRequestsSinceLastQuery := count! !

!RVMLocalHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 11:09'!
objectsFetchedSinceLastQuery
	"Answer how many objects were fetched into this local heap since the last query"
	objectsFetchedSinceLastQuery isNil ifTrue:[^0].
	^objectsFetchedSinceLastQuery! !

!RVMLocalHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 11:09'!
objectsFetchedSinceLastQuery: count
	"Set how many objects were fetched into this local heap since the last query"
	objectsFetchedSinceLastQuery := count! !

!RVMLocalHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:32'!
objectsFlushedSinceLastQuery
	"Answer how many objects were flushed since the last query"
	objectsFlushedSinceLastQuery isNil ifTrue:[^0].
	^objectsFlushedSinceLastQuery! !

!RVMLocalHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:32'!
objectsFlushedSinceLastQuery: count
	"Set how many objects were flushed since the last query"
	objectsFlushedSinceLastQuery := count! !

!RVMLocalHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:26'!
overlyLargeFetchOrAllocationRequestsDeniedSinceLastQuery
	"Answer how many 'cramden' requests were denied since the last query"
	overlyLargeFetchOrAllocationRequestsDeniedSinceLastQuery isNil ifTrue:[^0].
	^overlyLargeFetchOrAllocationRequestsDeniedSinceLastQuery! !

!RVMLocalHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:27'!
overlyLargeFetchOrAllocationRequestsDeniedSinceLastQuery: count
	"Set how many 'cramden' requests were denied since the last query"
	overlyLargeFetchOrAllocationRequestsDeniedSinceLastQuery := count! !

!RVMLocalHeapStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:11'!
scope
	"Answer my scope"
	^'Local'! !

!RVMLocalHeapStats methodsFor: 'testing' stamp: 'ssa 7/21/2008 10:11'!
isLocal

	^true! !

!RVMMemorySystemStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 18:15'!
gcCount
	"Answer the value of gcCount"

	gcCount isNil ifTrue:[self gcCount: nil].
	^gcCount! !

!RVMMemorySystemStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 18:15'!
gcCount: anObject
	"Set the value of gcCount"

	gcCount := anObject! !

!RVMMemorySystemStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 18:15'!
gcCycles
	"Answer the value of gcCycles"

	gcCycles isNil ifTrue:[self gcCycles: nil].
	^gcCycles! !

!RVMMemorySystemStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 18:15'!
gcCycles: anObject
	"Set the value of gcCycles"

	gcCycles := anObject! !

!RVMMemorySystemStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 18:15'!
gcMilliseconds
	"Answer the value of gcMilliseconds"

	gcMilliseconds isNil ifTrue:[self gcMilliseconds: nil].
	^gcMilliseconds! !

!RVMMemorySystemStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 18:15'!
gcMilliseconds: anObject
	"Set the value of gcMilliseconds"

	gcMilliseconds := anObject! !

!RVMMemorySystemStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:52'!
readMostlyHeapStats
	"Answer the value of readMostlyHeapStats"

	readMostlyHeapStats isNil ifTrue:[self readMostlyHeapStats: RVMHeapStats newReadMostly].
	^ readMostlyHeapStats! !

!RVMMemorySystemStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:51'!
readMostlyHeapStats: anObject
	"Set the value of readMostlyHeapStats"

	readMostlyHeapStats _ anObject! !

!RVMMemorySystemStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:51'!
readWriteHeapStats
	"Answer the value of readWriteHeapStats"

	readWriteHeapStats isNil ifTrue:[self readWriteHeapStats: RVMHeapStats newReadWrite].
	^ readWriteHeapStats! !

!RVMMemorySystemStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:51'!
readWriteHeapStats: anObject
	"Set the value of readWriteHeapStats"

	readWriteHeapStats _ anObject! !

!RVMMinMaxView class methodsFor: 'examples' stamp: 'ssa 9/13/2008 20:54'!
example
	"RVMMinMaxView example"
	| topView |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 100@50.
	topView maximumSize: 200@100.
	topView addSubView: self exampleInstance.
	topView label: 'MinMax'.
	topView controller open! !

!RVMMinMaxView class methodsFor: 'examples' stamp: 'ssa 9/17/2008 13:56'!
exampleInstance

	| scaler |
	scaler _ RVMDataScaler exampleInstance.
	^self on: scaler
		getMin:  [scaler min]
		setMin:[:v| scaler min: v]
		getMax:  [scaler max]
		setMax: [:v| scaler max: v].
	! !

!RVMMinMaxView class methodsFor: 'instance creation' stamp: 'ssa 9/17/2008 13:53'!
on: aModel getMin: getMin setMin: setMin getMax: getMax setMax: setMax
	| view v |
	view _ self new.
	view addSubView: (v _ RVMValueView on: aModel valueGetter: getMin valueSetter: setMin label:'m').
	view addSubView: (RVMValueView on: aModel valueGetter: getMax valueSetter: setMax  label:'M') above: v.
	^view! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/19/2008 00:27'!
closeRecordingFile
	"Close the recording file"
	self recordingFile flush;close.
	self recordingFile: nil! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/18/2008 22:41'!
isRecording

	^self recordingMode ~= #off! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/28/2008 15:32'!
loadChunkedSamplesFromRecordingFile
	"Load the samples with the data on a file supplied by the user"
	| fs data chunk readChunkTime compileChunkTime |
	fs _ StandardFileMenu oldFileStreamWithPattern:'*.recording'.
	fs isNil ifTrue:[^self inform:'No file to load'].
	Cursor read showWhile:[
	data _ OrderedCollection new.
	[fs atEnd] whileFalse:[Transcript cr;show:'reading data chunk #',(data size + 1) printString.
	readChunkTime _ Time millisecondsToRun:[chunk _ fs nextChunk].
	Transcript cr;show:(readChunkTime //1000 )printString,' secs to read chunk'.
	compileChunkTime _ Time millisecondsToRun:[data add: (Compiler evaluate: chunk)].
	Transcript cr;show: (compileChunkTime //1000) printString,' secs to compile chunk'.
	].
	fs close.
	self recordingMode = #file ifTrue:[self recordingMode: #loop].
	self recordingMode = #loop ifTrue:[data _ data asCircularCollection].
	self samples: data asCircularCollection].
	self changed:#recordingMode

! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/28/2008 19:45'!
loadSamplesFromRecordingFile
	"Load the samples with the data on a file supplied by the user"
	| fs data readChunkTime  |
	fs _ StandardFileMenu oldFileStreamWithPattern:'*.recording'.
	fs isNil ifTrue:[^self inform:'No file to load'].
	Cursor read showWhile:[
	data _ OrderedCollection new.
	[fs atEnd] whileFalse:[Transcript cr;show:'reading data chunk #',(data size + 1) printString.
	readChunkTime _ Time millisecondsToRun:[data add: (RVMSampleReader dearchiveRawDataFrom: fs)].
	Transcript cr;show:(readChunkTime /1000.0)printString,' seconds to read'.
	].
	fs close.
	self recordingMode = #file ifTrue:[self recordingMode: #loop].
	self recordingMode = #loop ifTrue:[data _ data asCircularCollection.  
		self sampleLimit: data size].
	self samples: data asCircularCollection].
	self changed:#recordingMode

! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/18/2008 22:41'!
openRecordingFile
	"Open the recording file"
	self recordingFile ensureOpen! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/18/2008 22:37'!
recordAllToFile: aCollection
	"Record each of these elements to the recording file in chunk format"
	
	aCollection do:[:each| self recordToFile: each]! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/28/2008 15:33'!
recordChunkToFile: anObject
	"Record the object on the recording file in chunk format"
	
	anObject printOn: self recordingFile.
	self recordingFile nextPut:$!!;cr;cr! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/18/2008 22:45'!
recordSample: someData
	"Record this sample data based on the recording mode"
	
	self recordingMode = #off ifTrue:[^self].
	self recordingMode = #file ifTrue:[^self recordToFile: someData].
	self samples add: someData! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/28/2008 19:27'!
recordToFile: anObject
	"Record the object on the recording file in archiver format"
	
	RVMSampleWriter archiveRawData: anObject on:self recordingFile
	! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/18/2008 22:24'!
recordingFile
	"Answer an appropriately named file for recording samples, open and ready."
	RecordingFile isNil ifTrue:[self recordingFile: self recordingFileFromUser].
	^RecordingFile! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/19/2008 00:28'!
recordingFile: aFile
	"Set an appropriately named file for recording samples, open and ready."
	RecordingFile isNil ifFalse:[RecordingFile close].
	RecordingFile _ aFile! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/18/2008 22:31'!
recordingFileFromUser
	"Answer an appropriately named file for recording samples, open and ready."
	^FileStream newFileNamed:'rvm-samples.recording'! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/18/2008 23:19'!
recordingMode
	"Recording modes are #off, #loop, #file, and #long"
	RecordingMode isNil ifTrue:[RecordingMode _ #loop].
	^RecordingMode! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/19/2008 00:52'!
recordingMode: nextMode
	"Recording modes are #off, #loop, #file, and #long"
	| lastMode |
	lastMode _ RecordingMode.
	lastMode = nextMode ifTrue:[^self].
	self switchFrom: lastMode to: nextMode.
	RecordingMode _ nextMode.
	self changed:#recordingMode! !

!RVMMonitor class methodsFor: 'recording' stamp: 'ssa 10/18/2008 22:21'!
switchFrom: lastMode to: nextMode.
	"Switch recording modes.  Recording modes are #off, #loop, #file, and #long"
	nextMode = #off ifTrue:[
		lastMode = #loop ifTrue:["do nothing, leave collection in place"].
		lastMode = #long ifTrue:["do nothing, leave collection in place"].
		lastMode = #file ifTrue:[self closeRecordingFile]].
	nextMode = #loop ifTrue:[
		lastMode = #off ifTrue:[self samples: (RVMCircularCollection new:self sampleLimit)].
		lastMode = #long ifTrue:[self samples: (RVMCircularCollection withAll: self samples)].
		lastMode = #file ifTrue:[self closeRecordingFile]].
	nextMode = #long ifTrue:[
		lastMode = #off ifTrue:[self samples: OrderedCollection new].
		lastMode = #loop ifTrue:[self samples: self samples asOrderedCollection].
		lastMode = #file ifTrue:[self closeRecordingFile]].
	nextMode = #file ifTrue:[self openRecordingFile; recordAllToFile: self samples].
	
		! !

!RVMMonitor class methodsFor: 'queries' stamp: 'ssa 1/1/1970 00:18'!
coreCount

^self lastSample  groupStats groupSize! !

!RVMMonitor class methodsFor: 'queries' stamp: 'ssa 11/27/2008 14:45'!
extent

^self lastSample  extent! !

!RVMMonitor class methodsFor: 'queries' stamp: 'ssa 11/17/2008 13:22'!
mainRank

^self lastSample  groupStats mainRank ! !

!RVMMonitor class methodsFor: 'user interface' stamp: 'ssa 11/17/2008 17:11'!
coreIndexFromUser
	"RVMMonitor coreIndexFromUser"
	"Answer a valid coreINdex from the user for my current configuration"
	|  maxIndex newIndex |
	maxIndex _ self coreCount.
	[newIndex _ FillInTheBlank request:'Enter a core index between 0 and ',(maxIndex - 1) printString,':' initialAnswer: '1'.
	(newIndex isEmpty or:[(newIndex asNumber between: 0 and: maxIndex - 1) not])] whileTrue.
	^newIndex asNumber! !

!RVMMonitor class methodsFor: 'user interface' stamp: 'ads 1/30/2011 15:21'!
dashboard
	"RVMMonitor dashboard      "   
	| topView samplingCheck turboCheck gcButton benchButton subViewCount sampleButton clearSamplesButton forgetButton shuffle56Button shuffle4Button multistripButton systemAspectsButton coreAspectsButton inspectSampleButton testAspectCheck spiderButton bytesUsedsSpiderButton delayTimingCheck recordingOptionsButton allToReadMostlyButton printAllHeapsButton printExecutionTraceButton printStackButton gridButton stripButton scanButton outlierButton locateClassesButton locatorButton locators4Button heartbeat spread56Button runningProcessesButton |
	topView := RVMStandardSystemView new  .
	topView borderWidth:1. 
	samplingCheck _ RVMCheckBoxView on: self label: 'Sampling' checkState: [self sampling] whenChecked: [self startSampling] whenUnchecked: [self stopSampling] monitor: true.
	turboCheck _ RVMCheckBoxView on: self label: 'Turbo' checkState: [self turboSampling] whenChecked: [self turboOn] whenUnchecked: [self turboOff] monitor: true.
	testAspectCheck _ RVMCheckBoxView on: self label: 'Test Aspects' checkState: [self showTestAspects] whenChecked: [self showTestAspects:true] whenUnchecked: [self showTestAspects:false] monitor: true.
	delayTimingCheck _ RVMCheckBoxView on: self label: 'Short Delay' checkState: [self delayTiming = #short] whenChecked: [self useShortDelay] whenUnchecked: [self useNormalDelay] monitor: true.
	heartbeat _ RVMCheckBoxView on: self label: 'Heartbeat' checkState: [self showHeartbeat] whenChecked: [self startHeartbeat] whenUnchecked: [self stopHeartbeat] monitor: true.
	sampleButton _ RVMButtonView label:'Take Sample' action:[RVMMonitor getSample; informListeners].
	inspectSampleButton _ RVMButtonView label:'Inspect Sample' action:[RVMMonitor lastSample inspect].
	clearSamplesButton _ RVMButtonView label:'Clear Samples' action:[RVMMonitor clearSamples].
	recordingOptionsButton _ RVMButtonView label:'Recording Options' action:[RVMMonitor recordingControls].
	forgetButton _ RVMButtonView label:'Forget Listeners' action:[RVMMonitor forgetListeners].
	gcButton _ RVMButtonView label:'GC' action:[Transcript cr show:'GC: ',Smalltalk garbageCollect printString].
	spread56Button _ RVMButtonView label:'Spread 56' action:[RVMOperations spreadFrom: 0 to: 55  moveRWtoRM: true moveRMtoRW: false].
	shuffle56Button _ RVMButtonView label:'Shuffle:56' action:[RVMOperations shuffle:56].
	shuffle4Button _ RVMButtonView label:'Shuffle:4' action:[RVMOperations shuffle:4].
	allToReadMostlyButton _ RVMButtonView label:'All->readMostly' action:[RVMOperations moveAllToReadMostlyHeaps].
	printAllHeapsButton _ RVMButtonView label:'Print BytesUsed' action:[RVMOperations printAllHeapsBytesUsed].
	printExecutionTraceButton _ RVMButtonView label:'Print Trace' action:[RVMOperations printExecutionTrace].
	printStackButton _ RVMButtonView label:'Print Stack' action:[RVMOperations printStack].
	gridButton _ self relAbsButtonLabeled:'Tile Grid...' 
					relAction:[RVMTileGridView example]
					absAction:[RVMTileGridScalerView example].
	stripButton _ self relAbsButtonLabeled:'Tile Strip...' 
					relAction:[RVMTileStripChartView example]
					absAction:[RVMTileStripChartScalerView example].
	scanButton _ self relAbsButtonLabeled:'Tile Scan...' 
					relAction:[RVMScanningStripChartView example]
					absAction:[RVMAbsScanningStripChartView example].
	multistripButton _ RVMButtonView label:'Multi Strip' action:[RVMCoreAspectTrace exampleView1].
	systemAspectsButton _ RVMButtonView label:'System Aspects' action:[RVMAspectTrace monitorAllSystemAspects].
	coreAspectsButton _ RVMButtonView label:'Core Aspects' action:[RVMCoreAspectTrace monitorAllCoreAspectsForCoreFromUser].
	runningProcessesButton _  RVMButtonView label:'Running Processes' action:[RVMAspectTrace exampleView8].
		spiderButton _ RVMButtonView label:'Kiviat' action:[RVMMultiKiviatView exampleBytecodesAndProcessesRunning].
	bytesUsedsSpiderButton _ RVMButtonView label:'heap size Kiviat' action:[RVMMultiKiviatView exampleBytesUsedTrioCommonPinned].
	outlierButton _ RVMButtonView label:'Outlier...' action:[RVMMonitor outlierFromUser].
	locateClassesButton _ RVMButtonView label:'Class Locator' action:[RVMGroupLocatorView openOn: Smalltalk objectsSource:#allClasses labeled:'All Classes'].
	locatorButton _ RVMButtonView label:'Group Locator' action:[RVMGroupLocatorView openWithSourceEditorOn: nil objectsSource:[Array allInstances]].
	locators4Button _ RVMButtonView label:'4 Group Locator' action:[RVMMultiGroupLocatorView openOn: nil sources: {[String allInstances]. [Collection withAllSubclasses]. [Object withAllSubclasses]. [View allSubInstances]} colors: nil].
	benchButton _ RVMButtonView label:'testCompiler' action:[Cursor wait showWhile:[RVMExperiment testCompiler]].
	
	topView addSubView: samplingCheck.
	topView addSubView:  turboCheck below:  samplingCheck.
	topView addSubView:  testAspectCheck below:  turboCheck.
	topView addSubView:  delayTimingCheck below:  testAspectCheck.
	topView addSubView:  heartbeat below:  delayTimingCheck.
	topView addSubView:  sampleButton below:  heartbeat.
	topView addSubView:  inspectSampleButton below:  sampleButton.
	topView addSubView:  clearSamplesButton below:  inspectSampleButton.
	topView addSubView:  recordingOptionsButton below:  clearSamplesButton.
	topView addSubView:  forgetButton below:  recordingOptionsButton.
	topView addSubView:  gcButton below:  forgetButton.
	topView addSubView:  spread56Button below:  gcButton.
	topView addSubView:  shuffle56Button below:  spread56Button.
	topView addSubView:  shuffle4Button below:  shuffle56Button.
 	topView addSubView:  allToReadMostlyButton below:  shuffle4Button.
	topView addSubView:  printAllHeapsButton below:  allToReadMostlyButton.
	topView addSubView:  printExecutionTraceButton below: printAllHeapsButton.
	topView addSubView:  printStackButton below: printExecutionTraceButton.
	topView addSubView:  gridButton below: printStackButton.
	topView addSubView:  stripButton below: gridButton.
	topView addSubView:  scanButton below: stripButton.
	topView addSubView:  multistripButton below: scanButton.
	topView addSubView:  systemAspectsButton below: multistripButton.
	topView addSubView:  coreAspectsButton below: systemAspectsButton.
	topView addSubView: runningProcessesButton below: coreAspectsButton.
	topView addSubView:  spiderButton below: runningProcessesButton.
	topView addSubView:  bytesUsedsSpiderButton below: spiderButton.
	topView addSubView:  outlierButton below: bytesUsedsSpiderButton.
	topView addSubView:  locateClassesButton below: outlierButton.
	topView addSubView:  locatorButton below: locateClassesButton.
	topView addSubView:  locators4Button below: locatorButton.
	topView addSubView:  benchButton below: locators4Button.
	topView label: 'RVM'.
	RVMMonitor forgetAll: topView allSubViews.
	RVMMonitor forget: topView.
	subViewCount _ topView subViews size.
	topView minimumSize: 120@(subViewCount*27).
	topView maximumSize: topView minimumSize.
	topView controller open! !

!RVMMonitor class methodsFor: 'user interface' stamp: 'ssa 11/13/2008 02:10'!
outlierFromUser
	| menu result selectors labels aspects sel cores |
	selectors _ #(coreAspectSubset coreAspectSubsetAllocationCompaction coreAspectSubsetBytecodes coreAspectSubsetBytes coreAspectSubsetRunWait coreAspectSubsetYields allCoreAspects).
	labels _ #('selected aspects' 'allocation/compaction' 'bytecodes' 'bytes' 'run/wait' 'yields' 'all for a single core').
	menu _ PopUpMenu labelArray: labels.
	result _ menu startUpWithCaption:'Which set of aspects for the Outlier?'.
	result = 0 ifTrue: [^self].
	aspects _ RVMMultiAspectKiviatView perform: (sel _ selectors at: result).
	cores _ sel = #allCoreAspects ifTrue:[Array with: self coreIndexFromUser]ifFalse:[(1 to: RVMMonitor coreCount) asOrderedCollection].
	RVMMultiAspectKiviatView openOnAspects:  aspects forCores:  cores titled:'Outliers: ',(labels at: result)! !

!RVMMonitor class methodsFor: 'user interface' stamp: 'ssa 5/12/2010 10:16'!
recordingControls
	"RVMMonitor recordingControls   "  
	| topView   offRadio loopRadio subViewCount longRadio fileRadio loadButton radios |
	topView := RVMStandardSystemView new  .
	radios _ RVMView new.
	topView borderWidth:1. 
	RVMRadioButtonView testState:#(true false false false false).
	offRadio _ RVMRadioButtonView on: self label: 'stop recording' checkState: [RVMMonitor recordingMode = #off] whenChecked: [RVMMonitor recordingMode: #off] whenUnchecked: [] monitor: true.
	loopRadio _ RVMRadioButtonView on: self label: 'record last ',RVMMonitor sampleLimit printString,' samples' checkState: [RVMMonitor recordingMode = #loop] whenChecked: [RVMMonitor recordingMode: #loop] whenUnchecked: [] monitor: true.
	longRadio _ RVMRadioButtonView on: self label: 'record all samples' checkState: [RVMMonitor recordingMode = #long] whenChecked: [RVMMonitor recordingMode: #long] whenUnchecked: [] monitor: true.
	fileRadio _ RVMRadioButtonView on: self label: 'record all samples to a file' checkState: [RVMMonitor recordingMode = #file] whenChecked: [RVMMonitor recordingMode: #file] whenUnchecked: [] monitor: true.
	loadButton _ RVMButtonView label:'Load samples from file' action:[RVMMonitor loadSamplesFromRecordingFile].
	
	radios addSubView: offRadio.
	radios addSubView:  loopRadio below:  offRadio.
	radios addSubView:  longRadio below:  loopRadio.
	radios addSubView:  fileRadio below:  longRadio.
	topView addSubView: radios.
	topView addSubView:  loadButton below:  radios.
	RVMMonitor forgetAll: topView allSubViews.
	RVMMonitor forget: topView.
	topView label: 'Recording Options'.
	subViewCount _ radios subViews size + topView subViews size - 1.
	topView minimumSize: 200@(subViewCount*28).
	topView maximumSize: 200@topView minimumSize y.
	topView controller open! !

!RVMMonitor class methodsFor: 'user interface' stamp: 'ssa 11/15/2008 23:30'!
relAbsButtonLabeled: aTitle relAction: relAction absAction: absAction
	| menu result |
	^RVMButtonView label: aTitle
		 action:				
	[menu _ PopUpMenu labelArray:#('Relative Scaling' 'Absolute Scaling').
	result _ menu startUpWithCaption:'Which color scaling to use?'.
	result = 1 ifTrue: [relAction copy value].
	result = 2 ifTrue: [absAction copy value]] copy! !

!RVMMonitor class methodsFor: 'test aspects' stamp: 'ssa 10/3/2008 15:06'!
showTestAspects

	ShowTestAspects isNil ifTrue:[ShowTestAspects _ false].
	^ShowTestAspects! !

!RVMMonitor class methodsFor: 'test aspects' stamp: 'ssa 10/3/2008 15:06'!
showTestAspects: aBoolean

	ShowTestAspects _ aBoolean! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 1/1/1970 00:12'!
clearSamples
	"Clear my collection of samples"
	Samples := nil.
	LastSample := nil.! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 10/7/2008 21:19'!
delaySamplingDuring: aBlock

	self sampling 
		ifTrue:[self stopSampling.
			aBlock value.
			self startSampling]
		ifFalse:[aBlock value]! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 10/7/2008 20:25'!
delayTiming

	DelayTiming isNil ifTrue:[DelayTiming _ #normal].
	^DelayTiming! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 10/7/2008 20:25'!
delayTiming: aSymbol
	"#normal or #short"

	DelayTiming _ aSymbol! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ads 1/30/2011 15:21'!
getSample
	"Get the next sample"
	LastSample := self turboSampling ifTrue:[RVMMulticoreSample captureFastest]ifFalse:[RVMMulticoreSample next].
	RVMOperations isRVM & self isRecording ifTrue:[
				self recordSample: LastSample rawData].
! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 11/15/2008 23:42'!
lastSample
	"Answer the last recorded sample"
	LastSample isNil ifTrue:[self getSample].
	^LastSample ! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 10/7/2008 20:23'!
normalDelayTiming
	^self delayTiming = #normal! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 10/21/2008 11:56'!
sampleLimit

	SampleLimit isNil ifTrue:[SampleLimit := 2].
	^SampleLimit! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 8/22/2008 09:42'!
sampleLimit: anInteger

	SampleLimit := anInteger.
	self clearSamples! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 10/18/2008 22:14'!
samples
	"Answer my collection of samples"
	Samples isNil ifTrue:[self samples:(RVMCircularCollection new:self sampleLimit)].
	^Samples! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 10/18/2008 22:14'!
samples: aCollection
	"Set my collection of samples"
	Samples _ aCollection! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 10/7/2008 21:19'!
sampling
	"Am I current sampling?"
	^SamplingProcess notNil! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ads 2/2/2011 14:52'!
startSampling
	"RVMMonitor startSampling"
	"Start the sampling process"
	| delay timeToRun delayTime lastTime|
	lastTime _ Time now asSeconds.
	SamplingProcess notNil ifTrue:[self stopSampling].
	SamplingProcess := [[ Sensor leftShiftDown & Sensor controlKeyPressed]
								whileFalse: [
									"RVMOperations print: (Time now asSeconds - lastTime)  printString,' seconds since last sample'."
									 timeToRun _ Time millisecondsToRun: [self getSample].
									lastTime _ Time now asSeconds.
									"RVMOperations print:'sampling took ',(timeToRun/1000.0) printString,' seconds'."
									delayTime _ self normalDelayTiming ifTrue:[10*timeToRun]ifFalse:[100 min: 10*timeToRun].
									delay := Delay forMilliseconds: delayTime.
									self informListeners.
									RVMMulticoreSample flush.  "clear sample buffers from monitor activity"
									delay wait]] newProcess.
	SamplingProcess name: 'RVMMonitor sampling process'.
	SamplingProcess resume	! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 9/4/2008 15:00'!
stopSampling
	"RVMMonitor stopSampling"
	"Stop the sampling process"

	SamplingProcess isNil ifFalse:[SamplingProcess terminate].
	SamplingProcess := nil! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 1/1/1970 00:16'!
turboOff
	"Turn off turboSampling"
	TurboSampling := false! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 1/1/1970 00:16'!
turboOn
	"Turn on turboSampling"
	TurboSampling := true! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 1/1/1970 00:16'!
turboSampling
	"Answer my  turboSampling flag"
	TurboSampling isNil ifTrue:[TurboSampling := true].
	^TurboSampling! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 10/7/2008 21:22'!
useNormalDelay
	self delaySamplingDuring:[self delayTiming: #normal].
	! !

!RVMMonitor class methodsFor: 'sampling' stamp: 'ssa 10/7/2008 21:22'!
useShortDelay
	self delaySamplingDuring:[self delayTiming: #short].! !

!RVMMonitor class methodsFor: 'listeners' stamp: 'ssa 1/1/1970 00:07'!
forget: someone

	self listeners remove: someone ifAbsent:[]! !

!RVMMonitor class methodsFor: 'listeners' stamp: 'ssa 10/28/2008 19:54'!
forgetAll: someListeners

	someListeners do:[:each|
	self forget: each]! !

!RVMMonitor class methodsFor: 'listeners' stamp: 'ssa 1/1/1970 00:07'!
forgetListeners

	Listeners := nil! !

!RVMMonitor class methodsFor: 'listeners' stamp: 'ssa 8/25/2008 05:02'!
inform: someone

	self listeners add: someone! !

!RVMMonitor class methodsFor: 'listeners' stamp: 'ssa 2/18/2009 17:42'!
informListeners

	self listeners do:[:each| each hear: self]


"	| sema |
	sema _ Semaphore  new.
	self listeners do:[:each| [each hear: self. sema signal] copy fixTemps fork].
	self listeners do: [:each| sema wait]"
	! !

!RVMMonitor class methodsFor: 'listeners' stamp: 'ssa 8/25/2008 04:59'!
listeners
	"Answer the list of listeners to me"
	Listeners isNil ifTrue:[Listeners := OrderedCollection new].
	^Listeners! !

!RVMMonitor class methodsFor: 'autocoding' stamp: 'ssa 1/1/1970 00:03'!
autocodeScalerMethodFor: aSelector
	"Autocode and install a default scaler method for the aspect found in this selector."
	"Note this also adds a class variable of the form SCALERaspect"
	
	| aspect code var |
	aspect _ aSelector allButLast:'Scaler' size.
	var _ 'SCALER',aspect.
	self addClassVarName: var.
	code _ aSelector,'
	"Answer the default scaler for ',aspect,'."
	',var,' isNil ifTrue:[',var,' _ RVMDataScaler aspect: #',aspect,' min: 0 max: 100].
	^',var.
	self class compile: code classified:'scalers' notifying:nil! !

!RVMMonitor class methodsFor: 'autocoding' stamp: 'ssa 1/1/1970 00:03'!
autocodeScalerMethodForScaler: aDataScaler
	"Autocode and install a default scaler method for the aspect found in this selector."
	"Note this also adds a class variable of the form SCALERaspect"
	
	| aspect code var |
	aspect _ aDataScaler aspect.
	var _ 'SCALER',aspect.
	(self classVarNames includes: var) ifFalse:[self addClassVarName: var].
	code _ aspect,'Scaler
	"Answer the default scaler for ',aspect,'."
	',var,' isNil ifTrue:[',var,' _ RVMDataScaler aspect:#',aspect,' min: ',aDataScaler min printString,' max: ',aDataScaler max printString,'].
	^',var.
	self class compile: code classified:'scalers' notifying:nil! !

!RVMMonitor class methodsFor: 'autocoding' stamp: 'ssa 1/1/1970 00:49'!
doesNotUnderstand: aMessage
	"autocode a method for aMessage if its one I recognize."
	(aMessage selector isUnary & (aMessage selector endsWith: 'Scaler')) 
		ifTrue:[self halt:'this should not be used anymore'.
			self  autocodeScalerMethodFor: aMessage selector.
			^self perform: aMessage selector].
		
	^super doesNotUnderstand: aMessage! !

!RVMMonitor class methodsFor: 'data generation' stamp: 'ssa 9/13/2008 19:40'!
dataFor: anAspect
	"Answer a generated data value for this aspect, based on the range of its scaler"
	
	^(self scalerFor:anAspect) atRandom! !

!RVMMonitor class methodsFor: 'scaling' stamp: 'ssa 1/1/1970 00:44'!
coloredScalerFor: aspect
	"Answer an appropriate colored scaler for this aspect."
	
	^RVMColoredDataScaler aspect: aspect! !

!RVMMonitor class methodsFor: 'scaling' stamp: 'ssa 1/1/1970 00:44'!
coloredScalersFor: aspects
	"Answer an appropriate colored scalers for this aspect."
	
	^aspects collect:[:each| self coloredScalerFor: each]! !

!RVMMonitor class methodsFor: 'scaling' stamp: 'ssa 1/1/1970 00:02'!
scalerFor: aspect
	"Answer an appropriate scalers for this aspect."
	[^RVMDataScaler new automatic]value.
	^self perform: (aspect,'Scaler') asSymbol! !

!RVMMonitor class methodsFor: 'scaling' stamp: 'ssa 9/13/2008 19:39'!
scalersFor: aspects
	"Answer a collection of appropriate scalers for these aspects."

	^aspects collect:[:aspect|
		self scalerFor: aspect]! !

!RVMMonitor class methodsFor: 'heartbeat' stamp: 'ssa 4/1/2009 16:02'!
showHeartbeat

	ShowHeartbeat isNil ifTrue:[ShowHeartbeat _ false].
	^ShowHeartbeat! !

!RVMMonitor class methodsFor: 'heartbeat' stamp: 'ssa 4/1/2009 16:03'!
showHeartbeat: aBoolean

	ShowHeartbeat _ aBoolean! !

!RVMMonitor class methodsFor: 'heartbeat' stamp: 'ssa 4/3/2009 12:18'!
startHeartbeat
	"RVMMonitor startHeartbeat"
	"RVMMonitor stopHeartbeat"
	| rect delay |
	self showHeartbeat: true.
	rect _ 0@0 extent: 4@4.
	delay _ Delay forSeconds: 1.
	[[self showHeartbeat] whileTrue:[Display reverse: rect. delay wait]] forkAt: Processor highestPriority.
	Processor yield ! !

!RVMMonitor class methodsFor: 'heartbeat' stamp: 'ssa 4/1/2009 16:09'!
stopHeartbeat
	"RVMMonitor startHeartbeat"
	"RVMMonitor stopHeartbeat"
	self showHeartbeat: false.! !

!RVMMultiAspectKiviatController methodsFor: 'control activity' stamp: 'ssa 10/7/2008 18:42'!
addCoreAspect
	| menu selectedAspect |
	self view topView dontDisplayWhile:[
menu := CustomMenu new.
 RVMMulticoreSample coreAspects do:[:aspect|
			menu add:  aspect action: aspect].
			selectedAspect := menu startUp: nil withCaption: 'Select a core aspect to monitor' at: Sensor cursorPoint.
			selectedAspect notNil ifTrue:[ self view addAspect: selectedAspect]].
			self view drawOnCanvas.
			self view displayView
			! !

!RVMMultiAspectKiviatController methodsFor: 'control activity' stamp: 'ssa 10/20/2008 10:26'!
changeRescaleCounter
	| result |
	self view dontDisplayWhile:[
	result _ FillInTheBlank request:'How many samples between rescaling?' initialAnswer: self view rescaleCounterDefault printString.
	result isNil ifFalse:[result _ result asNumber max:0.
	self view rescaleCounterDefault:result]].
	self view displayView! !

!RVMMultiAspectKiviatController methodsFor: 'control activity' stamp: 'ssa 10/7/2008 19:52'!
inspectView

self view inspect! !

!RVMMultiAspectKiviatController methodsFor: 'control activity' stamp: 'ssa 11/27/2008 14:00'!
redButtonActivity
	
	"((self view adjustScaleBox translateBy: self view insetDisplayBox origin)  containsPoint: Sensor cursorPoint) ifTrue:[Sensor waitNoButton.
		self spawnScaleAdjuster]"! !

!RVMMultiAspectKiviatController methodsFor: 'control activity' stamp: 'ssa 10/7/2008 18:55'!
removeAspect
	| menu selectedAspect |
	self view topView dontDisplayWhile:[
menu := CustomMenu new.
 self view aspects do:[:aspect|
			menu add:  aspect action: aspect].
			selectedAspect := menu startUp: nil withCaption: 'Select aspect to remove:' at: Sensor cursorPoint.
			selectedAspect notNil ifTrue:[ self view removeAspect: selectedAspect].
			].
			self view drawOnCanvas.
			self view displayView
! !

!RVMMultiAspectKiviatController methodsFor: 'control activity' stamp: 'ssa 10/7/2008 19:06'!
rescale

	self view resetScaling.
	self view displayView! !

!RVMMultiAspectKiviatController methodsFor: 'control activity' stamp: 'ssa 11/12/2008 12:48'!
yellowButtonActivity
	| menu answer |
	self view topView dontDisplayWhile:[
	menu := CustomMenu new.
	menu add:'Inspect View' action:#inspectView.
	menu add:'Rescale' action:#rescale.
	menu add:'Change Rescale Counter' action:#changeRescaleCounter.
	answer := menu startUp: nil withCaption: '' at: Sensor cursorPoint].
	answer notNil ifTrue:[self perform: answer]! !

!RVMMultiAspectKiviatController methodsFor: 'menu messages' stamp: 'ssa 10/7/2008 19:38'!
changeAspect

	| menu answer newAspect |
self view topView dontDisplayWhile:[
		menu := CustomMenu new.
	menu add: 'Core aspects' action: #core.
	menu add: 'Test aspects' action: #testCore.
	answer := menu startUp: nil withCaption: 'What kind of aspect would you like to monitor?' at: Sensor cursorPoint.
	answer isNil ifTrue:[^self].
	newAspect _ RVMMulticoreSample aspectFromUserUnder: answer.
	newAspect isNil ifTrue:[^self].
	self view aspect = newAspect ifTrue:[^self].
	self view aspect: newAspect].
	self view resetScaling.
	self view drawOnCanvas.
	self view displayView! !

!RVMMultiAspectKiviatController methodsFor: 'menu messages' stamp: 'ssa 5/12/2010 10:20'!
spawnScaleAdjuster

	|  maxView minView topView resetScaleButton setToObservedButton autoScaleCheckBox height scalerIndex result |
	(self view scalers size  = 1 or:[self view commonScale])ifFalse:[result _ (PopUpMenu labelArray:self view aspects) startUpWithCaption:'Adjust the scale of which aspect?'.
		result = 0 ifTrue:[^self].
		scalerIndex _ result]ifTrue:[scalerIndex _ 1].
	maxView _ RVMValueEditorView  on: (view scalerAt: scalerIndex) valueGetter: [(view scalerAt: scalerIndex) max] valueSetter:[:v|(view scalerAt: scalerIndex) setMax:v. view drawOnCanvas; displayView] label:'max: '.
	maxView lockGetter:#maxLocked; lockSetter:#maxLocked:.
	minView _ RVMValueEditorView  on: (view scalerAt: scalerIndex) valueGetter: [(view scalerAt: scalerIndex) min] valueSetter:[:v|(view scalerAt: scalerIndex) setMin:v.  view drawOnCanvas; displayView] label:'min: '.
	minView lockGetter:#minLocked; lockSetter:#minLocked:.
	resetScaleButton _ RVMButtonView label:'Reset scale to default' action:[(view scalerAt: scalerIndex) resetScaling.  view drawOnCanvas; displayView.  minView hear:nil.  maxView hear:nil].
	setToObservedButton _ RVMButtonView label:'Set scale to observed values' action:[(view scalerAt: scalerIndex) setRangeToObserved.  view drawOnCanvas; displayView.  minView hear:nil.  maxView hear:nil].
	autoScaleCheckBox _ RVMCheckBoxView on: (view scalerAt: scalerIndex) label: 'Automatic Scaling' checkState: [(view scalerAt: scalerIndex) automaticScaling] whenChecked: [(view scalerAt: scalerIndex) automatic.  view drawOnCanvas; displayView.  minView hear:nil.  maxView hear:nil] whenUnchecked: [(view scalerAt: scalerIndex) manual. view drawOnCanvas; displayView.  minView hear:nil.  maxView hear:nil] monitor: true.

	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView addSubView: minView.
	topView addSubView: maxView below:  minView.
	topView addSubView: resetScaleButton below:  maxView.
	topView addSubView: setToObservedButton below:  resetScaleButton.
	topView addSubView: autoScaleCheckBox below:  setToObservedButton.
	RVMMonitor forgetAll:{resetScaleButton. setToObservedButton. autoScaleCheckBox}.
	topView label: (view aspects at: scalerIndex).
	height _ topView subViews size * 26.
	topView minimumSize:200@height.
	topView maximumSize: 200@height.
	self scalerAdjusters add: topView.
	topView controller open! !

!RVMMultiAspectKiviatController methodsFor: 'accessing' stamp: 'ssa 11/11/2008 18:32'!
scalerAdjusters
	"Answer the value of scalerAdjusters"

	scalerAdjusters isNil ifTrue:[self scalerAdjusters: OrderedCollection new].
	^ scalerAdjusters! !

!RVMMultiAspectKiviatController methodsFor: 'accessing' stamp: 'ssa 11/11/2008 18:31'!
scalerAdjusters: anObject
	"Set the value of scalerAdjusters"

	scalerAdjusters _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 17:20'!
adjustScaleBox
	"Answer the value of adjustScaleBox"

	adjustScaleBox isNil ifTrue:[self adjustScaleBox: self insetDisplayBox].
	^ adjustScaleBox! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 17:20'!
adjustScaleBox: anObject
	"Set the value of adjustScaleBox"

	adjustScaleBox _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 23:14'!
aspects
	"Answer the value of aspects"

	aspects isNil ifTrue:[self aspects: RVMMulticoreSample systemAspects].
	^ aspects! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 23:12'!
aspects: anObject
	"Set the value of aspects"

	aspects _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/10/2008 18:39'!
backgroundCanvas
	"Answer the value of backgroundCanvas"

	backgroundCanvas isNil ifTrue:[ self backgroundCanvas:(ColorForm extent: self canvasExtent depth:8).
		self spokePens do:[:pen| pen destForm: backgroundCanvas].
		self drawBackgroundCanvas.].
	^ backgroundCanvas! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 13:53'!
backgroundCanvas: anObject
	"Set the value of backgroundCanvas"

	backgroundCanvas _ anObject
! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/12/2008 13:17'!
blinker
	"Answer the value of blinker"

	blinker isNil ifTrue:[self blinker: true].
	self blinker: blinker not.
	^ blinker! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/12/2008 13:18'!
blinker: anObject
	"Set the value of blinker"

	blinker _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/10/2008 18:39'!
canvas
	"Answer the value of canvas"

	canvas isNil ifTrue:[self canvas: (ColorForm extent: self canvasExtent depth:8)].
	^ canvas! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:11'!
canvas: anObject
	"Set the value of canvas"

	canvas _ anObject.
	self webPen destForm: anObject.
	self spokePens:nil! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/8/2008 18:00'!
canvasExtent
	"Answer the extent of my canvas"
	^self insetDisplayBox extent  ! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 13:38'!
center

	^self canvas center! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 17:08'!
centerMargin
	"the distance from center to the start of a spoke"
	^20! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/12/2008 10:36'!
colors
	"Answer the value of colors"

	colors isNil ifTrue:[self colors: ((Color wheel: self coreIndicies size) "collect:[:each| each darker darker]")
		].
	^ colors! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/12/2008 09:38'!
colors: anObject
	"Set the value of colors"

	colors _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/12/2008 10:34'!
coreIndicies
	"Answer the value of coreIndicies"

	coreIndicies isNil ifTrue:[self coreIndicies: (1 to: RVMMonitor coreCount) asOrderedCollection].
	^ coreIndicies! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/12/2008 09:50'!
coreIndicies: anObject
	"Set the value of coreIndicies"

	coreIndicies _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 14:13'!
diameter
	"Answer the smallest square diameter for this view's box"
	^self canvas height < self canvas width
		ifTrue:[self canvas height- (self labelRowCount * 10)]
		ifFalse:[self canvas width - 20]! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 14:17'!
drawingBackground
	"Answer the value of drawingBackground"

	drawingBackground isNil ifTrue:[self drawingBackground: false].
	^ drawingBackground! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 14:17'!
drawingBackground: anObject
	"Set the value of drawingBackground"

	drawingBackground _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/8/2008 18:52'!
firstDisplay
	"Answer the value of firstDisplay"

	firstDisplay isNil ifTrue:[self firstDisplay: false].
	^ firstDisplay! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/8/2008 15:13'!
firstDisplay: anObject
	"Set the value of firstDisplay"

	firstDisplay _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/12/2008 10:56'!
indexIcons
	"Answer the value of indexIcons"

	indexIcons isNil ifTrue:[self indexIcons: self buildIndexIcons].
	^ indexIcons! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/12/2008 10:56'!
indexIcons: anObject
	"Set the value of indexIcons"

	indexIcons _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 01:18'!
labelRowCount
	"How many rows of labels will I have?"
	^2! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:37'!
majorTicLength
	
	^8! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:35'!
majorTicSpacing

	^self spokeLength / (self numberOfMajorTics - 1) asFloat! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:36'!
minorTicLength
	
	^4! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:36'!
minorTicSpacing

	^self majorTicSpacing /( self numberOfMinorTics + 1)! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:38'!
numberOfMajorTics

	^3! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:37'!
numberOfMinorTics

	^1! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 13:56'!
radius
	"Answer the smallest radius for this view's box"
	^self diameter // 2! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/20/2008 10:25'!
rescaleCounter
	"Answer the value of rescaleCounter"

	rescaleCounter isNil ifTrue:[self rescaleCounter: self rescaleCounterDefault].
	^ rescaleCounter! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 15:02'!
rescaleCounter: anObject
	"Set the value of rescaleCounter"

	rescaleCounter _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/20/2008 10:25'!
rescaleCounterDefault
	"Answer the value of rescaleCounterDefault"

	rescaleCounterDefault isNil ifTrue:[self rescaleCounterDefault: 10].
	^ rescaleCounterDefault! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/20/2008 10:25'!
rescaleCounterDefault: anObject
	"Set the value of rescaleCounterDefault"

	rescaleCounterDefault _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 23:15'!
scalers
	"Answer the value of scalers"

	scalers isNil ifTrue:[self scalers: (self aspects collect:[:each| RVMDataScaler new automatic])].
	^ scalers! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 23:12'!
scalers: anObject
	"Set the value of scalers"

	scalers _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 22:07'!
spokeColor
	"Answer the value of spokeColor"

	spokeColor isNil ifTrue:[self spokeColor: Color gray lighter lighter].
	^ spokeColor! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 13:21'!
spokeColor: anObject
	"Set the value of spokeColor"

	spokeColor _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 14:30'!
spokeLength

	^self radius - self centerMargin - 5! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 11:25'!
spokePens
	"Answer the value of spokePens"

	spokePens isNil ifTrue:[self spokePens: self initializeSpokePens].
	^ spokePens! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 11:22'!
spokePens: anObject
	"Set the value of spokePens"

	spokePens _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 13:21'!
webColor
	"Answer the value of webColor"

	webColor isNil ifTrue:[self webColor: Color blue].
	^ webColor! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 13:21'!
webColor: anObject
	"Set the value of webColor"

	webColor _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 17:06'!
webPen
	"Answer the value of webPen"

	webPen isNil ifTrue:[self webPen: Pen new.
		webPen color: self webColor.
		webPen defaultNib:2.
		webPen  combinationRule: Form over.
		webPen destForm: self canvas].
	^ webPen! !

!RVMMultiAspectKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 13:29'!
webPen: anObject
	"Set the value of webPen"

	webPen _ anObject! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/11/2008 17:19'!
adjustScaleIcon
^((ColorForm
	extent: 16@31
	depth: 8
	fromArray: #( 0 0 0 0 0 0 169614364 622594560 0 0 1694498815 4294913536 0 0 1845490943 4294915840 0 0 0 3506384384 0 0 0 3506386688 73 1677721600 0 3657379328 163 3642490880 0 3506386688 9716 4287692800 172 4110364160 46591 4294913536 208 4110366464 4259839 4294936576 0 3506384384 8973264 4106150400 0 3657381632 6558618 3942664503 0 3506384384 154 3942645760 0 3657381632 154 3942645760 25700 3808374272 154 3942645760 60415 4294915840 154 3942645760 18761 3808374272 154 3942645760 0 3506386688 2424986 3942648357 0 3657379328 11304867 3947480869 0 3506386688 7798783 4294948096 0 3506384384 1300991 4294925056 217 4294915840 25855 4291821568 145 3959369216 199 4098424832 0 3657381632 118 2432696320 0 3506384384 28 620756992 0 3506386688 0 0 0 3657379328 0 0 1541003737 4110366464 0 0 1694498815 4294913536 0 0 321795886 1227753984 0 0 0 0)
	offset: 0@0)
	colorsFromArray: #(#(1.0 1.0 1.0) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0)  ))! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/12/2008 11:21'!
buildIndexIcons

	| icon label |
	^self coreIndicies collect:[:index|
		label _ index printString asDisplayText .
		label foregroundColor: Color black backgroundColor: Color transparent.
		icon _ self iconCircle.
		label align: label boundingBox center with: icon boundingBox center.
		label displayOn: icon at: 0 @ -2.
		icon offset: icon boundingBox center negated.
		icon]! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/11/2008 17:34'!
drawAdjustScaleIcon
	| adjustIcon origin |
.
	adjustIcon _ self adjustScaleIcon.
	origin _ self backgroundCanvas boundingBox leftCenter - adjustIcon boundingBox leftCenter + (4@0).
	adjustIcon displayOn: self backgroundCanvas at: origin.
	self adjustScaleBox:(origin extent: adjustIcon extent)! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/12/2008 12:59'!
drawBackgroundCanvas
	self drawingBackground: true.
	self backgroundCanvas fillWhite.
	self drawSpokes.
	"self drawAdjustScaleIcon."
	"self drawLabelsOnBackground."
	self drawingBackground: false.
	! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/11/2008 23:18'!
drawCounterOnCanvas
	|  counterLabel |
	counterLabel _ ('rescale
in: ',self rescaleCounter printString ) asDisplayText.
	counterLabel displayOn: self canvas at: self canvas boundingBox bottomRight -(counterLabel width@90).
! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/12/2008 10:27'!
drawLabelsOnBackground
	
	| labels count origin coreNameText |
	labels _ self coreIndicies isEmpty ifTrue:[Array with:'System Aspects']ifFalse:[self coreIndicies collect:[:each| 'Core #',each printString]].
	count _ 1.
	origin _ 2 @ -4.
	labels do:[:coreName|
		coreNameText _ coreName asDisplayText.
		coreNameText foregroundColor: (self colors at: count) backgroundColor: Color transparent.
		coreNameText displayOn: self backgroundCanvas at:  origin.
		origin  _ origin + (0@coreNameText height).
		count = (labels size //2) ifTrue:[origin _ self canvas boundingBox topRight - (coreNameText width @0)].
		count _ count + 1]
! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 10/6/2008 14:16'!
drawMajorTicUsing: pen

	pen turn:90; go: self majorTicLength/2;turn:180;down;go:self majorTicLength;up;
			turn:180; go: self majorTicLength/2;turn:-90! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 10/6/2008 14:16'!
drawMinorTicUsing: pen

	pen turn:90; go: self minorTicLength/2;turn:180;down;go:self minorTicLength;up;
			turn:180; go: self minorTicLength/2;turn:-90! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/12/2008 11:43'!
drawOnCanvas
	self drawingBackground ifTrue:[^self].
	self backgroundCanvas displayOn: self canvas at: 0@0.
	"self drawCounterOnCanvas."
	self drawWeb.
! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/11/2008 23:24'!
drawSpokes

	| pen label labelOffsets labelOffset |
	1 to: self spokePens size do:[:index|
		pen _ self spokePens at: index.
		pen destForm: self backgroundCanvas.
		pen place: self center.
		pen up; go: self centerMargin.
		pen down;go: self spokeLength;up.
		label _ (self aspects at: index) asString asDisplayText asParagraph asForm.
		"self diameter < 300 ifTrue:[label _ label scaledToSize: 11@11]."
		labelOffsets _ {0@label height negated.  0@0. label width negated@0.  label extent negated}.
		labelOffset _ labelOffsets at: ((index - 1// (self spokePens size / 4) + 1) min:4).
		label displayOn: self backgroundCanvas at: pen location + labelOffset clippingBox: self backgroundCanvas boundingBox rule: Form paint fillColor: nil.
		self drawTicsUsing: pen]
		! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 10/6/2008 11:54'!
drawTicsUsing: pen

	pen up;place: self center;go:self centerMargin.
	self drawMajorTicUsing: pen.
	self numberOfMajorTics - 1 timesRepeat:[
		self numberOfMinorTics timesRepeat:[
			pen go: self minorTicSpacing.
			self drawMinorTicUsing: pen].
		pen go: self minorTicSpacing.
		self drawMajorTicUsing: pen].
	! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/12/2008 13:06'!
drawWeb
	self coreIndicies isEmpty ifTrue:[^self drawWebSystem].
	self coreIndicies do:[:index|
		self placeSpokePensForCore: index.
		self webPen color: (self colors at: (self coreIndicies indexOf: index)).
		self webPen combinationRule: Form paint.
		self webPen up;place: self spokePens first location;down.
		self spokePens do:[:pen|
			self webPen goto: pen location].
		self webPen goto: self spokePens first location;up].
	self coreIndicies  "shuffled" do:[:index|
				self placeIconsForCore: index]

	! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/12/2008 10:07'!
drawWebSystem
	self drawingBackground ifTrue:[^self].
	self placeSpokePens.
	self webPen color: self webColor.
	self webPen up;place: self spokePens first location;down.
	self spokePens do:[:pen|
		self webPen goto: pen location].
	self webPen goto: self spokePens first location;up
	! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/12/2008 11:12'!
iconCircle

	| icon aForm aCircle |
	icon _ Form extent:18@18 depth: Display depth.
	aForm _ Form extent: 1@1.
	aForm fillBlack.
	aCircle _ Circle new.
	aCircle form: aForm.
	aCircle radius: 9.
	aCircle center: 8@8.
	aCircle displayOn: icon.
	^icon! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/12/2008 12:46'!
placeIconsForCore: anIndex

	| data scaledDatum offset aspectIndex |
	data _ anIndex > 0 ifTrue:[self aspects collect:[:aspect| (RVMMonitor lastSample perform: aspect) at: anIndex]] ifFalse:[self aspects collect:[:aspect| RVMMonitor lastSample perform: aspect]].
	offset _ self aspects size > 0 ifTrue:[0]ifFalse:[((anIndex) - 1)*8/5].
	aspectIndex _ 1.
	data with: self spokePens do:[:datum :pen|
		pen up;place: self center;turn: offset negated;go:self centerMargin.
		scaledDatum _ (self scalers at: aspectIndex) scale: datum.
		pen go:(self spokeLength /100.0*(scaledDatum)).
		pen turn: offset.
		aspectIndex _ aspectIndex + 1.
		(self indexIcons at: (self coreIndicies indexOf: anIndex)) displayOn: self canvas at: pen location].
! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/12/2008 02:26'!
placeSpokePens

	| data index |
	data _ self coreIndex > 0 ifTrue:[self aspects collect:[:aspect| (RVMMonitor lastSample perform: aspect) at: self coreIndex]] ifFalse:[self aspects collect:[:aspect| RVMMonitor lastSample perform: aspect]].
	index _ 0.
	data with: self spokePens do:[:datum :pen|
		index _ index + 1.
		pen up;place: self center;go:self centerMargin.
		pen go:(self spokeLength /100.0*((self scalers at: index) scale: datum))].
! !

!RVMMultiAspectKiviatView methodsFor: 'drawing' stamp: 'ssa 11/12/2008 12:45'!
placeSpokePensForCore: anIndex

	| data scaledDatum offset aspectIndex |
	data _ anIndex > 0 ifTrue:[self aspects collect:[:aspect| (RVMMonitor lastSample perform: aspect) at: anIndex]] ifFalse:[self aspects collect:[:aspect| RVMMonitor lastSample perform: aspect]].
	offset _ self aspects size > 0 ifTrue:[0]ifFalse:[((anIndex) - 1)*8/5].
	aspectIndex _ 1.
	data with: self spokePens do:[:datum :pen|
		pen color: (self colors at: (self coreIndicies indexOf: anIndex)).
		pen up;place: self center;turn: offset negated;go:self centerMargin.
		scaledDatum _ (self scalers at: aspectIndex) scale: datum.
		pen go:(self spokeLength /100.0*(scaledDatum)).
		pen turn: offset.
		aspectIndex _ aspectIndex + 1].
! !

!RVMMultiAspectKiviatView methodsFor: 'framing' stamp: 'ssa 10/8/2008 15:20'!
firstFrame
	! !

!RVMMultiAspectKiviatView methodsFor: 'framing' stamp: 'ssa 10/8/2008 19:20'!
newFrame
	self canvas:nil.
	self backgroundCanvas:nil.
	self drawOnCanvas.
	Display fill: self insetDisplayBox fillColor: Color white.
	self displayView! !

!RVMMultiAspectKiviatView methodsFor: 'scaling' stamp: 'ssa 11/11/2008 23:06'!
resetScaling

	self scalers do:[:each| each resetScaling].
! !

!RVMMultiAspectKiviatView methodsFor: 'initialize-release' stamp: 'ssa 11/11/2008 23:05'!
initializeSpokePens

	| pens numberOfSpokes spacing center pen |
	pens _ OrderedCollection new.
	numberOfSpokes _ self aspects size.
	spacing _ 360 / numberOfSpokes asFloat.
	center _ self insetDisplayBox center.
	numberOfSpokes timesRepeat:[
		pen _ Pen new.
		pen defaultNib:1.
		pen  combinationRule: Form over.
		pen color: self spokeColor.
		pen place: center.
		pen north.
		pen turn: pens size * spacing.
		pens add: pen].
	^pens! !

!RVMMultiAspectKiviatView methodsFor: 'initialize-release' stamp: 'ssa 11/11/2008 21:41'!
release
	"self controller scalerAdjusters do:[:each| each topView controller closeAndUnscheduleNoTerminate].	
	self controller scalerAdjusters: nil."
	super release! !

!RVMMultiAspectKiviatView methodsFor: 'displaying' stamp: 'ssa 11/12/2008 13:18'!
displayView
	"Display my canvas at my offset.
	Subclasses should not override this method but should draw on the canvas instead"
	self firstDisplay  ifFalse:[self firstDisplay:true.
		self drawOnCanvas].
	self okToDisplay ifFalse:[^self].
	self uncache.
	self canvas displayOn: Display at: self insetDisplayBox center - self canvas center clippingBox: self insetDisplayBox.
	self blinker  ifTrue:[(Form dotOfSize:5) displayOn: Display at: self insetDisplayBox center]

! !

!RVMMultiAspectKiviatView methodsFor: 'displaying' stamp: 'dmu 8/23/2010 17:38'!
resetAfterCoreCountChange
	self spokePens: nil. backgroundCanvas _ nil! !

!RVMMultiAspectKiviatView methodsFor: 'controller access' stamp: 'ssa 10/6/2008 13:35'!
defaultControllerClass
	^RVMMultiAspectKiviatController! !

!RVMMultiAspectKiviatView methodsFor: 'listening' stamp: 'dmu 2/6/2009 22:35'!
hear: something
	"Update my traces and redisplay"
	self firstDisplay ifFalse: [^self].
	self rescaleCounter: self rescaleCounter - 1.
	self rescaleCounter = 0 ifTrue:[self rescaleCounter:nil.  
		self resetScaling.]. 
	self drawingBackground ifTrue:[^self].
	self drawOnCanvas.
	self displayView! !

!RVMMultiAspectKiviatView commentStamp: '<historical>' prior: 0!
I'm a kiviat chart for displaying core aspect data!
!RVMMultiAspectKiviatView class methodsFor: 'aspect subsets' stamp: 'ssa 11/13/2008 02:02'!
allCoreAspects
	^RVMMulticoreSample coreAspects! !

!RVMMultiAspectKiviatView class methodsFor: 'aspect subsets' stamp: 'ssa 11/12/2008 12:53'!
coreAspectSubset
	"RVMMultiAspectKiviatView openOnAspects:  RVMMultiAspectKiviatView coreAspectSubset forCores:(1 to: RVMMonitor coreCount) asOrderedCollection titled:'Outliers'"
	^#(   bytecodesPerSecond   bytesUseds  contextChangeCounts interruptCheckCounts  unforcedInterruptCheckCounts yieldsPerSecond )! !

!RVMMultiAspectKiviatView class methodsFor: 'aspect subsets' stamp: 'ssa 11/12/2008 12:54'!
coreAspectSubsetAllocationCompaction
	"RVMMultiAspectKiviatView openOnAspects:  RVMMultiAspectKiviatView coreAspectSubsetAllocationCompaction forCores:(1 to: RVMMonitor coreCount) asOrderedCollection  titled:'Outliers: Allocation/Compaction'"
	^#(allocationsReadWrites allocationsReadMostlys allocationsTotal  compactionsReadWrites compactionsReadMostlys compactionsTotal  )! !

!RVMMultiAspectKiviatView class methodsFor: 'aspect subsets' stamp: 'ssa 11/12/2008 12:54'!
coreAspectSubsetBytecodes
	"RVMMultiAspectKiviatView openOnAspects:  RVMMultiAspectKiviatView coreAspectSubsetBytecodes forCores:(1 to: RVMMonitor coreCount) asOrderedCollection titled:'Outliers: Bytecodes'"
	^#( bytecodeCounts bytecodesPerCycles  bytecodesPerSecond )! !

!RVMMultiAspectKiviatView class methodsFor: 'aspect subsets' stamp: 'ssa 11/12/2008 12:54'!
coreAspectSubsetBytes
	"RVMMultiAspectKiviatView openOnAspects:  RVMMultiAspectKiviatView coreAspectSubsetBytes forCores:(1 to: RVMMonitor coreCount) asOrderedCollection titled:'Outliers: Bytes'"
	^#(bytesLeftReadWrites bytesLeftReadMostlys bytesLefts bytesUsedReadWrites bytesUsedReadMostlys bytesUseds )! !

!RVMMultiAspectKiviatView class methodsFor: 'aspect subsets' stamp: 'ssa 11/12/2008 12:55'!
coreAspectSubsetRunWait
	"RVMMultiAspectKiviatView openOnAspects:  RVMMultiAspectKiviatView coreAspectSubsetRunWait forCores:(1 to: RVMMonitor coreCount) asOrderedCollection titled:'Outliers: RunWait'"
	^#(millisecondsRunnings millisecondsWaitings msRunWaitRatios msSinceLasts )! !

!RVMMultiAspectKiviatView class methodsFor: 'aspect subsets' stamp: 'ssa 11/12/2008 12:55'!
coreAspectSubsetYields
	"RVMMultiAspectKiviatView openOnAspects:  RVMMultiAspectKiviatView coreAspectSubsetYields forCores:(1 to: RVMMonitor coreCount) asOrderedCollection titled:'Outliers: Yields'"
	^#(unforcedInterruptCheckCounts yieldCounts yieldFrequencies yieldsPerSecond )! !

!RVMMultiAspectKiviatView class methodsFor: 'examples' stamp: 'ssa 11/11/2008 23:18'!
example
	"RVMMultiAspectKiviatView example"
	self openOnAspects: RVMMulticoreSample systemAspects! !

!RVMMultiAspectKiviatView class methodsFor: 'examples' stamp: 'ssa 11/12/2008 10:26'!
example10Cores
	"RVMMultiAspectKiviatView example10Cores"
	self openOnAspects: RVMMulticoreSample coreAspects forCores: #(1 2 3 4 5 6 7 8 9 10)! !

!RVMMultiAspectKiviatView class methodsFor: 'examples' stamp: 'ssa 11/12/2008 10:50'!
example10CoresSubset1
	"RVMMultiAspectKiviatView example10CoresSubset1"
	self openOnAspects: self coreAspectSubset forCores: #(1 2 3 4 5 6 7 8 9 10)! !

!RVMMultiAspectKiviatView class methodsFor: 'examples' stamp: 'ssa 11/12/2008 10:34'!
example20Cores
	"RVMMultiAspectKiviatView example20Cores"
	self openOnAspects: RVMMulticoreSample coreAspects forCores: (1 to: 20) asOrderedCollection! !

!RVMMultiAspectKiviatView class methodsFor: 'examples' stamp: 'ssa 11/12/2008 11:53'!
exampleAllCores
	"RVMMultiAspectKiviatView exampleAllCores"
	self openOnAspects: RVMMulticoreSample coreAspects forCores:(1 to: RVMMonitor coreCount) asOrderedCollection! !

!RVMMultiAspectKiviatView class methodsFor: 'examples' stamp: 'ssa 11/12/2008 11:53'!
exampleAllCoresSubset1
	"RVMMultiAspectKiviatView exampleAllCoresSubset1"
	self openOnAspects:  self coreAspectSubset forCores:(1 to: RVMMonitor coreCount) asOrderedCollection! !

!RVMMultiAspectKiviatView class methodsFor: 'examples' stamp: 'ssa 11/12/2008 02:24'!
exampleCore5
	"RVMMultiAspectKiviatView exampleCore5"
	self openOnAspects: RVMMulticoreSample coreAspects forCore: 5! !

!RVMMultiAspectKiviatView class methodsFor: 'examples' stamp: 'ssa 11/12/2008 10:45'!
exampleSubset1
	"RVMMultiAspectKiviatView exampleSubset1"
	self openOnAspects: self coreAspectSubset! !

!RVMMultiAspectKiviatView class methodsFor: 'instance creation' stamp: 'ssa 11/11/2008 23:17'!
openOnAspect: aSymbol
	"RVMMultiAspectKiviatView example"
	
	self openOnAspects: (Array with: aSymbol)! !

!RVMMultiAspectKiviatView class methodsFor: 'instance creation' stamp: 'ssa 11/12/2008 11:44'!
openOnAspects: someSymbols
	"RVMMultiAspectKiviatView example"
	
	| topView v |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 600@250.
	topView maximumSize: 1000@800.
	v := self new.
	v borderWidth:1.
	v aspects: someSymbols.
	topView addSubView: v.
	topView label: 'MultiAspectKiviat'.
	topView controller open! !

!RVMMultiAspectKiviatView class methodsFor: 'instance creation' stamp: 'ssa 11/12/2008 10:15'!
openOnAspects: someSymbols forCore: anIndex
	"RVMMultiAspectKiviatView exampleCore5"
	
	self openOnAspects: someSymbols forCores: (Array with: anIndex)! !

!RVMMultiAspectKiviatView class methodsFor: 'instance creation' stamp: 'ssa 11/12/2008 12:52'!
openOnAspects: someSymbols forCores: indexArray
	"RVMMultiAspectKiviatView exampleAllCores"
	
	self openOnAspects: someSymbols forCores: indexArray titled: 'MultiAspectKiviat'! !

!RVMMultiAspectKiviatView class methodsFor: 'instance creation' stamp: 'ssa 11/12/2008 12:59'!
openOnAspects: someSymbols forCores: indexArray titled: aString
	"RVMMultiAspectKiviatView exampleAllCores"
	
	| topView v |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 300@150"(9*indexArray size max:250)".
	topView maximumSize: 1000@800.
	v := self new.
	v coreIndicies: indexArray.
	v borderWidth:1.
	v aspects: someSymbols.
	topView addSubView: v.
	topView label: aString.
	topView controller open! !

!RVMMultiAspectStripChartController methodsFor: 'menu messages' stamp: 'ssa 9/14/2008 21:49'!
eraseStrip

	self view eraseStrip! !

!RVMMultiAspectStripChartController methodsFor: 'controlling' stamp: 'ssa 9/13/2008 17:44'!
redButtonActivity

	self view displayView! !

!RVMMultiAspectStripChartController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 15:15'!
yellowButtonActivity
	| menu answer |
	self view dontDisplayWhile:[
	Sensor yellowButtonPressed 
		ifTrue: [menu := CustomMenu new.
			menu add: 'erase strip' action: #eraseStrip:.
			answer := menu startUp:  nil withCaption: nil at: Sensor cursorPoint.
			answer notNil ifTrue:[
				self perform: answer]]]! !

!RVMMultiAspectStripChartView methodsFor: 'controller access' stamp: 'ssa 9/13/2008 17:43'!
defaultControllerClass

^RVMMultiAspectStripChartController! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:12'!
aspects
	"Answer the value of aspects"

	aspects isNil ifTrue:[self aspects: OrderedCollection new].
	^ aspects! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:41'!
aspects: anObject
	"Set the value of aspects"

	aspects _ anObject..
	self scalers:nil.
	self data: nil.
! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:12'!
chart
	"Answer the value of chart"

	chart isNil ifTrue:[self chart: (Form fromDisplay: self insetDisplayBox) fillWhite].
	^ chart! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:11'!
chart: anObject
	"Set the value of chart"

	chart _ anObject! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 9/14/2008 20:55'!
colors
	"Answer the value of colors"

	^self scalers collect:[:each| each color]! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:36'!
coreIndex
	"Answer the value of coreIndex"

	coreIndex isNil ifTrue:[self coreIndex: 1].
	^ coreIndex! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:36'!
coreIndex: anObject
	"Set the value of coreIndex"

	coreIndex _ anObject! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:25'!
data
	"Answer the value of data"

	data isNil ifTrue:[self data: (Array new: self aspects size)].
	^ data! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:11'!
data: anObject
	"Set the value of data"

	data _ anObject! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:18'!
dotSize
	"Answer the value of dotSize"

	dotSize isNil ifTrue:[self dotSize: 2].
	^ dotSize! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:14'!
dotSize: anObject
	"Set the value of dotSize"

	dotSize _ anObject! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:49'!
getData
	 | sample |
	sample _ self sampleSource value.
	1 to: self aspects size do:[:index|
		self data at: index put: ((self scalers at: index) scale:((sample perform: (self aspects at: index)) at:  self coreIndex))]! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:29'!
sampleSource
	"Answer the value of sampleSource"

	sampleSource isNil ifTrue:[self sampleSource: [RVMMonitor lastSample]].
	^ sampleSource! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 17:27'!
sampleSource: anObject
	"Set the value of sampleSource"

	sampleSource _ anObject! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:45'!
scalers
	"Answer the value of scalers"

	scalers isNil ifTrue:[self scalers: (RVMMonitor coloredScalersFor: self aspects)].
	^ scalers! !

!RVMMultiAspectStripChartView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 18:04'!
scalers: anObject
	"Set the value of scalers"

	scalers _ anObject! !

!RVMMultiAspectStripChartView methodsFor: 'listening' stamp: 'ssa 1/1/1970 00:33'!
hear: something

	self displayView! !

!RVMMultiAspectStripChartView methodsFor: 'displaying' stamp: 'ssa 10/21/2008 11:32'!
displayView
	| bottomLeft points sortedPoints box |
	self okToDisplay ifFalse:[^self].
	self uncache.
	self getData.
	self chart displayOn: Display at: self insetDisplayBox origin + (self dotSize @ 0) clippingBox: self insetDisplayBox.
	bottomLeft := self insetDisplayBox bottomLeft.
	points := OrderedCollection new.
	1 to: self aspects size do: [:index | points add: index @ (self data at: index)].
	sortedPoints := points asSortedCollection: [:a :b | a y > b y].
	sortedPoints
		do: [:each | 
			box := bottomLeft - (0 @ (each y * self dotSize)) corner: bottomLeft + (self dotSize @ 0).
			Display fill: box fillColor: (self colors at: each x)].
	self chart:(Form fromDisplay: self insetDisplayBox).! !

!RVMMultiAspectStripChartView methodsFor: 'displaying' stamp: 'ssa 9/14/2008 21:50'!
eraseStrip
	Display fill: self insetDisplayBox fillColor: Color  white.
	self chart: nil;chart! !

!RVMMultiAspectStripChartView methodsFor: 'auxiliary views' stamp: 'ssa 1/1/1970 00:29'!
combinedScalerView
	"Answer a view holding all my appropriate scaler views"
	| v last current |
	v _ RVMView new.
	last _ nil.
	self scalers do:[:scaler|
		v addSubView: (current _ RVMColoredDataScalerView on: scaler) below: last.
		current borderWidth:1.
		last _ current].
	^v! !

!RVMMultiAspectStripChartView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:29'!
example
	"RVMMultiAspectStripChartView example"
	| topView chart scalers aspectCount |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	chart _ self exampleInstance.
	aspectCount _ chart aspects size.
	topView minimumSize: 200@(aspectCount*40).
	topView maximumSize: 800@(2*aspectCount*40).
	scalers _ chart combinedScalerView.
	topView addSubView: scalers in:(0@0 extent: 1/3 @ 1)borderWidth:1.
	topView addSubView: chart in:(1/3@0 extent: 2/3 @ 1)borderWidth:1.
	topView label: 'Multi Aspect Strip'.
	topView controller open! !

!RVMMultiAspectStripChartView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:28'!
exampleInstance

	| view |
	view _ self new.
	view aspects: #( bytecodeCounts bytesUseds yieldCounts ).
	^view! !

!RVMMultiAspectStripChartView class methodsFor: 'examples' stamp: 'ssa 9/14/2008 20:30'!
exampleMany
	"RVMMultiAspectStripChartView exampleMany"
	| topView view manyCount lastView |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	manyCount _ 4.
	topView minimumSize: 100@(25*manyCount).
	topView maximumSize: 200@(50*manyCount).
	lastView _ nil.
	manyCount timesRepeat:[
		view _ self exampleInstance.
		topView addSubView: view below: lastView.
		lastView _ view].
	topView label: 'Aspect/Color'.
	topView controller open! !

!RVMMultiAspectStripChartView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 01:10'!
coreIndex: index
	"Answer a stripchart for this core index watching these aspects from this source"
	| view |
	view _ self new.
	view coreIndex: index.
	view aspects: #(bytesUsed bytecodeCounts yieldCounts).
	view sampleSource: [RVMMonitor lastSample].
	^view! !

!RVMMultiAspectStripChartView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 01:08'!
coreIndex: index  aspects: aspects 
	"Answer a stripchart for this core index watching these aspects from this source"
	| view |
	view _ self new.
	view coreIndex: index.
	view aspects: aspects.
	view sampleSource: [RVMMonitor lastSample].
	^view! !

!RVMMultiAspectStripChartView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 01:08'!
coreIndex: index  aspects: aspects sampleSource: aBlock
	"Answer a stripchart for this core index watching these aspects from this source"
	| view |
	view _ self new.
	view coreIndex: index.
	view aspects: aspects.
	view sampleSource: aBlock.
	^view! !

!RVMMultiGroupLocatorController methodsFor: 'controlling' stamp: 'ssa 11/27/2008 13:44'!
changeSourceForGroupNumber: anIndex
	| menu action choices |
	menu := CustomMenu new.
	choices _ {'Object withAllSubclasses'. 
			'View withAllSubclasses'.
			'Number allSubclasses'.
			#line.
			'String allInstances'.
			'Array allInstances'.
			'Collection allSubInstances' }.
	choices do:[:choice|
		choice = #line ifTrue:[menu addLine]
			ifFalse:[menu add: choice action:choice]].
	
	action := menu startUp: nil withCaption: 'Select an expression to use for group #',(anIndex printString) at: Sensor cursorPoint.
	action notNil ifTrue:[self changeSourceSourcefromGroupNumber: anIndex to: action]! !

!RVMMultiGroupLocatorController methodsFor: 'controlling' stamp: 'ssa 11/27/2008 13:47'!
changeSourceSourcefromGroupNumber: anIndex to: aString
Cursor wait showWhile:[
	self view sourceSourceForGroupNumber: anIndex put: aString.
	self view changed:#updateDisplay]! !

!RVMMultiGroupLocatorController methodsFor: 'controlling' stamp: 'ssa 11/27/2008 13:53'!
yellowButtonActivity
	| menu action choices index |
	self view topView dontDisplayWhile:[
	menu := CustomMenu new.
	menu add:'Inspect View' action:[self view inspect].
	menu addLine.
	choices _ view sources collect:[:each| 'Change #',(index _ view sources indexOf: each) printString, ': ',(view sourceSourceForGroupNumber:index)].
	choices do:[:choice|
		choice = #line ifTrue:[menu addLine]
			ifFalse:[menu add: choice action: (choices indexOf: choice)]].
	
	action := menu startUp: nil withCaption: '' at: Sensor cursorPoint].
	(action isKindOf: BlockContext) ifTrue:[^action value].
	action notNil ifTrue:[self changeSourceForGroupNumber: action]! !

!RVMMultiGroupLocatorView methodsFor: 'listening' stamp: 'ssa 11/27/2008 13:24'!
hear: something
	"Update my display"
	self counts: nil.
	self drawOnCanvas.
	self displayView! !

!RVMMultiGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 12:55'!
colors
	"Answer the value of colors"

	colors isNil ifTrue:[self colors: (Color hotColdShades: (self sources size max:5))].
	^ colors! !

!RVMMultiGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 12:37'!
colors: anObject
	"Set the value of colors"

	colors _ anObject! !

!RVMMultiGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 13:33'!
counts
	"Answer the value of counts"

	counts isNil ifTrue:[self counts: (Array new:self sources size).
		1 to: self sources size do:[:index| self countsPerCoreForGroupNumber: index]].
	^ counts! !

!RVMMultiGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 12:31'!
counts: anObject
	"Set the value of counts"

	counts _ anObject! !

!RVMMultiGroupLocatorView methodsFor: 'accessing' stamp: 'ads 1/30/2011 15:20'!
countsPerCoreForGroupNumber: anIndex
	"Answer the value of countsPerCore"
	(self counts at: anIndex) isNil ifTrue:[self counts at: anIndex put: ((self objectsForGroupNumber: anIndex) asOrderedCollection  collect:[:obj| RVMOperations isRVM ifFalse:[RVMMonitor coreCount atRandom - 1]ifTrue:[RVMOperations getCoreHolding:obj]]) asBag].
	^ self counts at: anIndex! !

!RVMMultiGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 12:33'!
objectsForGroupNumber: anIndex
	"Answer my colection of objects to locate."
	| source |
	source _ self sources at: anIndex.
	^source isSymbol ifTrue:[self model perform: source] ifFalse:[source value]! !

!RVMMultiGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 13:19'!
sourceSourceForGroupNumber: anIndex
	| code source |
	source _ self sources at: anIndex.
	source isSymbol ifTrue:[^source printString].
	code _ source decompile printString.
	(code beginsWith:'{[') &(code endsWith:']}') ifTrue:[code _ code copyFrom: 3 to: code size - 2].
	^code! !

!RVMMultiGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 13:22'!
sourceSourceForGroupNumber: anIndex put: aText
	| value aString |
	aString _ aText asString.
	( aString withBlanksTrimmed beginsWith:'#')
		ifTrue:[value _  Compiler new evaluate: aString in: nil to: nil
						notifying: nil ifFail: [^ false].
				self model perform: value.  "test to make sure it works before installing"]
		ifFalse:[value _ Compiler new evaluate: '[',aString,']' in: nil to: nil
						notifying: nil ifFail: [^ false]].
	self sources at: anIndex put: value.
	self hear:nil.
	^true "tell the editor its OK"! !

!RVMMultiGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 12:42'!
sources
	"Answer the value of sources"

	sources isNil ifTrue:[self sources: {[String allInstances]. [View withAllSubclasses]. [Number withAllSubclasses]}].
	^ sources! !

!RVMMultiGroupLocatorView methodsFor: 'accessing' stamp: 'ssa 11/27/2008 12:31'!
sources: anObject
	"Set the value of sources"

	sources _ anObject! !

!RVMMultiGroupLocatorView methodsFor: 'drawing' stamp: 'ssa 11/27/2008 13:34'!
drawLocations
	| indicies |
	indicies _ (self counts asSortedCollection:[:a :b| a size < b size]) collect:[:each| self counts indexOf: each].
	indicies do:[:anIndex| self drawLocationsForGroupNumber: anIndex]! !

!RVMMultiGroupLocatorView methodsFor: 'drawing' stamp: 'ssa 11/27/2008 12:40'!
drawLocationsForGroupNumber: anIndex
	| dot coreExtent amt index rect pt dotSize realRect |
	coreExtent _ RVMMonitor extent.
	dotSize _(self boxes first width // (((self countsPerCoreForGroupNumber:anIndex) size // self boxes size)max:1))min:self boxes first width //2 max:1.
	dot _ Form dotOfSize: dotSize color: (self colors at: anIndex).
	0 to: coreExtent x - 1 do:[:x|
		0 to: coreExtent y - 1 do:[:y|
			amt _ (self countsPerCoreForGroupNumber:anIndex) occurrencesOf: (index _ y*8+x).
			rect _ (realRect _ self boxes at: index + 1) insetBy: dot offset abs.
			amt  timesRepeat:[pt _ rect asRandomPoint.
				dot displayOn: self canvas at: pt clippingBox: realRect rule: Form paint fillColor:nil]].
		]! !

!RVMMultiGroupLocatorView methodsFor: 'controller access' stamp: 'ssa 11/27/2008 13:40'!
defaultControllerClass

	^RVMMultiGroupLocatorController! !

!RVMMultiGroupLocatorView class methodsFor: 'instance creation' stamp: 'ssa 11/27/2008 12:58'!
on: aModel sources: someBlocksOrSelectors 
	^self on: aModel sources: someBlocksOrSelectors colors: nil! !

!RVMMultiGroupLocatorView class methodsFor: 'instance creation' stamp: 'ssa 11/27/2008 12:55'!
on: aModel sources: someBlocksOrSelectors colors: someColors
	"(RVMMultiGroupLocatorView on: Smalltalk sources: {#keys. #values. #classNames} colors: nil) demo"
	"(RVMultiGroupLocatorView on: nil sources: {[String allInstances]. [Array allInstances]} colors: {Color yellow. Color green}) demo"
	"(RVMMultiGroupLocatorView on: nil sources: {[String allInstances]. [Array allInstances]. [Object withAllSubclasses]. [Float allInstances]} colors: nil) demo"
	
	| v |
	v _ self new.
	v model: aModel.
	v sources: someBlocksOrSelectors.
	v colors: someColors.
	^v! !

!RVMMultiGroupLocatorView class methodsFor: 'instance creation' stamp: 'ssa 11/27/2008 14:04'!
openOn: aModel sources: someBlocksOrSelectors colors: someColors
	"RVMMultiGroupLocatorView openOn: Smalltalk sources: {#keys. #values. #classNames} colors: nil"
	"RVMMultiGroupLocatorView openOn: nil sources: {[String allInstances]. [Array allInstances]} colors: {Color yellow. Color green}"
	"RVMMultiGroupLocatorView openOn: nil sources: {[String allInstances]. [Array allInstances]. [Object withAllSubclasses]. [Float allInstances]} colors: nil"
	| topView v ptv cbv h |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	v := self on: aModel sources: someBlocksOrSelectors colors: someColors.
	v borderWidth:1.
	topView minimumSize: 150@(150 + (v sources size * 20)).
	topView maximumSize: 800@900.
	topView addSubView: v  viewport:(0@0 extent: 150@150).
	h _ 0.
	1 to: v sources size do:[:groupIndex|
		ptv _ RVMPluggableTextView on: v text:[v sourceSourceForGroupNumber: groupIndex] fixTemps accept:[:arg| v sourceSourceForGroupNumber: groupIndex put: arg] fixTemps.
		ptv borderWidth:1.
		cbv _ RVMColorButtonView on: v colorGetter:[v colors at: groupIndex] fixTemps colorSetter:[:arg|v colors at: groupIndex put: arg.  v displayView] fixTemps.
		cbv borderWidth:1.
		topView addSubView: cbv  viewport:(0@(h+150) extent:20@20).
		topView addSubView: ptv  viewport:(20@(h+150) extent:130@20).
		h _ h + 20].
	topView label: 'Group Locator'.
	topView controller open! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 19:35'!
addAspect: aSymbol

	| s |
	self aspects add: aSymbol.
	self scalers add:(s _ RVMDataScaler new automatic).
	self pinMinAtZero ifTrue:[s pinMinAtZero].
	self lastTotals add: 0.
	self lastAverages add:0
! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 18:02'!
aspect
	"Get the value of aspect"

	^self aspects at:1! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 19:44'!
aspect: anObject
	"Set the value of aspect"

	self aspects at:1 put: anObject.
	self lastAverages at: 1 put: 0.
	self lastTotals at: 1 put:0.
	self topView == self ifFalse:[self topView relabel: anObject asString].
	self resetScaling.
	self drawOnCanvas! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 17:22'!
aspectCount

	^self aspects size! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 15:02'!
aspects
	"Answer the value of aspects"
	
	aspects isNil ifTrue:[self aspects: #(bytesUseds bytesUsedReadWrites bytesUsedReadMostlys) asOrderedCollection].
	^ aspects ! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 18:33'!
aspects: anObject
	"Set the value of aspects"

	aspects _ anObject.
	aspects notNil ifTrue:[aspects _ aspects asOrderedCollection.
		aspects size > 4 ifTrue:[aspects _ aspects copyFrom: 1 to: 4]].
	self lastAverages: nil.
	self lastTotals: nil! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 17:57'!
colorForAspect: aSymbol

	^self colors at: (self aspects indexOf: aSymbol)! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/21/2008 11:33'!
colors
	"Answer the value of colors "

	colors isNil ifTrue:[self colors: {Color blue. Color red. Color green darker darker. Color orange darker }].
	^ colors! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 17:56'!
colors: anObject
	"Set the value of colors"

	colors _ anObject! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 19:12'!
commonScale
	"Answer the value of commonScale"

	commonScale isNil ifTrue:[self commonScale: false].
	^ commonScale! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 19:13'!
commonScale: anObject
	"Set the value of commonScale"

	commonScale _ anObject.! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 20:02'!
lastAverageForAspect: aSymbol

	^self lastAverages at: (self aspects indexOf: aSymbol ifAbsent:[1])! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 15:19'!
lastAverageForAspect: aSymbol put: aValue

	^self lastAverages at: (self aspects indexOf: aSymbol) put: aValue! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 18:41'!
lastAverages
	"Answer the value of lastAverages"

	lastAverages isNil ifTrue:[self lastAverages: (Array new: self aspects size withAll: 0)asOrderedCollection].
	^ lastAverages! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 15:14'!
lastAverages: anObject
	"Set the value of lastAverages"

	lastAverages _ anObject! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 15:15'!
lastTotalForAspect: aSymbol

	^self lastTotals at: (self aspects indexOf: aSymbol)! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 15:19'!
lastTotalForAspect: aSymbol put: aValue

	^self lastTotals at: (self aspects indexOf: aSymbol) put: aValue! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 18:41'!
lastTotals
	"Answer the value of lastTotals"

	lastTotals isNil ifTrue:[self lastTotals: (Array new: self aspects size withAll: 0) asOrderedCollection].
	^ lastTotals! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 15:14'!
lastTotals: anObject
	"Set the value of lastTotals"

	lastTotals _ anObject! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 19:12'!
pinMinAtZero
	"Answer the value of pinMinAtZero"

	pinMinAtZero isNil ifTrue:[self pinMinAtZero: false].
	^ pinMinAtZero! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 19:12'!
pinMinAtZero: anObject
	"Set the value of pinMinAtZero"

	pinMinAtZero _ anObject.
	self scalers do:[:each| each pinMinAtZero]! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 19:15'!
removeAspect: aSymbol

	| index |
	index _ self aspects indexOf: aSymbol.
	self aspects remove: aSymbol.
	self commonScale ifFalse:[self scalers remove:(self scalers at: index)].
	self lastTotals remove:(self lastTotals at: index).
	self lastAverages remove:(self lastAverages at: index)
! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 18:04'!
scaler
	"Get the default scaler"

	^self scalers at:1! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 21:27'!
scalerAt: anIndex
	"Get the default scaler"
	self commonScale ifTrue:[^self scalers first].
	^self scalers at: anIndex! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/7/2008 19:13'!
scalerForAspect: aSymbol
	self commonScale ifTrue:[^self scalers first].
	^self scalers at: (self aspects indexOf: aSymbol)! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 17:59'!
scalers
	"Answer the value of scalers"

	scalers isNil ifTrue:[self scalers: OrderedCollection new.
		self aspects do:[:a| scalers add: RVMDataScaler new automatic]].
	^ scalers! !

!RVMMultiKiviatView methodsFor: 'accessing' stamp: 'ssa 10/6/2008 17:56'!
scalers: anObject
	"Set the value of scalers"

	scalers _ anObject! !

!RVMMultiKiviatView methodsFor: 'drawing' stamp: 'ssa 10/7/2008 15:39'!
drawBottomLeftLabelsOnCanvasForAspect: aSymbol
	
	| minLabel maxLabel  aspectLabel avgLabel totalLabel aspectColor box height |
	box _ self canvas boundingBox.
	aspectColor _self colorForAspect:aSymbol.
	aspectLabel _ aSymbol asString asDisplayText.
	minLabel _ ('min: ',(self scalerForAspect: aSymbol) min printShowingMax3Digits) asDisplayText.
	maxLabel _ ('max: ',(self scalerForAspect: aSymbol) max printShowingMax3Digits) asDisplayText.
	avgLabel _ ('avg: ',(self lastAverageForAspect: aSymbol) printShowingMax3Digits) asDisplayText.
	totalLabel _ ('total: ',(self lastTotalForAspect: aSymbol) printShowingMax3Digits) asDisplayText.
	avgLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	totalLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	aspectLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	minLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	maxLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	height _ aspectLabel height -3.
	aspectLabel displayOn: self canvas at:  box bottomLeft - (0 @aspectLabel height).
	minLabel displayOn: self canvas at: ((box bottomLeft x )@(box bottomLeft y -( height*2) )) clippingBox: box rule: Form paint fillColor:nil.
	maxLabel displayOn: self canvas at: ((box bottomLeft x )@(box bottomLeft y - (height*3)+3)) clippingBox: box rule: Form paint fillColor:nil.
	totalLabel displayOn: self canvas at: ((box bottomLeft x )@(box bottomLeft y - (height *4)+6)) clippingBox: box rule: Form paint fillColor:nil.
	avgLabel displayOn: self canvas at: ((box bottomLeft x )@(box bottomLeft y - (height *5)+9)) clippingBox: box rule: Form paint fillColor:nil.
! !

!RVMMultiKiviatView methodsFor: 'drawing' stamp: 'ssa 10/7/2008 15:36'!
drawBottomRightLabelsOnCanvasForAspect: aSymbol
	
	| minLabel maxLabel  aspectLabel avgLabel totalLabel aspectColor box height |
	box _ self canvas boundingBox.
	aspectColor _self colorForAspect:aSymbol.
	aspectLabel _ aSymbol asString asDisplayText.
	minLabel _ ('min: ',(self scalerForAspect: aSymbol) min printShowingMax3Digits) asDisplayText.
	maxLabel _ ('max: ',(self scalerForAspect: aSymbol) max printShowingMax3Digits) asDisplayText.
	avgLabel _ ('avg: ',(self lastAverageForAspect: aSymbol) printShowingMax3Digits) asDisplayText.
	totalLabel _ ('total: ',(self lastTotalForAspect: aSymbol) printShowingMax3Digits) asDisplayText.
	avgLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	totalLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	aspectLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	minLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	maxLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	height _ aspectLabel height -3.
	aspectLabel displayOn: self canvas at:  box bottomRight - (aspectLabel extent).
	minLabel displayOn: self canvas at: ((box bottomRight x - minLabel width)@(box bottomRight y -( height*2) )) clippingBox: box rule: Form paint fillColor:nil.
	maxLabel displayOn: self canvas at: ((box bottomRight x - maxLabel width)@(box bottomRight y - (height*3)+3)) clippingBox: box rule: Form paint fillColor:nil.
	totalLabel displayOn: self canvas at: ((box bottomRight x - totalLabel width)@(box bottomRight y - (height *4)+6)) clippingBox: box rule: Form paint fillColor:nil.
	avgLabel displayOn: self canvas at: ((box bottomRight x - avgLabel width)@(box bottomRight y - (height *5)+9)) clippingBox: box rule: Form paint fillColor:nil.
! !

!RVMMultiKiviatView methodsFor: 'drawing' stamp: 'ssa 10/7/2008 14:56'!
drawLabelsOnCanvas
	
	| quads |
	quads _ #(drawTopLeftLabelsOnCanvasForAspect: drawTopRightLabelsOnCanvasForAspect: drawBottomRightLabelsOnCanvasForAspect: drawBottomLeftLabelsOnCanvasForAspect:).
	1 to: self aspects size do:[:index| 
		self perform: (quads at: index) with: (self aspects at: index)]! !

!RVMMultiKiviatView methodsFor: 'drawing' stamp: 'ssa 10/7/2008 15:13'!
drawTopLeftLabelsOnCanvasForAspect: aSymbol
	
	| minLabel maxLabel  aspectLabel avgLabel totalLabel aspectColor box height |
	box _ self canvas boundingBox.
	aspectColor _self colorForAspect:aSymbol.
	aspectLabel _ aSymbol asString asDisplayText.
	minLabel _ ('min: ',(self scalerForAspect: aSymbol) min printShowingMax3Digits) asDisplayText.
	maxLabel _ ('max: ',(self scalerForAspect: aSymbol) max printShowingMax3Digits) asDisplayText.
	avgLabel _ ('avg: ',(self lastAverageForAspect: aSymbol) printShowingMax3Digits) asDisplayText.
	totalLabel _ ('total: ',(self lastTotalForAspect: aSymbol) printShowingMax3Digits) asDisplayText.
	avgLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	totalLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	aspectLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	minLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	maxLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	height _ aspectLabel height - 6.
	aspectLabel displayOn: self canvas at:  (0 @ -4).
	minLabel displayOn: self canvas at: ((0)@(box topLeft y + height )) clippingBox: box rule: Form paint fillColor:nil.
	maxLabel displayOn: self canvas at: ((0)@(box topLeft y + (height*2))) clippingBox: box rule: Form paint fillColor:nil.
	totalLabel displayOn: self canvas at: ((0)@(box topLeft y + (height *3))) clippingBox: box rule: Form paint fillColor:nil.
	avgLabel displayOn: self canvas at: ((0)@(box topLeft y + (height *4))) clippingBox: box rule: Form paint fillColor:nil.
! !

!RVMMultiKiviatView methodsFor: 'drawing' stamp: 'ssa 10/7/2008 15:10'!
drawTopRightLabelsOnCanvasForAspect: aSymbol
	
	| minLabel maxLabel  aspectLabel avgLabel totalLabel aspectColor box height |
	box _ self canvas boundingBox.
	aspectColor _self colorForAspect:aSymbol.
	aspectLabel _ aSymbol asString asDisplayText.
	minLabel _ ('min: ',(self scalerForAspect: aSymbol) min printShowingMax3Digits) asDisplayText.
	maxLabel _ ('max: ',(self scalerForAspect: aSymbol) max printShowingMax3Digits) asDisplayText.
	avgLabel _ ('avg: ',(self lastAverageForAspect: aSymbol) printShowingMax3Digits) asDisplayText.
	totalLabel _ ('total: ',(self lastTotalForAspect: aSymbol) printShowingMax3Digits) asDisplayText.
	avgLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	totalLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	aspectLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	minLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	maxLabel foregroundColor: aspectColor backgroundColor: Color transparent.
	height _ aspectLabel height - 6.
	aspectLabel displayOn: self canvas at:  box topRight - (aspectLabel width @4).
	minLabel displayOn: self canvas at: ((box topRight x - minLabel width)@(box topRight y + height )) clippingBox: box rule: Form paint fillColor:nil.
	maxLabel displayOn: self canvas at: ((box topRight x - maxLabel width)@(box topRight y + (height*2))) clippingBox: box rule: Form paint fillColor:nil.
	totalLabel displayOn: self canvas at: ((box topRight x - totalLabel width)@(box topRight y + (height *3))) clippingBox: box rule: Form paint fillColor:nil.
	avgLabel displayOn: self canvas at: ((box topRight x - avgLabel width)@(box topRight y + (height *4))) clippingBox: box rule: Form paint fillColor:nil.
! !

!RVMMultiKiviatView methodsFor: 'drawing' stamp: 'ssa 10/7/2008 16:04'!
drawWeb
	self aspects do:[:aSymbol|
		self placeSpokePensForAspect: aSymbol.
		self webPen color: (self colorForAspect: aSymbol).
		self webPen combinationRule: Form paint.
		self webPen up;place: self spokePens first location;down.
		self spokePens do:[:pen|
			self webPen goto: pen location].
		self webPen goto: self spokePens first location;up]
	! !

!RVMMultiKiviatView methodsFor: 'drawing' stamp: 'dmu 8/23/2010 17:37'!
placeSpokePensForAspect: aSymbol

	| data scaledDatum tot offset |
	data _ RVMMonitor lastSample perform: aSymbol.
	offset _ ((self aspects indexOf: aSymbol) - 1)*4/5.
	tot _ 0.
	self spokePens size = data size ifFalse: [self resetAfterCoreCountChange].
	data with: self spokePens do:[:datum :pen|
		tot _ tot + datum.
		pen up;place: self center;turn: offset negated;go:self centerMargin.
		scaledDatum _ (self scalerForAspect: aSymbol) scale: datum.
		pen go:(self spokeLength /100.0*(scaledDatum)).
		pen turn: offset].
	self lastTotalForAspect: aSymbol put: tot.
	self lastAverageForAspect: aSymbol put: tot / data size! !

!RVMMultiKiviatView methodsFor: 'scaling' stamp: 'ssa 10/7/2008 19:48'!
resetScaling

	| data tot |
	self scalers do:[:s| s resetScaling].
	self aspects do:[:aSymbol|
	data _ RVMMonitor lastSample perform: aSymbol.
	tot _ 0.
	data do:[:datum |
		tot _ tot + datum.
		(self scalerForAspect: aSymbol) scale: datum].
	self lastTotalForAspect: aSymbol put: tot.
	self lastAverageForAspect: aSymbol put: tot / data size]! !

!RVMMultiKiviatView class methodsFor: 'examples' stamp: 'ssa 10/7/2008 15:38'!
example
	"RVMMultiKiviatView example"
	self openOnAspects: #(bytesUsedReadMostlys bytesUsedReadWrites bytesUseds bytecodeCounts)! !

!RVMMultiKiviatView class methodsFor: 'examples' stamp: 'ssa 4/3/2009 17:51'!
exampleBytecodesAndProcessesRunning
	"RVMMultiKiviatView exampleBytecodesAndProcessesRunning"
	self openOnAspects: #(bytecodeCounts runningProcessCountsPerCore ) pinAllScalesAtZero: false useCommonScale: false! !

!RVMMultiKiviatView class methodsFor: 'examples' stamp: 'ssa 10/7/2008 16:01'!
exampleBytesUsedTrioCommonPinned
	"RVMMultiKiviatView exampleBytesUsedTrioCommonPinned"
	self openOnAspects: #(bytesUsedReadWrites bytesUsedReadMostlys bytesUseds ) pinAllScalesAtZero: true useCommonScale: true! !

!RVMMultiKiviatView class methodsFor: 'examples' stamp: 'ssa 10/7/2008 16:01'!
exampleBytesUsedTrioPinned
	"RVMMultiKiviatView exampleBytesUsedTrioPinned"
	self openOnAspects: #(bytesUsedReadWrites bytesUsedReadMostlys bytesUseds ) pinAllScalesAtZero: true! !

!RVMMultiKiviatView class methodsFor: 'examples' stamp: 'ssa 10/7/2008 18:29'!
exampleSingle
	"RVMMultiKiviatView exampleSingle"
	self openOnAspects: #(bytecodeCounts) pinAllScalesAtZero: false useCommonScale: false titled: 'bytecodeCounts' ! !

!RVMMultiKiviatView class methodsFor: 'instance creation' stamp: 'ssa 10/7/2008 15:54'!
openOnAspects: someAspects
	"RVMMultiKiviatView example"
	
	self openOnAspects: someAspects pinAllScalesAtZero: false! !

!RVMMultiKiviatView class methodsFor: 'instance creation' stamp: 'ssa 10/7/2008 16:12'!
openOnAspects: someAspects pinAllScalesAtZero: aBoolean
	"RVMMultiKiviatView exampleBytesUsedTrioPinned"
	
	self openOnAspects: someAspects pinAllScalesAtZero: aBoolean useCommonScale: false! !

!RVMMultiKiviatView class methodsFor: 'instance creation' stamp: 'ssa 10/7/2008 16:09'!
openOnAspects: someAspects pinAllScalesAtZero: aBoolean useCommonScale: commonScale
	"RVMMultiKiviatView exampleBytesUsedTrioCommonPinned"
	| |
	self openOnAspects: someAspects pinAllScalesAtZero: aBoolean useCommonScale: commonScale titled: 'Multiaspect Kiviat'! !

!RVMMultiKiviatView class methodsFor: 'instance creation' stamp: 'ssa 10/7/2008 19:24'!
openOnAspects: someAspects pinAllScalesAtZero: aBoolean useCommonScale: commonScale titled: aString
	"RVMMultiKiviatView exampleBytesUsedTrioCommonPinned"
	
	| topView v label |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 300@250.
	topView maximumSize: 600@500.
	v := self new.
	v borderWidth:1.
	v aspects: someAspects.
	v commonScale: commonScale.
	v pinMinAtZero: aBoolean.
	topView addSubView: v.
	label _ aString,(aBoolean ifTrue:[' (pinned)']ifFalse:['']),(commonScale ifTrue:[' (uniscale)']ifFalse:['']).
	topView label: label.
	topView controller open! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 9/14/2008 20:50'!
aspects
	"Answer a list of message selectors that will return arrays of numbers for my monitor"
	
	^self class aspects! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:06'!
coreIndices

	^self groupStats coreIndices! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:33'!
cpuCoreStats
	"Answer the value of cpuCoreStats"

	^cpuCoreStats! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 8/13/2008 15:11'!
cpuCoreStats: anObject
	"Set the value of cpuCoreStats"

	cpuCoreStats := anObject! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 11/13/2008 09:42'!
extent
	"Answer the dimensions of my tile grid"
	^self groupStats extent! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 11/16/2008 15:03'!
fence
	"Answer the value of fence"

	fence isNil ifTrue:[self fence: nil].
	^ fence! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 11/16/2008 15:03'!
fence: anObject
	"Set the value of fence"

	fence _ anObject! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'dmu 8/15/2008 22:13'!
groupStats ^  groupStats! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'dmu 8/15/2008 22:14'!
groupStats: x    groupStats  _ x! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 8/13/2008 17:33'!
messageNames
	"Answer the value of messageNames"

	^messageNames! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 8/13/2008 15:11'!
messageNames: anObject
	"Set the value of messageNames"

	messageNames := anObject! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:07'!
numberOfCores

	^self groupStats isNil ifTrue:[56]ifFalse:[self groupStats groupSize]! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 7/16/2010 15:03'!
processInstanceCount
	"Answer the value of processInstanceCount"

	processInstanceCount isNil ifTrue:[self processInstanceCount: Process instanceCount].
	^ processInstanceCount! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 7/16/2010 15:02'!
processInstanceCount: anObject
	"Set the value of processInstanceCount"

	processInstanceCount _ anObject! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 8/13/2008 15:11'!
rawData
	"Answer the value of rawData"

	rawData isNil ifTrue:[self rawData: nil].
	^rawData! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'ssa 10/18/2008 18:03'!
rawData: anObject
	"Set the value of rawData"

	rawData := anObject! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:04'!
runMask
^ runMask! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:05'!
runMask: x
  runMask := x! !

!RVMMulticoreSample methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:20'!
totalYields
^ self cpuCoreStats yieldCounts sum! !

!RVMMulticoreSample methodsFor: 'initialize' stamp: 'ssa 8/13/2008 17:32'!
initializeAllCPUCoreStatsFrom: data
	
	self cpuCoreStats: (RVMAllCPUCoreStats newFrom: data forMessageNames: self messageNames)! !

!RVMMulticoreSample methodsFor: 'initialize' stamp: 'ssa 8/19/2008 10:50'!
initializeFastAllCPUCoreStatsFrom: data
	
	self cpuCoreStats: (RVMAllCPUCoreStats newFastFrom: data forMessageNames: self messageNames)! !

!RVMMulticoreSample methodsFor: 'initialize' stamp: 'ssa 7/16/2010 16:45'!
initializeFastFrom: data
	"This implementations assumes order dependency in the array for speed.
	
	Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.    Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	self rawData: data.
	self runMask: (data at: 2).
	self messageNames: (data at: 4).
	self initializeFastGroupStatsFrom: (data at: 6).
	self initializeFastAllCPUCoreStatsFrom: (data at: 8).
	self fence: (data at: 10).
	self processInstanceCount: Process instanceCount
! !

!RVMMulticoreSample methodsFor: 'initialize' stamp: 'ssa 3/25/2009 14:11'!
initializeFastGroupStatsFrom: data
	
	self groupStats: (RVMGroupStats new initializeFastFrom: data last)! !

!RVMMulticoreSample methodsFor: 'initialize' stamp: 'ssa 1/1/1970 00:04'!
initializeFastestAllCPUCoreStatsFrom: data
	
	self cpuCoreStats: (RVMAllCPUCoreStats newFastestFrom: data forMessageNames: self messageNames)! !

!RVMMulticoreSample methodsFor: 'initialize' stamp: 'dmu 5/21/2010 23:05'!
initializeFastestFrom: data
	"This implementations assumes order dependency in the array for speed.
	
	Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.    Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	self rawData: data.
	self runMask: (data at: 2).
	self messageNames: (data at: 4).
	self initializeFastestGroupStatsFrom: ((data at: 6 ) at: 2).
	self initializeFastestAllCPUCoreStatsFrom: (data at: 8).
	self fence: (data at: 10).
! !

!RVMMulticoreSample methodsFor: 'initialize' stamp: 'ssa 3/25/2009 19:17'!
initializeFastestGroupStatsFrom: data
	
	self groupStats: (RVMGroupStats new initializeFastFrom: data )! !

!RVMMulticoreSample methodsFor: 'initialize' stamp: 'ssa 7/16/2010 16:46'!
initializeFrom: data
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap objectMap |
	self rawData: data.
	valueMap := { }.
	objectMap := { 
				'runMask' -> #runMask:.
				'messageNames' -> #messageNames:.
				'allCPUCoreStats' -> #initializeAllCPUCoreStatsFrom:.
				'groupStats' -> #initializeGroupStatsFrom:.
				'fence' -> #fence:.
				}.
				
	self processMap: valueMap into: self forData: data.
	self processMap: objectMap into: self forData: data.
	self processInstanceCount: Process instanceCount
! !

!RVMMulticoreSample methodsFor: 'initialize' stamp: 'dmu 8/15/2008 22:11'!
initializeGroupStatsFrom: data
	
groupStats _ RVMGroupStats new initializeFrom: data! !

!RVMMulticoreSample methodsFor: 'initialize' stamp: 'ssa 8/13/2008 15:47'!
processMap: map into: targetObject forData: data
				
	| index datum |
	map do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		targetObject perform: assoc value with: datum].
! !

!RVMMulticoreSample methodsFor: 'printing' stamp: 'ssa 8/15/2008 16:28'!
printOn: aStream

	aStream 
		nextPutAll: 'anRVMMulticoreStats(';
		cr;tab;nextPutAll: ' bytecodesPerCycle=';nextPutAll: self bytecodesPerCycle printString;
		cr;tab;nextPutAll: ' bytecodesPerCyclesAverage=';nextPutAll: self bytecodesPerCyclesAverage printString;
		cr;tab;nextPutAll: ' bytecodesPerMillisecond=';nextPutAll: self bytecodesPerMillisecond printString;
		cr;tab;nextPutAll: ' bytecodesPerMillisecondsAverage=';nextPutAll: self bytecodesPerMillisecondsAverage printString;
		cr;tab;nextPutAll: ' bytecodeCountsAvg=';nextPutAll: self bytecodeCountsAverage printString;
		cr;tab;nextPutAll: ' bytecodePerSecondAvg=';nextPutAll: self bytecodesPerSecondAverage printString;
		cr;tab;nextPutAll: ' cyclesRunningsAvg=';nextPutAll: self cyclesRunningsAverage printString;
		cr;tab;nextPutAll: ' cyclesWaitingsAvg=';nextPutAll: self cyclesWaitingsAverage printString;
		cr;tab;nextPutAll: ' cyclesRunWaitRatiosAvg=';nextPutAll: self cyclesRunWaitRatiosAverage printString;
		cr;tab;nextPutAll: ' msRunningsAvg=';nextPutAll: self msRunningsAverage printString;
		cr;tab;nextPutAll: ' msWaitingsAvg=';nextPutAll: self msWaitingsAverage printString;
		cr;tab;nextPutAll: ' msRunWaitRatiosAvg=';nextPutAll: self msRunWaitRatiosAverage printString;
		cr;tab;nextPutAll: ' yieldCountsAvg=';nextPutAll: self yieldCountsAverage printString;
		cr;tab;nextPutAll: ' yieldsPerSecondAvg=';nextPutAll: self yieldsPerSecondAverage printString;
		cr;tab;nextPutAll: ')';cr
		! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:58'!
allocationsReadMostlys
	"RVMMulticoreSample capture allocationsReadMostlys"
	"Answer the collection of allocationsSinceLastReadMostlys"
	
	^self cpuCoreStats allocationsSinceLastReadMostlys! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:58'!
allocationsReadWrites
	"RVMMulticoreSample capture allocationsReadWrites"
	"Answer the collection of allocationsSinceLastReadWrites"
	
	^self cpuCoreStats allocationsSinceLastReadWrites! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:53'!
allocationsSinceLastReadMostlys
	"RVMMulticoreSample capture allocationsSinceLastReadMostlys"
	"Answer the collection of allocationsSinceLastReadMostlys"
	
	^self cpuCoreStats allocationsSinceLastReadMostlys! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:53'!
allocationsSinceLastReadWrites
	"RVMMulticoreSample capture allocationsSinceLastReadWrites"
	"Answer the collection of allocationsSinceLastReadWrites"
	
	^self cpuCoreStats allocationsSinceLastReadWrites! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 08:00'!
allocationsTotal
	"RVMMulticoreSample capture allocationsTotal"
	"Answer the collection of allocationsSinceLast"
	
	^self cpuCoreStats allocationsSinceLasts! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:40'!
bytecodeCounts
	"RVMMulticoreSample capture bytecodeCounts"
	"Answer the collection of bytecode counts during this sample"
	
	^self cpuCoreStats bytecodeCounts! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 17:14'!
bytecodeCountsAverage
	"RVMMulticoreSample capture bytecodeCountsAverage"
	"Answer the average of bytecode counts during this sample"
	
	^self cpuCoreStats bytecodeCounts average asFloat! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 9/17/2010 15:19'!
bytecodesPerCycle
	"RVMMulticoreSample capture bytecodesPerCycle"

	| avg |
	avg := self cyclesSinceLastsAverage.
	^avg = 0 
		ifTrue:[0] 
		ifFalse:[self bytecodeCounts sum / (1 max: self cyclesSinceLastsAverage) asFloat]! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:05'!
bytecodesPerCycles
	"RVMMulticoreSample capture bytecodesPerCycles"
	^self bytecodeCounts with: self cyclesRunnings 
		collect:[:bc :ms| ms = 0 ifTrue:[0] ifFalse:[bc/ms asFloat]]! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/15/2008 16:06'!
bytecodesPerCyclesAverage
	"RVMMulticoreSample capture bytecodesPerCyclesAverage"
	^self bytecodesPerCycles average! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:06'!
bytecodesPerKCs
^ self bytecodesPerCycles collect: [:x| x * 1000]! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:09'!
bytecodesPerMCs
^ self bytecodesPerCycles collect: [:x| x * 1000000]! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 9/17/2010 15:20'!
bytecodesPerMillisecond
	"RVMMulticoreSample capture bytecodesPerMillisecond"
	^self bytecodeCounts sum / (1 max: self msSinceLastsAverage) asFloat! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 9/17/2010 15:20'!
bytecodesPerMilliseconds
	"RVMMulticoreSample capture bytecodesPerMilliseconds"
	^self bytecodeCounts with: self msSinceLasts collect:[:bc :ms| bc/(1 max: ms) asFloat]! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/15/2008 15:35'!
bytecodesPerMillisecondsAverage
	"RVMMulticoreSample capture bytecodesPerMillisecondsAverage"
	^self bytecodesPerMilliseconds average! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:25'!
bytecodesPerSecond
	"RVMMulticoreSample capture bytecodesPerSecond"
	"Answer the collection of ratios of bytecodes executed per second during this sample"
	
	^self cpuCoreStats bytecodesPerSecond! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 17:14'!
bytecodesPerSecondAverage
	"RVMMulticoreSample capture bytecodesPerSecondAverage"
	"Answer the average of ratios of bytecodes executed per second during this sample"
	
	^self cpuCoreStats bytecodesPerSecond average asFloat! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:50'!
bytesLeftReadMostlys
	"RVMMulticoreSample capture bytesLeftReadMostlys"
	"Answer the collection of bytesLeftReadMostlys"
	
	^self cpuCoreStats bytesLeftReadMostlys! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:50'!
bytesLeftReadWrites
	"RVMMulticoreSample capture bytesLeftReadWrites"
	"Answer the collection of bytesLeftReadWrites"
	
	^self cpuCoreStats bytesLeftReadWrites! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:50'!
bytesLefts
	"RVMMulticoreSample capture bytesLefts"
	"Answer the collection of bytesLeft"
	
	^self cpuCoreStats bytesLefts! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:48'!
bytesUsedReadMostlys
	"RVMMulticoreSample capture bytesUsedReadMostlys"
	"Answer the collection of bytesUsedReadMostlys"
	
	^self cpuCoreStats bytesUsedReadMostlys! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:47'!
bytesUsedReadWrites
	"RVMMulticoreSample capture bytesUsedReadWrites"
	"Answer the collection of bytesUsedReadWrites"
	
	^self cpuCoreStats bytesUsedReadWrites! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:24'!
bytesUseds
	"RVMMulticoreSample capture bytesUseds"
	"Answer the collection of bytesUsed"
	
	^self cpuCoreStats bytesUseds! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:59'!
compactionsReadMostlys
	"RVMMulticoreSample capture compactionsSinceLastReadMostlys"
	"Answer the collection of compactionsSinceLastReadMostlys"
	
	^self cpuCoreStats compactionsSinceLastReadMostlys! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 07:59'!
compactionsReadWrites
	"RVMMulticoreSample capture compactionsReadWrites"
	"Answer the collection of compactionsSinceLastReadWrites"
	
	^self cpuCoreStats compactionsSinceLastReadWrites! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 10/4/2008 08:00'!
compactionsTotal
	"RVMMulticoreSample capture compactionsTotal"
	"Answer the collection of compactionsSinceLast"
	
	^self cpuCoreStats compactionsSinceLasts! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:06'!
contextChangeCounts
	"RVMMulticoreSample capture contextChangeCounts"
	"Answer the collection of yields during this sample"
	
	^self cpuCoreStats contextChangeCounts! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ads 1/30/2011 15:23'!
coreProcessUtilization

	^RVMOperations coreProcessUtilization asFloat! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:52'!
cyclesRunWaitRatios
	"RVMMulticoreSample capture cyclesRunWaitRatios"
	"Answer the collection of ratios during this sample"
	
	^self cpuCoreStats cyclesRunWaitRatios! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 17:14'!
cyclesRunWaitRatiosAverage
	"RVMMulticoreSample capture cyclesRunWaitRatiosAverage"
	"Answer the average of ratios during this sample"
	
	^self cpuCoreStats cyclesRunWaitRatios average asFloat! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:49'!
cyclesRunnings
	"RVMMulticoreSample capture cyclesRunnings"
	"Answer the collection of cyclesRunning counts during this sample"
	
	^self cpuCoreStats cyclesRunnings! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 17:14'!
cyclesRunningsAverage
	"RVMMulticoreSample capture cyclesRunningsAverage"
	"Answer the average of cyclesRunning counts during this sample"
	
	^self cpuCoreStats cyclesRunnings average asFloat! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/15/2008 16:30'!
cyclesSinceLasts
	"RVMMulticoreSample capture cyclesSinceLasts"
	"Answer the cyclesSinceLasts  during this sample"
	
	^self cpuCoreStats cyclesSinceLasts! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/15/2008 16:08'!
cyclesSinceLastsAverage
	"RVMMulticoreSample capture cyclesSinceLastsAverage"
	"Answer the average cyclesSinceLasts  during this sample"
	
	^self cpuCoreStats cyclesSinceLasts average! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:49'!
cyclesWaitings
	"RVMMulticoreSample capture cyclesWaitings"
	"Answer the collection of cyclesWaiting counts during this sample"
	
	^self cpuCoreStats cyclesWaitings! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 17:14'!
cyclesWaitingsAverage
	"RVMMulticoreSample capture cyclesWaitingsAverage"
	"Answer the average of cyclesWaiting counts during this sample"
	
	^self cpuCoreStats cyclesWaitings average asFloat! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/5/2011 12:55'!
gcMilliseconds
	"RVMMulticoreSample capture gcMilliseconds"
	^ self cpuCoreStats gcMilliseconds! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:08'!
interruptCheckCounts
	"RVMMulticoreSample capture yieldCounts"
	"Answer the collection of yields during this sample"
	
	^self cpuCoreStats interruptCheckCounts! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 8/17/2008 11:01'!
millisecondsRunnings
	"RVMMulticoreSample capture millisecondsRunnings"
	"Answer the collection of msRunning counts during this sample"
	
	^self cpuCoreStats millisecondsRunnings! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:41'!
millisecondsWaitings
	"RVMMulticoreSample capture millisecondsWaitings"
	"Answer the collection of millisecondsWaitings counts during this sample"
	
	^self cpuCoreStats millisecondsWaitings! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:44'!
msRunWaitRatios
	"RVMMulticoreSample capture msRunWaitRatios"
	"Answer the collection of ratios during this sample"
	
	^self cpuCoreStats msRunWaitRatios! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 17:15'!
msRunWaitRatiosAverage
	"RVMMulticoreSample capture msRunWaitRatiosAverage"
	"Answer the average of ratios during this sample"
	
	^self cpuCoreStats msRunWaitRatios average asFloat! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:29'!
msRunningsAverage
	"RVMMulticoreSample capture msRunningsAverage"
	"Answer the average of millisecondsRunning counts during this sample"
	
	^self cpuCoreStats millisecondsRunnings average asFloat! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/15/2008 15:30'!
msSinceLasts
	"RVMMulticoreSample capture msSinceLasts"
	"Answer the collection of msSinceLasts  during this sample"
	
	^self cpuCoreStats msSinceLasts! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/15/2008 15:30'!
msSinceLastsAverage
	"RVMMulticoreSample capture msSinceLastsAverage"
	"Answer the average msSinceLasts  during this sample"
	
	^self cpuCoreStats msSinceLasts average! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:43'!
msWaitingsAverage
	"RVMMulticoreSample capture msWaitingsAverage"
	"Answer the average of msWaiting counts during this sample"
	
	^self cpuCoreStats millisecondsWaitings average asFloat! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ads 1/30/2011 15:23'!
numberOfRunningProcesses

	^RVMOperations numberOfRunningProcesses ! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 7/16/2010 15:21'!
processCount
	^self processInstanceCount! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ads 1/30/2011 15:22'!
processCountsPerCore

 | bag counts |
bag _ (Process allInstances asOrderedCollection  collect:[:obj| RVMOperations isRVM ifFalse:[RVMMonitor coreCount atRandom - 1]ifTrue:[RVMOperations getCoreHolding:obj]]) asBag.
counts _ Array new: RVMMonitor coreCount.
1 to: RVMMonitor coreCount do:[:coreIndex| counts at: coreIndex put: (bag occurrencesOf: coreIndex)].
^counts
! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:20'!
receiveTallySum
^ self cpuCoreStats receiveTallySum! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ads 1/30/2011 15:23'!
runningProcessCountsPerCore


^RVMOperations runningProcessByCore  collect:[:obj| obj isNil ifTrue:[0]  ifFalse:[1]]! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 3/27/2009 17:04'!
sendTallySumsSortedReport
	"Answer a string report of the sorted send tallies across all cores"
	^self cpuCoreStats sendTallySumsSortedReport! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:08'!
unforcedInterruptCheckCounts
	"RVMMulticoreSample capture yieldCounts"
	"Answer the collection of yields during this sample"
	
	^self cpuCoreStats unforcedInterruptCheckCounts! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 17:17'!
yieldCounts
	"RVMMulticoreSample capture yieldCounts"
	"Answer the collection of yields during this sample"
	
	^self cpuCoreStats yieldCounts! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 17:18'!
yieldCountsAverage
	"RVMMulticoreSample capture yieldCountsAverage"
	"Answer the average of yields during this sample"
	
	^self cpuCoreStats yieldCounts average asFloat! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'dmu 1/1/1970 00:16'!
yieldFrequencies
	"RVMMulticoreSample capture yieldFrequencies"
	
	^self cpuCoreStats yieldFrequencies! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 16:36'!
yieldsPerSecond
	"RVMMulticoreSample capture yieldsPerSecond"
	"Answer the collection of ratios of yields  per second during this sample"
	
	^self cpuCoreStats yieldsPerSecond! !

!RVMMulticoreSample methodsFor: 'measuring' stamp: 'ssa 8/14/2008 17:15'!
yieldsPerSecondAverage
	"RVMMulticoreSample capture yieldsPerSecondAverage"
	"Answer the average of ratios of yields  per second during this sample"
	
	^self cpuCoreStats yieldsPerSecond average asFloat! !

!RVMMulticoreSample methodsFor: 'test measuring - system' stamp: 'ssa 10/3/2008 15:01'!
random1
	"RVMMulticoreSample new random1"
	"generated data for testing visualization"
	
	^1 atRandom! !

!RVMMulticoreSample methodsFor: 'test measuring - system' stamp: 'ssa 10/3/2008 15:01'!
random10
	"RVMMulticoreSample new random10"
	"generated data for testing visualization"
	
	^10 atRandom! !

!RVMMulticoreSample methodsFor: 'test measuring - system' stamp: 'ssa 10/3/2008 15:01'!
random100
	"RVMMulticoreSample new random100"
	"generated data for testing visualization"
	
	^100 atRandom! !

!RVMMulticoreSample methodsFor: 'test measuring - system' stamp: 'ssa 10/3/2008 15:00'!
random1000
	"RVMMulticoreSample new random1000"
	"generated data for testing visualization"
	
	^1000 atRandom! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 10/7/2008 17:28'!
test0001To1
	"RVMMulticoreSample new test0001To1"
	"generated data for testing visualization"
	
	| testData start end |
	testData _ OrderedCollection new.
	start _ 0.0001.
	end _ 1.0.
	start to: end by: end - start / self numberOfCores do:[:value|
		testData add: value].
	^testData copyFrom: 1 to: self numberOfCores! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 10/7/2008 17:28'!
test0to1
	"RVMMulticoreSample new test0to1"
	"generated data for testing visualization"
	
	| testData start end |
	testData _ OrderedCollection new.
	start _ 0.0.
	end _ 1.0.
	start to: end by: end - start / self numberOfCores do:[:value|
		testData add: value].
	^testData copyFrom: 1 to: self numberOfCores! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 10/7/2008 17:28'!
test0to10
	"RVMMulticoreSample new test0to10"
	"generated data for testing visualization"
	
	| testData start end |
	testData _ OrderedCollection new.
	start _ 0.0.
	end _ 10.0.
	start to: end by: end - start / self numberOfCores do:[:value|
		testData add: value].
	^testData copyFrom: 1 to: self numberOfCores! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 10/7/2008 17:32'!
test0to100
	"RVMMulticoreSample new test0to100"
	"generated data for testing visualization"
	
	| testData start end |
	testData _ OrderedCollection new.
	start _ 0.0.
	end _ 100.0.
	start to: end by: end - start / self numberOfCores do:[:value|
		testData add: value].
	^(testData copyFrom: 1 to: self numberOfCores) ! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 10/7/2008 17:27'!
test0to1B
	"RVMMulticoreSample new test0to1B"
	"generated data for testing visualization"
	
	| testData start end |
	testData _ OrderedCollection new.
	start _ 0.0.
	end _ 1000000000.0.
	start to: end by: end - start / self numberOfCores do:[:value|
		testData add: value].
	^testData copyFrom: 1 to: self numberOfCores! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 10/7/2008 17:28'!
test0to1K
	"RVMMulticoreSample new test0to1K"
	"generated data for testing visualization"
	
	| testData start end |
	testData _ OrderedCollection new.
	start _ 0.0.
	end _ 1000.0.
	start to: end by: end - start / self numberOfCores do:[:value|
		testData add: value].
	^testData copyFrom: 1 to: self numberOfCores! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 10/7/2008 17:28'!
test0to1M
	"RVMMulticoreSample new test0to1M"
	"generated data for testing visualization"
	
	| testData start end |
	testData _ OrderedCollection new.
	start _ 0.0.
	end _ 1000000.0.
	start to: end by: end - start / self numberOfCores do:[:value|
		testData add: value].
	^testData copyFrom: 1 to: self numberOfCores! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 10/7/2008 17:28'!
testNeg1To1
	"RVMMulticoreSample new testNeg1To1"
	"generated data for testing visualization"
	
	| testData start end |
	testData _ OrderedCollection new.
	start _ -1.0.
	end _ 1.0.
	start to: end by: end - start / self numberOfCores do:[:value|
		testData add: value].
	^testData copyFrom: 1 to: self numberOfCores! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 1/1/1970 00:07'!
testRandom1
	"RVMMulticoreSample new testRandom1"
	"generated data for testing visualization"
	
	| testData |
	testData _ OrderedCollection new.
	self numberOfCores timesRepeat:[
		testData add: 1 atRandom].
	^testData! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 1/1/1970 00:06'!
testRandom10
	"RVMMulticoreSample new testRandom10"
	"generated data for testing visualization"
	
	| testData |
	testData _ OrderedCollection new.
	self numberOfCores timesRepeat:[
		testData add: 10 atRandom].
	^testData! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 1/1/1970 00:06'!
testRandom100
	"RVMMulticoreSample new testRandom100"
	"generated data for testing visualization"
	
	| testData |
	testData _ OrderedCollection new.
	self numberOfCores timesRepeat:[
		testData add: 100 atRandom].
	^testData! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 1/1/1970 00:06'!
testRandom1000
	"RVMMulticoreSample new testRandom1000"
	"generated data for testing visualization"
	
	| testData |
	testData _ OrderedCollection new.
	self numberOfCores timesRepeat:[
		testData add: 1000 atRandom].
	^testData! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 1/1/1970 00:05'!
testRandom100s
	"RVMMulticoreSample new testRandom100s"
	"generated data for testing visualization"
	
	| testData min max delta |
	testData _ OrderedCollection new.
	min _ 100.
	max _ 999.
	delta _ max - min.
	self numberOfCores timesRepeat:[
		testData add: min + delta atRandom].
	^testData! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 1/1/1970 00:05'!
testRandom1Ks
	"RVMMulticoreSample new testRandom1Ks"
	"generated data for testing visualization"
	
	| testData min max delta |
	testData _ OrderedCollection new.
	min _ 1000.
	max _ 1999.
	delta _ max - min.
	self numberOfCores timesRepeat:[
		testData add: min + delta atRandom].
	^testData! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 1/1/1970 00:04'!
testRandomBs
	"RVMMulticoreSample new testRandomBs"
	"generated data for testing visualization"
	
	| testData min max delta |
	testData _ OrderedCollection new.
	min _ 1000000000.
	max _ 999000000000.
	delta _ max - min.
	self numberOfCores timesRepeat:[
		testData add: min + delta atRandom].
	^testData! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 1/1/1970 00:05'!
testRandomKs
	"RVMMulticoreSample new testRandomKs"
	"generated data for testing visualization"
	
	| testData min max delta |
	testData _ OrderedCollection new.
	min _ 1000.
	max _ 999000.
	delta _ max - min.
	self numberOfCores timesRepeat:[
		testData add: min + delta atRandom].
	^testData! !

!RVMMulticoreSample methodsFor: 'test measuring - core' stamp: 'ssa 1/1/1970 00:04'!
testRandomMs
	"RVMMulticoreSample new testRandomMs"
	"generated data for testing visualization"
	
	| testData min max delta |
	testData _ OrderedCollection new.
	min _ 1000000.
	max _ 999000000.
	delta _ max - min.
	self numberOfCores timesRepeat:[
		testData add: min + delta atRandom].
	^testData! !

!RVMMulticoreSample methodsFor: 'co vs inco' stamp: 'ads 2/2/2011 14:52'!
coinBytes
" RVMOperations moveAllToReadMostlyHeaps. RVMOperations printCoInBytesUsed. Smalltalk garbageCollect. RVMOperations printCoInBytesUsed. RVMMulticoreSample capture coinBytes"
	^self cpuCoreStats coreStats
		collect: [:stat | (stat memorySystemStats readWriteHeapStats bytesUsed @ stat memorySystemStats readMostlyHeapStats bytesUsed)]! !

!RVMMulticoreSample methodsFor: 'co vs inco' stamp: 'dmu 10/5/2008 00:26'!
coinBytesTotal
"Smalltalk garbageCollect. RVMMulticoreSample capture coinBytes"
	| s |
	s := 0 @ 0.
	self cpuCoreStats coreStats
		do: [:stat | s := s + (stat memorySystemStats readWriteHeapStats bytesUsed @ stat memorySystemStats readMostlyHeapStats bytesUsed)].
	^ s! !

!RVMMulticoreSample methodsFor: 'archiving' stamp: 'ssa 10/26/2008 21:12'!
archiveOn: aStream
	| rw |
	rw _ ReadWriteStream on:''.
	RVMSampleWriter archiveSample: RVMMonitor lastSample on: rw.
	
	aStream
		storeObject: self;
		storeClass: self class;
		store: rw reset.
	! !

!RVMMulticoreSample methodsFor: 'copying' stamp: 'ssa 10/26/2008 21:08'!
deepCopy
	"Use the RVMSampleWriter/Reader"
	| rw |
	rw _ ReadWriteStream on:''.
	RVMSampleWriter archiveSample: self on: rw.
	RVMSampleReader dearchiveSampleFrom: rw reset ! !

!RVMMulticoreSample commentStamp: 'ssa 8/19/2008 11:52' prior: 0!
two ways to capture a sample:
	RVMMulticoreSample captureSlow - uses a flexible but slower approach to handle data pairs
	            "            captureFast - fast, order dependent version (6x faster)
	            "            capture - calls captureFast

"performance test"
results := OrderedCollection new.
100 timesRepeat:[results add: (Time millisecondsToRun:[1000 timesRepeat:[RVMMulticoreSample captureFast]])/1000.0].
results average 

captureFast = 0.13813 
captureSlow = 0.80164

MessageTally spyOn:[1000 timesRepeat:[RVMMulticoreSample captureFast]]
shows a 6x improvement over captureSlow!
!RVMMulticoreSample class methodsFor: 'examples' stamp: 'ssa 8/13/2008 15:13'!
example
	"RVMMulticoreSample example"
	self capture explore! !

!RVMMulticoreSample class methodsFor: 'examples' stamp: 'ssa 9/9/2008 19:50'!
examplePrimitive
	"RVMMulticoreSample examplePrimitive"
	self primitiveCapture inspect! !

!RVMMulticoreSample class methodsFor: 'archiving' stamp: 'ssa 11/16/2008 15:07'!
archiveVersion
	^2! !

!RVMMulticoreSample class methodsFor: 'archiving' stamp: 'ssa 11/16/2008 15:10'!
dearchive: versionNumber from: aStream
	versionNumber = self archiveVersion ifTrue:[^self dearchiveFrom: aStream].	
	self error:'Can''t handle this archive version'! !

!RVMMulticoreSample class methodsFor: 'archiving' stamp: 'ssa 10/26/2008 22:07'!
dearchiveFrom: aStream

	| rwStream sample |
	rwStream _ aStream next.
	sample _ RVMSampleReader dearchiveSampleFrom: rwStream reset.
	aStream storeObject: sample.
	^sample! !

!RVMMulticoreSample class methodsFor: 'instance creation' stamp: 'ssa 8/19/2008 11:48'!
capture
	"Capture a sample from the vm and answer a new instance of me holding those values"
	"RVMMulticoreSample capture"
	
	^self captureFast! !

!RVMMulticoreSample class methodsFor: 'instance creation' stamp: 'ssa 8/19/2008 11:34'!
captureFast
	"Capture a sample from the vm and answer a new instance of me holding those values"
	"RVMMulticoreSample captureFast"
	| data sample |
	data := self primitiveCapture.
	sample := self new.
	sample initializeFastFrom: data.
	^sample! !

!RVMMulticoreSample class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:03'!
captureFastest
	"Capture a sample from the vm and answer a new instance of me holding those values"
	"RVMMulticoreSample captureFastest"
	| data sample |
	data := self primitiveCapture.
	sample := self new.
	sample initializeFastestFrom: data.
	^sample! !

!RVMMulticoreSample class methodsFor: 'instance creation' stamp: 'ssa 8/19/2008 11:48'!
captureSlow
	"Capture a sample from the vm and answer a new instance of me holding those values"
	"RVMMulticoreSample captureSlow"
	| data sample |
	data := self primitiveCapture.
	sample := self new.
	sample initializeFrom: data.
	^sample! !

!RVMMulticoreSample class methodsFor: 'instance creation' stamp: 'ssa 10/26/2008 20:26'!
newFrom: rawData
	"Answer a new instance of me holding these values"
	"RVMMulticoreSample newFrom: self primitiveCapture"
	|  sample |
	sample := self new.
	sample initializeFastFrom: rawData.
	^sample! !

!RVMMulticoreSample class methodsFor: 'primitive access' stamp: 'ssa 10/18/2008 21:42'!
primitiveCapture
	"Grab some data from the VM and return it"
	<primitive: 'primitiveSampleRVM' module: 'RVMPlugin'>
	[^RVMMonitor samples next]value.
	self primitiveFailed! !

!RVMMulticoreSample class methodsFor: 'primitive access' stamp: 'dmu 4/10/2009 17:39'!
primitiveCapture: flags
	"Grab some data from the VM and return it"
	<primitive: 'primitiveSampleRVM' module: 'RVMPlugin'>
	self primitiveFailed! !

!RVMMulticoreSample class methodsFor: 'primitive access' stamp: 'dmu 4/10/2009 17:39'!
primitiveCaptureOneCore
	"self primitiveCaptureOneCore"
	^ self primitiveCapture: RVMSampleFlags everything - RVMSampleFlags allCores! !

!RVMMulticoreSample class methodsFor: 'primitive access' stamp: 'ssa 11/12/2008 12:23'!
primitiveFlush
	"Clear out the sample buffer in the vm by grabbing a sample"
	<primitive: 'primitiveSampleRVM' module: 'RVMPlugin'>
	! !

!RVMMulticoreSample class methodsFor: 'sample access' stamp: 'ssa 11/12/2008 12:23'!
flush

	self primitiveFlush! !

!RVMMulticoreSample class methodsFor: 'sample access' stamp: 'ssa 1/1/1970 00:32'!
next

	^self capture! !

!RVMMulticoreSample class methodsFor: 'aspect access' stamp: 'ssa 10/3/2008 22:54'!
aspectFromUserUnder: aSymbol
	"Answer a selected aspect categorized under #system, #core, #testSystem, #testCore."
		| menu |
	menu := CustomMenu new.
	(self aspectsUnder: aSymbol)
		do: [:aspect | menu add: aspect action: aspect].
	^menu startUp:nil withCaption: 'Select the aspect to monitor'.
! !

!RVMMulticoreSample class methodsFor: 'aspect access' stamp: 'ssa 10/3/2008 15:10'!
aspects
	"Answer a list of message selectors that will return arrays of numbers for my monitor"
	^(RVMMulticoreSample allMethodsInCategory: #measuring),
	(RVMMonitor showTestAspects ifTrue:[self testAspects]ifFalse:[#()])! !

!RVMMulticoreSample class methodsFor: 'aspect access' stamp: 'ssa 10/3/2008 22:51'!
aspectsUnder: aSymbol
	"Answer the aspects categorized under #system, #core, #testSystem, #testCore."
	aSymbol == #system ifTrue:[^self systemAspects].
	aSymbol == #core ifTrue:[^self coreAspects].
	aSymbol == #testSystem ifTrue:[^self testSystemAspects].
	aSymbol == #testCore ifTrue:[^self testCoreAspects].
	^self aspects! !

!RVMMulticoreSample class methodsFor: 'aspect access' stamp: 'dmu 4/2/2009 02:09'!
coreAspects
	"Answer a list of message selectors that will return collections of core numbers for my monitor"
	
	^#(#allocationsReadWrites #allocationsReadMostlys #allocationsTotal #bytecodeCounts #bytecodesPerCycles #bytecodesPerKCs #bytecodesPerMCs #bytecodesPerMilliseconds #bytecodesPerSecond #bytesLeftReadWrites #bytesLeftReadMostlys #bytesLefts #bytesUsedReadWrites #bytesUsedReadMostlys #bytesUseds #compactionsReadWrites #compactionsReadMostlys #compactionsTotal #contextChangeCounts #cyclesRunWaitRatios #cyclesRunnings #cyclesSinceLasts #cyclesWaitings #interruptCheckCounts #millisecondsRunnings #millisecondsWaitings #msRunWaitRatios #msSinceLasts  #unforcedInterruptCheckCounts #yieldCounts #yieldFrequencies #yieldsPerSecond #processCountsPerCore #runningProcessCountsPerCore)! !

!RVMMulticoreSample class methodsFor: 'aspect access' stamp: 'ssa 3/26/2009 10:18'!
coreTallyAspects
	"Answer a list of message selectors that will return tallies from core message tallies"
	
	^RVMCoreMessageTally tallyOrder! !

!RVMMulticoreSample class methodsFor: 'aspect access' stamp: 'ssa 7/16/2010 15:21'!
systemAspects
	"Answer a list of message selectors that will return single system numbers for my monitor"
	
	^#(#numberOfRunningProcesses #processCount #coreProcessUtilization #bytecodeCountsAverage #bytecodesPerCycle #bytecodesPerCyclesAverage #bytecodesPerMillisecond #bytecodesPerMillisecondsAverage #bytecodesPerSecondAverage #cyclesRunWaitRatiosAverage #cyclesRunningsAverage #cyclesSinceLastsAverage #cyclesWaitingsAverage #msRunWaitRatiosAverage #msRunningsAverage #msSinceLastsAverage #msWaitingsAverage #yieldCountsAverage #yieldsPerSecondAverage )! !

!RVMMulticoreSample class methodsFor: 'aspect access' stamp: 'ssa 10/3/2008 15:14'!
testAspects
	"Answer a list of message selectors that will return arrays of test numbers for my monitor"
	
	^self testCoreAspects, self testSystemAspects! !

!RVMMulticoreSample class methodsFor: 'aspect access' stamp: 'ssa 10/3/2008 15:14'!
testCoreAspects
	"Answer a list of message selectors that will return arrays of test numbers for my monitor"
	
	^RVMMulticoreSample allMethodsInCategory: 'test measuring - core' asSymbol! !

!RVMMulticoreSample class methodsFor: 'aspect access' stamp: 'ssa 10/3/2008 15:14'!
testSystemAspects
	"Answer a list of message selectors that will return arrays of test numbers for my monitor"
	
	^RVMMulticoreSample allMethodsInCategory: 'test measuring - system' asSymbol! !

!RVMMulticoreSample class methodsFor: 'aspect access' stamp: 'ssa 10/6/2008 18:46'!
updateSystemAndCoreAspectMethods
	"RVMMulticoreSample updateSystemAndCoreAspectMethods"
	"Determine the lists of single value system aspects and multivalue core aspects and update the access methods for them"
	| all singles groups code sample |
	all _ RVMMulticoreSample allMethodsInCategory: #measuring.
	singles _ OrderedCollection new.
	groups _ OrderedCollection new.
	sample _ RVMMulticoreSample capture.
	all do:[:msg| ((sample perform: msg) isKindOf:Number)ifTrue:[singles add: msg]ifFalse:[groups add: msg]].
	groups remove:#receiveTallySum ifAbsent:[].
	code _ 'coreAspects
	"Answer a list of message selectors that will return collections of core numbers for my monitor"
	
	^', groups asArray storeString.
	self class compile: code classified:'aspect access' notifying:nil.
	code _ 'systemAspects
	"Answer a list of message selectors that will return single system numbers for my monitor"
	
	^', singles asArray storeString.
	self class compile: code classified:'aspect access' notifying:nil.
	
! !

!RVMObjectCoordinate methodsFor: 'accessing' stamp: 'ads 1/30/2011 15:23'!
activity
	"Answer the value of activity, whether or not you want the baton passed on a message send"

	^RVMOperations getPassTheBatonOf: self object! !

!RVMObjectCoordinate methodsFor: 'accessing' stamp: 'ssa 11/16/2008 02:11'!
coreCoordinate
	"Answer the value of coreCoordinate"

	^(self coreIndex + 1 asPointWithinRectangleWithExtent: RVMMonitor extent) ! !

!RVMObjectCoordinate methodsFor: 'accessing' stamp: 'ads 1/30/2011 15:23'!
coreIndex
	"Answer the value of coreIndex"

	^(RVMOperations getCoreHolding: self object)! !

!RVMObjectCoordinate methodsFor: 'accessing' stamp: 'ads 1/30/2011 15:23'!
mutability
	"Answer the value of mutability, whether you are readWrite (true) or readMostly (false)"

	^RVMOperations getReadWriteOf: self object! !

!RVMObjectCoordinate methodsFor: 'accessing' stamp: 'ssa 11/13/2008 10:29'!
object
	"Answer the value of object"

	object isNil ifTrue:[self object: nil].
	^ object! !

!RVMObjectCoordinate methodsFor: 'accessing' stamp: 'ssa 11/13/2008 10:29'!
object: anObject
	"Set the value of object"

	object _ anObject! !

!RVMObjectCoordinate methodsFor: 'moving' stamp: 'ads 1/30/2011 15:23'!
makeActive
RVMOperations isRVM ifTrue:[
	RVMOperations setCoordinatesOf: self object toCore: self coreIndex  readWrite:  self mutability].
	self changed! !

!RVMObjectCoordinate methodsFor: 'moving' stamp: 'ads 1/30/2011 15:23'!
makePassive

RVMOperations isRVM ifTrue:[
	RVMOperations setCoordinatesOf: self object toCore: self coreIndex readWrite: self mutability ].
	self changed! !

!RVMObjectCoordinate methodsFor: 'moving' stamp: 'ads 1/30/2011 15:23'!
makeReadMostly
RVMOperations isRVM ifTrue:[
	RVMOperations setCoordinatesOf: self object toCore: self coreIndex readWrite: false ].
	self changed! !

!RVMObjectCoordinate methodsFor: 'moving' stamp: 'ads 1/30/2011 15:23'!
makeReadWrite
RVMOperations isRVM ifTrue:[
	RVMOperations setCoordinatesOf: self object toCore: self coreIndex readWrite: true].
	self changed! !

!RVMObjectCoordinate methodsFor: 'moving' stamp: 'ssa 11/16/2008 02:23'!
moveToCoordinate: aPoint

	self moveToCore:  (aPoint y -1 * RVMMonitor extent x + aPoint x) -1 .
	self changed:#coreCoordinate! !

!RVMObjectCoordinate methodsFor: 'moving' stamp: 'ads 1/30/2011 15:23'!
moveToCore: anIndex

RVMOperations isRVM ifTrue:[
	RVMOperations setCoordinatesOf: self object toCore: (anIndex max:0) readWrite: self mutability ].
	self changed! !

!RVMObjectCoordinate methodsFor: 'testing' stamp: 'ssa 11/13/2008 10:26'!
isActive

	^self activity = true! !

!RVMObjectCoordinate methodsFor: 'testing' stamp: 'ssa 11/13/2008 10:26'!
isPassive

	^self activity = false! !

!RVMObjectCoordinate methodsFor: 'testing' stamp: 'ssa 11/13/2008 10:26'!
isReadMostly

	^self mutability = false! !

!RVMObjectCoordinate methodsFor: 'testing' stamp: 'ssa 11/13/2008 10:25'!
isReadWrite

	^self mutability = true! !

!RVMObjectCoordinate class methodsFor: 'instance creation' stamp: 'ssa 11/16/2008 01:27'!
for: anObject
	"Answer the coordinate for this object"
	| coord |
	coord _ self new.
	coord object: anObject.
	^coord! !

!RVMObjectCoordinateView methodsFor: 'listening' stamp: 'ssa 11/15/2008 23:43'!
hear: something

	self displayView! !

!RVMObjectCoordinateView methodsFor: 'listening' stamp: 'ssa 11/15/2008 23:44'!
update

	self displayView! !

!RVMObjectCoordinateView class methodsFor: 'instance creation' stamp: 'ssa 5/12/2010 10:15'!
on: anRVMObjectCoordinate  
	"RVMObjectCoordinateView openOn: nil asObjectCoordinate  "
	| mutabilityView readWriteButton readMostlyButton activityView passButton holdButton coreIndexView coordView tileCoordView |
	
	mutabilityView _ RVMView new.
	readWriteButton _ RVMRadioButtonView on: anRVMObjectCoordinate label: 'readWrite' checkState: #isReadWrite whenChecked: #makeReadWrite whenUnchecked: [] monitor: true.
	readMostlyButton _ RVMRadioButtonView on: anRVMObjectCoordinate label: 'readMostly' checkState: #isReadMostly whenChecked: #makeReadMostly whenUnchecked: [] monitor: true.
	mutabilityView addSubView: readWriteButton in:(0@0 extent: 1@0.5) borderWidth:0.
	mutabilityView addSubView: readMostlyButton in:(0@0.5 extent: 1@0.5) borderWidth:0.

	activityView _ RVMView new..
	passButton _ RVMRadioButtonView on: anRVMObjectCoordinate label: 'pass baton' checkState: #isActive whenChecked: #makeActive whenUnchecked: [] monitor: true.
	holdButton _ RVMRadioButtonView on: anRVMObjectCoordinate label: 'keep baton' checkState: #isPassive whenChecked: #makePassive whenUnchecked: [] monitor: true.
	activityView addSubView: passButton in:(0@0 extent: 1@0.5) borderWidth:0.
	activityView addSubView: holdButton  in:(0@0.5 extent: 1@0.5) borderWidth:0.
	
	tileCoordView _ RVMGridLocationView on: anRVMObjectCoordinate pointGetter: #coreCoordinate pointSetter: #moveToCoordinate: extentGetter: [RVMMonitor extent].

	coreIndexView _ RVMCoreIndexView on: anRVMObjectCoordinate
		getCoreIndex:#coreIndex
		setCoreIndex: #moveToCore:
		getAvailableIndicies: [RVMMonitor coreCount].
		
	coordView _ self new.
	coordView addSubView: mutabilityView in:(0@0 extent: 1/3@1) borderWidth:1.
	coordView addSubView: activityView in:((1/3)@0 extent: 1/3@1) borderWidth:1.
	coordView addSubView: tileCoordView in:((2/3)@0 extent: 1/6@1) borderWidth:1.
	coordView addSubView: coreIndexView in:((5/6)@0 extent: 1/6@1) borderWidth:1.
	^coordView
! !

!RVMObjectCoordinateView class methodsFor: 'instance creation' stamp: 'ssa 11/15/2008 15:52'!
openOn: anRVMObjectCoordinate
	"RVMObjectCoordinateView openOn: nil asObjectCoordinate"
	"Add me to a system view and open me on the desktop"
	| topView  |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 300@50.
	topView addSubView: (self on: anRVMObjectCoordinate) .
	topView label: 'Locating: ',anRVMObjectCoordinate object printString.
	topView controller open! !

!RVMObjectTableStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:20'!
allocatedEntryCount
	"Answer the number of allocated entries in this object table"
	allocatedEntryCount isNil ifTrue:[^0].
	^allocatedEntryCount! !

!RVMObjectTableStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:20'!
allocatedEntryCount: count
	"Set the number of allocated entries in this object table"
	allocatedEntryCount := count! !

!RVMObjectTableStats methodsFor: 'acessing' stamp: 'dmu 8/15/2008 21:43'!
allocationsSinceLastQuery
	"Answer the allocations made since the last query"
	allocationsSinceLastQuery isNil ifTrue:[^0].
	^allocationsSinceLastQuery! !

!RVMObjectTableStats methodsFor: 'acessing' stamp: 'dmu 8/15/2008 21:44'!
allocationsSinceLastQuery: count
	"Set the allocations made since the last query"
	allocationsSinceLastQuery := count! !

!RVMObjectTableStats methodsFor: 'acessing' stamp: 'dmu 8/15/2008 21:45'!
entriesFreedSinceLastQuery
	"Answer the allocations freed since the last query"
	entriesFreedSinceLastQuery isNil ifTrue:[^0].
	^entriesFreedSinceLastQuery! !

!RVMObjectTableStats methodsFor: 'acessing' stamp: 'dmu 8/15/2008 21:46'!
entriesFreedSinceLastQuery: count
	"Set the allocations freed since the last query"
	entriesFreedSinceLastQuery := count! !

!RVMObjectTableStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:19'!
entryCount
	"Answer the number of entries in this object table"
	entryCount isNil ifTrue:[^0].
	^entryCount! !

!RVMObjectTableStats methodsFor: 'acessing' stamp: 'ssa 7/21/2008 10:19'!
entryCount: count
	"Set the number of entries in this object table"
	entryCount := count! !

!RVMOperations commentStamp: 'ads 1/24/2011 13:43' prior: 0!
This was the original parking lot for various VM testing methods!
!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:52'!
allObjectsInHeap: rank isReadWrite: isC
"RVMOperations allObjectsInHeap: 34 isReadWrite: true"
<primitive: 'primitiveAllObjectsInHeap' module: 'RVMPlugin'>
self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'RS 7/25/2011 17:18'!
awakeInterpreters
	<primitive: 'primitiveAwakeOtherInterpreters' module: 'RVMPlugin'>
	^false! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
coreCount
  "RVMOperations coreCount"
  <primitive: 'primitiveCoreCount' module: 'RVMPlugin'>
  ^ 1! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
coreProcessUtilization
	"RVMOperations coreProcessUtilization"
	"How many processes are running on my cores versus how many core??"
	^self numberOfRunningProcesses / RVMMonitor coreCount! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
cycleCounter
	"RVMOperations cycleCounter"
	  <primitive: 'primitiveCycleCounter' module: 'RVMPlugin' >
 	 ^ -1! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
enableMultithreading: aBool
"RVMOperations enableMultithreading: true"
<primitive:'primitiveEnableMultithreading' module: 'RVMPlugin'>
self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 1/1/1970 00:01'!
extraRemoteContextAllocations: n
<primitive: 'primitiveExtraRemoteContextAllocations' module: 'RVMPlugin'>
^ self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 1/1/1970 00:01'!
extraYields: n
<primitive: 'primitiveExtraYields' module: 'RVMPlugin'>
^ self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
getCore
  "RVMOperations getCore"
  <primitive: 'primitiveGetCore' module: 'RVMPlugin' >
  ^ -1! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
getCoreIAmRunningOn
  "RVMOperations getCoreIAmRunningOn"
  <primitive: 'primitiveGetCoreIAmRunningOn' module: 'RVMPlugin' >
  ^ -1! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 1/1/1970 00:05'!
getCoreTrace
<primitive: 'primitiveTraceCores' module: 'RVMPlugin'>
^ self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 1/1/1970 00:03'!
getMutatedReplicatedObjectsTrace
<primitive: 'primitiveTraceMutatedReplicatedObjects' module: 'RVMPlugin'>
^ self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ssa 1/1/1970 00:11'!
getPassTheBatonOf: anObject
<primitive: 'primitiveGetPassTheBaton' module: 'RVMPlugin'>
^ true! !

!RVMOperations class methodsFor: 'primitives' stamp: 'sm 5/26/2011 14:22'!
isHeadless
	<primitive: 'primitiveRunsHeadless' module: 'RVMPlugin'>
	
	"The default is set to false to avoid problems if the primitive is not their in normal mode.
	 Made this choice since most smalltalkers are not console users anyway. Stefan 2011-05-25"
	^ false
! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 4/3/2009 03:40'!
move: anObject toCore: anInt
<primitive: 'primitiveSetCoordinatesFor' module: 'RVMPlugin'>
self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 4/3/2009 03:40'!
move: anObject toCore: anInteger readWritely: readWriteBoolean passTheBaton: batonBoolean
<primitive: 'primitiveSetCoordinatesFor' module: 'RVMPlugin'>
self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
moveAllToReadMostlyHeaps
"RVMOperations moveAllToReadMostlyHeaps"
<primitive: 'primitiveMoveAllToReadMostlyHeaps' module: 'RVMPlugin'>
^ self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ssa 7/16/2010 14:59'!
numberOfProcessInstances

	^Process instanceCount! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ssa 4/1/2009 21:56'!
numberOfRunningProcesses

	^self runningProcesses size! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
primitiveRunningProcessByCore
	"Answers an array of numberOfCores size with a nil or Process instance for each core.  If a Process instance then that process was running on that core when invoked"
	"RVMOperations primitiveRunningProcessByCore"
<primitive: 'primitiveRunningProcessByCore' module: 'RVMPlugin'>
^ self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
print: aString
"RVMOperations print: 'hello'"
<primitive: 'primitivePrint' > "omit module just as in thisProcess method to hit obsolete_named-primitive_table and be local"! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
printAllHeapsBytesUsed
"RVMOperations printAllHeapsBytesUsed"
<primitive: 'primitivePrintReadWriteReadMostlyBytesUsed' module: 'RVMPlugin'>
! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
printExecutionTrace
"RVMOperations printExecutionTrace"
" [ [ [ RVMOperations printExecutionTrace ] value ] value ] value"
<primitive: 'primitivePrintExecutionTrace' module: 'RVMPlugin'>
^ self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 10/1/2010 19:59'!
printObjectForVMDebugging: obj
	"self printObjectForVMDebugging: 3@4"
	<primitive: 'primitivePrintObjectForVMDebugging' module: 'RVMPlugin'>! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
printStack
"RVMOperations printStack"
<primitive: 'primitivePrintStack' module: 'RVMPlugin'>
^ self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'sm 2/24/2011 15:51'!
printVMStatistics
	<primitive: 'primitivePrintStats' module: 'RVMPlugin'>! !

!RVMOperations class methodsFor: 'primitives' stamp: 'sm 5/26/2011 11:10'!
resetPerfCounters
	"RVMPrimitives resetPerfCounters"
	<primitive: 'primitiveResetPerfCounters' module: 'RVMPlugin'>! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 1/1/1970 00:02'!
runMask: aMask 
<primitive: 'primitiveRunMask' module: 'RVMPlugin'>! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
runOnAll
"RVMOperations runOnAll"
self runOnlyOn: -1! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 1/1/1970 00:03'!
runOnOne: aBool
self runMask: ( aBool ifTrue: [1] ifFalse: [0] )! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:53'!
runOnlyOn: anInt
"RVMOperations runOnlyOn: 0"
<primitive:'primitiveRunOnlyOn' module: 'RVMPlugin'>
self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ssa 4/1/2009 21:47'!
runningProcessByCore
	"Answers an array of numberOfCores size with a nil or Process instance for each core.  If a Process instance then that process was running on that core when invoked"
^self primitiveRunningProcessByCore! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ssa 4/1/2009 21:48'!
runningProcesses
	"Answers an array of Process instances that were running when invoked"
^self runningProcessByCore select:[:each| each notNil]! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:54'!
setCoordinatesOf: anObject toCore: anInt readWrite: aBool
"RVMOperations setCoordinatesOf: 3@4 toCore: 17 readWrite: false "
<primitive: 'primitiveSetCoordinatesFor' module: 'RVMPlugin'>
self primitiveFailed
! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:54'!
setCoordinatesOf: anObject toCore: anInt readWrite: aBool passTheBaton: anotherBool
"RVMOperations setCoordinatesOf: 3@4 toCore: 17 readWrite: false passTheBaton: false"
<primitive: 'primitiveSetCoordinatesFor' module: 'RVMPlugin'>
self primitiveFailed
! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 1/1/1970 00:00'!
setCoreTraceSize: n
<primitive: 'primitiveTraceCores' module: 'RVMPlugin'>! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 1/1/1970 00:06'!
setMutatedReplicatedObjectsTraceSize: n
<primitive: 'primitiveTraceMutatedReplicatedObjects' module: 'RVMPlugin'>
^ self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 1/1/1970 00:40'!
shuffle: numCores
^ self shuffleFrom: 0 to: numCores - 1! !

!RVMOperations class methodsFor: 'primitives' stamp: 'dmu 1/1/1970 00:39'!
shuffleFrom: first to: last
<primitive: 'primitiveShuffle' module: 'RVMPlugin'>
^ self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:54'!
shuffleFrom: first to: last  moveRWtoRM: bool1 moveRMtoRW: bool2
"RVMOperations shuffleFrom: 1 to: 17 moveRWtoRM: false moveRMtoRW: true"
<primitive: 'primitiveShuffle' module: 'RVMPlugin'>
^ self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:54'!
soleRunningCore
"RVMOperations soleRunningCore"
<primitive:'primitiveRunOnlyOn' module: 'RVMPlugin'>
self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'ads 2/2/2011 14:54'!
spreadFrom: first to: last  moveRWtoRM: bool1 moveRMtoRW: bool2
"RVMOperations spreadFrom: 1 to: 17 moveRWtoRM: true moveRMtoRW: false"
<primitive: 'primitiveSpread' module: 'RVMPlugin'>
^ self primitiveFailed! !

!RVMOperations class methodsFor: 'primitives' stamp: 'RS 7/25/2011 17:17'!
suspendButMainInterpreter
	<primitive: 'primitiveSuspendOtherInterpreters' module: 'RVMPlugin'>
	^false! !

!RVMOperations class methodsFor: 'testing' stamp: 'ads 2/2/2011 14:52'!
changingSuperclassTest
	"RVMOperations changingSuperclassTest"
	"Create a class, then change its superclass and  verify"
	Transcript cr;show:'Starting changing superclass test......'.
	#(Foo Bar Baz)do:[:n| Smalltalk removeClassNamed: n].
	Object subclass: #Foo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'RVM-Testing'.
	Object subclass: #Bar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'RVM-Testing'.
	(Smalltalk classNamed:#Foo) subclass: #Baz
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'RVM-Testing'.
	Transcript cr;show:'Foo, Bar and Baz test classes created, Baz is subclass of Foo, ready to try to change superclass to Bar'.
	(Smalltalk classNamed:#Bar) subclass: #Baz
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'RVM-Testing'.
	(Smalltalk classNamed:#Baz) superclass == (Smalltalk classNamed:#Bar)
		ifTrue:[Transcript cr;show:'Successful....test passed']
		ifFalse:[Transcript cr;show:'Nope....test failed'].
	Transcript cr;show:'Cleaning up....'.
	#(Foo Bar Baz)do:[:n| Smalltalk removeClassNamed: n].
	Transcript cr;show:'...End of changing superclass test'.

! !

!RVMOperations class methodsFor: 'testing' stamp: 'dmu 1/11/2011 12:32'!
cyclesToRun: blk
	| x |
	x _ self cycleCounter.
	blk value.
	^ self cycleCounter - x ! !

!RVMOperations class methodsFor: 'testing' stamp: 'ads 2/2/2011 14:53'!
delayTest
"RVMOperations delayTest"
	| rect delay |
	rect _ 0@0 extent: 40@40.
	delay _ Delay forSeconds: 1.
	[Sensor leftShiftDown not] whileTrue:[Display reverse: rect. delay wait]
! !

!RVMOperations class methodsFor: 'testing' stamp: 'ads 2/2/2011 14:53'!
methodDeletionTest
	"RVMOperations methodDeletionTest"
	"Create a test class and add 32 methods to it, then try to add 33"
	
	| testClassName testClass |
	testClassName := #RVMTESTforMethodDeletion.
	(Smalltalk includesKey: testClassName) ifTrue:[(Smalltalk at: testClassName) removeFromSystem].
	
	Object subclass: testClassName
		instanceVariableNames: ''
		classVariableNames: ''
		poolDictionaries: ''
		category: 'RVM-Testing'.
	
	testClass := Smalltalk at: testClassName.
	Transcript cr;cr;show:'Test class created: ',testClassName.
	Transcript cr;show:'Method dictionary size = ',testClass selectors size printString.

	Transcript cr;show:'Adding 5 methods'.
	1 to: 5 do:[:count|
		testClass compile: 'testMethod',count printString].
	Transcript cr;show:'Method dictionary size = ',testClass selectors size printString.

	Transcript cr;show:'Removing 5 methods'.
	1 to: 5 do:[:count|
		testClass removeSelector: ('testMethod',count printString) asSymbol].
	Transcript cr;show:'Method dictionary size = ',testClass selectors size printString.
	testClass selectors notEmpty ifTrue:[Transcript cr;show:'Test Failed']ifFalse:[Transcript cr;show:'test passed'].

	Transcript cr;show:'Removing test class: ',testClassName.
	testClass removeFromSystem.
	Transcript cr;show:'test class removed.... test over'.
! !

!RVMOperations class methodsFor: 'testing' stamp: 'ads 2/2/2011 14:53'!
methodDictionaryGrowthTest
	"RVMOperations methodDictionaryGrowthTest"
	"Create a test class and add 32 methods to it, then try to add 33"
	
	| testClassName testClass |
	testClassName := #RVMTESTforMethodDictionaryGrowth.
	(Smalltalk includesKey: testClassName) ifTrue:[(Smalltalk at: testClassName) removeFromSystem].
	
	Object subclass: testClassName
		instanceVariableNames: ''
		classVariableNames: ''
		poolDictionaries: ''
		category: 'RVM-Testing'.
	
	testClass := Smalltalk at: testClassName.
	Transcript cr;cr;show:'Test class created: ',testClassName.
	Transcript cr;show:'Method dictionary size = ',testClass selectors size printString.

	Transcript cr;show:'Adding 32 methods'.
	1 to: 32 do:[:count|
		testClass compile: 'testMethod',count printString].
	Transcript cr;show:'Method dictionary size = ',testClass selectors size printString.

	Transcript cr;show:'Adding 33rd method'.
		testClass compile: 'testMethod33'.
	Transcript cr;show:'Method dictionary size = ',testClass selectors size printString.

	Transcript cr;show:'Removing test class: ',testClassName.
	testClass removeFromSystem.
	Transcript cr;show:'test class removed.... test over'.
! !

!RVMOperations class methodsFor: 'testing' stamp: 'ads 2/2/2011 14:53'!
runParallelCompilerBenchmarks: n
"RVMOperations runParallelCompilerBenchmarks: 4"
n timesRepeat: [[Benchmark new testCompiler. Transcript show: 'done'; cr] copy fixTemps fork]! !

!RVMOperations class methodsFor: 'testing' stamp: 'ads 2/2/2011 14:53'!
segmentationFaultTest
	"RVMOperations segmentationFaultTest"
	"Executing this code produces a segmenation fault"
	| all singles groups file |
	Transcript cr;show:'test starting... segmentation fault test... writing to segfaultLog.txt'.
file _ FileStream newFileNamed:'segfaultLog.txt'.
all _ #(bytecodeCounts bytecodeCountsAverage bytecodesPerCycle bytecodesPerCycles bytecodesPerCyclesAverage bytecodesPerKCs bytecodesPerMCs bytecodesPerMillisecond bytecodesPerMilliseconds bytecodesPerMillisecondsAverage bytecodesPerSecond bytecodesPerSecondAverage bytesUseds contextChangeCounts cyclesRunWaitRatios cyclesRunWaitRatiosAverage cyclesRunnings cyclesRunningsAverage cyclesSinceLasts cyclesSinceLastsAverage cyclesWaitings cyclesWaitingsAverage interruptCheckCounts millisecondsRunnings millisecondsWaitings msRunWaitRatios msRunWaitRatiosAverage msRunningsAverage msSinceLasts msSinceLastsAverage msWaitingsAverage receiveTallySum unforcedInterruptCheckCounts yieldCounts yieldCountsAverage yieldFrequencies yieldsPerSecond yieldsPerSecondAverage).
singles _ OrderedCollection new.
groups _ OrderedCollection new.
all do:[:msg| file nextPutAll:'Attempting ',msg,'
	'.
	file flush.
	((RVMMonitor lastSample perform: msg) isKindOf:Number)ifTrue:[singles add: msg]ifFalse:[groups add: msg]].
file close.
	Transcript cr;show:'test passed.... test over'.
! !

!RVMOperations class methodsFor: 'testing' stamp: 'dmu 5/4/2009 23:51'!
testAtRandom
	"self testAtRandom"
	| r n t |
	r _ Random new.
	n _ 0.
	100000 timesRepeat: [
		t _ 396 atRandom: r.
		n _ n + 1.
		t isInteger ifFalse: [self error: 'not int'].
		t < 0 ifTrue: [self error: 'neg' ].
		t > 400 ifTrue: [self error: 'too big'].
	]! !

!RVMOperations class methodsFor: 'testing' stamp: 'dmu 5/5/2009 00:24'!
testNextInt
	"self testAtRandom"
	| r n t |
	r _ Random new.
	n _ 0.
	100000 timesRepeat: [
		t _ r nextInt: 396.
		n _ n + 1.
		t isInteger ifFalse: [self error: 'not int'].
		t < 0 ifTrue: [self error: 'neg' ].
		t > 400 ifTrue: [self error: 'too big'].
	]! !

!RVMOperations class methodsFor: 'demos' stamp: 'ads 2/2/2011 14:52'!
colorTrail
	"RVMOperations colorTrail"
| rect boxes centers count colors pen x y coreIndex |
rect _ Rectangle fromUser.
boxes _ rect subDivideBy: 8@8.
centers _ boxes collect:[:box| box center].
count _ 500.
colors _ Color hotColdShades:count.
pen _ Pen new.
pen defaultNib:6.
pen combinationRule: Form paint.
pen place: (centers at:32).
x _ y _ 4.
pen down.
1 to:count do:[:index|pen color: (colors at: index).
	x _ (x + (3 atRandom - 2))min:8 max:1.
	y _ (y + (3 atRandom - 2))min:8 max:1.
	coreIndex _ y - 1 * 8 + x.
	pen goto: (centers at:(coreIndex))]! !

!RVMOperations class methodsFor: 'demos' stamp: 'ads 1/30/2011 15:21'!
displayImageOnReadMostlyStripChart
	"RVMOperations displayImageOnReadMostlyStripChart"
	"Works on readMostlyHeap tile strip chart"
| f text images height width pixelOn |
f _ Form fromDisplay:(0@0 extent: 200@200)..

text _ 'IBM' asDisplayText asParagraph asForm magnifyBy:2.
"logo _ GIFReadWriter formFromFileNamed: 'ibm-logo-bw.gif'.
logo replaceColor: Color white with: Color transparent.
face _ GIFReadWriter formFromFileNamed: 'sam-photo-bw.gif'.
face replaceColor: Color white with: Color transparent."
images _ OrderedCollection new.
"images add: logo.
images add: face."
images add: text.
images do:[:image|
height _ image boundingBox height.
width _ image boundingBox width.
0 to: width -1 do:[:x|
	0 to: height - 1 do:[:y|
		pixelOn _ (image colorAt: x@y) isTransparent.
		RVMOperations move: f copy toCore: y + 3 readWritely: pixelOn passTheBaton: true.
			].
		RVMOperations move: f toCore: 1 readWritely: true passTheBaton: true..
		RVMMonitor getSample;informListeners.
				Smalltalk garbageCollect.
]]
! !

!RVMOperations class methodsFor: 'demos' stamp: 'ads 2/2/2011 14:54'!
spockToursTheRenaissance
	"RVMOperations spockToursTheRenaissance"
	'Spock' rwPass24 rmHold2 rmPass40 rwHold0 rwPass55
! !

!RVMOperations class methodsFor: 'filing out ' stamp: 'ads 2/2/2011 14:53'!
fileOutAllRVMCategories
	"RVMOperations fileOutAllRVMCategories"
	| cats classNames classes orderedClasses fileStream |
	cats := SystemOrganization categoriesMatching: 'RVM-*'.
	classNames := OrderedCollection new.
	cats
		do: [:cat | classNames
				addAll: (SystemOrganization listAtCategoryNamed: cat)].
	classes := classNames
				collect: [:n | Smalltalk at: n].
	orderedClasses := ChangeSet superclassOrder: classes.
	fileStream := FileStream fileNamed: 'all-RVM-categories ' , Time now print24 , ' '
					, (Date today printFormat: #(2 1 3 $- 1 2 2 )) , '.st'.
	orderedClasses
		do: [:cls | cls fileOutOn: fileStream].
	fileStream close! !

!RVMOperations class methodsFor: 'teleportation' stamp: 'ssa 11/4/2008 23:39'!
isMulticoreCoordinate: stringOrSymbol
	"Answer true if my unary selector matched the special multicore object coordinate format.
	{rm,rw}{Pass,Hold}{coreIndex, 0-55}"
	
	 | readWrite baton coreIndex aSymbol |
	aSymbol _ stringOrSymbol asSymbol.
	aSymbol isUnary ifFalse:[^false].
	aSymbol size >= 7 ifFalse:[^false].
	readWrite _ aSymbol first: 2.
	(#('rw' 'rm') includes: readWrite) ifFalse:[^false].
	baton _ aSymbol copyFrom: 3 to: 6.
	(#('Pass' 'Hold') includes: baton) ifFalse:[^false].
	coreIndex _ aSymbol allButFirst:6.
	(coreIndex isAllDigits and:[(coreIndex _ coreIndex asNumber) between: 0 and: 55]) ifFalse:[^false].
	^true
	! !

!RVMOperations class methodsFor: 'teleportation' stamp: 'ssa 11/16/2008 01:00'!
teleport: anObject to: aSymbol
	"move this object to this multicore object coordinate.
	aSymbol := {in,co}{Pass,Hold}{coreIndex, 1-56}"
	
	 | readWrite baton coreIndex old new |
	(self isMulticoreCoordinate: aSymbol) ifFalse:[self error:'Teleport aborted; bad coordinates = ',aSymbol].
	readWrite _ (aSymbol first: 2) = 'rw'.
	baton _ (aSymbol copyFrom: 3 to: 6) = 'Pass'.
	coreIndex _ (aSymbol allButFirst:6) asNumber - 1 max: 0.
	old _ self printPrefixFor: anObject.
	self move: anObject toCore: coreIndex readWritely: readWrite passTheBaton: baton.
	Sensor leftShiftDown ifTrue:[new _ self printPrefixFor: anObject.
	Transcript cr;show:'Zzzoingggg!!  ',anObject printString,' vanished from ',old.
	Transcript cr;show:'Ggggniozzz!!  ',anObject printString,' appeared at ',new].
	
	! !

!RVMOperations class methodsFor: 'testing for RVM' stamp: 'ads 2/2/2011 14:53'!
positiveIfOnRVM
  "RVMOperations positiveIfOnRVM"
  <primitive: 'primitiveCoreCount' module: 'RVMPlugin'>
  ^ -1! !

!RVMOperations class methodsFor: 'debugging' stamp: 'sm 5/27/2011 13:27'!
breakpoint
	<primitive: 'primitiveBreakpoint' module: 'RVMPlugin' >! !

!RVMOperations class methodsFor: 'debugging' stamp: 'ads 1/30/2011 15:21'!
randomWalk
"RVMOperations randomWalk"
[
[Sensor leftShiftDown not] whileTrue: [
	Delay forMilliseconds: 250.
	RVMOperations move: false toCore: ( 0 max: (55 min: ( self getCoreHolding: false)   + 3 atRandom - 2)) ].
Transcript show: 'killed'; cr
] fork.
! !

!RVMPluggableTextView methodsFor: 'model access' stamp: 'ssa 11/27/2008 13:06'!
getText 
	"Answer the list to be displayed."
	| txt |
	getTextSelector == nil ifTrue: [^ Text new].
	txt _ getTextSelector isSymbol ifTrue:[model perform: getTextSelector]ifFalse:[getTextSelector value].
	txt == nil ifTrue: [^ Text new].
	self hasUnacceptedEdits: false.	"clean now"
	^ txt! !

!RVMPluggableTextView methodsFor: 'model access' stamp: 'ssa 11/27/2008 13:08'!
setText: textToAccept from: ctlr
	"Inform the model of text to be accepted, and return true if OK.
	Any errors should be reported to the controller, ctlr."
	setTextSelector == nil ifTrue: [^ true].
	setTextSelector isSymbol
		ifTrue: [^ model perform: setTextSelector with: textToAccept]
		ifFalse: [^ setTextSelector value: textToAccept]! !

!RVMPluggableTextView methodsFor: 'updating' stamp: 'ssa 11/27/2008 13:47'!
update: aSymbol
	"Refer to the comment in View|update:. Do nothing if the given symbol does not match any action. "

	aSymbol == #updateDisplay ifTrue: [^ self updateDisplayContents].
	^super update: aSymbol! !

!RVMPrimitivesNeededForBootstrapping class methodsFor: 'as yet unclassified' stamp: 'ads 1/24/2011 12:47'!
getCoreHolding: anObject
	^(self primitivGetCoreHolding: anObject)! !

!RVMPrimitivesNeededForBootstrapping class methodsFor: 'as yet unclassified' stamp: 'ads 1/24/2011 12:57'!
getEmergencySemaphore
	"When you hit shift-control-a, the VM will signal the emergency semaphore, if it has been set to a semaphore"
	"self getEmergencySemaphore signal"
	<primitive: 'primitiveEmergencySemaphore' module: 'RVMPlugin'>! !

!RVMPrimitivesNeededForBootstrapping class methodsFor: 'as yet unclassified' stamp: 'ads 1/24/2011 12:55'!
getReadWriteOf: anObject
<primitive: 'primitiveGetMutability' module: 'RVMPlugin'>
^ true! !

!RVMPrimitivesNeededForBootstrapping class methodsFor: 'as yet unclassified' stamp: 'ads 2/2/2011 14:54'!
isRVM
	"RVMPrimitivesNeededForBootstrapping isRVM"
	"Am I actually running on the Tilera64?"
	^(self getCoreHolding: nil) ~= -1! !

!RVMPrimitivesNeededForBootstrapping class methodsFor: 'as yet unclassified' stamp: 'ads 1/24/2011 12:47'!
primitivGetCoreHolding: anObject
<primitive: 'primitiveGetCore' module: 'RVMPlugin'>
^ -1! !

!RVMPrimitivesNeededForBootstrapping class methodsFor: 'as yet unclassified' stamp: 'ads 2/2/2011 14:54'!
printPrefixFor: anObject
	"RVMPrimitivesNeededForBootstrapping printPrefixFor: Array "
	"Answer a string to use as a prefix in Inspectors and Debuggers when printing an object"
	| index readWrite |
	(anObject isKindOf: SmallInteger) ifTrue:[^''].
	(anObject isKindOf: Boolean) ifTrue:[^''].
	(anObject isNil) ifTrue:[^''].
	index _ (self getCoreHolding: anObject) printString.
	readWrite _ (self getReadWriteOf: anObject) ifTrue: ['rw'] ifFalse: ['rm'].
	
	
	^'<',readWrite,index,'> '! !

!RVMPrimitivesNeededForBootstrapping class methodsFor: 'as yet unclassified' stamp: 'ads 1/24/2011 12:57'!
setEmergencySemaphore: aSemaOrNil
	"When you hit shift-control-a, the VM will signal the emergency semaphore, if it has been set to a semaphore"
	<primitive: 'primitiveEmergencySemaphore' module: 'RVMPlugin'>! !

!RVMProcessSwarm methodsFor: 'creation' stamp: 'dmu 2/22/2009 07:14'!
initialize: aBlock
	| p |
	processes _ OrderedCollection new.
	0 to: 55 do: [:i | 
		p _ aBlock copy fixTemps newProcess.
		p coreMask: (1 bitShift: i).
		p resume.
	].! !

!RVMProcessSwarm methodsFor: 'creation' stamp: 'ssa 2/26/2009 04:36'!
initialize: aBlock  onCores: aCollectionOfIndicies
	| p |
	aCollectionOfIndicies size timesRepeat:[
		p _ aBlock copy fixTemps newProcess.
		p useOnlyCores: aCollectionOfIndicies.
		p resume.
	].! !

!RVMProcessSwarm commentStamp: 'ads 2/2/2011 14:56' prior: 0!
RVMProcessSwarm newRunning: [1000 timesRepeat:[10 factorial]].

56 timesRepeat:[1000 timesRepeat:[10 factorial]]

(Time millisecondsToRun:[1000 timesRepeat:[10 factorial]])/1000.0 ====> 1.5ms per 10 factorial
(Time millisecondsToRun:[1000 timesRepeat:[10 factorial]]) ====> 1587ms per job
(Time millisecondsToRun:[10 timesRepeat:[56 timesRepeat:[1000 timesRepeat:[10 factorial]]]])/10.0 
 87902.1
85059.2
91263

proc _ [RVMOperations print: ((Time millisecondsToRun:[10 timesRepeat:[56 timesRepeat:[1000 timesRepeat:[10 factorial]]]])/10.0) printString] copy fixTemps newProcess.
proc coreMask: (1 bitShift: 4).
proc resume.




Process allInstances collect:[:proc| proc coreMask]    
Process instanceCount
Process allInstances do:[:proc| proc coreMask:(1 bitShift:27)]   
[:x | x _ 10. [x] value] value: 2




Array locate.
coord _ Array asObjectCoordinate.
delay _ Delay forMilliseconds: 500.
0 to: 55 do:[:coreIndex|delay wait. coord moveToCore: coreIndex]

Benchmark new testCompiler

Process allInstancesDo:[:each| each coreMask: nil].

RVMOperations runOnlyOn: 8.
RVMOperations runOnAll

count _ 0.
[[true] whileTrue:[0 to: 55 do: [:i | Processor thisProcess coreMask: (1 bitShift: i).
	Processor  yield.
	10 factorial.
	RVMOperations print: '[',count printString,'] finished on core ',Processor thisProcess hostCore printString].
count _ count +1]]fork

Process allInstances collect:[:e| e coreMask]


RVMOperations moveAllToReadMostlyHeaps

  "RVMProcessSwarm newRunning: [3000 factorial] onCores:(1 to: 10)"
  "RVMProcessSwarm newRunning: [RVMOperations print: Processor thisProcess hostCore factorial printString] onCores:#(1 3 5 7)"
  "RVMProcessSwarm newRunning: [3000 factorial.  RVMOperations print: Processor thisProcess hostCore  printString,' done'] onCores:(1 to: 10),(40 to:50) "!
!RVMProcessSwarm class methodsFor: 'instance creation' stamp: 'ads 2/2/2011 14:55'!
newRunning: aBlock
  "RVMProcessSwarm newRunning: [3000 factorial]"
  "RVMProcessSwarm newRunning: [RVMOperations print: Processor thisProcess hostCore factorial printString]"
	super new initialize: aBlock! !

!RVMProcessSwarm class methodsFor: 'instance creation' stamp: 'ads 2/2/2011 14:56'!
newRunning: aBlock onCores: aCollectionOfIndicies
  "RVMProcessSwarm newRunning: [3000 factorial] onCores:(1 to: 10)"
  "RVMProcessSwarm newRunning: [RVMOperations print: Processor thisProcess hostCore factorial printString] onCores:#(1 3 5 7)"
  "RVMProcessSwarm newRunning: [3000 factorial.  RVMOperations print: Processor thisProcess hostCore  printString,' done'] onCores:(1 to: 10),(40 to:50) "
	super new initialize: aBlock onCores: aCollectionOfIndicies! !

!RVMRadioButtonView methodsFor: 'displaying' stamp: 'ssa 11/16/2008 00:19'!
buildCheckedBoxForm 
	"Answer the check(ed) circle "
	
	| box aForm aCircle dot |
	box _ Form extent:18@18 depth: Display depth.
	aForm _ Form extent: 2@2.
	aForm fillBlack.
	aCircle _ Circle new.
	aCircle form: aForm.
	aCircle radius: 9.
	aCircle center: 8@8.
	aCircle displayOn: box.
	dot _ Form dotOfSize: 10.
	dot displayOn: box at: box boundingBox center clippingBox: box boundingBox  rule: Form paint fillColor:nil.
		
	^box! !

!RVMRadioButtonView methodsFor: 'displaying' stamp: 'ssa 11/16/2008 00:19'!
buildUncheckedBoxForm  
	"Answer the uncheck(ed) circle "
	
	| box aForm aCircle |
	box _ Form extent:18@18 depth: Display depth.
	aForm _ Form extent: 2@2.
	aForm fillBlack.
	aCircle _ Circle new.
	aCircle form: aForm.
	aCircle radius: 9.
	aCircle center: 8@8.
	aCircle displayOn: box.
	^box! !

!RVMRadioButtonView methodsFor: 'action' stamp: 'ssa 11/16/2008 01:26'!
performAction
	"I've been clicked, switch state and act"
	| others |
	self checked: true.
	self performCheckAction.
	others _ self superView subViewsSatisfying: [:each| each ~~ self and:[each class == self class]].
	others  do:[:each| 
		each checked: false.
		each performUncheckAction.
		each displayView].
	self displayView
! !

!RVMRadioButtonView class methodsFor: 'examples' stamp: 'ssa 10/18/2008 23:34'!
example
	"RVMRadioButtonView example"
	
	super example! !

!RVMRadioButtonView class methodsFor: 'examples' stamp: 'ssa 5/12/2010 10:15'!
exampleRecording
	"RVMRadioButtonView exampleRecording"
	| topView   offRadio loopRadio subViewCount longRadio fileRadio |
	topView := RVMStandardSystemView new  .
	topView borderWidth:1. 
	RVMRadioButtonView testState:#(true false false false false).
	offRadio _ RVMRadioButtonView on: self label: 'off' checkState: [RVMMonitor recordingMode = #off] whenChecked: [RVMMonitor recordingMode: #off] whenUnchecked: [] monitor: true.
	loopRadio _ RVMRadioButtonView on: self label: 'record last ',RVMMonitor sampleLimit printString,' samples' checkState: [RVMMonitor recordingMode = #loop] whenChecked: [RVMMonitor recordingMode: #loop] whenUnchecked: [] monitor: true.
	longRadio _ RVMRadioButtonView on: self label: 'record all samples' checkState: [RVMMonitor recordingMode = #long] whenChecked: [RVMMonitor recordingMode: #long] whenUnchecked: [] monitor: true.
	fileRadio _ RVMRadioButtonView on: self label: 'record all samples to a file' checkState: [RVMMonitor recordingMode = #file] whenChecked: [RVMMonitor recordingMode: #file] whenUnchecked: [] monitor: true.
	
	topView addSubView: offRadio.
	topView addSubView:  loopRadio below:  offRadio.
	topView addSubView:  longRadio below:  loopRadio.
	topView addSubView:  fileRadio below:  longRadio.
	topView label: 'Recording Options'.
	subViewCount _ topView subViews size.
	topView minimumSize: 100@(subViewCount*28).
	topView maximumSize: 200@topView minimumSize y.
	topView controller open! !

!RVMReadersWriterLock methodsFor: 'private' stamp: 'dmu 11/13/2010 17:41'!
finishedReading
	self isRunningWritingProcess ifTrue: [^ self].
	readerCountInterlock critical: [
		readerCount > 1  ifTrue: [readerCount _ readerCount - 1] ifFalse: [
	        readerCount = 1 ifFalse: [self error: 'oops'] ifTrue: [
			readerCount _ 0.
			 readVsWriteInterlock signal
		]].
	]! !

!RVMReadersWriterLock methodsFor: 'private' stamp: 'dmu 11/13/2010 16:29'!
finishedWriting
	writingProcess _ nil.
	readVsWriteInterlock signal! !

!RVMReadersWriterLock methodsFor: 'private' stamp: 'dmu 11/13/2010 16:28'!
initialize
	readerCount _ 0.
	readerCountInterlock _ Semaphore forMutualExclusion.
	readVsWriteInterlock _ Semaphore forMutualExclusion.
	writingProcess _ nil! !

!RVMReadersWriterLock methodsFor: 'private' stamp: 'dmu 11/13/2010 16:33'!
isRunningWritingProcess
	^ Processor thisProcess == writingProcess! !

!RVMReadersWriterLock methodsFor: 'private' stamp: 'dmu 11/13/2010 17:42'!
startingToRead
	self isRunningWritingProcess  ifTrue: [^ self].
	readerCountInterlock critical: [
		readerCount > 0  ifTrue: [readerCount _ readerCount + 1] ifFalse: [
	        readerCount = 0 ifFalse: [self error: 'oops'] ifTrue: [
			readVsWriteInterlock wait.
			readerCount _ 1.
		]].
	]! !

!RVMReadersWriterLock methodsFor: 'private' stamp: 'dmu 6/13/2011 23:53'!
startingToWrite
	writingProcess == Processor thisProcess ifTrue: [self error: 'recursive write'].
	readVsWriteInterlock wait.
	writingProcess _ Processor thisProcess! !

!RVMReadersWriterLock methodsFor: 'public' stamp: 'dmu 11/12/2010 17:31'!
guardForReading: blockWhichReads
	self startingToRead.
	^ blockWhichReads ensure: [self finishedReading]! !

!RVMReadersWriterLock methodsFor: 'public' stamp: 'dmu 11/12/2010 17:31'!
guardForWriting: blockWhichWrites
	self startingToWrite.
	^ blockWhichWrites ensure: [self finishedWriting]! !

!RVMReadersWriterLock commentStamp: 'dmu 11/12/2010 17:26' prior: 0!
I provide synchronization for multiple readers or one writer.
I am not very clever.

readerCount: how many readers are currently reading
readerCountInterlock: protects readerCount
readVsWriteInterlock: ensures that reading & writing do not happen at the same time, also ensures only one writer at a time

Usage:

x _ RVMReadersWriterLock new.

x guardForReading: [ "read the data" ].
x guardForWriting: [ "write the data" ].!
!RVMReadersWriterLock class methodsFor: 'as yet unclassified' stamp: 'dmu 11/12/2010 18:08'!
crudeTest
	| x g p |
	"RVMReadersWriterLock  crudeTest"
	"Flashes dots in upper row when reading, flashes dots in lower row when writing."
	x _ RVMReadersWriterLock new.
	g _ 0@0.
	1 to: 10 do: [:i| 
		[	[g x = 0] whileTrue.
			p _  (100@100) + ( (5*i) @ 0).
			100 timesRepeat: [
				x guardForReading: [
					(Delay forMilliseconds: 10) wait.
					Display drawDot5At: p.
					(Delay forMilliseconds: 10) wait.
					Display eraseDot5At: p.
				]
			]
		] copy fixTemps fork.
	].
	1 to: 4 do: [:i| 
		[     [g x = 0] whileTrue.
			p _  (100@110) + ( (5*i) @ 0).
			100 timesRepeat: [
				x guardForWriting: [
					(Delay forMilliseconds: 10) wait.
					Display drawDot5At: p.
					(Delay forMilliseconds: 10) wait.
					Display eraseDot5At: p.
				]
			]
		] copy fixTemps fork.
	].
	g x: 1! !

!RVMSBinarySampleWriter commentStamp: 'ssa 10/26/2008 23:51' prior: 0!
A test to see if a completely flattened binary stream write method would be faster than the archiver.

Not so!!
this takes 4-6 seconds and generates a 600K file for a 56 core sample

Archiver takes 0.7 sec and generates a 40K file!
!RVMSBinarySampleWriter class methodsFor: 'sample writing' stamp: 'ssa 10/26/2008 23:48'!
writeSample: aSample on: aStream
	"RVMSBinarySampleWriter writeSample: RVMMonitor lastSample on: (FileStream newFileNamed:'binary-sample-writer.test')"
	"Write the minimum data in aSample to aStream in binary format"
	| data subData innerCoreStats allSendTallies tallies rcvTallies memoryStats readWriteHeap readMostlyHeap interpStats objTableStats |
	data _ aSample rawData.
	aStream binary;
		nextNumber: 8 put:  (data at: 2);  "runMask"
		nextPut:  ((data at: 4)) ;  "extraYields"
		nextPut:  ((data at: 6)).  "extraRemoteContextAllocations"
		"remember messageNames"
		subData _ data at: 10. "groupStats"
	aStream
		nextPut:  ((subData at: 2));  "mainX"
		nextPut:  ((subData at: 4));  "mainY"
		nextPut:  ((subData at: 6));  "mainRank"
		nextPut:  ((subData at: 8));  "width"
		nextPut:  ((subData at: 10));  "height"
		nextPut:  ((subData at: 12));  "groupSize"
		nextPut:  ((subData at: 14)).  "remaining"
	subData _ data at: 12. "allCPUCoreStats"
	subData do:[:each|
		aStream
			nextInt32Put:  (each at: 2);  "millisecs"
			nextInt32Put:  (each at: 4).  "cycles"
		innerCoreStats _ each at: 6.
		aStream
			nextPut:  ((innerCoreStats at: 2));  "x"
			nextPut:  ((innerCoreStats at: 4));  "y"
			nextPut:  ((innerCoreStats at: 6)).  "rank"
		allSendTallies _ innerCoreStats at: 8. "sendTalliesByCore"
		allSendTallies do:[:sndTally|
			tallies _ allSendTallies at: 2.
			tallies do:[:tally|
			aStream
				nextWordPut: tally].  "a single send tally"
			].
		rcvTallies _ innerCoreStats at: 10.
		rcvTallies do:[:tally|
			aStream
				nextWordPut: tally].  "a single recieve tally"
	memoryStats _ each at: 8. "memorySystemStats"
	aStream
		nextWordPut: (memoryStats at: 2);  "gcCount"
		nextInt32Put:  (memoryStats at: 4);  "gcMilliseconds"
		nextInt32Put:  (memoryStats at: 6).  "gcCycles"
	readWriteHeap _ memoryStats at: 8.  "readWriteHeapStats"
	aStream
		nextInt32Put:  (readWriteHeap at: 2);  "bytesUsed()"
		nextInt32Put:  (readWriteHeap at: 4);  "bytesLeft()"
		nextInt32Put:  (readWriteHeap at: 6);  "allocationsSinceLastQuery"
		nextInt32Put:  (readWriteHeap at: 8).  "compactionsSinceLastQuery"
	readMostlyHeap _ memoryStats at: 10.  "readMostlyHeapStats"
	aStream
		nextInt32Put:  (readMostlyHeap at: 2);  "bytesUsed()"
		nextInt32Put:  (readMostlyHeap at: 4);  "bytesLeft()"
		nextInt32Put:  (readMostlyHeap at: 6);  "allocationsSinceLastQuery"
		nextInt32Put:  (readMostlyHeap at: 8).  "compactionsSinceLastQuery"
	interpStats _ each at: 10. "interpreterStats"
	aStream
		nextInt32Put:  (interpStats at: 2);  "bytecodesExecuted"
		nextInt32Put:  (interpStats at: 4);  "yieldCount"
		nextNumber: 6 put:  (interpStats at: 6);  "cyclesRunning"
		nextNumber: 6 put:  (interpStats at: 8);  "cyclesWaiting"
		nextInt32Put:  (interpStats at: 10);  "contextChangeCount"
		nextInt32Put:  (interpStats at: 12);  "interruptCheckCount"
		nextInt32Put:  (interpStats at: 14);  "unforcedInterruptCheckCount"
		nextInt32Put:  (interpStats at: 16);  "numberOfMovedMutatedReadMostlyObjects"
		nextNumber: 6 put:  (interpStats at: 18).  "cyclesMovingMutatedReadMostlyObjects"
	].
	objTableStats _ data at: 14.   "objectTableStats"
	aStream
		nextInt32Put:  (objTableStats at: 2);  "allocatedEntryCount"
		nextInt32Put:  (objTableStats at: 4);  "entryCount"
		nextInt32Put:  (objTableStats at: 6);  "allocationsSinceLastQuery"
		nextInt32Put:  (objTableStats at: 8).  "entriesFreedSinceLastQuery"
	aStream
		nextPut:  ((data at: 16));  "extraRunPrimitives"
		nextPut:  ((data at: 18));  "extraDoublewordBroadcasts"
		nextPut:  ((data at: 20));  "extraWordBroadcasts"
		nextPut:  (((data at: 22) ifTrue:[1]ifFalse:[0]));  "dontPassTheBatonDefault"
		nextPut:  (((data at: 24) ifTrue:[1]ifFalse:[0])).  "fence"
! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 09:38'!
cyclesSinceLastSample
	"Answer the number of processor cycles since the last sample was taken"
	cyclesSinceLastSample isNil ifTrue:[^0].
	^cyclesSinceLastSample! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 10:05'!
cyclesSinceLastSample: count
	"Set the number of processor cycles since the last sample was taken"
	cyclesSinceLastSample := count! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 11:29'!
globalHeapStats
	"Answer the global heap stats for this sample"
	globalHeapStats isNil ifTrue:[self globalHeapStats: RVMGlobalHeapStats new].
	^globalHeapStats! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 09:40'!
globalHeapStats: anRVMGlobalHeapStats
	"Set the global heap stats for this sample"
	globalHeapStats := anRVMGlobalHeapStats! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 11:29'!
localHeapStats
	"Answer the local heap stats for this sample"
	localHeapStats isNil ifTrue:[self localHeapStats: RVMLocalHeapStats new].
	^localHeapStats! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 10:13'!
localHeapStats: anRVMLocalHeapStats
	"Set the local heap stats for this sample"
	localHeapStats := anRVMLocalHeapStats! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 09:38'!
millisecondsSinceLastSample
	"Answer the time since the last sample was taken"
	millisecondsSinceLastSample isNil ifTrue:[^0].
	^millisecondsSinceLastSample! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 09:37'!
millisecondsSinceLastSample: milliseconds
	"Set the time since the last sample was taken"
	millisecondsSinceLastSample := milliseconds! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 11:29'!
objectTableStats
	"Answer the object stats for this sample"
	objectTableStats isNil ifTrue:[self objectTableStats: RVMObjectTableStats new].
	^objectTableStats! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 11:45'!
objectTableStats: anRVMObjectTableStats
	"Set the object stats for this sample"
	objectTableStats := anRVMObjectTableStats! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 11:25'!
rawData
	"Answer the raw data for this sample"
	^rawData! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 11:25'!
rawData: anArray
	"Set the raw data for this sample"
	rawData := anArray! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 11:30'!
squeakInterpreterStats
	"Answer the squeak interpreter stats for this sample"
	squeakInterpreterStats isNil ifTrue:[self squeakInterpreterStats: RVMSqueakInterpreterStats new].
	^squeakInterpreterStats! !

!RVMSample methodsFor: 'accessing' stamp: 'ssa 7/21/2008 11:22'!
squeakInterpreterStats: anRVMSqueakInterpreterStats
	"Set the squeak interpreter stats for this sample"
	squeakInterpreterStats := anRVMSqueakInterpreterStats! !

!RVMSample methodsFor: 'initialize' stamp: 'ssa 7/21/2008 11:31'!
initializeFrom: data
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap objectMap index datum |
	self rawData: data.
	valueMap := { 
				'millisecs' -> #millisecondsSinceLastSample:.
				'cycles' -> #cyclesSinceLastSample:.
				}.
	objectMap := { 
				'The_Global_Object_Heap.get_stats()' -> #initializeGlobalHeapStatsFrom:.
				'The_Local_Object_Heap.get_stats()' -> #initializeLocalHeapStatsFrom:.
				'The_Object_Table.get_stats()' -> #initializeObjectTableStatsFrom:.
				'The_Squeak_Interpreter.get_stats()' -> #initializeSqueakInterpreterStatsFrom:.
				}.
				
	valueMap do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		self perform: assoc value with: datum].
		
	objectMap do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		self perform: assoc value with: datum].
! !

!RVMSample methodsFor: 'initialize' stamp: 'ssa 7/21/2008 11:11'!
initializeGlobalHeapStatsFrom: data
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap objectMap index datum |
	self initializeHeapStatsFrom: data into: self globalHeapStats.
	valueMap := {}.
	objectMap := {}.
				
	valueMap do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		self globalHeapStats perform: assoc value with: datum].
		
	objectMap do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		self globalHeapStats perform: assoc value with: datum].
! !

!RVMSample methodsFor: 'initialize' stamp: 'ssa 7/21/2008 11:11'!
initializeHeapStatsFrom: data into: aHeapStats
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap objectMap index datum |
	valueMap := { 
				'bytesUsed()' -> #bytesUsed:.
				'bytesLeft()' -> #bytesLeft:.
				'allocations_since_last_query' -> #allocationsSinceLastQuery:.
				'compactions_since_last_query' -> #compactionsSinceLastQuery:.
				}.
	objectMap := {}.
				
	valueMap do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		aHeapStats perform: assoc value with: datum].
		
	objectMap do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		aHeapStats perform: assoc value with: datum].
! !

!RVMSample methodsFor: 'initialize' stamp: 'ssa 7/21/2008 11:12'!
initializeLocalHeapStatsFrom: data
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap objectMap index datum |
	self initializeHeapStatsFrom: data into: self localHeapStats.
	valueMap := { 
				'objects_fetched_into_local_heap_since_last_query' -> #objectsFetchedSinceLastQuery:.
				'overly_large_fetch_or_allocation_requests_denied_since_last_query' -> #overlyLargeFetchOrAllocationRequestsDeniedSinceLastQuery:.
				'fetch_requests_that_failed_since_last_query' -> #failedFetchRequestsSinceLastQuery:.
				'objects_flushed_since_last_query' -> #objectsFlushedSinceLastQuery:.
				}.
	objectMap := {}.
				
	valueMap do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		self localHeapStats perform: assoc value with: datum].
		
	objectMap do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		self localHeapStats perform: assoc value with: datum].
! !

!RVMSample methodsFor: 'initialize' stamp: 'ssa 7/21/2008 11:16'!
initializeObjectTableStatsFrom: data
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap objectMap index datum |
	valueMap := { 
				'how_many_entries_are_currently_allocated' -> #allocatedEntryCount:.
				'how_many_entries_exist' -> #entryCount:.
				'how_many_allocations_have_occured_since_last_query' -> #allocationsMadeSinceLastQuery:.
				'how_many_have_been_freed_since_last_query' -> #allocationsFreedSinceLastQuery:.
				}.
	objectMap := {}.
				
	valueMap do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		self objectTableStats perform: assoc value with: datum].
		
	objectMap do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		self objectTableStats perform: assoc value with: datum].
! !

!RVMSample methodsFor: 'initialize' stamp: 'ssa 7/21/2008 11:19'!
initializeSqueakInterpreterStatsFrom: data
	"Set my variables based on the data array.  The data array is organized as a series of name-value pairs, where the names are strings and the values are either numbers, strings, symbols or an array of name-value pairs.  This implementations assumes no order dependency in the array except that values always follow their names.  Subarrays will be passed to another method like me that will factor them into appropriate subobjects."
	
	| valueMap objectMap index datum |
	valueMap := { 
				'bcCount - bytecodes' -> #bytecodeCount:.
				}.
	objectMap := {}.
				
	valueMap do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		self squeakInterpreterStats perform: assoc value with: datum].
		
	objectMap do:[:assoc |
		index := data indexOf: assoc key.
		index = 0 ifTrue:[self error:'Can''t find ',assoc key,' in sample data'].
		datum := data at: index + 1.
		self squeakInterpreterStats perform: assoc value with: datum].
! !

!RVMSample class methodsFor: 'primitive access' stamp: 'ssa 7/21/2008 10:38'!
primitiveCapture
	"Grab some data from the VM and return it"
	<primitive: 'primitiveSampleRVM' module: 'RVMPlugin'>
	self primitiveFailed! !

!RVMSample class methodsFor: 'instance creation' stamp: 'ssa 7/21/2008 11:23'!
capture
	"Capture a sample from the vm and answer a new instance of me holding those values"
	| data sample |
	data := self primitiveCapture.
	sample := self new.
	sample initializeFrom: data.
	^sample! !

!RVMSample class methodsFor: 'example' stamp: 'ssa 7/21/2008 11:24'!
example
	"RVMSample example"
	self capture explore! !

!RVMSample class methodsFor: 'example' stamp: 'ssa 8/13/2008 15:05'!
examplePrimitive
	"RVMSample examplePrimitive"
	self primitiveCapture explore! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:27'!
allCoreStats ^ 1 bitShift: 4! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:27'!
allCores ^ 1 bitShift: 0! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:28'!
bufferedMessageStats ^ 1 bitShift: 17! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:28'!
bytecodes ^ 1 bitShift: 21! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:27'!
coreCoords ^ 1 bitShift: 14! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:28'!
cpuCoreStats ^ 1 bitShift: 3! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:29'!
cycleCounts ^ 1 bitShift: 23! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:29'!
cycles ^ 1 bitShift: 8! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:29'!
dontPassTheBatonDefault ^ 1 bitShift: 5! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:30'!
everything ^ SmallInteger maxVal! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:31'!
fence  ^  1 bitShift: 6! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:31'!
gcStats ^ 1 bitShift: 19! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:32'!
heapStats ^ 1 bitShift: 20! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:32'!
interactionStats ^ 1 bitShift: 13! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:32'!
interpreterLoopStats ^ 1 bitShift: 27! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:32'!
interpreterStats ^ 1 bitShift: 11! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:32'!
interruptChecks ^ 1 bitShift: 24! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:33'!
memorySystemStats  ^ 1 bitShift: 10! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:33'!
messageNames ^ 1 bitShift: 2! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:33'!
messageStats  ^ 1 bitShift: 9! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:33'!
millisecs  ^ 1 bitShift: 7! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:33'!
movedMutatedObjectStats ^ 1 bitShift: 25! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:34'!
mutexStats ^ 1 bitShift: 26
! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:34'!
objectTableStats  ^ 1 bitShift: 12! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:34'!
receiveCycles ^ 1 bitShift: 18! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:34'!
receiveTallies ^ 1 bitShift: 16! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:34'!
runMask ^ 1 bitShift: 1! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:35'!
sendTallies ^ 1 bitShift: 15! !

!RVMSampleFlags class methodsFor: 'flag values' stamp: 'dmu 4/10/2009 17:35'!
yieldCount ^  1 bitShift: 22! !

!RVMSampleReader methodsFor: 'common entries' stamp: 'ssa 11/16/2008 15:12'!
messageNames
	"Normally at index 8 in sample raw data array"
	^#('noMessage' 'allocateOrRecycleContextMessage' 'allocateOrRecycleContextJustTestingMessage' 'recycleContextIfPossibleMessage' 'flushInterpreterCachesMessage' 'flushMethodCacheMessage' 'flushByMethodMessage' 'flushSelectiveMessage' 'addObjectFromSnapshotMessage' 'addObjectFromSnapshotResponse' 'updateWholeInterpreterMessage' 'updateEnoughInterpreterToTransferControlMessage' 'updateEnoughInterpreterToTransferControlJustTestingMessage' 'updateEnoughInterpreterToTransferControlJustTestingResponse' 'zapUnusedPortionOfHeapMessage' 'zapUnusedPortionOfHeapResponse' 'verifyInterpreterAndHeapMessage' 'doAllRootsThereMessage' 'doAllRootsThereResponse' 'doAllRootsHereMessage' 'hereIsARootResponse' 'newValueForOopMessage' 'noMoreRootsResponse' 'scanCompactOrMakeFreeObjectsMessage' 'scanCompactOrMakeFreeObjectsResponse' 'returnContextMessage' 'runPrimitiveMessage' 'runPrimitiveJustTestingMessage' 'runPrimitiveResponse' 'loadFunctionFromPluginMessage' 'loadFunctionFromPluginResponse' 'broadcastInterpreterDoublewordMessage' 'broadcastInterpreterWordMessage' 'broadcastInterpreterBoolMessage' 'sampleOneCoreMessage' 'sampleOneCoreResponse' 'initiateBarrierMessage' 'respondToBarrierMessage' 'aboutToWriteRead_MostlyMemoryMessage' 'aboutToWriteRead_MostlyMemoryResponse' 'wroteRead_MostlyMemoryMessage' 'flushFreeContextsMessage' 'enforceCoherenceBeforeSenderStoresIntoAllHeapsMessage' 'enforceCoherenceBeforeSenderStoresIntoAllHeapsResponse' 'enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapMessage' 'enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapResponse' 'enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapMessage' 'enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapResponse' 'preGCActionMessage' 'preGCActionResponse' 'postGCActionMessage' 'postGCActionResponse' 'startAnotherProcessMessage' 'startAnotherProcessResponse' 'initContextMessage' 'initContextResponse' 'requestSafepointMessage' 'requestSafepointResponse' 'relinquishSafepointMessage' 'relinquishSafepointResponse')! !

!RVMSampleReader methodsFor: 'common entries' stamp: 'ssa 11/16/2008 15:12'!
version1messageNames
	"Normally at index 8 in sample raw data array"
	^#('allocateOrRecycleContextMessage' 'allocateOrRecycleContextJustTestingMessage' 'recycleContextIfPossibleMessage' 'flushInterpreterCachesMessage' 'flushMethodCacheMessage' 'flushByMethodMessage' 'flushSelectiveMessage' 'addObjectFromSnapshotMessage' 'addObjectFromSnapshotResponse' 'updateWholeInterpreterMessage' 'updateEnoughInterpreterToTransferControlMessage' 'updateEnoughInterpreterToTransferControlJustTestingMessage' 'updateEnoughInterpreterToTransferControlJustTestingResponse' 'zapUnusedPortionOfHeapMessage' 'zapUnusedPortionOfHeapResponse' 'verifyInterpreterAndHeapMessage' 'doAllRootsThereMessage' 'doAllRootsThereResponse' 'doAllRootsHereMessage' 'hereIsARootResponse' 'newValueForOopMessage' 'noMoreRootsResponse' 'scanCompactOrMakeFreeObjectsMessage' 'scanCompactOrMakeFreeObjectsResponse' 'returnContextMessage' 'runPrimitiveMessage' 'runPrimitiveJustTestingMessage' 'runPrimitiveResponse' 'loadFunctionFromPluginMessage' 'loadFunctionFromPluginResponse' 'broadcastInterpreterDoublewordMessage' 'broadcastInterpreterWordMessage' 'broadcastInterpreterBoolMessage' 'sampleOneCoreMessage' 'sampleOneCoreResponse' 'initiateBarrierMessage' 'respondToBarrierMessage' 'aboutToWriteReadMostlyMemoryMessage' 'aboutToWriteReadMostlyMemoryResponse' 'wroteReadMostlyMemoryMessage' 'flushFreeContextsMessage' 'enforceCoherenceBeforeSenderStoresIntoAllHeapsMessage' 'enforceCoherenceBeforeSenderStoresIntoAllHeapsResponse' 'enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapMessage' 'enforceCoherenceAfterEachCoreHasStoredIntoItsOwnHeapResponse' 'enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapMessage' 'enforceCoherenceBeforeEachCoreStoresIntoItsOwnHeapResponse')! !

!RVMSampleReader methodsFor: 'reading' stamp: 'ssa 10/26/2008 16:03'!
nextAllCPUCoreStats

	| rawData |
	rawData _ OrderedCollection new.
	56 timesRepeat:[rawData add: self nextCoreStats].
	^rawData asArray! !

!RVMSampleReader methodsFor: 'reading' stamp: 'ssa 11/16/2008 15:31'!
nextCoreStats

	| rawData |
	rawData _ Array new: 12.
	rawData at:1 put: 'millisecs'.
	rawData at:2 put: self next.
	rawData at:3 put: 'cycles'.
	rawData at:4 put: self next.
	rawData at:5 put: 'coreStats'.
	rawData at:6 put: self nextInnerCoreStats.
	rawData at:7 put: 'memorySystemStats'.
	rawData at:8 put: self nextMemorySystemStats.
	rawData at:9 put: 'interpreterStats'.
	rawData at:10 put: self nextInterpreterStats.
	rawData at:11put: 'objectTableStats'.
	rawData at:12 put: self nextObjectTableStats.
	^rawData! !

!RVMSampleReader methodsFor: 'reading' stamp: 'ssa 10/26/2008 16:00'!
nextGroupStats

	| rawData |
	rawData _ Array new: 14.
	rawData at:1 put: 'mainX'.
	rawData at:2 put: self next.
	rawData at:3 put: 'mainY'.
	rawData at:4 put: self next.
	rawData at:5 put: 'mainRank'.
	rawData at:6 put: self next.
	rawData at:7 put: 'width'.
	rawData at:8 put: self next.
	rawData at:9 put: 'height'.
	rawData at:10 put: self next.
	rawData at:11 put: 'groupSize'.
	rawData at:12 put: self next.
	rawData at:13 put: 'remaining'.
	rawData at:14 put: self next.
	^rawData! !

!RVMSampleReader methodsFor: 'reading' stamp: 'ssa 10/26/2008 19:52'!
nextInnerCoreStats

	| rawData |
	rawData _ Array new: 11.
	rawData at:1 put: 'x'.
	rawData at:2 put: self next.
	rawData at:3 put: 'y'.
	rawData at:4 put: self next.
	rawData at:5 put: 'rank'.
	rawData at:6 put: self next.
	rawData at:7 put: 'sendTalliesByCore'.
	rawData at:8 put: self nextSendTalliesByCore.
	rawData at:9 put: 'receiveTallies'.
	rawData at:10 put: self nextReceiveTallies.
	rawData at:11 put: #().
	^rawData! !

!RVMSampleReader methodsFor: 'reading' stamp: 'ssa 11/16/2008 15:24'!
nextInterpreterStats

	| rawData |
	rawData _ Array new: 18.
	rawData at:1 put: 'bytecodesExecuted'.
	rawData at:2 put: self next.
	rawData at:3 put: 'yieldCount'.
	rawData at:4 put: self next.
	rawData at:5 put: 'cyclesRunning'.
	rawData at:6 put: self next.
	rawData at:7 put: 'cyclesWaiting'.
	rawData at:8 put: self next.
	rawData at:9 put: 'contextChangeCount'.
	rawData at:10 put: self next.
	rawData at:11 put: 'interruptCheckCount'.
	rawData at:12 put: self next.
	rawData at:13 put: 'unforcedInterruptCheckCount'.
	rawData at:14 put: self next.
	rawData at:15 put: 'numberOfMovedMutatedRead_MostlyObjects'.
	rawData at:16 put: self next.
	rawData at:17 put: 'cyclesMovingMutatedRead_MostlyObjects'.
	rawData at:18 put: self next.
	^rawData! !

!RVMSampleReader methodsFor: 'reading' stamp: 'ssa 10/26/2008 20:10'!
nextMemorySystemStats

	| rawData heap |
	rawData _ Array new: 10.
	rawData at:1 put: 'gcCount'.
	rawData at:2 put: self next.
	rawData at:3 put: 'gcMilliseconds'.
	rawData at:4 put: self next.
	rawData at:5 put: 'gcCycles'.
	rawData at:6 put: self next.
	rawData at:7 put: 'readWriteHeapStats'.
	heap _ Array new:8.
	heap at: 1 put:'bytesUsed()'.
	heap at: 2 put:self next.
	heap at: 3 put:'bytesLeft()'.
	heap at: 4 put:self next.
	heap at: 5 put:'allocationsSinceLastQuery'.
	heap at: 6 put:self next.
	heap at: 7 put:'compactionsSinceLastQuery'.
	heap at: 8 put: self next.
	rawData at:8 put: heap.
	rawData at:9 put: 'readMostlyHeapStats'.
	heap _ Array new:8.
	heap at: 1 put:'bytesUsed()'.
	heap at: 2 put:self next.
	heap at: 3 put:'bytesLeft()'.
	heap at: 4 put:self next.
	heap at: 5 put:'allocationsSinceLastQuery'.
	heap at: 6 put:self next.
	heap at: 7 put:'compactionsSinceLastQuery'.
	heap at: 8 put: self next.
	rawData at:10 put: heap.
	^rawData! !

!RVMSampleReader methodsFor: 'reading' stamp: 'ssa 11/16/2008 15:25'!
nextObjectTableStats

	| rawData |
	rawData _ Array new: 8.
	rawData at:1 put: 'allocatedEntryCount[rank]'.
	rawData at:2 put: self next.
	rawData at:3 put: 'entryCount[rank]'.
	rawData at:4 put: self next.
	rawData at:5 put: 'allocationsSinceLastQuery[rank]'.
	rawData at:6 put: self next.
	rawData at:7 put: 'entriesFreedSinceLastQuery[rank]'.
	rawData at:8 put: self next.
	^rawData! !

!RVMSampleReader methodsFor: 'reading' stamp: 'ssa 10/26/2008 20:00'!
nextReceiveTallies

	^ self next asArray! !

!RVMSampleReader methodsFor: 'reading' stamp: 'ssa 11/16/2008 15:15'!
nextSample

	| rawData |
	rawData _ Array new: 22.
	rawData at:1 put: 'runMask'.
	rawData at:2 put: self next.
	rawData at:3 put: 'extraYields'.
	rawData at:4 put: self next.
	rawData at:5 put: 'extraRemoteContextAllocations'.
	rawData at:6 put: self next.
	rawData at:7 put: 'messageNames'.
	rawData at:8 put: self messageNames.
	self next.  "consume #messageNames"
	rawData at:9 put: 'groupStats'.
	rawData at:10 put: self nextGroupStats.
	rawData at:11 put: 'allCPUCoreStats'.
	rawData at:12 put: self nextAllCPUCoreStats.
	rawData at:13 put: 'extraRunPrimitives'.
	rawData at:14 put: self next.
	rawData at:15 put: 'extraDoublewordBroadcasts'.
	rawData at:16 put: self next.
	rawData at:17 put: 'extraWordBroadcasts'.
	rawData at:18 put: self next.
	rawData at:19 put: 'dontPassTheBatonDefault'.
	rawData at:20 put: self next.
	rawData at:21 put: 'fence'.
	rawData at:22 put: self next.
	^rawData! !

!RVMSampleReader methodsFor: 'reading' stamp: 'ssa 10/26/2008 19:58'!
nextSendTalliesByCore

	| rawData |
	rawData _ Array new: 112.
	1 to: 111 by: 2 do:[:index|
		rawData at: index put: 'sendTallies'.
		rawData at: index + 1 put: self next asArray].
	^rawData ! !

!RVMSampleReader class methodsFor: 'instance creation' stamp: 'ssa 10/26/2008 15:51'!
dearchive: aString 
	"RVMSampleReader dearchive: 'sample-writer.test' "
	| aStream anObject  |
	aStream _ self on: (self fastStreamOn: aString).
	anObject _ aStream nextSample.
	aStream close.
	^anObject! !

!RVMSampleReader class methodsFor: 'instance creation' stamp: 'ssa 10/26/2008 20:24'!
dearchiveRawData: aString 
	"RVMSampleReader dearchiveRawData: 'sample-writer.test' "
	| aStream anObject  |
	aStream _ self on: (self fastStreamOn: aString).
	anObject _ aStream nextSample.
	aStream close.
	^anObject! !

!RVMSampleReader class methodsFor: 'instance creation' stamp: 'ssa 10/28/2008 19:27'!
dearchiveRawDataFrom: aStream
	"| rw |
	rw _ ReadWriteStream on:''.
	RVMSampleWriter archiveRawData: (RVMMonitor samples first) on: rw.
	RVMSampleReader dearchiveRawDataFrom: rw reset "
	|  anObject  aReader |
	aReader _ self on: aStream.
	anObject _ aReader nextSample.
	^anObject! !

!RVMSampleReader class methodsFor: 'instance creation' stamp: 'ssa 10/26/2008 20:27'!
dearchiveSample: aString 
	"RVMSampleReader dearchiveSample: 'sample-writer.test' "
	| aStream anObject  |
	aStream _ self on: (self fastStreamOn: aString).
	anObject _ aStream nextSample.
	aStream close.
	^RVMMulticoreSample newFrom:anObject! !

!RVMSampleReader class methodsFor: 'instance creation' stamp: 'ssa 10/28/2008 19:28'!
dearchiveSampleFrom: aStream
	"| rw |
	rw _ ReadWriteStream on:''.
	RVMSampleWriter archiveSample: RVMMonitor lastSample on: rw.
	RVMSampleReader dearchiveSampleFrom: rw reset "
	|  anObject  aReader |
	aReader _ self on: aStream.
	anObject _ aReader nextSample.
	^RVMMulticoreSample newFrom:anObject! !

!RVMSampleWriter methodsFor: 'accessing' stamp: 'ssa 10/26/2008 15:04'!
rawData
	"Answer the value of rawData"

	^ rawData! !

!RVMSampleWriter methodsFor: 'accessing' stamp: 'ssa 10/26/2008 15:04'!
rawData: anObject
	"Set the value of rawData"

	rawData _ anObject! !

!RVMSampleWriter methodsFor: 'archiving' stamp: 'ssa 11/16/2008 15:42'!
archiveAllCPUCoreStats: data
	"Archive the rawData I have from the sample, minimizing space"
	|  datum |
	data do:[:batch|
 2 to: batch size by: 2 do:[:index|
	datum _ batch at: index.
	index = 6 ifTrue:[self archiveCoreStats: datum]
		ifFalse:[index = 8 ifTrue:[self archiveMemorySystemStats: datum]
			ifFalse:[(#(10 12) includes:index) ifTrue:[self archiveNameValuePairArray: datum]
				ifFalse:[self nextPut:datum]]]]].
	! !

!RVMSampleWriter methodsFor: 'archiving' stamp: 'ssa 10/26/2008 15:18'!
archiveCoreStats: data
	"Archive the rawData I have from the sample, minimizing space"
	|  datum |
 2 to: data size by: 2 do:[:index|
	datum _ data at: index.
	index = 8 ifTrue:[self archiveSendTalliesByCore: datum]
		ifFalse:[index = 10 ifTrue:[self archiveRecieveTallies: datum]
			ifFalse:[self nextPut:datum]]].
	! !

!RVMSampleWriter methodsFor: 'archiving' stamp: 'ssa 10/26/2008 15:25'!
archiveMemorySystemStats: data
	"Archive the rawData I have from the sample, minimizing space"
	|  datum |
 2 to: data size by: 2 do:[:index|
	datum _ data at: index.
	index = 8 ifTrue:[self archiveNameValuePairArray: datum]
		ifFalse:[index = 10 ifTrue:[self archiveNameValuePairArray: datum]
			ifFalse:[self nextPut:datum]]].
	! !

!RVMSampleWriter methodsFor: 'archiving' stamp: 'ssa 10/26/2008 15:25'!
archiveNameValuePairArray: data
	"Archive the rawData I have from the sample, minimizing space"
	|  datum |
 2 to: data size by: 2 do:[:index|
	datum _ data at: index.
	self nextPut: datum].
	! !

!RVMSampleWriter methodsFor: 'archiving' stamp: 'ssa 10/26/2008 15:20'!
archiveRecieveTallies: data
	"Archive the rawData I have from the sample, minimizing space"
	self nextPut: data asRunArray
	! !

!RVMSampleWriter methodsFor: 'archiving' stamp: 'ssa 11/16/2008 15:31'!
archiveSampleData
	"Archive the rawData I have from the sample, minimizing space"
	| data datum |
	data _ self rawData.
 2 to: data size by: 2 do:[:index|
	datum _ data at: index.
	index = 8 ifTrue:[self nextPut: #messageNames]
		ifFalse:[index = 12 ifTrue:[self archiveAllCPUCoreStats: datum]
			ifFalse:[(index = 10) ifTrue:[self archiveNameValuePairArray: datum]
			ifFalse:[self nextPut:datum]]]].
	! !

!RVMSampleWriter methodsFor: 'archiving' stamp: 'ssa 10/26/2008 15:19'!
archiveSendTalliesByCore: data
	"Archive the rawData I have from the sample, minimizing space"
	|  datum |
 2 to: data size by: 2 do:[:index|
	datum _ data at: index.
	self nextPut: datum asRunArray].
	! !

!RVMSampleWriter methodsFor: 'private' stamp: 'ssa 7/7/2010 13:13'!
setStream: aWriteStream
	"Since I only store arrays of numbers, use plain Dictionarys"
	stream _ aWriteStream.
	classMap _ Dictionary new: 30.
	classMap at: self put: 1.
	objectMap _ Dictionary new: 400.
	position _ 0  ! !

!RVMSampleWriter class methodsFor: 'instance creation' stamp: 'ssa 10/26/2008 20:23'!
archive: rawData to: aString 
	"use the other specific versions of me"
	self shouldNotImplement! !

!RVMSampleWriter class methodsFor: 'instance creation' stamp: 'ssa 10/28/2008 19:26'!
archiveRawData: rawData on: aStream
	"RVMSampleWriter archiveRawData: (RVMMonitor samples first) on: (ReadWriteStream on:'')"
	"rawData is expected to be the array of sample data obtained from the RVMMulticoreSample primitiveCapture primitive."

	| writer |
	writer _ self on: aStream.
	writer rawData: rawData.
	writer archiveSampleData.
	^aStream! !

!RVMSampleWriter class methodsFor: 'instance creation' stamp: 'ssa 10/26/2008 20:22'!
archiveRawData: rawData to: aString 
	"RVMSampleWriter archiveRawData: (RVMMonitor samples first) to: 'sample-writer.test'"
	"rawData is expected to be the array of sample data obtained from the RVMMulticoreSample primitiveCapture primitive."

	| stream writer |
	 stream _ self fastStreamOn:  aString.
	writer _ self on: stream.
	writer rawData: rawData.
	writer archiveSampleData.
	writer close.! !

!RVMSampleWriter class methodsFor: 'instance creation' stamp: 'ssa 10/28/2008 19:26'!
archiveSample: aMulticoreSample on: aStream
	"RVMSampleWriter archiveRawData: (RVMMonitor samples first)  on: (ReadWriteStream on:'')"
	"rawData is expected to be the array of sample data obtained from the RVMMulticoreSample primitiveCapture primitive."

	| writer |
	writer _ self on: aStream.
	writer rawData: aMulticoreSample rawData.
	writer archiveSampleData.
	^aStream! !

!RVMSampleWriter class methodsFor: 'instance creation' stamp: 'ssa 10/26/2008 20:23'!
archiveSample: aMulticoreSample to: aString 
	"RVMSampleWriter archiveRawData: (RVMMonitor samples first) to: 'sample-writer.test'"
	"rawData is expected to be the array of sample data obtained from the RVMMulticoreSample primitiveCapture primitive."

	| stream writer |
	 stream _ self fastStreamOn:  aString.
	writer _ self on: stream.
	writer rawData: aMulticoreSample rawData.
	writer archiveSampleData.
	writer close.! !

!RVMScanningStripChartView methodsFor: 'displaying' stamp: 'ssa 10/28/2008 15:21'!
drawOnCanvas
	| color colorIndex |
	1 to: self count do: [:index | 
			colorIndex := ((self data at: index)
						/ self scale min: self numberOfColors max: 1) rounded.
			color := self colors at: colorIndex.
			self scanner
				fill: (self boxes at: index)
				fillColor: color].
	self scanner displayOn: self canvas at: self nextScannerLocation @ 0.
! !

!RVMScanningStripChartView methodsFor: 'displaying' stamp: 'ssa 10/28/2008 20:37'!
eraseStrip
	
	
	self resetScannerLocation.
	super eraseStrip.! !

!RVMScanningStripChartView methodsFor: 'displaying' stamp: 'ssa 10/28/2008 20:02'!
nextScannerLocation
	"Answer the next location for the scanner"
	self scannerLocation: self scannerLocation + self boxSize.
	^self scannerLocation! !

!RVMScanningStripChartView methodsFor: 'displaying' stamp: 'ssa 10/28/2008 20:41'!
redrawOnCanvas
	| color colorIndex |
	self canvas fillWhite.
	self resetScannerLocation.
	self previousData do:[:oldData|
	1 to: self count do: [:index | 
			colorIndex := ((oldData at: index)
						/ self scale min: self numberOfColors max: 1) rounded.
			color := self colors at: colorIndex.
			self scanner
				fill: (self boxes at: index)
				fillColor: color].
	self scanner displayOn: self canvas at: self nextScannerLocation @ 0]! !

!RVMScanningStripChartView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 15:20'!
box
	"Answer the value of box"

	box isNil ifTrue:[self box: (0@0 extent: self boxSize @ self scanner boundingBox height)].
	^box! !

!RVMScanningStripChartView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 20:37'!
resetScannerLocation

	scannerLocation _ nil! !

!RVMScanningStripChartView methodsFor: 'accessing' stamp: 'ssa 5/4/2010 15:27'!
scanner
	"Answer the value of scanner"

	scanner isNil ifTrue:[self scanner: (ColorForm extent: self boxSize * 3 @self canvas height depth:8)].
	^ scanner! !

!RVMScanningStripChartView methodsFor: 'accessing' stamp: 'ssa 5/4/2010 15:31'!
scanner: anObject
	"Set the value of scanner"

	scanner _ anObject.
	scanner fillWhite.
	scanner border: scanner boundingBox width:1 fillColor:Color black.
'<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<' asParagraph asForm displayOn: scanner at: scanner boundingBox topCenter - (1@0).
scanner border: scanner boundingBox width:1
	! !

!RVMScanningStripChartView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 15:24'!
scannerLocation
	"Answer the value of scannerLocation"

	scannerLocation isNil ifTrue:[self scannerLocation: self boxSize negated].
	^ scannerLocation! !

!RVMScanningStripChartView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 20:15'!
scannerLocation: anInteger
	"Set the value of scannerLocation"

	anInteger > self canvas boundingBox width
		ifTrue:[scannerLocation _ self boxSize negated]
		ifFalse:[scannerLocation _ anInteger]! !

!RVMScanningStripChartView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 20:49'!
typeLabel

	^'RelScan: '! !

!RVMSqueakInterpreterStats methodsFor: 'measuring' stamp: 'dmu 9/17/2010 15:21'!
cyclesRunWaitRatio
	"Answer the ratio between my cyclesRunning and cyclesWaiting"
	
	^self cyclesWaiting = 0 ifTrue:[0] ifFalse:[self cyclesRunning / (1 max: self cyclesWaiting) asFloat]! !

!RVMSqueakInterpreterStats methodsFor: 'measuring' stamp: 'dmu 9/17/2010 15:21'!
msRunWaitRatio
	"Answer the ratio between my millisecondsRunning and millisecondsWaiting"
	
	^self millisecondsWaiting = 0 ifTrue:[0] ifFalse:[self millisecondsRunning / (1 max: self millisecondsWaiting) asFloat]! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:27'!
bytecodesExecuted
	"Answer the number of bytecodes processed since last query"
	bytecodesExecuted isNil ifTrue:[^0].
	^bytecodesExecuted! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:27'!
bytecodesExecuted: count
	"Set the number of bytecodes processed since last query"
	bytecodesExecuted := count! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:02'!
contextChangeCount
	"Answer the value of contextChangeCount"

	contextChangeCount isNil ifTrue:[self contextChangeCount: 0].
	^contextChangeCount! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:10'!
contextChangeCount: anObject
	"Set the value of contextChangeCount"

	contextChangeCount := anObject! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:02'!
cyclesRunning
	"Answer the value of cyclesRunning"

	cyclesRunning isNil ifTrue:[self cyclesRunning: 0].
	^cyclesRunning! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 18:13'!
cyclesRunning: anObject
	"Set the value of cyclesRunning"

	cyclesRunning := anObject! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:02'!
cyclesWaiting
	"Answer the value of cyclesWaiting"

	cyclesWaiting isNil ifTrue:[self cyclesWaiting: 0].
	^cyclesWaiting! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 18:13'!
cyclesWaiting: anObject
	"Set the value of cyclesWaiting"

	cyclesWaiting := anObject! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:03'!
interruptCheckCount
^ interruptCheckCount! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:03'!
interruptCheckCount: x
 interruptCheckCount := x! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:03'!
millisecondsRunning
	"Answer the value of millisecondsRunning"

	millisecondsRunning isNil ifTrue:[self millisecondsRunning: 0].
	^millisecondsRunning! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:24'!
millisecondsRunning: anObject
	"Set the value of msRunning"

	millisecondsRunning := anObject! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:01'!
millisecondsWaiting
	"Answer the value of msWaiting"

	millisecondsWaiting isNil ifTrue:[self millisecondsWaiting: 0].
	^millisecondsWaiting! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'dmu 8/15/2008 21:25'!
millisecondsWaiting: anObject
	"Set the value of msWaiting"

	millisecondsWaiting := anObject! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:04'!
unforcedInterruptCheckCount
 ^ unforcedInterruptCheckCount! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:03'!
unforcedInterruptCheckCount: x
 unforcedInterruptCheckCount := x! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:03'!
yieldCount
	"Answer the value of yieldCount"

	yieldCount isNil ifTrue:[self yieldCount: 0].
	^yieldCount! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'ssa 8/13/2008 18:13'!
yieldCount: anObject
	"Set the value of yieldCount"

	yieldCount := anObject! !

!RVMSqueakInterpreterStats methodsFor: 'accessing' stamp: 'dmu 9/17/2010 15:21'!
yieldFrequency
	"Answer the value of yieldCount/contextChangeCount"
	^self  contextChangeCount = 0 ifTrue: [0] ifFalse: [(self yieldCount / (1 max: self contextChangeCount)) asFloat]! !

!RVMStandardSystemView methodsFor: 'displaying' stamp: 'ssa 8/20/2008 19:15'!
displayLabelText
	"The label goes in the center of the window"
	| labelRect |
	labelText foregroundColor: Color black
			backgroundColor: self labelColor.
	labelRect := self labelTextRegion.
	Display fill: (labelRect expandBy: 3@0) fillColor: self labelColor.
	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect
			rule: labelText rule fillColor: labelText fillColor.
	labelText destinationForm: nil! !

!RVMStandardSystemView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 00:02'!
displayView
	self okToDisplay: true.
	super displayView! !

!RVMStandardSystemView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 00:21'!
dontDisplayWhile: aBlock
	"Switch my okToDisplay flag off during this block"
	
	self okToDisplay: false.
	aBlock value.
	self okToDisplay: true.
	self displayView! !

!RVMStandardSystemView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 00:21'!
erase
	self okToDisplay: false.
	^super erase! !

!RVMStandardSystemView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 00:21'!
okToDisplay: aBoolean
	self subViews do:[:v| v isRVMView ifTrue:[v okToDisplay: aBoolean]].
! !

!RVMStandardSystemView methodsFor: 'framing' stamp: 'ssa 1/1/1970 00:24'!
constrainFrame: aRectangle
	"Constrain aRectangle, to the minimum and maximum size
	for this window"

   | adjustmentForLabel bWidth |
bWidth _ labelFrame borderWidth.
(bWidth isKindOf: Rectangle) ifTrue:[bWidth _ bWidth origin x].
   adjustmentForLabel := 0 @ (labelFrame height  - bWidth).
	^ aRectangle origin extent:
		((aRectangle extent max: minimumSize + adjustmentForLabel)
		      min: maximumSize + adjustmentForLabel).! !

!RVMStandardSystemView methodsFor: 'framing' stamp: 'ssa 1/1/1970 00:51'!
initialExtent

	^self minimumSize! !

!RVMStandardSystemView methodsFor: 'framing' stamp: 'ssa 1/1/1970 00:25'!
newFrame

	self subViews do:[:v| v isRVMView ifTrue:[v  newFrame]]! !

!RVMStandardSystemView methodsFor: 'framing' stamp: 'ssa 1/1/1970 00:15'!
newFrame: frameChangeBlock

	super newFrame: frameChangeBlock.
	self subViews do:[:v| v isRVMView ifTrue:[v  newFrame]]! !

!RVMStandardSystemView methodsFor: 'framing' stamp: 'ssa 1/1/1970 00:14'!
resizeInitially
	"Determine the rectangular area for the receiver, adjusted to the 
	minimum and maximum sizes."
	self resizeTo: self initialFrame.
	self subViews do:[:v| v isRVMView ifTrue:[v  firstFrame]]
! !

!RVMStandardSystemView methodsFor: 'accessing' stamp: 'ssa 10/4/2008 08:29'!
subViews: aCollection.

	subViews _ aCollection! !

!RVMStripChartController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 00:56'!
eraseStrip

	self view traces do:[:trace| trace removeAllData].
	self view canvas:nil.
	self view displayView! !

!RVMStripChartController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 01:00'!
inspectScaler

	self view traces first scaler inspect! !

!RVMStripChartController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 12:59'!
muteAll

	self view traces do:[:trace| trace mute].
	self view topView allSubViews  do:[:v|( v isKindOf: RVMCheckBoxOnlyView) ifTrue:[v  update:#checked]]! !

!RVMStripChartController methodsFor: 'menu messages' stamp: 'ssa 10/20/2008 09:02'!
spawnUnmuted

	| unmutes |
	unmutes _ self view traces select:[:trace| trace muted not].
	self view okToDisplay: true.
	RVMStripChartView openOnTraces: unmutes deepCopy titled: 'Selected traces'! !

!RVMStripChartController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 12:59'!
unmuteAll

	self view traces do:[:trace| trace unmute].
	self view topView allSubViews  do:[:v|( v isKindOf: RVMCheckBoxOnlyView) ifTrue:[v  update:#checked]]! !

!RVMStripChartController methodsFor: 'controlling' stamp: 'ssa 10/20/2008 08:21'!
yellowButtonActivity
	| menu answer |
	self view dontDisplayWhile:[
	Sensor yellowButtonPressed 
		ifTrue: [menu := CustomMenu new.
			"menu add: 'inspect scaler' action: #inspectScaler."
			menu add: 'mute all' action: #muteAll.
			menu add: 'unmute all' action: #unmuteAll.
			menu add: 'spawn unmuted' action: #spawnUnmuted.
			menu addLine.
			menu add: 'erase strip' action: #eraseStrip.
			answer := menu startUp: #eraseStrip withCaption: nil at: Sensor cursorPoint.
			answer notNil ifTrue:[
				self perform: answer]]]! !

!RVMStripChartScaleController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:33'!
addCoreTrace
	| menu selectedAspect |
	self view topView dontDisplayWhile:[
menu := CustomMenu new.
 RVMMulticoreSample coreAspects do:[:aspect|
			menu add:  aspect action: aspect].
			selectedAspect := menu startUp: nil withCaption: 'Select a core aspect to trace' at: Sensor cursorPoint.
			selectedAspect notNil ifTrue:[ self view stripChart addCoreTraceForAspect: selectedAspect coreIndex: RVMMonitor coreIndexFromUser]].
			self view stripChart rebuildAll. 
			! !

!RVMStripChartScaleController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:36'!
addSystemTrace
	| menu selectedAspect |
	self view topView dontDisplayWhile:[
menu := CustomMenu new.
 RVMMulticoreSample systemAspects do:[:aspect|
			menu add:  aspect action: aspect].
			selectedAspect := menu startUp: nil withCaption: 'Select a system aspect to trace' at: Sensor cursorPoint.
			selectedAspect notNil ifTrue:[ self view stripChart addSystemTraceForAspect: selectedAspect]].
			self view stripChart rebuildAll. 
! !

!RVMStripChartScaleController methodsFor: 'controlling' stamp: 'ssa 10/3/2008 23:12'!
changeAspect

	| menu answer newAspect |
self view topView dontDisplayWhile:[
		menu := CustomMenu new.
	menu add: 'System aspects' action: #system.
	menu add: 'Core aspects' action: #core.
	menu add: 'Test System Aspects' action: #testSystem.
	menu add: 'Test Core Aspects' action: #testCore.
	answer := menu startUp: nil withCaption: 'What kind of aspect would you like to monitor?' at: Sensor cursorPoint.
	answer isNil ifTrue:[^self].
	newAspect _ RVMMulticoreSample aspectFromUserUnder: answer.
	newAspect isNil ifTrue:[^self].
	newAspect = self view stripChart traces first aspect ifTrue:[^self].
	self view stripChart removeAllTraces.
	(#(testCore core) includes: answer)
		ifTrue:[self view stripChart addCoreTraceForAspect: newAspect coreIndex: RVMMonitor coreIndexFromUser]
		ifFalse:[self view stripChart addSystemTraceForAspect: newAspect].
	self view currentTrace: self view stripChart traces first].
	self view hear: nil.
	self view stripChart newFrame.! !

!RVMStripChartScaleController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:31'!
changeScaleAspect
	| menu selectedTrace |
	self view topView dontDisplayWhile:[
menu := CustomMenu new.
 self view stripChart traces do:[:trace|
			menu add: trace aspect action: trace].
			selectedTrace := menu startUp: self view currentAspect withCaption: 'Show scale for this aspect:' at: Sensor cursorPoint.
			selectedTrace notNil ifTrue:[ self view currentTrace: selectedTrace]].
			self view hear: nil! !

!RVMStripChartScaleController methodsFor: 'controlling' stamp: 'ssa 11/11/2008 22:06'!
redButtonActivity
	
	((self view adjustScaleBox translateBy: self view insetDisplayBox origin)  containsPoint: Sensor cursorPoint) ifTrue:[Sensor waitNoButton.
		self spawnScaleAdjuster]! !

!RVMStripChartScaleController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:08'!
removeOtherTraces
	| menu selectedTrace |
	self view topView dontDisplayWhile:[
menu := CustomMenu new.
 self view stripChart traces do:[:trace|
			menu add: trace aspect action: trace].
			selectedTrace := menu startUp: self view currentAspect withCaption: 'Remove all traces except:' at: Sensor cursorPoint.
			selectedTrace notNil ifTrue:[ self view stripChart removeTraces: (self view stripChart traces copyWithout: selectedTrace).
				self view currentTrace: selectedTrace]].
			self view stripChart rebuildAll. 
! !

!RVMStripChartScaleController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:07'!
removeTrace
	| menu selectedTrace |
	self view topView dontDisplayWhile:[
menu := CustomMenu new.
 self view stripChart traces do:[:trace|
			menu add: trace aspect action: trace].
			selectedTrace := menu startUp: self view currentAspect withCaption: 'Select trace to remove:' at: Sensor cursorPoint.
			selectedTrace notNil ifTrue:[ self view stripChart removeTrace: selectedTrace.
				self view currentTrace = selectedTrace ifTrue:[self view currentTrace: nil]].
			].
			self view stripChart rebuildAll. 
! !

!RVMStripChartScaleController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:05'!
scalerForThisAspect

	self view okToDisplay:true.
	RVMColoredDataScalerView openOnAspect:  self view currentTrace aspect! !

!RVMStripChartScaleController methodsFor: 'controlling' stamp: 'ssa 5/12/2010 10:20'!
spawnScaleAdjuster

	|  maxView minView topView resetScaleButton setToObservedButton autoScaleCheckBox height |
	maxView _ RVMValueEditorView  on: view currentTrace scaler valueGetter: [view currentTrace scaler max] valueSetter:[:v|view currentTrace scaler setMax:v. view drawCanvas; displayView] label:'max: '.
	maxView lockGetter:#maxLocked; lockSetter:#maxLocked:.
	minView _ RVMValueEditorView  on: view currentTrace scaler valueGetter: [view currentTrace scaler min] valueSetter:[:v|view currentTrace scaler setMin:v.  view drawCanvas; displayView] label:'min: '.
	minView lockGetter:#minLocked; lockSetter:#minLocked:.
	resetScaleButton _ RVMButtonView label:'Reset scale to default' action:[view currentTrace scaler resetScaling.  view drawCanvas; displayView.  minView hear:nil.  maxView hear:nil].
	setToObservedButton _ RVMButtonView label:'Set scale to observed values' action:[view currentTrace scaler setRangeToObserved.  view drawCanvas; displayView.  minView hear:nil.  maxView hear:nil].
	autoScaleCheckBox _ RVMCheckBoxView on: view currentTrace scaler label: 'Automatic Scaling' checkState: [view currentTrace scaler automaticScaling] whenChecked: [view currentTrace scaler automatic.  view drawCanvas; displayView.  minView hear:nil.  maxView hear:nil] whenUnchecked: [view currentTrace scaler manual. view drawCanvas; displayView.  minView hear:nil.  maxView hear:nil] monitor: true.

	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView addSubView: minView.
	topView addSubView: maxView below:  minView.
	topView addSubView: resetScaleButton below:  maxView.
	topView addSubView: setToObservedButton below:  resetScaleButton.
	topView addSubView: autoScaleCheckBox below:  setToObservedButton.
	RVMMonitor forgetAll:{resetScaleButton. setToObservedButton. autoScaleCheckBox}.
	topView label: view currentAspect.
	height _ topView subViews size * 26.
	topView minimumSize:200@height.
	topView maximumSize: 200@height.
	topView controller open! !

!RVMStripChartScaleController methodsFor: 'controlling' stamp: 'ssa 10/4/2008 08:19'!
yellowButtonActivity
	| menu answer onlyOneTrace |
	onlyOneTrace _ self view stripChart traces size = 1.
	self view topView dontDisplayWhile:[
	menu := CustomMenu new.
 	onlyOneTrace ifTrue:[menu add: 'Change aspect' action: #changeAspect.
 		menu addLine].
 	onlyOneTrace ifFalse:[menu add: 'Show other scale' action: #changeScaleAspect.
 		menu addLine].
 	menu add: 'Add system aspect trace' action: #addSystemTrace.
 	menu add: 'Add core aspect trace' action: #addCoreTrace.
	onlyOneTrace ifFalse:[menu addLine.
 		menu add: 'Remove trace' action: #removeTrace.
		menu add: 'Remove other traces' action: #removeOtherTraces].
	answer := menu startUp: nil withCaption: '' at: Sensor cursorPoint].
	answer notNil ifTrue:[self perform: answer]! !

!RVMStripChartScaleController methodsFor: 'view resizing' stamp: 'ssa 1/1/1970 00:38'!
adjustViewSizes
	self view topView unlock.
	self view topView display! !

!RVMStripChartScaleView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 22:02'!
adjustScaleBox
	"Answer the value of adjustScaleBox"

	adjustScaleBox isNil ifTrue:[self adjustScaleBox: self insetDisplayBox].
	^ adjustScaleBox! !

!RVMStripChartScaleView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 22:02'!
adjustScaleBox: anObject
	"Set the value of adjustScaleBox"

	adjustScaleBox _ anObject! !

!RVMStripChartScaleView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:11'!
currentAspect
	"Answer the value of currentAspect"

	^self currentTrace aspect! !

!RVMStripChartScaleView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 23:17'!
currentAspectLabel
	"Answer a good label for this aspect"

	^self currentTrace aspectLabel! !

!RVMStripChartScaleView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:12'!
currentColor
	"Answer the value of currentColor"

	^self currentTrace color! !

!RVMStripChartScaleView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:12'!
currentTrace
	"Answer the value of currentTrace"

	currentTrace isNil ifTrue:[self currentTrace: self stripChart traces first].
	^ currentTrace! !

!RVMStripChartScaleView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:11'!
currentTrace: anObject
	"Set the value of currentTrace"

	currentTrace _ anObject! !

!RVMStripChartScaleView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:10'!
stripChart
	"Answer the value of stripChart"

	stripChart isNil ifTrue:[self stripChart: (RVMStripChartView trace:RVMCoreAspectTrace exampleInstance)].
	^ stripChart! !

!RVMStripChartScaleView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:03'!
stripChart: anObject
	"Set the value of stripChart"

	stripChart _ anObject! !

!RVMStripChartScaleView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:57'!
uiHolder
	"Answer the value of uiHolder"

	uiHolder isNil ifTrue:[self uiHolder: nil].
	^ uiHolder! !

!RVMStripChartScaleView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:57'!
uiHolder: anObject
	"Set the value of uiHolder"

	uiHolder _ anObject! !

!RVMStripChartScaleView methodsFor: 'drawing' stamp: 'ssa 11/11/2008 21:59'!
adjustScaleIcon
^((ColorForm
	extent: 16@31
	depth: 8
	fromArray: #( 0 0 0 0 0 0 169614364 622594560 0 0 1694498815 4294913536 0 0 1845490943 4294915840 0 0 0 3506384384 0 0 0 3506386688 73 1677721600 0 3657379328 163 3642490880 0 3506386688 9716 4287692800 172 4110364160 46591 4294913536 208 4110366464 4259839 4294936576 0 3506384384 8973264 4106150400 0 3657381632 6558618 3942664503 0 3506384384 154 3942645760 0 3657381632 154 3942645760 25700 3808374272 154 3942645760 60415 4294915840 154 3942645760 18761 3808374272 154 3942645760 0 3506386688 2424986 3942648357 0 3657379328 11304867 3947480869 0 3506386688 7798783 4294948096 0 3506384384 1300991 4294925056 217 4294915840 25855 4291821568 145 3959369216 199 4098424832 0 3657381632 118 2432696320 0 3506384384 28 620756992 0 3506386688 0 0 0 3657379328 0 0 1541003737 4110366464 0 0 1694498815 4294913536 0 0 321795886 1227753984 0 0 0 0)
	offset: 0@0)
	colorsFromArray: #(#(1.0 1.0 1.0) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.94 0.94 0.94) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.847 0.847 0.847) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.815 0.815 0.815) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.784 0.784 0.784) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.753 0.753 0.753) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.721 0.721 0.721) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.69 0.69 0.69) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.658 0.658 0.658) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.627 0.627 0.627) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.595 0.595 0.595) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.501 0.501 0.501) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.439 0.439 0.439) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.408 0.408 0.408) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.376 0.376 0.376) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.345 0.345 0.345) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.313 0.313 0.313) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.282 0.282 0.282) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.25 0.25 0.25) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.188 0.188 0.188) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.156 0.156 0.156) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.125 0.125 0.125) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.094 0.094 0.094) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.063 0.063 0.063) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.031 0.031 0.031) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0) #(0.0 0.0 0.0)  ))! !

!RVMStripChartScaleView methodsFor: 'drawing' stamp: 'ssa 11/11/2008 22:05'!
drawAdjustScaleIcon
	| adjustIcon origin |
.	adjustIcon _ self adjustScaleIcon.
	adjustIcon _ adjustIcon scaledToSize: adjustIcon extent * 0.75.
	origin _ self canvas boundingBox center - adjustIcon boundingBox extent - (0@6).
	adjustIcon displayOn: self canvas at: origin.
	self adjustScaleBox:(origin extent: adjustIcon extent)! !

!RVMStripChartScaleView methodsFor: 'drawing' stamp: 'ssa 11/11/2008 22:03'!
drawCanvas
	| scaler maxLabel minLabel midLabel  box ticLength ticOffset topY midY bottomY leftX rightX margin aspectLabel |
	self eraseCanvas.
	scaler _ self currentTrace scaler.
	aspectLabel _ self currentAspectLabel asDisplayText asParagraph asForm rotateBy: #left centerAt: 0@0.
	maxLabel _ scaler max printShowingMax3Digits asDisplayText.
	minLabel _ scaler min printShowingMax3Digits asDisplayText.	
	midLabel _ (scaler range / 2 + scaler min) printShowingMax3Digits asDisplayText.
	maxLabel foregroundColor: self currentColor backgroundColor: Color transparent.
	midLabel foregroundColor: self currentColor backgroundColor: Color transparent.
	minLabel foregroundColor: self currentColor backgroundColor: Color transparent.
	box _ self canvas boundingBox.
	ticLength _ 4.
	ticOffset _ maxLabel height // 2.
	margin _ 2.
	aspectLabel align: aspectLabel boundingBox leftCenter with: box leftCenter.
	aspectLabel displayOn: self canvas at: 0@0 clippingBox: box.
	maxLabel align: maxLabel boundingBox topRight with: box topRight - (ticLength+margin+1@0).
	maxLabel displayOn: self canvas.
	midLabel align: midLabel boundingBox rightCenter with: box rightCenter - (ticLength+margin+1@0).
	midLabel displayOn: self canvas.
	minLabel align: minLabel boundingBox bottomRight with: box bottomRight -(ticLength+margin+1@0).
	minLabel displayOn: self canvas.
	topY _ box topRight y .
	midY _ box center y.
	bottomY _ box bottomRight y - 2.
	leftX _ box topRight x - ticLength - margin.
	rightX _ box corner x - margin.
	self canvas fill: (rightX - 1@topY corner: rightX@bottomY) fillColor: self currentColor.	
	self canvas fill: (leftX@topY extent: ticLength@1) fillColor: self currentColor.
	self canvas fill: (leftX@(topY+midY//2) extent: ticLength@1) fillColor: self currentColor.
	self canvas fill: (leftX@midY extent: ticLength@1) fillColor: self currentColor.
	self canvas fill: (leftX@(midY+bottomY//2) extent: ticLength@1) fillColor: self currentColor.
	self canvas fill: (leftX@bottomY extent: ticLength@1) fillColor: self currentColor.
	self drawAdjustScaleIcon! !

!RVMStripChartScaleView methodsFor: 'framing' stamp: 'ssa 1/1/1970 00:24'!
newFrame
	self canvas: nil.
	self extent: self insetDisplayBox extent.
	self drawCanvas.
	self displayView! !

!RVMStripChartScaleView methodsFor: 'controller access' stamp: 'ssa 1/1/1970 00:04'!
defaultControllerClass

	^RVMStripChartScaleController! !

!RVMStripChartScaleView methodsFor: 'listening' stamp: 'ssa 1/1/1970 00:05'!
hear: something
	"Update my traces and redisplay"
	self drawCanvas.
	self displayView! !

!RVMStripChartScaleView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:22'!
example
	"RVMStripChartScaleView example"
	
	self new demo! !

!RVMStripChartScaleView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:58'!
stripChart: aStripChart uiHolder: aUIHolder

	| view |
	view _ self new.
	view stripChart: aStripChart.
	view uiHolder: aUIHolder.
	^view! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 10/10/2008 19:23'!
color
	"Answer the value of color"

	color isNil ifTrue:[self color: Color black].
	^ color! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:02'!
color: anObject
	"Set the value of color"

	color _ anObject.
	color notNil ifTrue:[self pen color: color]! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
max
	"Answer my scaler max."
	^self scaler max! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
max: aValue
	"Set my scaler max."
	self scaler max: aValue! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
min
	"Answer my scaler min."
	^self scaler min! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
min: aValue
	"Set my scaler min."
	self scaler min: aValue! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:24'!
muted
	"Answer the value of muted"

	muted isNil ifTrue:[self muted: false].
	^ muted! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:24'!
muted: anObject
	"Set the value of muted"

	muted _ anObject! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 10/10/2008 19:22'!
pen
	"Answer the value of pen"

	| bic |
	pen isNil ifTrue:[bic _ Pen new.
		bic defaultNib:1.
		bic combinationRule: Form over.
		self pen: bic].
	^ pen! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:01'!
pen: anObject
	"Set the value of pen"

	pen _ anObject! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:07'!
rawData
	"Answer the value of rawData"

	rawData isNil ifTrue:[self rawData: (RVMCircularCollection new:10)].
	^ rawData! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:51'!
rawData: anObject
	"Set the value of rawData"

	rawData _ anObject.
	scaledData _ rawData collect:[:datum| self scaler scale: datum].! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:09'!
scaledData
	"Answer the value of scaledData"

	scaledData isNil ifTrue:[self scaledData: self initialScaledData].
	^ scaledData! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:45'!
scaledData: anObject
	"Set the value of scaledData"

	scaledData _ anObject! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:45'!
scaler
	"Answer the value of scaler"

	scaler isNil ifTrue:[self scaler: nil].
	^ scaler! !

!RVMStripChartTrace methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:04'!
scaler: anObject
	"Set the value of scaler"

	scaler _ anObject.
	scaler notNil ifTrue:[self removeAllData]! !

!RVMStripChartTrace methodsFor: 'add/remove data' stamp: 'ssa 1/1/1970 00:53'!
add: aValue
	"Add this value to the end of my data"
	self rawData add: aValue.
	self scaledData add: (self scaler scale: aValue)! !

!RVMStripChartTrace methodsFor: 'add/remove data' stamp: 'ssa 1/1/1970 01:25'!
addData
	"do nothing, only works in subclasses"! !

!RVMStripChartTrace methodsFor: 'add/remove data' stamp: 'ssa 1/1/1970 00:25'!
initialScaledData
	"Generate the scaled data by scaling the rawData"
	^self rawData collect:[:datum| self scaler scale: datum]! !

!RVMStripChartTrace methodsFor: 'add/remove data' stamp: 'ssa 1/1/1970 00:41'!
removeAllData

	self rawData removeAll.
	self scaledData removeAll! !

!RVMStripChartTrace methodsFor: 'add/remove data' stamp: 'ssa 1/1/1970 01:13'!
resizeTo: anInteger

	(self rawData isKindOf: RVMCircularCollection) ifTrue:[
	self rawData size: anInteger.
	self scaledData size: anInteger]! !

!RVMStripChartTrace methodsFor: 'drawing' stamp: 'ssa 1/1/1970 00:12'!
drawLastOn: aColorForm
	"Draw the last line segment on this canvas using this pen."
	| yScale xSpacing x |
	self muted ifTrue:[^self].
	self pen destForm: aColorForm.
	self scaledData numberOfElements = 1 ifTrue:[^self drawOn: aColorForm].
	yScale _ aColorForm height / 100.
	xSpacing _ 2.
	x _ self scaledData numberOfElements  - 1* xSpacing.
	self pen place: x@ (aColorForm height -((self scaledData at: self scaledData numberOfElements - 1) * yScale)).
	self pen goto: x+ xSpacing @ (aColorForm height -((self scaledData at: self scaledData numberOfElements) * yScale)).
! !

!RVMStripChartTrace methodsFor: 'drawing' stamp: 'ssa 1/1/1970 00:25'!
drawOn: aColorForm

	| yScale xSpacing x first |
	self muted ifTrue:[^self].
	self pen destForm: aColorForm.
	yScale _ aColorForm height / 100.
	xSpacing _ 2.
	x _ 0.
	first _ true.
	self scaledData do:[:datum|
		first ifTrue:[self pen place: x@ (aColorForm height -(datum * yScale)). first _ false].
		self pen goto: x@ (aColorForm height -(datum * yScale)).
		x _ x + xSpacing.
		x < 0 ifTrue:[^self]]! !

!RVMStripChartTrace methodsFor: 'drawing' stamp: 'ssa 1/1/1970 00:28'!
mute

	self muted: true.! !

!RVMStripChartTrace methodsFor: 'drawing' stamp: 'ssa 1/1/1970 00:11'!
redrawOn: aColorForm
	self scaledData: nil.
	self drawOn: aColorForm! !

!RVMStripChartTrace methodsFor: 'drawing' stamp: 'ssa 1/1/1970 00:28'!
unmute

	self muted: false.! !

!RVMStripChartTrace methodsFor: 'testing' stamp: 'ssa 1/1/1970 00:04'!
isEmpty

	^self rawData isEmpty! !

!RVMStripChartTrace methodsFor: 'testing' stamp: 'ssa 1/1/1970 00:04'!
isFull

	^self rawData isFull! !

!RVMStripChartTrace methodsFor: 'user interface' stamp: 'ssa 1/1/1970 00:21'!
colorButton
	"Answer a color button connect to my color"
	^RVMColorButtonView on: self colorGetter:#color colorSetter:#color:! !

!RVMStripChartTrace methodsFor: 'user interface' stamp: 'ssa 1/1/1970 00:23'!
minmaxButton
	"Answer a minmax button connect to my scaler's minmax"
	^RVMMinMaxView on: self  getMin: #min setMin: #min: getMax: #max setMax: #max:! !

!RVMStripChartTrace methodsFor: 'user interface' stamp: 'ssa 5/12/2010 10:13'!
muteButton
	"Answer a color button connect to my color"
	| v |
	v _ RVMCheckBoxOnlyView on: self label: '' checkState: [self muted not] whenChecked: [self unmute] whenUnchecked: [self mute].
	RVMMonitor inform: v.
	^v! !

!RVMStripChartTrace methodsFor: 'scaling' stamp: 'ssa 10/6/2008 16:29'!
rescale
	"Reset my scaler and recompute my scaledData"
	self scaler resetScaling.
	self scaledData:nil.! !

!RVMStripChartTrace class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:50'!
data: someData min: minValue max: maxValue color: aColor
	"Answer a new strip chart trace with this data and parameters.
	Note that the type of collection used for someData will also be used for scaled data.
	Use OrderedCollection for variable sized data, CircularCollection for fixed size."
	| trace |
	trace _ self new.
	trace
		scaler: (RVMDataScaler min: minValue max: maxValue);
		rawData: someData;
		color: aColor.
	^trace! !

!RVMStripChartTrace class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 01:29'!
size: anInteger min: minValue max: maxValue color: aColor
	"Answer a new strip chart trace with this size buffer and parameters"
	| trace |
	trace _ self new.
	trace
		scaler: (RVMDataScaler min: minValue max: maxValue);
		rawData: (RVMCircularCollection new: anInteger);
		color: aColor.
	^trace! !

!RVMStripChartTrace class methodsFor: 'examples' stamp: 'ssa 10/18/2008 23:18'!
exampleCircularInstance
	"RVMStripChartTrace exampleCircularInstance"
	
	^ self data: #(1 2 3 4 5 6 7 8 9) asCircularCollection min: 0 max: 10 color: Color blue! !

!RVMStripChartTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:55'!
exampleInstance
	"RVMStripChartTrace exampleInstance"
	
	^ self data: #(1 2 3 4 5 6 5 4 3 2 1) min: 0 max: 10 color: Color blue! !

!RVMStripChartTrace class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:14'!
randomInstance
	"RVMStripChartTrace randomInstance"
	
	| data |
	data _ OrderedCollection new.
	100 timesRepeat:[data add: 10 atRandom].
	^ self data: data min: 0 max: 10 color: Color random! !

!RVMStripChartView methodsFor: 'drawing' stamp: 'ssa 10/2/2008 19:21'!
drawCanvas

	self eraseCanvas.
	self traces do:[:trace|
		trace drawOn: self canvas]! !

!RVMStripChartView methodsFor: 'drawing' stamp: 'ssa 10/3/2008 23:13'!
drawFastOnCanvas
	| box |
	self traces isEmpty ifTrue:[^self canvas fillWhite].
	self traces first isFull ifTrue:[self canvas displayOn: self canvas at: -2@0].
	box _ self canvas boundingBox.
	self canvas fillWhite: (box topRight - (2@0) extent: 2@ box height).
	self traces do:[:trace|
		trace drawLastOn: self canvas ]! !

!RVMStripChartView methodsFor: 'drawing' stamp: 'ssa 10/2/2008 19:21'!
redrawCanvas

	self eraseCanvas.
	self traces do:[:trace|
		trace redrawOn: self canvas]! !

!RVMStripChartView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:26'!
defaultOffset

	^self canvas width negated@ 0! !

!RVMStripChartView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 16:09'!
rescaleCounter
	"Answer the value of rescaleCounter"

	rescaleCounter isNil ifTrue:[self rescaleCounter: 15].
	^ rescaleCounter ! !

!RVMStripChartView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 15:21'!
rescaleCounter: anObject
	"Set the value of rescaleCounter"

	rescaleCounter _ anObject! !

!RVMStripChartView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:00'!
traces
	"Answer the value of traces"

	traces isNil ifTrue:[self traces: OrderedCollection new].
	^ traces! !

!RVMStripChartView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:00'!
traces: anObject
	"Set the value of traces"

	traces _ anObject! !

!RVMStripChartView methodsFor: 'framing' stamp: 'ssa 10/8/2008 18:34'!
firstFrame
	"First time framed, set my canvas to match my view"
	self canvas: nil.
	self extent: self insetDisplayBox extent - (0@2).
	self traces do:[:trace| trace resizeTo: self extent x //2].
	self drawCanvas.
! !

!RVMStripChartView methodsFor: 'framing' stamp: 'ssa 10/3/2008 23:23'!
newFrame
	"My frame has changed. Reset my canvas to my new size and redraw"
	self canvas: nil.
	self extent: self insetDisplayBox extent - (0@2).
	self traces do:[:trace| trace resizeTo: self extent x //2].
	self drawCanvas.
	self displayView! !

!RVMStripChartView methodsFor: 'framing' stamp: 'ssa 10/4/2008 08:28'!
rebuildAll
	|  view subGroups width scaleView scaleWidth topView extraRows |
	topView _ self topView.
	(topView allSubViews copyWithout: self) do:[:v| v release].
	topView subViews: (OrderedCollection with: self).
	topView borderWidth:1.
	width _ 400.
	view _ self .
	scaleWidth _ 60.
	subGroups _ RVMTraceUIHolderView forStripChart: view.
	view extent: width - scaleWidth@100.
	scaleView _ RVMStripChartScaleView stripChart: view uiHolder:subGroups.
	extraRows _ self traces size = 1 ifTrue:[0]ifFalse:[subGroups subViews size].
	topView minimumSize: width@(100+(extraRows * 20)).
	topView addSubView: scaleView viewport: (0@0 extent: scaleWidth@100).
	extraRows > 0 ifTrue:[topView addSubView: subGroups viewport: (0@100 extent: width@(extraRows* 20))].
	topView backgroundColor: Color white.
	view borderWidthLeft: 0
		right: 1
		top: 1
		bottom: 1.
	scaleView borderWidthLeft: 1
		right: 0
		top: 1
		bottom: 1.
	subGroups borderWidth:0.
	topView reframeTo:(topView displayBox origin - (0@(topView labelHeight -2) ) extent: topView minimumSize + (0@topView labelHeight)).
	ScheduledControllers restore: topView windowBox.
	! !

!RVMStripChartView methodsFor: 'listening' stamp: 'ssa 11/11/2008 22:38'!
hear: something
	"Update my traces and redisplay"
	| outOfRangeTraces |
	self rescaleCounter: self rescaleCounter - 1.
	self rescaleCounter = 0 ifTrue:[self rescaleCounter:nil.  
		self traces do:[:trace| trace scaler automaticScaling ifTrue:[trace rescale]]]. 
	self traces do:[:trace| trace addData].
	outOfRangeTraces _ self traces select:[:trace| trace scaler outOfRangeDetected] .
	outOfRangeTraces isEmpty ifTrue:[self drawFastOnCanvas.
			^self displayView].
	self redrawCanvas.
	outOfRangeTraces do:[:trace| trace scaler resetOutOfRangeDetector].
	self displayView! !

!RVMStripChartView methodsFor: 'controller access' stamp: 'ssa 1/1/1970 00:38'!
defaultControllerClass

	^RVMStripChartController! !

!RVMStripChartView methodsFor: 'add/remove traces' stamp: 'ssa 10/4/2008 08:18'!
addCoreTraceForAspect: aSymbol coreIndex: anInteger
	
	 | traceSize existingColors traceColor newTrace |
	traceSize _ self extent x //2.
	existingColors _ self traces collect:[:trace| trace color].
	[traceColor _ Color random darker.
	self traces isEmpty or:[ (existingColors collect:[:color| color diff: traceColor]) asSortedCollection last < 0.7]] whileFalse.
	newTrace _ RVMCoreAspectTrace coreIndex: anInteger aspect: aSymbol size: traceSize color: traceColor.
	self traces add: newTrace.
	self newFrame! !

!RVMStripChartView methodsFor: 'add/remove traces' stamp: 'ssa 10/3/2008 23:08'!
addSystemTraceForAspect: aSymbol
	
	 | traceSize existingColors traceColor newTrace |
	traceSize _ self extent x //2.
	existingColors _ self traces collect:[:trace| trace color].
	[traceColor _ Color random darker.
	self traces isEmpty or:[(existingColors collect:[:color| color diff: traceColor]) asSortedCollection last < 0.7]] whileFalse.
	newTrace _ RVMAspectTrace aspect: aSymbol size: traceSize color: traceColor.
	self traces add: newTrace.
	self newFrame! !

!RVMStripChartView methodsFor: 'add/remove traces' stamp: 'ssa 10/3/2008 22:59'!
removeAllTraces
	
	self traces removeAll: self traces copy.
! !

!RVMStripChartView methodsFor: 'add/remove traces' stamp: 'ssa 1/1/1970 00:51'!
removeTrace: aTrace
	
	self traces remove: aTrace.
	self newFrame! !

!RVMStripChartView methodsFor: 'add/remove traces' stamp: 'ssa 1/1/1970 00:51'!
removeTraces: someTraces
	
	self traces removeAll: someTraces.
	self newFrame! !

!RVMStripChartView methodsFor: 'displaying' stamp: 'ssa 10/21/2008 11:32'!
displayView
	"Display my canvas at my offset.
	Subclasses should not override this method but should draw on the canvas instead"
	self okToDisplay ifFalse:[^self].
	self uncache.
	self canvas displayOn: Display at: self insetDisplayBox origin + self offset - (0@2 ) clippingBox: self insetDisplayBox.
! !

!RVMStripChartView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:30'!
openOnTrace: aTrace
	"RVMStripChartView openOnTrace: RVMAspectTrace exampleInstance"
	self openOnTrace:  aTrace titled:'Multi-aspect Stripchart'
! !

!RVMStripChartView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:30'!
openOnTrace: aTrace titled: aString
	| topView view subGroups width scaleView scaleWidth |
	topView _ RVMStandardSystemView new.
	topView label: aString.
	topView borderWidth:1.
	width _ 400.
	view _ self traces: (OrderedCollection with: aTrace).
	scaleWidth _ 60.
	view extent: width - scaleWidth@100.
	scaleView _ RVMStripChartScaleView stripChart: view uiHolder:subGroups.
	topView minimumSize: width@100.
	topView addSubView: view viewport: (scaleWidth@0 extent: width-scaleWidth@100).
	topView addSubView: scaleView viewport: (0@0 extent: scaleWidth@100).
	topView backgroundColor: Color white.
	view borderWidthLeft: 0
		right: 1
		top: 1
		bottom: 1.
	scaleView borderWidthLeft: 1
		right: 0
		top: 1
		bottom: 1.
	topView controller open! !

!RVMStripChartView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 01:16'!
openOnTraces: someTraces
	"RVMCoreAspectTrace exampleView3"
	self openOnTraces: someTraces titled: 'Multi-aspect Stripchart'! !

!RVMStripChartView class methodsFor: 'instance creation' stamp: 'ssa 10/8/2008 19:09'!
openOnTraces: someTraces titled: aString
	| topView view subGroups width scaleView scaleWidth |
	someTraces size = 1 ifTrue:[self openOnTrace: someTraces first titled: aString].
	topView _ RVMStandardSystemView new.
	topView label: aString.
	topView borderWidth:1.
	someTraces size > 2 ifTrue:[width _ 400]ifFalse:[width _ someTraces size + 1 * 150 ].
	view _ self traces: someTraces.
	scaleWidth _ 60.
	subGroups _ RVMTraceUIHolderView forStripChart: view.
	view extent: width - scaleWidth@100.
	scaleView _ RVMStripChartScaleView stripChart: view uiHolder:subGroups.
	topView minimumSize: width@(100+(subGroups subViews size + 1 * 20)).
	topView addSubView: view viewport: (scaleWidth@0 extent: width-scaleWidth@100).
	topView addSubView: scaleView viewport: (0@0 extent: scaleWidth@100).
	topView addSubView: subGroups viewport: (0@100 extent: width@(subGroups subViews size* 20)).
	topView backgroundColor: Color white.
	view borderWidthLeft: 0
		right: 1
		top: 1
		bottom: 1.
	scaleView borderWidthLeft: 1
		right: 0
		top: 1
		bottom: 1.
	subGroups borderWidth:0.
	topView controller open! !

!RVMStripChartView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:10'!
trace: aTrace

	^self traces:(OrderedCollection with: aTrace)! !

!RVMStripChartView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 01:09'!
traces: someTraces

	| view |
	view _ self new.
	view traces: someTraces.
	^view! !

!RVMStripChartView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:09'!
example
	"RVMStripChartView example"
	self openOnTrace: RVMCoreAspectTrace exampleInstance! !

!RVMTest methodsFor: 'logging' stamp: 'dmu 11/11/2009 18:06'!
log: aString

	Transcript cr;show:'log: [',self name,'] ',aString. Transcript cr; cr.
	self runLog add: {Time dateAndTimeNow. aString}! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 06:19'!
assertionBlock
	"Answer the value of assertionBlock"

	assertionBlock isNil ifTrue:[self assertionBlock: [:test :outcome| false]].
	^ assertionBlock! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:46'!
assertionBlock: anObject
	"Set the value of assertionBlock"

	assertionBlock _ anObject! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 06:47'!
assertions
	"Answer the value of assertions"

	assertions isNil ifTrue:[self assertions: OrderedCollection new].
	^ assertions! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 06:47'!
assertions: anObject
	"Set the value of assertions"

	assertions _ anObject! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:15'!
environment
	"Answer the value of environment"

	environment isNil ifTrue:[self environment: nil].
	^ environment! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:15'!
environment: anObject
	"Set the value of environment"

	environment _ anObject! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:15'!
lastResult
	"Answer the value of lastResult"

	lastResult isNil ifTrue:[self lastResult: nil].
	^ lastResult! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:15'!
lastResult: anObject
	"Set the value of lastResult"

	lastResult _ anObject! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 06:05'!
name
	"Answer the value of name"

	name isNil ifTrue:[self name: 'unnamed'].
	^ name! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 06:05'!
name: anObject
	"Set the value of name"

	name _ anObject! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 07:39'!
result

	^self lastResult! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 06:31'!
runLog
	"Answer the value of runLog"

	runLog isNil ifTrue:[self runLog: OrderedCollection new].
	^ runLog! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 06:31'!
runLog: anObject
	"Set the value of runLog"

	runLog _ anObject! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 08:58'!
setUpBlock
	"Answer the value of setUpBlock"

	setUpBlock isNil ifTrue:[self setUpBlock: [:test| ]].
	^ setUpBlock! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:15'!
setUpBlock: anObject
	"Set the value of setUpBlock"

	setUpBlock _ anObject! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 08:58'!
tearDownBlock
	"Answer the value of tearDownBlock"

	tearDownBlock isNil ifTrue:[self tearDownBlock: [:test :env|]].
	^ tearDownBlock! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:15'!
tearDownBlock: anObject
	"Set the value of tearDownBlock"

	tearDownBlock _ anObject! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 06:19'!
testBlock
	"Answer the value of testBlock"

	testBlock isNil ifTrue:[self testBlock: [:test :env| self log:'testing']].
	^ testBlock! !

!RVMTest methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:22'!
testBlock: anObject
	"Set the value of testBlock"

	testBlock _ anObject! !

!RVMTest methodsFor: 'testing process' stamp: 'ssa 3/5/2010 17:37'!
run
	self environment: (self setUpBlock value: self).
	self lastResult: self runTest.
	self tearDownBlock value: self value: self environment.
	^self lastResult
	! !

!RVMTest methodsFor: 'testing process' stamp: 'dmu 9/3/2010 11:49'!
runTest

	| outcome result decision |
	outcome _ self testBlock value: self value: self environment.
	result _ RVMTestResult test: self result: outcome asserting: ((self assertionBlock value: self value: outcome) and:[self allAssertionsPassed]).
	self log: result gradeString.
	(result failed and:[self name ~= 'testFailure'])ifTrue:[decision _ self confirm:'Test [', self name,'] failed, continue?'.
		decision ifFalse:[self halt:'Test [', self name,'] failed, aborting other tests']].
	^result! !

!RVMTest methodsFor: 'printing' stamp: 'ssa 8/27/2009 07:00'!
fullPrintOn: aStream

	aStream nextPutAll: 'Testing: ',self name.
	aStream cr; nextPutAll: 'result: '.
	self result printOn:aStream.
	aStream cr; nextPutAll: 'setUp: '.
	self setUpBlock printOn:aStream.
	aStream cr; nextPutAll: 'test: '.
	self testBlock printOn:aStream.
	aStream cr; nextPutAll: 'tearDown: '.
	self tearDownBlock printOn:aStream.
	aStream cr; nextPutAll: 'asserting: '.
	self assertionBlock printOn:aStream.
	aStream cr; nextPutAll: 'runLog: '.
	self runLog printOn:aStream.
	! !

!RVMTest methodsFor: 'printing' stamp: 'ssa 8/27/2009 07:05'!
gradeString
	^self lastResult isNil ifTrue:['untested']ifFalse:[self lastResult gradeString]! !

!RVMTest methodsFor: 'printing' stamp: 'ssa 8/27/2009 06:59'!
printOn: aStream

	aStream nextPutAll: self shortPrintString,'(',self gradeString,')'! !

!RVMTest methodsFor: 'printing' stamp: 'ssa 8/27/2009 06:04'!
shortPrintString

	^'Testing: ',self name! !

!RVMTest methodsFor: 'assertions' stamp: 'ssa 8/27/2009 06:51'!
allAssertionsPassed

	self assertions detect:[:each| each = false] ifNone:[^true].
	^false! !

!RVMTest methodsFor: 'assertions' stamp: 'ssa 9/15/2009 16:34'!
assert: aTrueResult 

	self assert: aTrueResult ifFail: [self log: 'assertion failed']! !

!RVMTest methodsFor: 'assertions' stamp: 'dmu 12/16/2009 16:06'!
assert: aTrueResult ifFail: failBlock

	(aTrueResult = true) | (aTrueResult = false) 
		ifFalse:[self lyError:'assertion expressions result result in Booleans'].
	self assertions add: aTrueResult.
	aTrueResult ifFalse:[self class debugOnFail ifTrue:[self halt:self printString,' assertion failed']ifFalse:failBlock].
	! !

!RVMTest commentStamp: 'ssa 7/7/2010 14:09' prior: 0!
See "examples" in my class!
!RVMTest class methodsFor: 'settings' stamp: 'ssa 9/15/2009 16:28'!
debugOnFail
	"If true, then a failing assertion or failBlock execution will open a Debugger"
	
	DebugOnFail isNil ifTrue:[DebugOnFail _ false].
	^DebugOnFail! !

!RVMTest class methodsFor: 'settings' stamp: 'ssa 9/15/2009 16:29'!
debugOnFail: aBoolean
	"If true, then a failing assertion or failBlock execution will open a Debugger"
	
	DebugOnFail _ aBoolean! !

!RVMTest class methodsFor: 'quick run' stamp: 'ssa 8/27/2009 05:52'!
runSetUp: setUpBlock test: testBlock asserting: assertionBlock

	| test |
	test _ self setUp: setUpBlock test: testBlock  asserting: assertionBlock.
	^test run! !

!RVMTest class methodsFor: 'quick run' stamp: 'ssa 8/27/2009 05:51'!
runSetUp: setUpBlock test: testBlock tearDown: tearDownBlock  asserting: assertionBlock

	| test |
	test _ self setUp: setUpBlock test: testBlock tearDown: tearDownBlock asserting: assertionBlock.
	^test run! !

!RVMTest class methodsFor: 'quick run' stamp: 'ssa 8/27/2009 05:52'!
runTest: testBlock asserting: assertionBlock

	| test |
	test _ self  test: testBlock  asserting: assertionBlock.
	^test run! !

!RVMTest class methodsFor: 'quick run' stamp: 'ssa 8/27/2009 05:52'!
runTest: testBlock tearDown: tearDownBlock  asserting: assertionBlock

	| test |
	test _ self test: testBlock tearDown: tearDownBlock asserting: assertionBlock.
	^test run! !

!RVMTest class methodsFor: 'examples' stamp: 'ssa 7/7/2010 14:02'!
fullExample
	"self fullExample run"
	"Use this example as a template for your tests in subclasses of LyTestSuite in the 'tests' message category"
	| theTest |
	theTest _ RVMTest setUp: [:test| test log:'setting up for test:',test name. 
				"setUpBlocks return the test environment"
				#( 1 2 3 4 5 )]
			test:[:test :env| test log:'test:',test name,' starting...'.
				"testBlocks perform the test in the setup environment.  
				The test object is available for assertions and logging"
				test assert: (env at: 2)=2.
				test assert:(env select:[:e| e odd]) = #(1 3 5) ifFail:[test log:'odd selections failed'].
				test log:'test:',test name,' complete'.
				"the last expression result is the outcome of the test"
				env size = 5]
			tearDown:[:test :env| test log:'tearing down test:',test name.
				"tearDownBlocks do any necessary cleanup that would not otherwise be garbage collected"
				test log:'tear down complete']
			asserting:[:test :outcome| "assertionBlocks must result in True or False, and
								represent the pass/fail judgement of the test outcome" 
								"if you use  assert: or assert:ifFail: in these blocks their ANDed result
								will be ANDed to the result of this block for the final assertion"
								outcome = true "or use an expression that results in True or False"].
	theTest name: 'fullExample'.
	^theTest! !

!RVMTest class methodsFor: 'examples' stamp: 'ssa 7/7/2010 14:03'!
simpleFullExample
	"self simpleFullExample run"
	| theTest |
	theTest _ RVMTest setUp: [:test| ]
			test:[:test :env| 123]
			tearDown:[:test :env| ]
			asserting:[:test :outcome| outcome = 123].
	theTest name: 'simpleFullExample'.
	^theTest! !

!RVMTest class methodsFor: 'instance creation' stamp: 'ssa 8/27/2009 05:49'!
setUp: setUpBlock test: testBlock  asserting: assertionBlock

	^self new
		setUpBlock: setUpBlock;
		testBlock: testBlock;
		 assertionBlock: assertionBlock;
		yourself! !

!RVMTest class methodsFor: 'instance creation' stamp: 'ssa 8/27/2009 05:48'!
setUp: setUpBlock test: testBlock tearDown: tearDownBlock asserting: assertionBlock

	^self new
		setUpBlock: setUpBlock;
		testBlock: testBlock;
		tearDownBlock: tearDownBlock;
		 assertionBlock: assertionBlock;
		yourself! !

!RVMTest class methodsFor: 'instance creation' stamp: 'ssa 8/27/2009 05:50'!
test: testBlock  asserting: assertionBlock

	^self new
		testBlock: testBlock;
		 assertionBlock: assertionBlock;
		yourself! !

!RVMTest class methodsFor: 'instance creation' stamp: 'ssa 8/27/2009 05:50'!
test: testBlock tearDown: tearDownBlock asserting: assertionBlock

	^self new
		testBlock: testBlock;
		tearDownBlock: tearDownBlock;
		 assertionBlock: assertionBlock;
		yourself! !

!RVMTest class methodsFor: 'user interfacing' stamp: 'ssa 5/12/2010 10:19'!
debugOnFailSwitch
	"self debugOnFailSwitch"
	| topView |
	topView := RVMStandardSystemView new.
	topView noLabel.
	topView borderWidth:1.
	topView minimumSize: 130@30.
	topView maximumSize: 200@200.
	topView addSubView: (RVMCheckBoxView on: self label: 'LyTest debugOnFail' checkState: [self debugOnFail] whenChecked: [self debugOnFail: true] whenUnchecked: [self debugOnFail: false] monitor: true).
	topView controller open! !

!RVMTest class methodsFor: 'tests' stamp: 'ssa 7/7/2010 14:03'!
fullExampleTest
	"self fullExampleTest"
	| theTest |
	theTest _ RVMTest setUp: [:test| test log:'setting up for test:',test name.
				"setUpBlocks return the test environment"
				#( 1 2 3 4 5 )]
			test:[:test :env| test log:'test:',test name,' starting...'.
				"testBlocks perform the test in the setup environment.  
				The test object is available for assertions and logging"
				test assert: (env at: 2)=2.
				test assert:(env select:[:e| e odd]) = #(1 3 5) ifFail:[test log:'odd selections failed'].
				test log:'test:',test name,' complete'.
				"the last expression result is the outcome of the test"
				env size = 5]
			tearDown:[:test :env| test log:'tearing down test:',test name.
				"tearDownBlocks do any necessary cleanup that would not otherwise be garbage collected"
				test log:'tear down complete']
			asserting:[:test :outcome| "assertionBlocks must result in True or False, and
								represent the pass/fail judgement of the test outcome" 
								test allAssertionsPassed . " use this when using assert: or assert:ifFail:"
								outcome = true "or use an expression that results in True or False"].
	theTest name: 'fullExampleTest'.
	^theTest! !

!RVMTestResult methodsFor: 'accessing' stamp: 'ssa 8/27/2009 07:03'!
assertion
	"Answer the value of assertion"

	assertion isNil ifTrue:[self assertion: nil].
	^ assertion! !

!RVMTestResult methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:27'!
assertion: anObject
	"Set the value of assertion"

	assertion _ anObject! !

!RVMTestResult methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:17'!
result
	"Answer the value of result"

	result isNil ifTrue:[self result: nil].
	^ result! !

!RVMTestResult methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:17'!
result: anObject
	"Set the value of result"

	result _ anObject! !

!RVMTestResult methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:17'!
test
	"Answer the value of test"

	test isNil ifTrue:[self test: nil].
	^ test! !

!RVMTestResult methodsFor: 'accessing' stamp: 'ssa 8/27/2009 05:17'!
test: anObject
	"Set the value of test"

	test _ anObject! !

!RVMTestResult methodsFor: 'printing' stamp: 'ssa 8/27/2009 07:01'!
gradeString
	^self passed ifTrue:['passed']ifFalse:['failed']! !

!RVMTestResult methodsFor: 'printing' stamp: 'ssa 8/27/2009 07:01'!
printOn: aStream

	aStream nextPutAll: self gradeString, ' ',self test shortPrintString! !

!RVMTestResult methodsFor: 'testing' stamp: 'ssa 8/27/2009 06:02'!
failed

	^self assertion not! !

!RVMTestResult methodsFor: 'testing' stamp: 'ssa 8/27/2009 06:02'!
passed

	^self assertion! !

!RVMTestResult class methodsFor: 'instance creation' stamp: 'ssa 8/27/2009 05:26'!
test: aRVMTest result: anOutcome asserting: anAssertion

	^self new
		test: aRVMTest;
		result: anOutcome;
		assertion: anAssertion;
		yourself! !

!RVMTestSuite methodsFor: 'acessing' stamp: 'ssa 8/27/2009 07:07'!
results

	^self tests collect:[:test| test result]! !

!RVMTestSuite methodsFor: 'testing process' stamp: 'ssa 8/30/2009 03:50'!
failureCount
	^(self tests select:[:test| test result failed])size! !

!RVMTestSuite methodsFor: 'testing process' stamp: 'ssa 8/30/2009 03:50'!
failures
	^(self tests select:[:test| test result failed])! !

!RVMTestSuite methodsFor: 'testing process' stamp: 'ssa 8/27/2009 09:06'!
reportResults
	| passers failures |
	passers _ OrderedCollection new.
	failures _ OrderedCollection new.
	self tests do:[:test| test result passed ifTrue:[passers add: test name asSymbol]ifFalse:[failures add: test name asSymbol]].
	Transcript cr;show:'-------------------';cr;
		show: 'Results for TestSuite:';
		show: 'Summary: ',passers size printString,' passed, ',failures size printString,' failed';cr.
	failures isEmpty ifFalse:[Transcript show:'Failed tests: ',failures asArray printString;cr;
		show:'"1 systemNavigation browseAllImplementorsOfList:', failures asArray printString,' title: ''Failed Tests'' "']
		! !

!RVMTestSuite methodsFor: 'testing process' stamp: 'dmu 9/3/2010 11:43'!
run
	Transcript cr;show:'Starting run.....................'.
	self tests do:[:test|  test run].
	Transcript cr;show:'......................Ending run'.
	self reportResults! !

!RVMTestSuite methodsFor: 'accessing' stamp: 'ssa 8/27/2009 07:31'!
tests
	"Answer the value of tests"

	tests isNil ifTrue:[self tests: OrderedCollection new].
	^ tests! !

!RVMTestSuite methodsFor: 'accessing' stamp: 'ssa 8/27/2009 07:31'!
tests: anObject
	"Set the value of tests"

	tests _ anObject! !

!RVMTestSuite class methodsFor: 'instance creation' stamp: 'ssa 8/27/2009 05:35'!
tests: someTests

	^self new tests: someTests! !

!RVMTestSuite class methodsFor: 'running tests' stamp: 'ssa 8/27/2009 07:31'!
run
	"self run"
	"just run the tests in my own 'testing' message category"
	^self tests run! !

!RVMTestSuite class methodsFor: 'running tests' stamp: 'ssa 8/27/2009 07:45'!
runAll
	"self runAll"
	"just run all tests in the 'testing' message category of myself and my subclasses"
	^self testsWithSubTests run! !

!RVMTestSuite class methodsFor: 'running tests' stamp: 'ssa 8/27/2009 07:45'!
runSubs
	"self runSubs"
	"just run all tests in the 'testing' message category of my subclasses"
	^self subTests run! !

!RVMTestSuite class methodsFor: 'suite creation' stamp: 'ssa 8/27/2009 09:37'!
subTests
	"Answer a test suite built by scanning methods in my subclasses 'tests' categories"
	
	| testSelectors tests |
	tests _ OrderedCollection new.
	self allSubclassesDo:[:cls| testSelectors _ cls class organization listAtCategoryNamed: 'tests'.
		tests addAll:(testSelectors collect:[:selector| cls perform: selector])].
	^self tests: tests! !

!RVMTestSuite class methodsFor: 'suite creation' stamp: 'ssa 8/27/2009 06:57'!
tests
	"self tests"
	"Answer a test suite built by scanning methods in my 'tests' category"
	
	| testSelectors |
	testSelectors _ self  class organization listAtCategoryNamed: 'tests'.
	^self tests: (testSelectors collect:[:selector| self perform: selector])! !

!RVMTestSuite class methodsFor: 'suite creation' stamp: 'ssa 8/27/2009 08:29'!
testsWithSubTests
	"Answer a test suite built by scanning methods in my own and my subclasses 'tests' categories"
	
	| testSelectors tests |
	tests _ OrderedCollection new.
	self withAllSubclassesDo:[:cls| testSelectors _ cls class organization listAtCategoryNamed: 'tests'.
		tests addAll:(testSelectors collect:[:selector| cls perform: selector])].
	^self tests: tests! !

!RVMTestSuite class methodsFor: 'tests' stamp: 'ssa 7/7/2010 14:03'!
testFailure
	"self testFailure run"
	"A test that will always fail to ensure the system is functioning at a minimum"
	| theTest |
	theTest _ RVMTest test:[:test :env| ]
			asserting:[:test :outcome| false].
	theTest name: 'testFailure'.
	^theTest! !

!RVMTestSuite class methodsFor: 'tests' stamp: 'ssa 7/7/2010 14:03'!
testRVMTest

	^RVMTest fullExampleTest! !

!RVMTestSuite class methodsFor: 'user interface' stamp: 'ssa 8/31/2009 10:50'!
runAllButton
	"self runAllButton"
	| topView |
	topView := RVMStandardSystemView new.
	topView noLabel.
	topView borderWidth:1.
	topView minimumSize: 130@30.
	topView maximumSize: 200@200.
	topView addSubView: (RVMButtonView label:'Run All Tests' action:[self runAll]).
	topView label: 'Tester'.
	topView controller open! !

!RVMTileGridController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 16:22'!
browseAspectsForCore: coreIndex

	self view okToDisplay:true.
	RVMCoreAspectTrace monitorAllCoreAspectsForCore: coreIndex! !

!RVMTileGridController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 16:29'!
browseThisAspectForAllCores: coreIndex

	self view okToDisplay:true.
	RVMTileStripChartView openOnAspect:  self view aspect! !

!RVMTileGridController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 16:24'!
browseThisAspectForCore: coreIndex

	self view okToDisplay:true.
	RVMCoreAspectTrace monitorAspects: (Array with: self view aspect) forCore: coreIndex! !

!RVMTileGridController methodsFor: 'menu messages' stamp: 'ssa 10/4/2008 08:36'!
changeAspect: coreIndex
	| menu answer |
	menu := CustomMenu new.
	self view sample aspects
		do: [:aspect | menu add: aspect action: aspect].
	answer := menu startUp: self view aspect withCaption: 'Select the aspect to monitor'.
self view topView okToDisplay:true.
answer isNil ifTrue:[^self].
	self view aspect: answer.
	self view topView allSubViews do:[:each| each hear: nil].
	self view displayView! !

!RVMTileGridController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 00:12'!
doMessageTallyOfDisplayView
self view topView okToDisplay:true.
	MessageTally spyOn:[100 timesRepeat:[view displayView]]

! !

!RVMTileGridController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 00:12'!
inspectDataValues: coreIndex
self view topView okToDisplay:true.
	self view data inspect! !

!RVMTileGridController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 02:00'!
inspectView:coreIndex

	self view okToDisplay:true.
	self view inspect! !

!RVMTileGridController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 00:02'!
scalerForThisAspect: coreIndex

	self view okToDisplay:true.
	RVMColoredDataScalerView openOnAspect:  self view aspect! !

!RVMTileGridController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 13:10'!
coreIndexAt: aPoint

	| box |
	1 to: self view tiles size do:[:index| box _ self view tiles at: index.
		( box containsPoint: aPoint) ifTrue:[^index]]! !

!RVMTileGridController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:55'!
redButtonActivity
	| delay |
	["Color showColors: self view colors. " ^self ]value.
	Cursor move show.  Sensor waitNoButton.  Cursor normal show.
			self process isNil
				ifTrue: [
					self view showProcessOn.
					self
						process: [[((self view displayBox containsPoint: Sensor cursorPoint)
								& Sensor redButtonPressed) or:[Sensor leftShiftDown & Sensor controlKeyPressed]]
								whileFalse: [
									delay := Delay forMilliseconds: 1 * (Time millisecondsToRun: [self view displayView]).
									delay wait]].
					self process fork]
				ifFalse: [self stopDisplayProcess]! !

!RVMTileGridController methodsFor: 'controlling' stamp: 'dmu 1/1/1970 00:08'!
stopDisplayProcess
	self process terminate.
	self view showProcessOff.
	self view displayView.
	self process: nil! !

!RVMTileGridController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:11'!
yellowButtonActivity
	| menu answer coreIndex |
		coreIndex _ self coreIndexAt: Sensor cursorPoint.
		self view dontDisplayWhile:[
Sensor yellowButtonPressed 
		ifTrue: [menu := self yellowButtonMenu.
			answer := menu startUp: nil withCaption: nil at: Sensor cursorPoint.
			answer notNil ifTrue:[
				self perform: answer with: coreIndex]]]! !

!RVMTileGridController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 01:59'!
yellowButtonMenu
| menu coreIndex |
coreIndex _ self coreIndexAt: Sensor cursorPoint.
menu := CustomMenu new.
			menu add: 'change aspect' action: #changeAspect:.
			menu add: ' stripchart all aspects for core #',coreIndex printString  action: #browseAspectsForCore:.
			menu add: 'stripchart this aspect for core #',coreIndex printString action: #browseThisAspectForCore:.
			menu add: 'stripchart this aspect for all cores' action: #browseThisAspectForAllCores:.
			menu add: 'adjust scale for this aspect' action: #scalerForThisAspect:.
			menu add: 'current data values' action: #inspectDataValues:.
			menu add: 'inspect view' action: #inspectView:.
^menu
! !

!RVMTileGridController methodsFor: 'accessing' stamp: 'ssa 8/15/2008 20:14'!
process
	"Answer the value of process"

	process isNil ifTrue:[self process: nil].
	^process! !

!RVMTileGridController methodsFor: 'accessing' stamp: 'ssa 8/15/2008 20:14'!
process: anObject
	"Set the value of process"

	process := anObject! !

!RVMTileGridController methodsFor: 'initialize-release' stamp: 'ssa 8/15/2008 20:21'!
release

	self process notNil ifTrue:[self process terminate].
	super release! !

!RVMTileGridScalerView methodsFor: 'displaying' stamp: 'ssa 10/21/2008 11:32'!
displayView
	| color  |
	self okToDisplay
		ifFalse: [^ self].
	self uncache.
	self sample: nil.
	self scaler resetObservations.
	self canvas fillColor: self tileBorderColor.
	1 to: self tiles size
		do: [:index | 
			color := index > self data size
						ifTrue: [Color black]
						ifFalse: [self colors at: ((self scaler scale: (self data at: index))min: 100 max:1)].
			self canvas
				fill: (((self tiles at: index)
						translateBy: self insetDisplayBox origin negated)
						insetBy: 1 @ 1)
				fillColor: color.
			self tiles size = 1
				ifTrue: [(self data first printString asDisplayText alignedTo: #center)
						displayOn: self canvas
						at: self canvas boundingBox center]].
	self canvas displayAt: self insetDisplayBox origin! !

!RVMTileGridScalerView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 20:07'!
aspect: aSymbol.
	self scaler: nil.
	super aspect: aSymbol! !

!RVMTileGridScalerView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 20:02'!
rescaleCounter
	"Answer the value of rescaleCounter"

	rescaleCounter isNil ifTrue:[self rescaleCounter: 30].
	^ rescaleCounter! !

!RVMTileGridScalerView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 20:03'!
rescaleCounter: anObject
	"Set the value of rescaleCounter"

	rescaleCounter _ anObject ! !

!RVMTileGridScalerView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 08:46'!
scaler
	"Answer the value of scaler"

	scaler isNil ifTrue:[self scaler: (RVMMonitor scalerFor: self aspect)].
	^ scaler! !

!RVMTileGridScalerView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 08:45'!
scaler: anObject
	"Set the value of scaler"

	scaler _ anObject! !

!RVMTileGridScalerView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:11'!
typeLabel

	^'Abs: '! !

!RVMTileGridScalerView methodsFor: 'listening' stamp: 'ssa 11/4/2008 15:37'!
hear: someObject

	"self rescaleCounter: self rescaleCounter - 1.
	self rescaleCounter = 0 ifTrue:[self rescaleCounter:nil.  
		self scaler resetScaling]. "
	self sample: nil.
	self topView isCollapsed ifFalse:[self displayView]! !

!RVMTileGridScalerView class methodsFor: 'examples' stamp: 'ssa 11/4/2008 20:15'!
example
	"RVMTileGridScalerView example"
	
	| topView v scaleWidth |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	scaleWidth _ 70.
	topView minimumSize: 200+scaleWidth@200.
	topView maximumSize: 460@400.
	topView addSubView: (v := self new) viewport: (scaleWidth@0 extent: 200@200).
	topView addSubView: (RVMColorScaleView aspectSource: [v aspect] scalerSource: [v scaler] colorsSource: [v colors reverse] orientation: #vertical forView: v adjustScaler: true) viewport:(0@0 extent:scaleWidth@200).
	topView label: v typeLabel,v aspect.
	topView controller open! !

!RVMTileGridView methodsFor: 'autoscaling' stamp: 'ssa 10/1/2008 09:09'!
autoscale
	"Adjust my scale so that it fits the data."
	self minValue: self data min.
	self maxValue: self data max.
	self scale:nil! !

!RVMTileGridView methodsFor: 'updating' stamp: 'ssa 1/1/1970 00:34'!
hear: someObject

	self sample: nil.
	self topView isCollapsed ifFalse:[self displayView]! !

!RVMTileGridView methodsFor: 'updating' stamp: 'ssa 10/3/2008 19:33'!
newFrame

	self canvas: nil.
	self displayView! !

!RVMTileGridView methodsFor: 'updating' stamp: 'ssa 8/19/2008 18:25'!
unlock

	super unlock.
	self tiles:nil
! !

!RVMTileGridView methodsFor: 'controller access' stamp: 'ssa 1/1/1970 00:30'!
defaultControllerClass
	^RVMTileGridController! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/15/2008 16:34'!
aspect
	"Answer the value of aspect"

	aspect isNil ifTrue:[self aspect: #bytecodesPerSecond].
	^aspect! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:57'!
aspect: anObject
	"Set the value of aspect"

	aspect := anObject.
	self topView == self ifFalse:[self topView relabel: self typeLabel,anObject]! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/20/2008 14:27'!
aspects
	^self sample aspects! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 20:46'!
canvas
	canvas isNil ifTrue:[self canvas: (Form fromDisplay: self insetDisplayBox) fillWhite].
	^canvas ! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 9/24/2008 17:45'!
canvas: aForm

	canvas _ aForm! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
colors
	"Answer the value of colors"

	colors isNil ifTrue:[self colors: self makeColors].
	^colors! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/15/2008 16:20'!
colors: anObject
	"Set the value of colors"

	colors := anObject! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 09:12'!
data
	"Answer the value of data"
	data isNil ifTrue:[
		(self sample respondsTo: self aspect) ifFalse: [^ Array new: 0].
		self data: (self sample perform: self aspect)].
	^data! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 20:29'!
data: anObject
	"Set the value of data"

	data := anObject.
	data ifNotNil:[(data isKindOf: Collection) ifFalse:[data _ Array with: data]].
	data notNil ifTrue:[self autoscale]! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 5/4/2010 12:44'!
gridExtent
	"Answer the width and height of the grid of tiles that is appropriate for the  layout of cores we have"

	| total |
	total _ self data size.
	total = 1 ifTrue:[^1@1].
	total < 4 ifTrue:[^1@ total].
	total = 4 ifTrue:[^2@ 2].
	total < 16 ifTrue:[^4@ (total/4+0.5)rounded].
	"otherwise assume a Tilera 8x8 grid"
	^self sample groupStats width @ self sample groupStats height! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:23'!
makeColors

	^(Color hotColdShades: self numberOfColors) reversed! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/15/2008 16:22'!
maxValue
	"Answer the value of maxValue"

	maxValue isNil ifTrue:[self maxValue: 5000].
	^maxValue! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/15/2008 16:20'!
maxValue: anObject
	"Set the value of maxValue"

	maxValue := anObject! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/15/2008 16:22'!
minValue
	"Answer the value of minValue"

	minValue isNil ifTrue:[self minValue: 0].
	^minValue! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/15/2008 16:20'!
minValue: anObject
	"Set the value of minValue"

	minValue := anObject! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'dmu 1/1/1970 00:26'!
numberOfColors
	"Answer the value of numberOfColors"

	numberOfColors isNil ifTrue:[self numberOfColors: 100].
	^numberOfColors! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/15/2008 19:50'!
numberOfColors: anObject
	"Set the value of numberOfColors"

	numberOfColors := anObject rounded.
	self colors:nil.
	self changed:#numberOfColors! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/22/2008 09:25'!
sample
	"Answer the value of sample"

	sample isNil ifTrue:[self sample: RVMMonitor lastSample].
	^sample! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/22/2008 09:49'!
sample: anObject
	"Set the value of sample"

	sample := anObject..
	self data:nil.

! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/22/2008 10:04'!
scale
	"Answer the value of scale"

	scale isNil ifTrue:[self scale: self maxValue / self numberOfColors asFloat].
	^scale ! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:50'!
scale: anObject
	"Set the value of scale"

	scale := anObject.
	scale = 0 ifTrue: [scale := 0.01].
	self changed:#scale.
! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 10/1/2008 09:06'!
scaler
	"Answer a scaler for me as needed"
	^RVMDataScaler aspect: self aspect min: self minValue max: self maxValue! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/19/2008 18:09'!
showProcessState
	"Answer the value of showProcessState"

	showProcessState isNil ifTrue:[self showProcessState: false].
	^showProcessState! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/19/2008 18:08'!
showProcessState: anObject
	"Set the value of showProcessState"

	showProcessState := anObject! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:13'!
tiles
	"Answer the value of tiles"
	tiles isNil ifTrue:[self tiles: (self insetDisplayBox subDivideRoundedBy: 
		(self data size > 1 ifTrue:[self sample groupStats width @ self sample groupStats height]ifFalse:[1@1]))].
	^tiles! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 8/15/2008 11:56'!
tiles: anObject
	"Set the value of tiles"

	tiles := anObject! !

!RVMTileGridView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:58'!
typeLabel

	^'Rel: '! !

!RVMTileGridView methodsFor: 'displaying' stamp: 'ssa 11/4/2008 15:47'!
displayView
	| color colorIndex |
	self okToDisplay ifFalse:[^self].
	self uncache.
	self sample: nil.
 	
self canvas fillColor: self tileBorderColor.

	1 to: self tiles size do:[:index|
		color := index > self data size 
				ifFalse:[
					colorIndex _ (((self data at: index) / self scale)min: self numberOfColors max: 1) rounded.
					self colors at: colorIndex]
				ifTrue:[Color black].
				self canvas fill: (((self tiles at: index) translateBy: self insetDisplayBox origin negated)insetBy:1@1) fillColor: color .
		self tiles size = 1 ifTrue:[(self data first printString asDisplayText alignedTo:#center)displayOn: self canvas at: self canvas boundingBox  center].
		
		].
self canvas displayAt: self insetDisplayBox origin
! !

!RVMTileGridView methodsFor: 'displaying' stamp: 'ssa 11/4/2008 20:41'!
redrawOnCanvas
	"do nothing"! !

!RVMTileGridView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 01:42'!
tileBorderColor

	^Color darkGray! !

!RVMTileGridView class methodsFor: 'examples' stamp: 'ssa 11/4/2008 20:17'!
example
	"RVMTileGridView example"
	
	| topView v scaleWidth |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	scaleWidth _ 70.
	topView minimumSize: 200+scaleWidth@200.
	topView maximumSize: 460@400.
	topView addSubView: (v := self new) viewport: (scaleWidth@0 extent: 200@200).
	topView addSubView: (RVMColorScaleView aspectSource: [v aspect] scalerSource: [v scaler] colorsSource: [v colors reverse] orientation: #vertical  forView: v adjustScaler: false) viewport:(0@0 extent:scaleWidth@200).
	topView label: v typeLabel,v aspect.
	topView controller open! !

!RVMTileGridView class methodsFor: 'instance creation' stamp: 'ssa 8/15/2008 16:36'!
aspect: aMessageSelector numberOfColors: numColors minValue: minValue maxValue: maxValue
	"Answer a new view with these params"
	
	| view |
	view := self new.
	view 
		aspect: aMessageSelector;
	 	numberOfColors: numColors;
		minValue: minValue;
		maxValue: maxValue.
	^view! !

!RVMTileGridView class methodsFor: 'accessing' stamp: 'ssa 11/4/2008 20:19'!
adjustScaler

	^false! !

!RVMTileStripChartController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 15:14'!
eraseStrip: coreIndex

	self view eraseStrip! !

!RVMTileStripChartController methodsFor: 'menu messages' stamp: 'ssa 1/1/1970 01:40'!
redraw: coreIndex
	self view okToDisplay: true.
	self view redrawOnCanvas.
	self view displayView! !

!RVMTileStripChartController methodsFor: 'menu messages' stamp: 'ssa 10/3/2008 21:43'!
rescale: coreIndex
	self view okToDisplay: true.
	self view rescale.
	self view displayView! !

!RVMTileStripChartController methodsFor: 'menu messages' stamp: 'ssa 10/3/2008 21:27'!
yellowButtonMenu

	| menu |
	menu _ super yellowButtonMenu.
	menu add: 'erase strip' action: #eraseStrip:.
	menu add: 'redraw' action: #redraw:.
	menu add: 'rescale' action: #rescale:.
	^menu! !

!RVMTileStripChartController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 16:20'!
coreIndexAt: aPoint

	| p |
	p _ aPoint y - self view insetDisplayBox origin y // self view boxSize.
	^p max:1! !

!RVMTileStripChartScalerView methodsFor: 'displaying' stamp: 'ssa 10/3/2008 21:02'!
drawOnCanvas
	| color  |
	self canvas displayOn: self canvas at: self boxSize negated @0.
1 to: self count do:[:index|
	color := self colors at: ((self scaler scale:(self data at: index))  min:  self numberOfColors max:1).
		self canvas fill: ((self boxes at: index) translateBy: self insetDisplayBox origin negated )fillColor: color].
! !

!RVMTileStripChartScalerView methodsFor: 'displaying' stamp: 'ssa 10/28/2008 20:51'!
redrawOnCanvas
	| color x |
	[#redrawScaler print].
	self canvas fillWhite.
	x _ 0.
	self previousData asOrderedCollection reversed do:[:oldData|
	1 to: self count do: [:index | 
			color := self colors at: ((self scaler scale:(oldData at: index))  min:  self numberOfColors max:1).
			self canvas
				fill: ((self boxes at: index)
						translateBy: self insetDisplayBox origin negated - (x@0))
				fillColor: color].
			x _ x + self boxSize]! !

!RVMTileStripChartScalerView methodsFor: 'scaling' stamp: 'ssa 10/6/2008 16:30'!
rescale
	"Reset the scaler and pass the previous data thorugh it to find the min/max.
	Then redraw"
	[#rescaling print].
	self scaler resetScaling.
	self previousData do:[:dats| dats do:[:d| scaler scale: d]].
	self scaler resetOutOfRangeDetector.
		self redrawOnCanvas! !

!RVMTileStripChartScalerView methodsFor: 'listening' stamp: 'ssa 11/4/2008 19:50'!
hear: someObject

	self sample: nil.
	"self rescaleCounter: self rescaleCounter - 1.
	self rescaleCounter = 0 ifTrue:[self rescaleCounter:nil.  
		self rescale]. 
	self scaler outOfRangeDetected 
		ifTrue:[[('out of range = ',self scaler lastObserved printString) print].
			self rescale]."
	self drawOnCanvas.
	self topView isCollapsed ifFalse:[self displayView].
! !

!RVMTileStripChartScalerView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 21:06'!
aspect: aSymbol.
	self scaler: nil.
	super aspect: aSymbol! !

!RVMTileStripChartScalerView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 20:51'!
rescaleCounter
	"Answer the value of rescaleCounter"

	rescaleCounter isNil ifTrue:[self rescaleCounter: 1].
	^ rescaleCounter! !

!RVMTileStripChartScalerView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 22:09'!
rescaleCounter: anObject
	"Set the value of rescaleCounter"

	rescaleCounter _ anObject ! !

!RVMTileStripChartScalerView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 21:04'!
scaler
	"Answer the value of scaler"

	scaler isNil ifTrue:[self scaler: (RVMMonitor scalerFor: self aspect)].
	^ scaler! !

!RVMTileStripChartScalerView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 21:03'!
scaler: anObject
	"Set the value of scaler"

	scaler _ anObject! !

!RVMTileStripChartScalerView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:16'!
typeLabel

	^'Abs: '! !

!RVMTileStripChartScalerView class methodsFor: 'accessing' stamp: 'ssa 11/4/2008 20:20'!
adjustScaler

	^true! !

!RVMTileStripChartView methodsFor: 'displaying' stamp: 'ssa 10/21/2008 11:32'!
displayView
	self okToDisplay ifFalse:[^self].
	self uncache.
	self canvas displayOn: Display at: self insetDisplayBox origin clippingBox: self insetDisplayBox.! !

!RVMTileStripChartView methodsFor: 'displaying' stamp: 'ssa 10/3/2008 20:47'!
drawOnCanvas
	| color colorIndex |
	[#draw print].
	self canvas displayOn: self canvas at: self boxSize negated @ 0.
	1 to: self count do: [:index | 
			colorIndex := ((self data at: index)
						/ self scale min: self numberOfColors max: 1) rounded.
			color := self colors at: colorIndex.
			self canvas
				fill: ((self boxes at: index)
						translateBy: self insetDisplayBox origin negated)
				fillColor: color]! !

!RVMTileStripChartView methodsFor: 'displaying' stamp: 'ssa 1/1/1970 01:38'!
eraseStrip
	self previousData:nil.
	self canvas fillWhite.
	
	self displayView! !

!RVMTileStripChartView methodsFor: 'displaying' stamp: 'ssa 10/3/2008 20:27'!
redrawOnCanvas
	| color colorIndex x |
	#redraw print.
	self canvas fillWhite.
	x _ 0.
	self previousData do:[:oldData|
	1 to: self count do: [:index | 
			colorIndex := ((oldData at: index)
						/ self scale min: self numberOfColors max: 1) rounded.
			color := self colors at: colorIndex.
			self canvas
				fill: ((self boxes at: index)
						translateBy: self insetDisplayBox origin negated - (x@0))
				fillColor: color].
			x _ x + self boxSize]! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 20:37'!
aspect: anObject
	"Set the value of aspect"

	super aspect: anObject.
	self eraseStrip! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 8/22/2008 08:48'!
box
	"Answer the value of box"

	box isNil ifTrue:[self box: (self insetDisplayBox topRight - (self boxSize @ 0) extent: self boxSize @ self insetDisplayBox height)].
	^box! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 8/22/2008 09:02'!
box: anObject
	"Set the value of box"

	box := anObject.
	self boxes:nil.
	self boxSize: nil! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 5/4/2010 15:24'!
boxSize
	"Answer the value of boxSize"

	boxSize isNil ifTrue:[self boxSize: ((self insetDisplayBox height // self count max:1)min:4)].
	^boxSize! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 8/20/2008 16:30'!
boxSize: anObject
	"Set the value of boxSize"

	boxSize := anObject! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 4/20/2010 10:23'!
boxes
	"Answer the value of boxes"

	boxes isNil ifTrue:[self boxes: (self box subDivideRoundedBy: 1@ self count)].
	^boxes! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 8/20/2008 16:30'!
boxes: anObject
	"Set the value of boxes"

	boxes := anObject! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 10/9/2008 11:42'!
chart
	"Answer the value of chart"

	chart isNil ifTrue:[self chart: (Form fromDisplay: self insetDisplayBox)].
	^chart! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 8/20/2008 16:33'!
chart: anObject
	"Set the value of chart"

	chart := anObject! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 8/20/2008 16:32'!
count
	"Answer the value of count"

	count isNil ifTrue:[self count: self data size].
	^count! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 8/20/2008 16:30'!
count: anObject
	"Set the value of count"

	count := anObject! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:36'!
data: someData

	super data: someData.
	someData notNil ifTrue:[self previousData add: someData]! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:00'!
previousData
	"Answer the value of previousData"

	previousData isNil ifTrue:[self previousData: (RVMCircularCollection new: self visibleSampleCount)].
	^previousData! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 8/20/2008 16:28'!
previousData: anObject
	"Set the value of previousData"

	previousData := anObject! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 10/3/2008 20:41'!
scale: aValue
	"Set the value of scale"

	super scale: aValue.
	"aValue isNil ifFalse:[self redrawOnCanvas]"! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 8/20/2008 17:22'!
unlock

	super unlock.
	self box:nil
! !

!RVMTileStripChartView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 01:06'!
visibleSampleCount
	"How many samples (columns of boxes) can I currently display?"
	
	^self chart boundingBox width // self boxSize! !

!RVMTileStripChartView methodsFor: 'updating' stamp: 'ssa 10/3/2008 20:34'!
hear: someObject

	self sample: nil.
	self drawOnCanvas.
	self topView isCollapsed ifFalse:[self displayView]! !

!RVMTileStripChartView methodsFor: 'updating' stamp: 'ssa 1/1/1970 00:10'!
newFrame

	super newFrame.
	self canvas:nil.
	self box: nil! !

!RVMTileStripChartView methodsFor: 'controller access' stamp: 'ssa 1/1/1970 00:30'!
defaultControllerClass
	^RVMTileStripChartController! !

!RVMTileStripChartView methodsFor: 'scaling' stamp: 'ssa 10/3/2008 22:26'!
rescale

	"do nothing"! !

!RVMTileStripChartView class methodsFor: 'examples' stamp: 'ssa 11/4/2008 20:18'!
example
	"RVMTileStripChartView example"
	
	| topView v scaleWidth stripWidth |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	scaleWidth _ 70.
	stripWidth _ 200.
	topView minimumSize: stripWidth+scaleWidth@200.
	topView maximumSize: 1000@400.
	topView addSubView: (v := self new) viewport: (scaleWidth@0 extent: stripWidth@200).
	topView addSubView: (RVMColorScaleView aspectSource: [v aspect] scalerSource: [v scaler] colorsSource: [v colors reverse] orientation: #vertical  forView: v adjustScaler: self adjustScaler) viewport:(0@0 extent:scaleWidth@200).
	topView label: v typeLabel,v aspect.
	topView controller open! !

!RVMTileStripChartView class methodsFor: 'examples' stamp: 'ssa 1/1/1970 00:16'!
example1
	"RVMTileStripChartView example1"
	
	self openOnAspect: #bytesUseds! !

!RVMTileStripChartView class methodsFor: 'scheduling' stamp: 'ssa 1/1/1970 00:16'!
openOnAspect: aSymbol
	"Open a new monitor on this aspect"
	| topView v |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 200@200.
	topView maximumSize: 600@400.
	topView insideColor: Color white.
	v := self new.
	v aspect: aSymbol.
	topView addSubView: v.
	topView label: v typeLabel,aSymbol.
	topView controller open! !

!RVMTraceUIHolderView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:37'!
stripChart
	"Answer the value of stripChart"

	^ stripChart! !

!RVMTraceUIHolderView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:37'!
stripChart: anObject
	"Set the value of stripChart"

	stripChart _ anObject! !

!RVMTraceUIHolderView methodsFor: 'controller access' stamp: 'ssa 1/1/1970 00:39'!
defaultControllerClass

	^RVMTraceUIHolderController! !

!RVMTraceUIHolderView methodsFor: 'subView inserting' stamp: 'ssa 1/1/1970 00:19'!
myControls
	"Add the button to use to modify the number of traces my stripchart uses"
	| addTraceButton removeTraceButton holder |
	addTraceButton _ RVMButtonView  label:'+' action:[self addTrace].
	removeTraceButton _ RVMButtonView  label:'-' action:[self removeTrace].
	holder _ RVMView new.
	holder addSubView: addTraceButton.
	holder addSubView: removeTraceButton toRightOf: addTraceButton.
	^holder! !

!RVMTraceUIHolderView methodsFor: 'subView inserting' stamp: 'ssa 1/1/1970 00:15'!
rebuildSubViews

	| allSubs lastGroup holder last |
	allSubs _ self stripChart traces collect:[:trace| trace allView].
	lastGroup _ nil.
	allSubs groupsOfNoMoreThan: 3 atATimeDo:[:group| 
		holder _ RVMView new.
		last _ nil.
		group do:[:v| holder addSubView: v  toRightOf: last.   last _ v].
	self addSubView:holder below: lastGroup.
	lastGroup _ holder].
! !

!RVMTraceUIHolderView class methodsFor: 'instance creation' stamp: 'ssa 1/1/1970 00:55'!
forStripChart: aViewWithTraces

	| v |
	v _ self new.
	v stripChart: aViewWithTraces.
	v rebuildSubViews.
	^v! !

!RVMValueController methodsFor: 'controlling' stamp: 'ssa 9/19/2008 11:51'!
adjustCursor
	"Show the appropriate arrow cursor"
	(Sensor cursorPoint x - self view insetDisplayBox center x )> 0 
		ifTrue:[Cursor up show]
		ifFalse:[Cursor down show].
! !

!RVMValueController methodsFor: 'controlling' stamp: 'ssa 9/19/2008 11:50'!
controlActivity
	"Show the appropriate arrow cursor, then default to other controlActivity"
	self adjustCursor.
	super controlActivity! !

!RVMValueController methodsFor: 'controlling' stamp: 'ssa 9/19/2008 11:34'!
controlTerminate
	Cursor normal show.
	super controlTerminate! !

!RVMValueController methodsFor: 'controlling' stamp: 'ssa 9/19/2008 11:49'!
redButtonActivity
	| point center delta sign delay |
	center _ self view insetDisplayBox center.
	delay _ Delay forMilliseconds: 100.
	[Sensor redButtonPressed]
		whileTrue: [self adjustCursor.
			point := Sensor cursorPoint.
			delta _ (point x - center x).
			sign _ delta < 0 ifTrue:[-1]ifFalse:[1].
			delta _ delta abs max:1.
			delta >10 ifFalse:[delta _ 1].
			self view changeValueBy: (delta * sign).
			delay wait]! !

!RVMValueController methodsFor: 'controlling' stamp: 'ssa 1/1/1970 00:15'!
yellowButtonActivity

	| result |
	self view dontDisplayWhile:[
	result _ FillInTheBlank request: 'Enter the new value' initialAnswer: self view value printString.
	result notNil ifTrue:[self view value: (Compiler evaluate: result).
		self view displayView] ]! !

!RVMValueEditorController methodsFor: 'controller access' stamp: 'ssa 10/29/2008 21:32'!
defaultControllerClass

	^RVMValueEditorController! !

!RVMValueEditorController methodsFor: 'controlling' stamp: 'ssa 11/4/2008 20:47'!
redButtonActivity

	| p wait delay |
	delay _ Delay forMilliseconds: 100.
	wait _ [Sensor leftShiftDown ifFalse:[Sensor waitNoButton] ifTrue:[delay wait]].
	p _ Sensor cursorPoint - self view insetDisplayBox origin.
	(self view lockBox containsPoint: p) ifTrue:[self view locked: self view locked not. self view displayView.  ^Sensor waitNoButton.].
	(self view oneBox containsPoint: p) ifTrue:[self view performOperationWith: 1.  ^wait value].
	(self view tenBox containsPoint: p) ifTrue:[self view performOperationWith: 10.  ^wait value].
	(self view hundredBox containsPoint: p) ifTrue:[self view performOperationWith: 100.  ^wait value].
	(self view zeroBox containsPoint: p) ifTrue:[^self view resetValueToZero].
	self view operations with: self view operationBoxes do:[:op :bx|
		(bx containsPoint: p) ifTrue:[self view operation: op.  ^self view displayView]]! !

!RVMValueEditorController methodsFor: 'controlling' stamp: 'ssa 11/4/2008 19:35'!
yellowButtonActivity

	| result |
	self view topView dontDisplayWhile:[
	result _ FillInTheBlank request: 'Enter the new value' initialAnswer: self view value printString.
	result notNil ifTrue:[self view value: (Compiler evaluate: result).
		self view displayView] ]! !

!RVMValueEditorView methodsFor: 'displaying' stamp: 'ssa 10/29/2008 20:27'!
closedPadlock
^((ColorForm
	extent: 14@16
	depth: 8
	fromArray: #( 0 2511181205 2912223232 0 197 2097152000 7456089 0 51549 9817545 2908582317 0 7456000 2915368960 2915893445 1895825408 9276765 3445161984 13473173 2365587456 9276813 3439329280 13473173 2365587456 7712141 3036678400 12167597 1962934272 1701414249 2171169129 1770357121 2237988864 2634354961 286331153 286331153 228392960 2702252313 421075225 286857497 834732032 3625525537 555819297 555819321 1103167488 4011402533 623191333 623984969 905641984 4012455225 892942657 1094797621 1374617600 3693688117 892679497 893995345 1241186304 4012193065 1094795573 1363752273 1375404032 3504924904 3253266652 3705461980 3704619008)
	offset: 0@0)
	colorsFromArray: #(#(1.0 1.0 1.0) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.376) #(0.972 0.972 0.376) #(0.972 0.972 0.376) #(0.972 0.972 0.376) #(0.972 0.94 0.909) #(0.972 0.94 0.909) #(0.972 0.94 0.909) #(0.972 0.94 0.909) #(0.972 0.94 0.25) #(0.972 0.94 0.25) #(0.972 0.94 0.25) #(0.972 0.94 0.25) #(0.972 0.94 0.219) #(0.972 0.94 0.219) #(0.972 0.94 0.219) #(0.972 0.94 0.219) #(0.972 0.94 0.188) #(0.972 0.94 0.188) #(0.972 0.94 0.188) #(0.972 0.94 0.188) #(0.972 0.878 0.156) #(0.972 0.878 0.156) #(0.972 0.878 0.156) #(0.972 0.878 0.156) #(0.972 0.878 0.125) #(0.972 0.878 0.125) #(0.972 0.878 0.125) #(0.972 0.878 0.125) #(0.972 0.815 0.094) #(0.972 0.815 0.094) #(0.972 0.815 0.094) #(0.972 0.815 0.094) #(0.972 0.784 0.094) #(0.972 0.784 0.094) #(0.972 0.784 0.094) #(0.972 0.784 0.094) #(0.972 0.721 0.094) #(0.972 0.721 0.094) #(0.972 0.721 0.094) #(0.972 0.721 0.094) #(0.972 0.721 0.063) #(0.972 0.721 0.063) #(0.972 0.721 0.063) #(0.972 0.721 0.063) #(0.972 0.69 0.031) #(0.972 0.69 0.031) #(0.972 0.69 0.031) #(0.972 0.69 0.031) #(0.972 0.658 0.063) #(0.972 0.658 0.063) #(0.972 0.658 0.063) #(0.972 0.658 0.063) #(0.972 0.658 0.031) #(0.972 0.658 0.031) #(0.972 0.658 0.031) #(0.972 0.658 0.031) #(0.972 0.627 0.031) #(0.972 0.627 0.031) #(0.972 0.627 0.031) #(0.972 0.627 0.031) #(0.972 0.595 0.031) #(0.972 0.595 0.031) #(0.972 0.595 0.031) #(0.972 0.595 0.031) #(0.972 0.564 0.031) #(0.972 0.564 0.031) #(0.972 0.564 0.031) #(0.972 0.564 0.031) #(0.972 0.533 0.0) #(0.972 0.533 0.0) #(0.972 0.533 0.0) #(0.972 0.533 0.0) #(0.972 0.501 0.0) #(0.972 0.501 0.0) #(0.972 0.501 0.0) #(0.972 0.501 0.0) #(0.972 0.47 0.0) #(0.972 0.47 0.0) #(0.972 0.47 0.0) #(0.972 0.47 0.0) #(0.94 0.94 0.972) #(0.94 0.94 0.972) #(0.94 0.94 0.972) #(0.94 0.94 0.972) #(0.909 0.909 0.94) #(0.909 0.909 0.94) #(0.909 0.909 0.94) #(0.909 0.909 0.94) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.69 0.501) #(0.878 0.69 0.501) #(0.878 0.69 0.501) #(0.878 0.69 0.501) #(0.878 0.658 0.345) #(0.878 0.658 0.345) #(0.878 0.658 0.345) #(0.878 0.658 0.345) #(0.878 0.658 0.313) #(0.878 0.658 0.313) #(0.878 0.658 0.313) #(0.878 0.658 0.313) #(0.847 0.847 0.878) #(0.847 0.847 0.878) #(0.847 0.847 0.878) #(0.847 0.847 0.878) #(0.847 0.784 0.721) #(0.847 0.784 0.721) #(0.847 0.784 0.721) #(0.847 0.784 0.721) #(0.847 0.784 0.69) #(0.847 0.784 0.69) #(0.847 0.784 0.69) #(0.847 0.784 0.69) #(0.815 0.815 0.847) #(0.815 0.815 0.847) #(0.815 0.815 0.847) #(0.815 0.815 0.847) #(0.815 0.627 0.282) #(0.815 0.627 0.282) #(0.815 0.627 0.282) #(0.815 0.627 0.282) #(0.784 0.595 0.282) #(0.784 0.595 0.282) #(0.784 0.595 0.282) #(0.784 0.595 0.282) #(0.784 0.595 0.25) #(0.784 0.595 0.25) #(0.784 0.595 0.25) #(0.784 0.595 0.25) #(0.753 0.753 0.784) #(0.753 0.753 0.784) #(0.753 0.753 0.784) #(0.753 0.753 0.784) #(0.753 0.721 0.721) #(0.753 0.721 0.721) #(0.753 0.721 0.721) #(0.753 0.721 0.721) #(0.721 0.721 0.784) #(0.721 0.721 0.784) #(0.721 0.721 0.784) #(0.721 0.721 0.784) #(0.721 0.721 0.753) #(0.721 0.721 0.753) #(0.721 0.721 0.753) #(0.721 0.721 0.753) #(0.721 0.501 0.156) #(0.721 0.501 0.156) #(0.721 0.501 0.156) #(0.721 0.501 0.156) #(0.721 0.47 0.125) #(0.721 0.47 0.125) #(0.721 0.47 0.125) #(0.721 0.47 0.125) #(0.69 0.69 0.753) #(0.69 0.69 0.753) #(0.69 0.69 0.753) #(0.69 0.69 0.753) #(0.69 0.658 0.658) #(0.69 0.658 0.658) #(0.69 0.658 0.658) #(0.69 0.658 0.658) #(0.658 0.658 0.721) #(0.658 0.658 0.721) #(0.658 0.658 0.721) #(0.658 0.658 0.721) #(0.658 0.658 0.69) #(0.658 0.658 0.69) #(0.658 0.658 0.69) #(0.658 0.658 0.69) #(0.627 0.533 0.501) #(0.627 0.533 0.501) #(0.627 0.533 0.501) #(0.627 0.533 0.501) #(0.627 0.533 0.47) #(0.627 0.533 0.47) #(0.627 0.533 0.47) #(0.627 0.533 0.47) #(0.627 0.408 0.125) #(0.627 0.408 0.125) #(0.627 0.408 0.125) #(0.627 0.408 0.125) #(0.627 0.345 0.063) #(0.627 0.345 0.063) #(0.627 0.345 0.063) #(0.627 0.345 0.063) #(0.595 0.595 0.69) #(0.595 0.595 0.69) #(0.595 0.595 0.69) #(0.595 0.595 0.69) #(0.564 0.564 0.658) #(0.564 0.564 0.658) #(0.564 0.564 0.658) #(0.564 0.564 0.658) #(0.533 0.533 0.595) #(0.533 0.533 0.595) #(0.533 0.533 0.595) #(0.533 0.408 0.313) #(0.533 0.408 0.313) #(0.533 0.408 0.313) #(0.533 0.408 0.313) #(0.533 0.376 0.313) #(0.533 0.376 0.313) #(0.533 0.376 0.313) #(0.533 0.376 0.313) #(0.533 0.313 0.094) #(0.533 0.313 0.094) #(0.533 0.313 0.094) #(0.533 0.313 0.094) #(0.533 0.282 0.094) #(0.533 0.282 0.094) #(0.533 0.282 0.094) #(0.533 0.282 0.094) #(0.501 0.533 0.595) #(0.501 0.533 0.595) #(0.501 0.533 0.595) #(0.501 0.533 0.595) #(0.501 0.501 0.595) #(0.501 0.501 0.595) #(0.501 0.501 0.595) #(0.501 0.501 0.595) #(0.501 0.313 0.125) #(0.501 0.313 0.125) #(0.501 0.313 0.125) #(0.501 0.313 0.125) #(0.501 0.25 0.063) #(0.501 0.25 0.063) #(0.501 0.25 0.063) #(0.47 0.282 0.094) #(0.47 0.282 0.094) #(0.47 0.282 0.094) #(0.47 0.282 0.094) #(0.47 0.25 0.094) #(0.47 0.25 0.094) #(0.47 0.25 0.094) #(0.47 0.25 0.094) #(0.47 0.25 0.063) #(0.47 0.25 0.063) #(0.47 0.25 0.063) #(0.47 0.25 0.063) #(0.47 0.219 0.063) #(0.47 0.219 0.063) #(0.47 0.219 0.063) #(0.47 0.219 0.063) #(0.0 0.0 0.0)  ))! !

!RVMValueEditorView methodsFor: 'displaying' stamp: 'ssa 11/4/2008 20:03'!
displayView

	self box.
	self okToDisplay ifFalse:[^self].
	self uncache.
	((self lastValue = self value and:[self lastOp  = self operation])and:[self lastLocked = self locked])ifFalse:[
		self drawOnCanvas].
	self canvas displayAt: self insetDisplayBox origin
! !

!RVMValueEditorView methodsFor: 'displaying' stamp: 'ssa 11/4/2008 20:03'!
drawOnCanvas

	| lock lt vt ot nt val |
	self box.
	self canvas fillWhite.
	lock _ self lockForm.
	self lastLocked: self locked.
	lock displayOn: self canvas at: self lockBox center - lock boundingBox center clippingBox: self lockBox.
	self lockBox displayOn: self canvas withBorderWidths:#(0 0 0 1).
	(lt _ (' ',label) asDisplayText) displayOn: self canvas at: self prefixBox leftCenter - (0@lt boundingBox leftCenter y) clippingBox: self prefixBox.
	self prefixBox displayOn: self canvas withBorderWidths:#(1 0 0 1).
	val _ self value.
	(vt _ val printShowingMax3Digits asDisplayText) displayOn: self canvas at: self valueBox leftCenter - vt boundingBox leftCenter clippingBox: self valueBox.
	self lastValue: val.
	self valueBox displayOn: self canvas withBorderWidths:#(0 0 0 1).
	self operationBoxes with: self operations do:[:bx :op|
			(ot _  op asString asDisplayText) displayOn: self canvas at: bx center - ot boundingBox center-(0@((#(/ + -) includes: op) ifTrue:[2]ifFalse:[1])) clippingBox: bx.
				bx displayOn: self canvas withBorderWidths:#(1 0 0 1).
				op = self operation ifTrue:[self lastOp: op.
					self canvas reverse: (bx insetBy:1)].
].
	self numberBoxes with: #(1 10 100 0) do:[:bx :num|
			(nt _  num printString asDisplayText) displayOn: self canvas at: bx center - nt boundingBox center clippingBox: bx.
			bx displayOn: self canvas withBorderWidths:#(1 0 0 1)].
	

	! !

!RVMValueEditorView methodsFor: 'displaying' stamp: 'ssa 10/29/2008 21:25'!
lockForm

	^self locked
		ifTrue:[self closedPadlock]
		ifFalse:[self openPadlock]! !

!RVMValueEditorView methodsFor: 'displaying' stamp: 'ssa 10/29/2008 20:27'!
openPadlock
^((ColorForm
	extent: 20@16
	depth: 8
	fromArray: #( 146 2861732522 2449473536 0 0 5614218 0 1841452288 0 0 12741888 3334915730 5882368 0 0 1839879626 2852126914 2852170349 0 0 2324859594 0 3396178570 0 0 2324859594 0 3396176522 0 0 1908838070 0 2995956337 0 0 0 24962 2122220133 1701143938 2122220129 0 39429 151850253 218959117 218958234 0 40461 353178901 353178901 353709502 0 54805 488447261 488447261 490028478 0 60957 556605729 556605733 1027944954 0 60961 824522037 825310525 1160859118 0 60965 825569585 1027423557 1162692090 0 60961 824524093 893732165 1162694126 0 52966 3873888954 3873888998 3873102542)
	offset: 0@0)
	colorsFromArray: #(#(1.0 1.0 1.0) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.972) #(0.972 0.972 0.376) #(0.972 0.972 0.376) #(0.972 0.972 0.376) #(0.972 0.972 0.376) #(0.972 0.94 0.25) #(0.972 0.94 0.25) #(0.972 0.94 0.25) #(0.972 0.94 0.25) #(0.972 0.94 0.219) #(0.972 0.94 0.219) #(0.972 0.94 0.219) #(0.972 0.94 0.219) #(0.972 0.94 0.188) #(0.972 0.94 0.188) #(0.972 0.94 0.188) #(0.972 0.94 0.188) #(0.972 0.878 0.156) #(0.972 0.878 0.156) #(0.972 0.878 0.156) #(0.972 0.878 0.156) #(0.972 0.878 0.125) #(0.972 0.878 0.125) #(0.972 0.878 0.125) #(0.972 0.878 0.125) #(0.972 0.815 0.094) #(0.972 0.815 0.094) #(0.972 0.815 0.094) #(0.972 0.815 0.094) #(0.972 0.784 0.094) #(0.972 0.784 0.094) #(0.972 0.784 0.094) #(0.972 0.784 0.094) #(0.972 0.721 0.094) #(0.972 0.721 0.094) #(0.972 0.721 0.094) #(0.972 0.721 0.094) #(0.972 0.721 0.063) #(0.972 0.721 0.063) #(0.972 0.721 0.063) #(0.972 0.721 0.063) #(0.972 0.69 0.031) #(0.972 0.69 0.031) #(0.972 0.69 0.031) #(0.972 0.69 0.031) #(0.972 0.658 0.063) #(0.972 0.658 0.063) #(0.972 0.658 0.063) #(0.972 0.658 0.063) #(0.972 0.658 0.031) #(0.972 0.658 0.031) #(0.972 0.658 0.031) #(0.972 0.658 0.031) #(0.972 0.627 0.031) #(0.972 0.627 0.031) #(0.972 0.627 0.031) #(0.972 0.627 0.031) #(0.972 0.595 0.031) #(0.972 0.595 0.031) #(0.972 0.595 0.031) #(0.972 0.595 0.031) #(0.972 0.564 0.031) #(0.972 0.564 0.031) #(0.972 0.564 0.031) #(0.972 0.564 0.031) #(0.972 0.533 0.0) #(0.972 0.533 0.0) #(0.972 0.533 0.0) #(0.972 0.533 0.0) #(0.972 0.501 0.0) #(0.972 0.501 0.0) #(0.972 0.501 0.0) #(0.972 0.501 0.0) #(0.972 0.47 0.0) #(0.972 0.47 0.0) #(0.972 0.47 0.0) #(0.972 0.47 0.0) #(0.94 0.94 0.972) #(0.94 0.94 0.972) #(0.94 0.94 0.972) #(0.94 0.94 0.972) #(0.909 0.909 0.94) #(0.909 0.909 0.94) #(0.909 0.909 0.94) #(0.909 0.909 0.94) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.909 0.909 0.909) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.878 0.878) #(0.878 0.69 0.501) #(0.878 0.69 0.501) #(0.878 0.69 0.501) #(0.878 0.69 0.501) #(0.878 0.658 0.345) #(0.878 0.658 0.345) #(0.878 0.658 0.345) #(0.878 0.658 0.345) #(0.878 0.658 0.313) #(0.878 0.658 0.313) #(0.878 0.658 0.313) #(0.878 0.658 0.313) #(0.847 0.847 0.878) #(0.847 0.847 0.878) #(0.847 0.847 0.878) #(0.847 0.847 0.878) #(0.847 0.784 0.721) #(0.847 0.784 0.721) #(0.847 0.784 0.721) #(0.847 0.784 0.721) #(0.847 0.784 0.69) #(0.847 0.784 0.69) #(0.847 0.784 0.69) #(0.847 0.784 0.69) #(0.815 0.815 0.847) #(0.815 0.815 0.847) #(0.815 0.815 0.847) #(0.815 0.815 0.847) #(0.815 0.815 0.847) #(0.815 0.627 0.282) #(0.815 0.627 0.282) #(0.815 0.627 0.282) #(0.815 0.627 0.282) #(0.784 0.595 0.282) #(0.784 0.595 0.282) #(0.784 0.595 0.282) #(0.784 0.595 0.282) #(0.784 0.595 0.25) #(0.784 0.595 0.25) #(0.784 0.595 0.25) #(0.784 0.595 0.25) #(0.753 0.753 0.784) #(0.753 0.753 0.784) #(0.753 0.753 0.784) #(0.753 0.753 0.784) #(0.753 0.721 0.721) #(0.753 0.721 0.721) #(0.753 0.721 0.721) #(0.753 0.721 0.721) #(0.721 0.721 0.784) #(0.721 0.721 0.784) #(0.721 0.721 0.784) #(0.721 0.721 0.784) #(0.721 0.721 0.753) #(0.721 0.721 0.753) #(0.721 0.721 0.753) #(0.721 0.721 0.753) #(0.721 0.501 0.156) #(0.721 0.501 0.156) #(0.721 0.501 0.156) #(0.721 0.501 0.156) #(0.721 0.47 0.125) #(0.721 0.47 0.125) #(0.721 0.47 0.125) #(0.721 0.47 0.125) #(0.69 0.69 0.753) #(0.69 0.69 0.753) #(0.69 0.69 0.753) #(0.69 0.69 0.753) #(0.69 0.658 0.658) #(0.69 0.658 0.658) #(0.69 0.658 0.658) #(0.69 0.658 0.658) #(0.658 0.658 0.721) #(0.658 0.658 0.721) #(0.658 0.658 0.721) #(0.658 0.658 0.721) #(0.658 0.658 0.69) #(0.658 0.658 0.69) #(0.658 0.658 0.69) #(0.658 0.658 0.69) #(0.627 0.533 0.501) #(0.627 0.533 0.501) #(0.627 0.533 0.501) #(0.627 0.533 0.501) #(0.627 0.533 0.47) #(0.627 0.533 0.47) #(0.627 0.533 0.47) #(0.627 0.533 0.47) #(0.627 0.408 0.125) #(0.627 0.408 0.125) #(0.627 0.408 0.125) #(0.627 0.408 0.125) #(0.627 0.345 0.063) #(0.627 0.345 0.063) #(0.627 0.345 0.063) #(0.627 0.345 0.063) #(0.595 0.595 0.69) #(0.595 0.595 0.69) #(0.595 0.595 0.69) #(0.595 0.595 0.69) #(0.564 0.564 0.658) #(0.564 0.564 0.658) #(0.564 0.564 0.658) #(0.564 0.564 0.658) #(0.533 0.533 0.595) #(0.533 0.533 0.595) #(0.533 0.533 0.595) #(0.533 0.533 0.595) #(0.533 0.408 0.313) #(0.533 0.408 0.313) #(0.533 0.408 0.313) #(0.533 0.408 0.313) #(0.533 0.376 0.313) #(0.533 0.376 0.313) #(0.533 0.376 0.313) #(0.533 0.376 0.313) #(0.533 0.313 0.094) #(0.533 0.313 0.094) #(0.533 0.313 0.094) #(0.533 0.313 0.094) #(0.533 0.282 0.094) #(0.533 0.282 0.094) #(0.533 0.282 0.094) #(0.533 0.282 0.094) #(0.501 0.533 0.595) #(0.501 0.533 0.595) #(0.501 0.533 0.595) #(0.501 0.533 0.595) #(0.501 0.501 0.595) #(0.501 0.501 0.595) #(0.501 0.501 0.595) #(0.501 0.501 0.595) #(0.501 0.313 0.125) #(0.501 0.313 0.125) #(0.501 0.313 0.125) #(0.501 0.313 0.125) #(0.501 0.25 0.063) #(0.501 0.25 0.063) #(0.501 0.25 0.063) #(0.501 0.25 0.063) #(0.47 0.282 0.094) #(0.47 0.282 0.094) #(0.47 0.282 0.094) #(0.47 0.282 0.094) #(0.47 0.25 0.094) #(0.47 0.25 0.094) #(0.47 0.25 0.094) #(0.47 0.25 0.094) #(0.47 0.25 0.063) #(0.47 0.25 0.063) #(0.47 0.25 0.063) #(0.47 0.25 0.063) #(0.47 0.219 0.063) #(0.47 0.219 0.063) #(0.47 0.219 0.063) #(0.47 0.219 0.063) #(0.47 0.219 0.063) #(0.0 0.0 0.0)  ))! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 19:20'!
box

	box isNil ifTrue:[self box: self canvas boundingBox].
	box extent = self insetDisplayBox extent ifFalse:[self box: self canvas boundingBox].
	^box! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/29/2008 10:43'!
box: anObject
	"Set the value of box"

	box _ anObject.
	lockBox _ prefixBox _ valueBox _ operationBox _ oneBox _ tenBox _ hundredBox _ zeroBox _ nil.! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'dmiu 4/18/2011 13:34'!
canvas
	"Answer the value of canvas"

	canvas isNil ifTrue:[self canvas: (ColorForm extent:198@26 depth: (8 min: Display depth)) fillWhite].
	^ canvas! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 19:12'!
canvas: anObject
	"Set the value of canvas"

	canvas _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:51'!
hundredBox
	"Answer the value of hundredBox"

	hundredBox isNil ifTrue:[self hundredBox: (self zeroBox topLeft - (self hundredLabel boundingBox width@0) extent: ( self hundredLabel boundingBox width @ self box height))].
	^ hundredBox! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:27'!
hundredBox: anObject
	"Set the value of hundredBox"

	hundredBox _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:50'!
hundredLabel

	^' 100 ' asDisplayText! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 20:02'!
lastLocked
	"Answer the value of lastLocked"

	lastLocked isNil ifTrue:[self lastLocked: nil].
	^ lastLocked! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 20:02'!
lastLocked: anObject
	"Set the value of lastLocked"

	lastLocked _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 19:57'!
lastOp
	"Answer the value of lastOp"

	lastOp isNil ifTrue:[self lastOp: #none].
	^ lastOp! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 19:56'!
lastOp: anObject
	"Set the value of lastOp"

	lastOp _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 19:52'!
lastValue
	"Answer the value of lastValue"

	lastValue isNil ifTrue:[self lastValue: 0.0000000000000001].
	^ lastValue! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 19:51'!
lastValue: anObject
	"Set the value of lastValue"

	lastValue _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 11/4/2008 19:43'!
lockBox
	"Answer the value of lockBox"

	lockBox isNil ifTrue:[self lockBox: (self box origin extent: (24@self box height))].
	^ lockBox! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:27'!
lockBox: anObject
	"Set the value of lockBox"

	lockBox _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/29/2008 20:29'!
lockGetter
	"Answer the value of lockGetter"

	lockGetter isNil ifTrue:[self lockGetter: nil].
	^ lockGetter! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/29/2008 20:29'!
lockGetter: anObject
	"Set the value of lockGetter"

	lockGetter _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/29/2008 20:29'!
lockSetter
	"Answer the value of lockSetter"

	lockSetter isNil ifTrue:[self lockSetter: nil].
	^ lockSetter! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/29/2008 20:29'!
lockSetter: anObject
	"Set the value of lockSetter"

	lockSetter _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/29/2008 21:37'!
locked
	| temp |
	temp _ self lockGetter isSymbol
						ifTrue:[self model perform: self lockGetter]
						ifFalse:[self lockGetter value].
	^temp! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/29/2008 20:31'!
locked: aBoolean
	"Set the value of locked"

	self lockSetter isSymbol
		ifTrue:[model perform: self lockSetter with: aBoolean]
		ifFalse:[self lockSetter value: aBoolean]! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/29/2008 07:49'!
numberBoxes
	"Answer the number boxes"
	^{self oneBox. self tenBox. self hundredBox. self zeroBox}! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:52'!
numbersBox
	"Answer the rectangle encompassing all number boxes"
	^((self zeroBox merge: self hundredBox)merge: self tenBox)merge:self oneBox! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:51'!
oneBox
	"Answer the value of oneBox"

	oneBox isNil ifTrue:[self oneBox: (self tenBox topLeft - (self oneLabel boundingBox width@0) extent: ( self oneLabel boundingBox width @ self box height))].
	^ oneBox! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:27'!
oneBox: anObject
	"Set the value of oneBox"

	oneBox _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:49'!
oneLabel

	^' 1 ' asDisplayText! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:42'!
opBox
	"Answer the value of opBox, the rectangle sized for a single operation button"

	^0@0 extent: (self box height //2) asPoint! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:39'!
operation
	"Answer the value of operation, #+, #-, #*, or #/"

	operation isNil ifTrue:[self operation: #+].
	^ operation! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:27'!
operation: anObject
	"Set the value of operation"

	operation _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:41'!
operationBox
	"Answer the value of operationBox"

	operationBox isNil ifTrue:[self operationBox: ((self numbersBox topLeft - (self opBox width * 2 @0)extent:self opBox extent * 2))].
	^ operationBox! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:27'!
operationBox: anObject
	"Set the value of operationBox"

	operationBox _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:45'!
operationBoxes
	"Answer the boxes for + * - / boxes in 
	+  |  *
	-----
	-  |  /
	order"

	^self operationBox subDivideBy: 2@2! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:47'!
operations

	^#(+ * - /)! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:37'!
postLabelBox
	"Answer the rectangle encompassing all boxes to the left of the label"
	^self operationBox merge: self numbersBox! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:35'!
preLabelBox
	"Answer the rectangle encompassing all boxes to the right of the label"
	^self lockBox merge: self prefixBox! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:53'!
prefixBox
	"Answer the value of prefixBox"

	prefixBox isNil ifTrue:[self prefixBox: (self lockBox topRight extent: (self label asDisplayText boundingBox width @ self box height))].
	^ prefixBox! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:32'!
prefixBox: anObject
	"Set the value of prefixBox"

	prefixBox _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:51'!
tenBox
	"Answer the value of tenBox"

	tenBox isNil ifTrue:[self tenBox: (self hundredBox topLeft - (self tenLabel boundingBox width@0) extent: ( self tenLabel boundingBox width @ self box height))].
	^ tenBox! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:27'!
tenBox: anObject
	"Set the value of tenBox"

	tenBox _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:50'!
tenLabel

	^' 10 ' asDisplayText! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:34'!
valueBox
	"Answer the value of valueBox"

	valueBox isNil ifTrue:[self valueBox: (self preLabelBox topRight corner: self postLabelBox bottomLeft)].
	^ valueBox! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:27'!
valueBox: anObject
	"Set the value of valueBox"

	valueBox _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:49'!
zeroBox
	"Answer the value of zeroBox"

	zeroBox isNil ifTrue:[self zeroBox: (self box topRight - (self zeroLabel boundingBox width@0) extent: ( self zeroLabel boundingBox width @ self box height))].
	^ zeroBox! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:27'!
zeroBox: anObject
	"Set the value of zeroBox"

	zeroBox _ anObject! !

!RVMValueEditorView methodsFor: 'accessing' stamp: 'ssa 10/28/2008 21:49'!
zeroLabel

	^' 0 ' asDisplayText! !

!RVMValueEditorView methodsFor: 'controller access' stamp: 'ssa 10/29/2008 21:35'!
defaultControllerClass

	^RVMValueEditorController! !

!RVMValueEditorView methodsFor: 'editing' stamp: 'ssa 10/29/2008 21:45'!
performOperationWith: aNumber
	self value: (self value perform: self operation with: aNumber).
	self displayView! !

!RVMValueEditorView methodsFor: 'editing' stamp: 'ssa 10/29/2008 21:46'!
resetValueToZero
	self value: 0.
	self displayView! !

!RVMValueEditorView class methodsFor: 'examples' stamp: 'ssa 10/29/2008 21:06'!
example
	"RVMValueEditorView example"
	| topView  |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize:200@26.
	topView maximumSize: 200@26.
	topView addSubView: self exampleInstanceMin.
	topView label: 'Value Editor'.
	topView controller open! !

!RVMValueEditorView class methodsFor: 'examples' stamp: 'ssa 10/29/2008 20:38'!
exampleInstanceMax

	| view scaler |
	scaler _ RVMMonitor scalerFor: #bytesUseds.
	view _ self  on: scaler valueGetter: [scaler max] valueSetter:[:v|scaler max:v] label:'max: '.
	view lockGetter:#maxLocked; lockSetter:#maxLocked:.
	^view! !

!RVMValueEditorView class methodsFor: 'examples' stamp: 'ssa 10/29/2008 21:06'!
exampleInstanceMin

	| view scaler |
	scaler _ RVMMonitor scalerFor: #bytesUseds.
	view _ self  on: scaler valueGetter: [scaler min] valueSetter:[:v|scaler min:v] label:'min: '.
	view lockGetter:#minLocked; lockSetter:#minLocked:.
	^view! !

!RVMValueEditorView class methodsFor: 'examples' stamp: 'ssa 10/29/2008 21:33'!
exampleMinMax
	"RVMValueEditorView exampleMinMax"
	| topView  v x |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize:200@54.
	topView maximumSize: 200@54.
	topView addSubView: (v_self exampleInstanceMin).
	topView addSubView: (x _ self exampleInstanceMax) below: v.
	topView label: 'Value Editor'.
	topView controller open! !

!RVMValueView methodsFor: 'accessing' stamp: 'ssa 9/19/2008 11:00'!
changeValueBy: delta

	self value: self value + delta.
	self displayView.! !

!RVMValueView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 20:57'!
label
	"Answer the value of label"

	label isNil ifTrue:[self label: ''].
	^ label! !

!RVMValueView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 20:57'!
label: anObject
	"Set the value of label"

	label _ anObject! !

!RVMValueView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:37'!
value
	"Answer the value of value"

	| temp |
	temp _ self valueGetter isSymbol
						ifTrue:[self model perform: self valueGetter]
						ifFalse:[self valueGetter value].
	^temp isFraction ifTrue:[temp asFloat] ifFalse:[temp]! !

!RVMValueView methodsFor: 'accessing' stamp: 'ssa 9/17/2008 14:28'!
value: anObject
	"Set the value of value"

	self valueSetter isSymbol
		ifTrue:[model perform: self valueSetter with: anObject]
		ifFalse:[self valueSetter value: anObject]! !

!RVMValueView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 21:37'!
valueGetter
	"Answer the value of valueGetter"

	valueGetter isNil ifTrue:[self valueGetter: [100 atRandom]].
	^ valueGetter! !

!RVMValueView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 21:36'!
valueGetter: anObject
	"Set the value of valueGetter"

	valueGetter _ anObject! !

!RVMValueView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 21:38'!
valueSetter
	"Answer the value of valueSetter"

	valueSetter isNil ifTrue:[self valueSetter: [:v| v print]].
	^ valueSetter! !

!RVMValueView methodsFor: 'accessing' stamp: 'ssa 9/13/2008 21:36'!
valueSetter: anObject
	"Set the value of valueSetter"

	valueSetter _ anObject! !

!RVMValueView methodsFor: 'displaying' stamp: 'ssa 10/21/2008 11:32'!
displayView

	| label1 labelForm |
	self okToDisplay ifFalse:[^self].
	self uncache.
	label1 _ ' ',self label,' ',self value printString.
	labelForm _ label1 asDisplayText.
	Display fill: self insetDisplayBox fillColor: Color white.
	labelForm displayOn: Display at: self insetDisplayBox leftCenter - labelForm boundingBox leftCenter clippingBox: self insetDisplayBox.
	"(self controller isKindOf: NoController) ifFalse:[
	Display border: (self insetDisplayBox insetBy: 1)width: 1 fillColor: self backgroundColor negated.]"
! !

!RVMValueView methodsFor: 'controller access' stamp: 'ssa 9/13/2008 20:35'!
defaultControllerClass

	^RVMValueController! !

!RVMValueView methodsFor: 'listening' stamp: 'ssa 11/4/2008 19:37'!
hear: something


	self displayView! !

!RVMValueView class methodsFor: 'instance creation' stamp: 'ssa 9/17/2008 13:52'!
on: aModel valueGetter: getterSymbolOrBlock valueSetter: setterSymbolOrBlock label: aString

	| view |
	view _ self new.
	view model: aModel.
	view valueGetter: getterSymbolOrBlock.
	view valueSetter: setterSymbolOrBlock.
	view label: aString.
	^view! !

!RVMValueView class methodsFor: 'instance creation' stamp: 'ssa 9/17/2008 14:29'!
on: aModel valueGetterOnly: getterSymbolOrBlock 

	| view |
	view _ self new.
	view model: aModel.
	view controller: NoController new.
	view valueGetter: getterSymbolOrBlock.
	view valueSetter: [:v| ].
	view label: ''.
	^view! !

!RVMValueView class methodsFor: 'examples' stamp: 'ssa 9/13/2008 20:31'!
example
	"RVMValueView example"
	| topView  |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: 100@25.
	topView maximumSize: 200@50.
	topView addSubView: self exampleInstance.
	topView label: 'Value Editor'.
	topView controller open! !

!RVMValueView class methodsFor: 'examples' stamp: 'ssa 10/29/2008 07:51'!
exampleInstance

	| view |
	view _ self  on: nil valueGetter: [100 atRandom] valueSetter:[:v|v print] label:'min: '.
	^view! !

!RVMView methodsFor: 'updating' stamp: 'ssa 1/1/1970 00:16'!
dontDisplayWhile: aBlock
	"Switch my okToDisplay flag off during this block"
	
	self okToDisplay: false.
	aBlock value.
	self okToDisplay: true.
	self displayView! !

!RVMView methodsFor: 'updating' stamp: 'ssa 10/7/2008 21:55'!
firstFrame
	"A signal from my topView that I have been reframed.
	Default is to do nothing but propagate the signal.
	Subclasses will override to react appropriately"
	self subViews do:[:each| each firstFrame]! !

!RVMView methodsFor: 'updating' stamp: 'ssa 1/1/1970 00:12'!
newFrame
	"A signal from my topView that I have been reframed.
	Default is to do nothing but propagate the signal.
	Subclasses will override to react appropriately"
	self subViews do:[:each| each newFrame]! !

!RVMView methodsFor: 'updating' stamp: 'ssa 10/21/2008 11:31'!
uncache
	(self topView isKindOf: StandardSystemView) ifTrue:[self topView uncacheBits]! !

!RVMView methodsFor: 'initialize-release' stamp: 'ssa 10/3/2008 23:24'!
initialize

	super initialize.
	self backgroundColor: Color white.
	RVMMonitor inform: self! !

!RVMView methodsFor: 'initialize-release' stamp: 'ssa 1/1/1970 00:07'!
release

	RVMMonitor forget: self.
		super release.
! !

!RVMView methodsFor: 'listening' stamp: 'ssa 1/1/1970 00:34'!
hear: aSpeaker
	"Some object I am listening to is speaking"
! !

!RVMView methodsFor: 'demonstrating' stamp: 'ssa 11/15/2008 15:43'!
demo
	"Add me to a system view and open me on the desktop"
	self demoSized: self minimumSize! !

!RVMView methodsFor: 'demonstrating' stamp: 'ssa 11/15/2008 15:42'!
demoSized: anExtent
	"Add me to a system view and open me on the desktop"
	| topView  |
	topView := RVMStandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: anExtent.
	topView addSubView: self .
	topView label: self class name,' demo'.
	topView controller open! !

!RVMView methodsFor: 'accessing' stamp: 'ssa 11/11/2008 18:24'!
controller: aController

	super controller: aController.
	aController isNil ifTrue:[self okToDisplay: false]! !

!RVMView methodsFor: 'accessing' stamp: 'ssa 11/15/2008 15:44'!
minimumSize

	^100@100! !

!RVMView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:15'!
okToDisplay
	"Answer the value of okToDisplay"

	okToDisplay isNil ifTrue:[self okToDisplay: false].
	^ okToDisplay  ! !

!RVMView methodsFor: 'accessing' stamp: 'ssa 1/1/1970 00:05'!
okToDisplay: aBoolean
	"Set the value of okToDisplay"

	okToDisplay _ aBoolean.
	self subViews do:[:v| v okToDisplay: aBoolean]! !

!RVMView methodsFor: 'testing' stamp: 'ssa 1/1/1970 00:19'!
isRVMView

	^true! !

!Random methodsFor: 'private' stamp: 'sma 5/12/2000 12:28'!
nextValue
	"This method generates random instances of Integer 	in the interval
	0 to 16r7FFFFFFF. This method does NOT update the seed; repeated sends
	answer the same value.
	The algorithm is described in detail in 'Random Number Generators: 
	Good Ones Are Hard to Find' by Stephen K. Park and Keith W. Miller 
	(Comm. Asso. Comp. Mach., 31(10):1192--1201, 1988)."

	| lo hi aLoRHi answer |
	hi _ (seed quo: q) asFloat.
	lo _ seed - (hi * q).  " = seed rem: q"  
	aLoRHi _ (a * lo) - (r * hi).
	answer _ (aLoRHi > 0.0)
		ifTrue:  [aLoRHi]
		ifFalse: [aLoRHi + m].
	^ answer! !

!RankThread methodsFor: 'accessing'!
end: val
	end := val! !

!RankThread methodsFor: 'accessing'!
id: val
	id := val! !

!RankThread methodsFor: 'accessing'!
localHist
	^localHist ! !

!RankThread methodsFor: 'accessing'!
localHist: val
	localHist := val! !

!RankThread methodsFor: 'accessing'!
rEnd
	^rEnd! !

!RankThread methodsFor: 'accessing'!
rEnd: val
	rEnd := val! !

!RankThread methodsFor: 'accessing'!
rStart
	^rStart! !

!RankThread methodsFor: 'accessing'!
rStart: val
	rStart := val! !

!RankThread methodsFor: 'accessing'!
start
	[self run] fork.! !

!RankThread methodsFor: 'accessing'!
start: val
	start := val! !

!RankThread methodsFor: 'accessing'!
state: val
	state := val! !

!RankThread methodsFor: 'as yet unclassified'!
initKeys
	| rng mySeed a x k |
	a := NPBIS amult.
	rng := NPBRandom new.
	mySeed := rng findSeedFor: (id - 1) with: numThreads of: (4 * totalKeys * 1) using: (NPBRandom seed) and: a.
	
	rng seed: mySeed.
	
	k := (maxKey / 4) asInteger.
    
	((start + numKeys) > (end + 1)) ifTrue: [self error: 'this here seems to be inconsistent'.].
	
	start to: end do: [:i |
		x := rng randlc: a.
		x := x + (rng randlc: a).
		x := x + (rng randlc: a).
		x := x + (rng randlc: a).
		keyArray at: i put: (x * k) asInteger.
		]! !

!RankThread methodsFor: 'as yet unclassified'!
step1
	"RVMTester print: 'do step 1 '."
	
	keyArray at: (Iteration + 1) put: Iteration.
	keyArray at: (1 + Iteration + (NPBISBase maxIterations)) put: (maxKey - Iteration).
	
	1 to: NPBISBase testArraySize do: [
		:i | partialVerifyVals at: i put: (keyArray at: (1 + (testIndexArray at: i)))].
	
	1 to: maxKey do: [
		:i | localHist at: i put: 0].
	
	start to: end do: [
		:i | localHist at: (1 + (keyArray at: i)) incrementBy: 1].
	
	1 to: (maxKey - 1) do: [
		:i | localHist at: (i + 1) incrementBy: (localHist at: i)]! !

!RankThread methodsFor: 'as yet unclassified'!
step2
	"RVMTester print: 'do step 2 '."
	rStart to: rEnd do: [
		:i | 1 to: numThreads do: [
			:j | masterHist at: i incrementBy: ((rankThreads at: j) localHist at: i)]]! !

!RankThread methodsFor: 'initialization'!
initializeValues: anIS
	numThreads := anIS numThreads.
	maxKey := anIS maxKey.
	
	keyArray := anIS keyArray.
	testIndexArray := anIS testIndexArray.
	masterHist := anIS masterHist.
	partialVerifyVals := anIS partialVerifyVals.
	totalKeys := anIS totalKeys.
	numKeys := (anIS numKeys / anIS numThreads * 1) asInteger.
! !

!RankThread methodsFor: 'license' stamp: 'StefanMarr 4/15/2011 17:04'!
license
	^'This code is based on the Java version of NPB3.

Permission to use, copy, distribute and modify this software for any purpose
with or without fee is hereby granted. We request, however, that all derived
work reference the NAS Parallel Benchmarks 3.0. This software is provided "as
is" without express or implied warranty.

Information on NPB 3.0, including the Technical Report NAS-02-008
"Implementation of the NAS Parallel Benchmarks in Java", original
specifications, source code, results and information on how to submit new
results, is available at:

   http://www.nas.nasa.gov/Software/NPB/'! !

!RankThread methodsFor: 'running'!
run
	[true] whileTrue: [
		"RVMOperations print: 'RankThread waiting id=.', id asString."
		self wait.
		
		self critical: [
			"RVMOperations print: 'RankThread entered run critical Id=', id asString."
					
			(state == #quit)
				ifTrue: [
					master notify. 
					^self
				]
				ifFalse: [
					self perform: state.
					master notify.
				].
		]
	]! !

!RankThread methodsFor: 'running' stamp: 'sm 6/1/2011 15:14'!
startStep: aStep
	self critical: [
		self state: aStep.
		self notify.
	].! !

!RankThread class methodsFor: 'instance variables'!
iteration
	^ Iteration! !

!RankThread class methodsFor: 'instance variables'!
iteration: val
	Iteration := val! !

!RankThread class methodsFor: 'benchmarking'!
newFor: anIS with: id start: s1 end: e1 rStart: s2 rEnd: e2
	"create new instance"

	| o |

"RVMOperations print: ('new RankThread: ', id asString, ' ', s1 asString, ' ', e1 asString, ' ', s2 asString, ' ', e2 asString)."

	o := self new.
	
	o initializeValues: anIS.
	
	o master: anIS.
	o id: id.
	o start: s1.
	o end: e1.
	o rStart: s2.
	o rEnd: e2.
	o localHist: (Array new: o maxKey).
	o state: 0.
	
	^o
"setPriority(Thread.MAX_PRIORITY);
setDaemon(true);"! !

!ReBenchHarness commentStamp: 'StefanMarr 5/16/2011 09:10' prior: 0!
The ReBenchHarness is optimized for use from the command-line.
It is especially meant to be used together with ReBench, a tool to execute and document benchmarks reproducibly.

See: https://github.com/smarr/ReBench#readme!
!ReBenchHarness class methodsFor: 'defaults'!
defaultReporter
	^ ReBenchReporter! !

!ReBenchHarness class methodsFor: 'defaults' stamp: 'sm 5/25/2011 17:06'!
defaultRunner
	^ SMarkWeakScalingRunner! !

!ReBenchHarness class methodsFor: 'helper'!
parseArguments: arguments
	| parser |
	parser := ReBenchHarnessArgumentParser new.
	parser harness: self.  
	^ parser parse: arguments.! !

!ReBenchHarness class methodsFor: 'helper' stamp: 'sm 5/25/2011 17:20'!
usageBenchmarkParameters: usage
	^ usage,		' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' inner-iterations   optional, number of iterations done by a single process', String crlf,
				' problemSize        optional, depending on benchmark for instance size of used data set', String crlf.
				! !

!ReBenchHarness class methodsFor: 'helper' stamp: 'StefanMarr 7/25/2011 23:58'!
usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name,
				' <suiteOrBenchmark> [',self withoutWeakScalingOption ,']',
				' [processes [inner-iterations [problemSize]]]', String crlf.
	usage := usage, String crlf.
	
	usage := usage, '  This harness is mostly used for weak-scalling benchmarks.', String crlf.
	usage := usage, '  Use the SMarkHarness for more general settings, it offers more options.', String crlf.
	
	usage := usage, String crlf.
	^ usage! !

!ReBenchHarness class methodsFor: 'helper'!
usageReporter: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !

!ReBenchHarness class methodsFor: 'helper'!
usageRunner: usage
	"Will rely on default, which is good for ReBench, so do not advertise option."
	^ usage! !

!ReBenchHarness class methodsFor: 'constant' stamp: 'StefanMarr 7/25/2011 23:56'!
withoutWeakScalingOption
	^  '--without-weak-scaling'! !

!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:17'!
determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		processes := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			iterations := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !

!ReBenchHarnessArgumentParser methodsFor: 'argument parsing'!
determineReporter
	reporter := harness defaultReporter new.! !

!ReBenchHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'StefanMarr 7/26/2011 00:10'!
determineRunner
	(arguments includes: ReBenchHarness withoutWeakScalingOption) ifTrue: [
		current = ReBenchHarness withoutWeakScalingOption ifTrue: [
			current := arguments at: (i + 1).
		].
		arguments remove: ReBenchHarness withoutWeakScalingOption.
		runner := harness superclass defaultRunner new.
	]
	ifFalse: [
		runner := harness defaultRunner new.
	].! !

!ReBenchHarnessArgumentParser methodsFor: 'helper' stamp: 'StefanMarr 7/26/2011 00:18'!
instructRunner
	super instructRunner.
	
	runner iterations: runner class defaultNumberOfIterations.
	
	(runner respondsTo: #innerIterations:) ifTrue: [
		runner innerIterations: iterations.
	].! !

!ReBenchReporter methodsFor: 'as yet unclassified' stamp: 'StefanMarr 5/16/2011 15:23'!
benchmarkHeader: aName
	^ self! !

!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'ssa 9/3/2008 10:48'!
assignCollapsePointFor: aSSView
	"Offer up a location along the left edge of the screen for a collapsed SSView.
	Make sure it doesn't overlap any other collapsed frames."

	| grid otherFrames y free topLeft viewBox |
	grid _ 24.  "should be mult of 8, since manual move is gridded by 8"
	aSSView isMorph ifTrue: [otherFrames := (SystemWindow windowsIn: aSSView world satisfying: [:w | true])
                            collect: [:w | w collapsedFrame]
                            thenSelect: [:rect | rect notNil].
                          viewBox := self reduceByFlaps: aSSView world viewBox]
		ifFalse: [otherFrames _ ScheduledControllers scheduledWindowControllers
					collect: [:aController | aController view collapsedFrame]
					thenSelect: [:rect | rect notNil].
				viewBox _ Display boundingBox].
	y _ viewBox top.
	[(y _ y + grid) <= (viewBox height - grid)]
		whileTrue:
		[topLeft _ viewBox left@y.
		free _ true.
		otherFrames do: [:w | free _ free & (topLeft ~= w topLeft)].
		free ifTrue: [^ topLeft]].
	"If all else fails..."
	^ 0 @ 0! !

!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'ssa 9/3/2008 11:11'!
maximumUsableArea

	| allowedArea |
	allowedArea _ Display usableArea.
  Smalltalk isMorphic ifTrue: [
    allowedArea := allowedArea intersect: ActiveWorld visibleClearArea.
  ].
	^allowedArea
! !

!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'ssa 9/3/2008 11:12'!
screenTopSetback
	Smalltalk isMorphic
		ifTrue: [^ 0]
		ifFalse: [^ 18]! !

!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'ssa 9/3/2008 11:12'!
scrollBarSetback
	Smalltalk isMorphic
		ifTrue: [^ 16 - 3]  "width = 16; inset from border by 3"
		ifFalse: [^ 24]! !

!Rectangle methodsFor: 'accessing'!
ottomLeft: aPoint
	"Set the position of the bottomLeft corner of the receiver."
	"KSC Extension"

	origin _ aPoint x @ self top.
	corner _ self right @ aPoint y! !

!Rectangle methodsFor: 'accessing'!
ottomRight: bottomRightPoint 
	"Set the position of the right corner of the bottom horizontal line of the receiver."

	corner _ bottomRightPoint! !

!Rectangle methodsFor: 'accessing' stamp: 'ssa 8/22/2009 18:02'!
corner: aPoint
	"Set the point at the bottom right corner of the receiver."

	corner _ aPoint! !

!Rectangle methodsFor: 'accessing' stamp: 'ssa 8/23/2009 14:39'!
extent: aPoint

	corner _ origin + aPoint! !

!Rectangle methodsFor: 'accessing' stamp: 'ssa 8/22/2009 16:32'!
height: heightInteger 
	"Change the receiver's bottom y to make its height 
	the argument heightInteger."

	corner y: origin y + heightInteger! !

!Rectangle methodsFor: 'accessing' stamp: 'ssa 9/2/2009 17:10'!
origin: aPoint
	"Set the point at the top left corner of the receiver."

	origin _ aPoint! !

!Rectangle methodsFor: 'accessing'!
topLeft: topLeftPoint 
	"Set the point at the top left corner of the receiver's top horizontal line."

	origin _ topLeftPoint! !

!Rectangle methodsFor: 'accessing' stamp: 'ssa 8/25/2009 14:40'!
topRight: aPoint
	"Set the position of the top right corner of the receiver."
	origin _ self left @ aPoint y.
	corner _ aPoint x @ self bottom! !

!Rectangle methodsFor: 'accessing' stamp: 'ssa 8/31/2009 16:30'!
width: widthInteger 
	"Change the receiver's right x to make its width 
	the argument widthInteger."

	corner x: origin x + widthInteger! !

!Rectangle methodsFor: 'rectangle functions' stamp: 'ssa 11/16/2008 02:34'!
asRandomPoint
	"ssa - Answer a random point that lies within my borders"
	^self origin + self extent atRandom ! !

!Rectangle methodsFor: 'rectangle functions' stamp: 'ssa 8/24/2009 09:39'!
intersect: aRectangle 
	"Answer a Rectangle that is the area in which the receiver overlaps with 
	aRectangle. Optimized for speed; old code read:
		^Rectangle 
			origin: (origin max: aRectangle origin)
			corner: (corner min: aRectangle corner)
	"
	| aPoint left right top bottom |
	aPoint _ aRectangle origin copy.
	aPoint x > origin x ifTrue:[left _ aPoint x] ifFalse:[left _ origin x].
	aPoint y > origin y ifTrue:[top _ aPoint y] ifFalse:[top _ origin y].
	aPoint _ aRectangle corner copy.
	aPoint x < corner x ifTrue:[right _ aPoint x] ifFalse:[right _ corner x].
	aPoint y < corner y ifTrue:[bottom _ aPoint y] ifFalse:[bottom _ corner y].
	^Rectangle
		origin: (left@top)
		corner: (right@bottom)
! !

!Rectangle methodsFor: 'rectangle functions' stamp: 'ssa 8/23/2009 17:07'!
selfMerge: aRectangle 
	"Alter the receiver so that it contains both self and the argument aRectangle.  
	This is much faster than a merge: but must be used wisely since it modifies both
	the receiver and the points which make up its origin and corner."
	"KSC Extension"

	| hisOrigin hisCorner hisOriginX hisOriginY hisCornerX hisCornerY |
	hisOrigin _ aRectangle origin.
	hisCorner _ aRectangle corner.
	hisOriginX _ hisOrigin x. hisOriginY _ hisOrigin y.
	hisCornerX _ hisCorner x. hisCornerY _ hisCorner y.
	origin x > hisOriginX ifTrue: [origin x: hisOriginX].
	origin y > hisOriginY ifTrue: [origin y: hisOriginY].
	corner x < hisCornerX ifTrue: [corner x: hisCornerX].
	corner y < hisCornerY ifTrue: [corner y: hisCornerY].! !

!Rectangle methodsFor: 'rectangle functions' stamp: 'ssa 8/15/2008 11:39'!
subDivideBy: aPoint
	"Answer a collection of rectangles which divide the receiver evenly into aPoint x columns and aPoint y rows.  Answer the new rectangles left to right then down.  Yes, this method could be much shorter, but I tried to minimize duplications of arithmetic for efficiency."
	"(0@0 corner: 100@100) subDivideBy: 4@2"
	
	| rows columns eachWidth eachHeight subRegions rowTop baseIndex myLeft rowBottom columnLeft columnRight |
	columns _ aPoint x.
	rows _ aPoint y.
	eachWidth _ self width / columns.
	eachHeight _ self height / rows.
	subRegions _ Array new: columns * rows.
	rowTop _ self top.
	baseIndex _ 0.
	myLeft _ self left.
	1 to: rows do: [:rowNumber |
		rowBottom _ rowTop + eachHeight.
		columnLeft _ myLeft.
		columnRight _ columnLeft + eachWidth.
		1 to: columns do: [:columnNumber |
			subRegions 
				at: baseIndex + columnNumber
				put: (self species origin: columnLeft @ rowTop corner: columnRight @ rowBottom).
			columnLeft _ columnRight.
			columnRight _ columnRight + eachWidth].
		rowTop _ rowBottom.
		rowBottom _ rowBottom + eachHeight.
		baseIndex _ baseIndex + columns].
	^subRegions
! !

!Rectangle methodsFor: 'rectangle functions' stamp: 'ssa 8/15/2008 12:24'!
subDivideRoundedBy: aPoint
	"ssa - round the orign and extent points"
	"Answer a collection of rectangles which divide the receiver evenly into aPoint x columns and aPoint y rows.  Answer the new rectangles left to right then down.  Yes, this method could be much shorter, but I tried to minimize duplications of arithmetic for efficiency."
	"(0@0 corner: 100@100) subDivideBy: 4@2"
	
	| rows columns eachWidth eachHeight subRegions rowTop baseIndex myLeft rowBottom columnLeft columnRight |
	columns _ aPoint x.
	rows _ aPoint y.
	eachWidth _ self width / columns.
	eachHeight _ self height / rows.
	subRegions _ Array new: columns * rows.
	rowTop _ self top.
	baseIndex _ 0.
	myLeft _ self left.
	1 to: rows do: [:rowNumber |
		rowBottom _ rowTop + eachHeight.
		columnLeft _ myLeft.
		columnRight _ columnLeft + eachWidth.
		1 to: columns do: [:columnNumber |
			subRegions 
				at: baseIndex + columnNumber
				put: (self species origin: columnLeft @ rowTop corner: columnRight @ rowBottom) rounded.
			columnLeft _ columnRight.
			columnRight _ columnRight + eachWidth].
		rowTop _ rowBottom.
		rowBottom _ rowBottom + eachHeight.
		baseIndex _ baseIndex + columns].
	^subRegions
! !

!Rectangle methodsFor: 'transforming' stamp: 'ssa 8/25/2009 14:24'!
fastMoveBy: aPoint 
	"Change the corner positions of the receiver so that its area translates by
	the amount defined by the argument, aPoint.  
	This is much faster than a merge: but must be used wisely since it modifies both
	the receiver and the points which make up its origin and corner."

	origin moveBy: aPoint.
	corner moveBy: aPoint! !

!Rectangle methodsFor: 'transforming' stamp: 'ssa 8/25/2009 14:09'!
moveBy: aPoint 
	"Change the corner positions of the receiver so that its area translates by
	the amount defined by the argument, aPoint."

	origin _ origin + aPoint.
	corner _ corner + aPoint! !

!Rectangle methodsFor: 'transforming' stamp: 'ssa 8/25/2009 14:09'!
moveTo: aPoint 
	"Change the corners of the receiver so that its top left position is aPoint."

	corner _ corner + aPoint - origin.
	origin _ aPoint! !

!Rectangle methodsFor: 'transforming' stamp: 'ssa 10/8/2008 17:52'!
newRectButtonPressedDo: newRectBlock 
	"Track the outline of a new rectangle until mouse button 
	changes. newFrameBlock produces each new rectangle from the 
	previous. Only tracks while mouse is down."
	| rect newRect buttonNow delay |
	delay _ Delay forMilliseconds: 10.
	buttonNow _ Sensor anyButtonPressed.
	rect _ self.
	Display
		border: rect
		width: 2
		rule: Form reverse
		fillColor: Color gray.
	[buttonNow]
		whileTrue: ["delay wait."
			buttonNow _ Sensor anyButtonPressed.
			newRect _ newRectBlock value: rect.
			newRect = rect
				ifFalse: [Display
						border: rect
						width: 2
						rule: Form reverse
						fillColor: Color gray.
					Display
						border: newRect
						width: 2
						rule: Form reverse
						fillColor: Color gray.
					rect _ newRect]].
	Display
		border: rect
		width: 2
		rule: Form reverse
		fillColor: Color gray.
	" pay the price for reading the sensor directly ; get this party started "
	Smalltalk isMorphic
		ifTrue: [].
	Sensor processEvent: Sensor createMouseEvent.
	^ rect! !

!Rectangle methodsFor: 'transforming' stamp: 'ssa 10/8/2008 17:49'!
newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow delay |
	delay _ Delay forMilliseconds: 10.
	buttonStart _ buttonNow _ Sensor anyButtonPressed.
	rect _ self.
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	[buttonNow == buttonStart] whileTrue: 
		["delay wait."
		buttonNow _ Sensor anyButtonPressed.
		newRect _ newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.
			rect _ newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	" pay the price for reading the sensor directly ; get this party started "

	Sensor processEvent: Sensor createMouseEvent.
	^ rect! !

!Rectangle methodsFor: 'transforming' stamp: 'ssa 8/27/2008 04:43'!
scaleByRect: scale 
	"Answer a Rectangle scaled by scale, a rectangle."

	^Rectangle origin: origin * scale origin corner: corner * scale corner! !

!Rectangle methodsFor: 'displaying' stamp: 'ssa 10/29/2008 20:57'!
display

	| quad |
	quad _ Quadrangle region: self borderWidth: 1 borderColor: Color black insideColor: nil.
	quad display! !

!Rectangle methodsFor: 'displaying' stamp: 'ssa 11/4/2008 19:15'!
displayOn: aDisplayMedium withBorderWidths: anArray
	"Rectangle fromUser displayOn: Display withBorderWidths:#(16 8 4 1)"
	"anArray = #(left top right bottom ) integers"

	| quad |
	quad _ Quadrangle region: self borderWidth: ((anArray at:1)@(anArray at:2) corner: (anArray at:3)@(anArray at:4))borderColor: Color black insideColor: nil.
	quad displayOn: aDisplayMedium! !

!Rectangle methodsFor: 'displaying' stamp: 'ssa 11/4/2008 19:16'!
displayWithBorderWidths: anArray
	"Rectangle fromUser displayWithBorderWidths:#(16 8 4 1)"
	"anArray = #(left top right bottom ) integers"

	self displayOn: Display withBorderWidths: anArray! !

!Rectangle methodsFor: 'sizing - Louvre' stamp: 'ssa 12/5/2009 08:28'!
size

	^self extent! !

!RemoteString methodsFor: 'accessing' stamp: 'dmu 9/7/2010 17:19'!
text 
	"Answer the receiver's string asText if remote files are enabled."
	| theFile theText |
	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].
	theFile _ SourceFiles at: sourceFileNumber.		theFile safelyDo: [
		theFile position: filePositionHi.
		theText _ theFile nextChunkText].
	^theText! !

!RemoteString methodsFor: 'private' stamp: 'dmu 9/7/2010 14:23'!
string: aString onFileNumber: fileNumber
	"Store this as my string if source files exist."
	| theFile |
	(SourceFiles at: fileNumber) == nil ifFalse: 
		[theFile _ SourceFiles at: fileNumber.
		theFile safelyDo: [
			theFile setToEnd; cr.
			self string: aString onFileNumber: fileNumber toFile: theFile]
		]! !

!RenaissanceTransporter methodsFor: 'initializing' stamp: 'sm 7/8/2011 23:17'!
initialize
	self
		initializePackage;
		initializeTeam;
		initializePreambleAndPostscript.
		
	subTransporters := { 
		MSWLookTransporter new.
		Transporter forPackage: (PackageInfo named: 'Ly').
		SlyTransporter new. }! !

!RenaissanceTransporter methodsFor: 'initializing' stamp: 'sm 3/11/2011 12:11'!
initializePackage
	self package: (CompositePackageInfo new
					name: 'Renaissance';
					packages: {
						"RVMBootstrapPackage new."
						PackageInfo named: 'RVM'.
						PackageInfo named: 'DMU'.
					};
					yourself).
! !

!RenaissanceTransporter methodsFor: 'initializing' stamp: 'ads 1/24/2011 14:52'!
initializePreambleAndPostscript
	self
		preambleBlock: [:file | RVMBootstrapPackage new saveTrickyModificationsToFile: file];
		postscriptBlock: [:file | 	file nextPutAll: '(ChangeSorter basicNewChangeSet: ''New changes'') ifNotNilDo: [:cs | ChangeSet  newChanges: cs].'; cr].! !

!RenaissanceTransporter methodsFor: 'initializing' stamp: 'sm 3/7/2011 15:35'!
initializeTeam
	self team: (ProjectTeam new
				initialsOfProjectMembers: {'dmu'. 'smu'. 'ssa'. 'ads'. 'sm'. 'piv'. 'max'};
		
				"The Renaissance image is based on Squeak 3.7, which was put out in 2004; the Renaissance project started in 2007 or 2008.
				 I don't understand why some of our methods are stamped 1970, though. -- Adam"
				timestampFilter: [:t | t year > 2005 or: [t year = 1970]]; 
		
				yourself).! !

!RenaissanceTransporter methodsFor: 'removing' stamp: 'ads 1/26/2011 16:17'!
revert
	super revert.
	self team revertPackage: RVMBootstrapPackage new.! !

!RenaissanceTransporter class methodsFor: 'transporter' stamp: 'ads 2/4/2011 11:47'!
transportersForFileOutMenu
	^ { self new }! !

!ResumableTestFailure methodsFor: 'camp smalltalk'!
isResumable
	"Of course a ResumableTestFailure is resumable ;-)"

	^true! !

!ResumableTestFailure methodsFor: 'camp smalltalk'!
sunitExitWith: aValue
	self resume: aValue! !

!ResumableTestFailure commentStamp: '<historical>' prior: 0!
A ResumableTestFailure triggers a TestFailure, but lets execution of the TestCase continue. this is useful when iterating through collections, and #assert: ing on each element. in combination with methods like testcase>>#assert:description:, this lets you run through a whole collection and note which tests pass.

here''s an example:

	

	(1 to: 30) do: [ :each |
		self assert: each odd description: each printString, ' is even' resumable: true]

for each element where #odd returns <false>, the element will be printed to the Transcript. !
!ResumableTestFailureTestCase methodsFor: 'Not categorized' stamp: 'BaseSystem 8/30/2009 09:40'!
resumableTestFailureTest
	self
		assert: false description: 'You should see more than me' resumable: true; 
		assert: false description: 'You should see more than me' resumable: true; 
		assert: false description: 'You should see me last' resumable: false; 
		assert: false description: 'You should not see me' resumable: true! !

!ResumableTestFailureTestCase methodsFor: 'logging' stamp: 'BaseSystem 8/30/2009 09:40'!
logFailure: aString
	duplicateFailureLog add: aString.
	super logFailure: aString.! !

!ResumableTestFailureTestCase methodsFor: 'running' stamp: 'BaseSystem 8/30/2009 09:40'!
setUp
	duplicateFailureLog := OrderedCollection with: 'In set up'.! !

!ResumableTestFailureTestCase methodsFor: 'running' stamp: 'BaseSystem 8/30/2009 09:40'!
tearDown
	self deny: 'You should not see me' = duplicateFailureLog last
			description: 'We saw the ''You should not see me'' failure'.
	self deny: 'You should see more than me' = duplicateFailureLog last
			description: 'We did not see more than a ''You should see more than me'' failure'.! !

!ResumableTestFailureTestCase methodsFor: 'running' stamp: 'BaseSystem 8/30/2009 09:40'!
testResumable
	| result suite |
	suite := TestSuite new.
	suite addTest: (self class selector: #errorTest).
	suite addTest: (self class selector: #regularTestFailureTest).
	suite addTest: (self class selector: #resumableTestFailureTest).
	suite addTest: (self class selector: #okTest).
	result := suite run.
	self assert: result failures size = 2;
		assert: result errors size = 1! !

!ResumableTestFailureTestCase methodsFor: 'test data' stamp: 'BaseSystem 8/30/2009 09:40'!
errorTest
	1 zork! !

!ResumableTestFailureTestCase methodsFor: 'test data' stamp: 'BaseSystem 8/30/2009 09:40'!
failureTest
	self
		assert: false description: 'You should see me' resumable: true; 
		assert: false description: 'You should see me too' resumable: true; 
		assert: false description: 'You should see me last' resumable: false; 
		assert: false description: 'You should not see me' resumable: true! !

!ResumableTestFailureTestCase methodsFor: 'test data' stamp: 'BaseSystem 8/30/2009 09:40'!
okTest
	self assert: true! !

!ResumableTestFailureTestCase methodsFor: 'test data' stamp: 'BaseSystem 8/30/2009 09:40'!
regularTestFailureTest
	self assert: false description: 'You should see me'! !

!ResumableTestFailureTestCase class methodsFor: 'history' stamp: 'simon.denier 11/22/2008 22:13'!
lastStoredRun
	^ ((Dictionary new) add: (#passed->((Set new) add: #testResumable; yourself)); add: (#timeStamp->'22 November 2008 10:11:35 pm'); add: (#failures->((Set new))); add: (#errors->((Set new))); yourself)! !

!RoarTinyBench methodsFor: 'benchmarking' stamp: 'StefanMarr 11/7/2010 03:31'!
benchBytecode: iterations
	"Handy bytecode-heavy benchmark, was Integers>>benchmark"
	"(500000 // time to run) = approx bytecodes per second"
	"5000000 // (Time millisecondsToRun: [10 benchmark]) * 1000"
	"3059000 on a Mac 8100/100"
    | size flags prime k count |
    size := 8190.
    1 to: iterations do:
        [:iter |
        count := 0.
        flags := (Array new: size) atAllPut: true.
        1 to: size do:
            [:i | (flags at: i) ifTrue:
                [prime := i+1.
                k := i + prime.
                [k <= size] whileTrue:
                    [flags at: k put: false.
                    k := k + prime].
                count := count + 1]]].
    ^ count! !

!RoarTinyBench methodsFor: 'benchmarking' stamp: 'StefanMarr 11/7/2010 03:34'!
benchFib: n
	"Handy send-heavy benchmark, was Integer>>benchFib"
	"(result // seconds to run) = approx calls per second"
	" | r t |
	  t := Time millisecondsToRun: [r := 26 benchFib].
	  (r * 1000) // t"
	"138000 on a Mac 8100/100"
	^ n < 2
		ifTrue: [1] 
		ifFalse: [(self benchFib: (n-1)) + (self benchFib: (n-2)) + 1]
! !

!RoarTinyBench methodsFor: 'benchmarking' stamp: 'StefanMarr 1/15/2011 22:53'!
startBenchmarkAndWaitForCompletion
	RVMOperations print: (self tinyBenchmarksParallel)! !

!RoarTinyBench methodsFor: 'benchmarking' stamp: 'StefanMarr 11/7/2010 03:36'!
tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results"
	"0 tinyBenchmarks"
	"On a 292 MHz G3 Mac: 22727272 bytecodes/sec; 984169 sends/sec"
	"On a 400 MHz PII/Win98:  18028169 bytecodes/sec; 1081272 sends/sec"
	| t1 t2 r n1 n2 |
	n1 := 1.
	[t1 := Time millisecondsToRun: [self benchBytecode: n1].
	t1 < 1000] whileTrue: [n1 := n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 := 28.
	[t2 := Time millisecondsToRun: [r := self benchFib: n2].
	t2 < 1000] whileTrue: [n2 := n2 + 1]. "Note: #benchFib's runtime is about O(n^2)."

	^ ((n1 * 500000 * 1000) // t1) printString, ' bytecodes/sec; ',
	  ((r * 1000) // t2) printString, ' sends/sec'! !

!RoarTinyBench methodsFor: 'benchmarking' stamp: 'StefanMarr 1/15/2011 22:45'!
tinyBenchmarksParallel
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results"
	"0 tinyBenchmarks"
	"On a 292 MHz G3 Mac: 22727272 bytecodes/sec; 984169 sends/sec"
	"On a 400 MHz PII/Win98:  18028169 bytecodes/sec; 1081272 sends/sec"
	| t1 t2 r n1 n2 |
	
	"Determine a good problem size for the benchmark"
	n1 := 1.
	[t1 := Time millisecondsToRun: [self benchBytecode: n1].
	t1 < 1000] whileTrue: [n1 := n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	"now n1 is the value for which we do the measurement"
	t1 := Time millisecondsToRun: [self run: #benchBytecode: with: n1 times: numberOfProcesses].

	"Determine a good problem size for the benchmark"
	n2 := 28.
	[t2 := Time millisecondsToRun: [r := self benchFib: n2].
	t2 < 1000] whileTrue: [n2 := n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."
		
	"now we have our target n2 and r value.
	 lets take the time for it"
	t2 := Time millisecondsToRun: [self run: #benchFib: with: n2 times: numberOfProcesses].

	^ ((n1 * numberOfProcesses * 500000 * 1000) // t1) printString, ' bytecodes/sec; ',
	   ((r * numberOfProcesses * 1000) // t2) printString, ' sends/sec'
	   ! !

!RoarTinyBench methodsFor: 'private' stamp: 'StefanMarr 1/15/2011 22:49'!
run: aSymbol with: argument times: nTimes
	| mtx sig n |
	
	mtx := Semaphore forMutualExclusion.
	sig := Semaphore new.
	n := nTimes.

	1 to: nTimes do: [:i |
		[ aSymbol = #benchFib: 
			ifTrue: [
				self benchFib: argument.]
			ifFalse: [
				aSymbol = #benchBytecode:
					ifTrue: [
						self benchBytecode: argument]
					ifFalse: [
						self perform: aSymbol with: argument.]].
		mtx critical: [
			n := n - 1.
			(n == 0) ifTrue: [sig signal]]
		] fork
	].
	sig wait.! !

!RoarTinyBench class methodsFor: 'benchmarking' stamp: 'StefanMarr 11/7/2010 12:45'!
tinyBenchmarks
	"RoarTinyBench tinyBenchmarks"
	RVMOperations print: (self new tinyBenchmarks)! !

!RoarTinyBench class methodsFor: 'benchmarking' stamp: 'StefanMarr 11/7/2010 12:45'!
tinyBenchmarksParallel
	"RoarTinyBench tinyBenchmarksParallel"
	RVMOperations print: (self new numProcesses: 16; tinyBenchmarksParallel)! !

!RunArray methodsFor: '*RVM-Archiving-fileIn/Out'!
archiveOn: aStream
	aStream
		storeObject: self;
		storeClass: self class;
		store: runs size.
	1 to: runs size do:
		[:x |
		aStream store: (runs at: x).
		aStream nextPut: (values at: x)]! !

!RunArray class methodsFor: 'instance creation' stamp: 'ssa 9/3/2008 11:15'!
scanFrom: strm
	"Read the style section of a fileOut or sources file.  nextChunk has already been done.  We need to return a RunArray of TextAttributes of various kinds.  These are written by the implementors of writeScanOn:"
	| rr vv aa this |
	(strm peekFor: $( ) ifFalse: [^ nil].
	rr _ OrderedCollection new.
	[strm skipSeparators.
	 strm peekFor: $)] whileFalse: 
		[rr add: (Number readFrom: strm)].
	vv _ OrderedCollection new.	"Value array"
	aa _ OrderedCollection new.	"Attributes list"
	[(this _ strm next) == nil] whileFalse: [
		this == $, ifTrue: [vv add: aa asArray.  aa _ OrderedCollection new].
		this == $a ifTrue: [aa add: 
			(TextAlignment new alignment: (Integer readFrom: strm))].
		this == $f ifTrue: [aa add: 
			(TextFontChange new fontNumber: (Integer readFrom: strm))].
		this == $F ifTrue: [aa add: (TextFontReference new toFont: 
			(StrikeFont familyName: (strm upTo: $#) size: (Integer readFrom: strm)))].
		this == $b ifTrue: [aa add: (TextEmphasis bold)].
		this == $i ifTrue: [aa add: (TextEmphasis italic)].
		this == $u ifTrue: [aa add: (TextEmphasis underlined)].
		this == $= ifTrue: [aa add: (TextEmphasis struckOut)].
		this == $n ifTrue: [aa add: (TextEmphasis normal)].
		this == $- ifTrue: [aa add: (TextKern kern: -1)].
		this == $+ ifTrue: [aa add: (TextKern kern: 1)].
		this == $c ifTrue: [aa add: (TextColor scanFrom: strm)]. "color"
		this == $L ifTrue: [aa add: (TextLink scanFrom: strm)].	"L not look like 1"
	"	this == $R ifTrue: [aa add: (TextURL scanFrom: strm)]."
				"R capitalized so it can follow a number"
	"	this == $q ifTrue: [aa add: (TextSqkPageLink scanFrom: strm)]. "
	"	this == $p ifTrue: [aa add: (TextSqkProjectLink scanFrom: strm)]. "
		this == $P ifTrue: [aa add: (TextPrintIt scanFrom: strm)].
		this == $d ifTrue: [aa add: (TextDoIt scanFrom: strm)].
		"space, cr do nothing"
		].
	aa size > 0 ifTrue: [vv add: aa asArray].
	^ self runs: rr asArray values: vv asArray
"
RunArray scanFrom: (ReadStream on: '(14 50 312)f1,f1b,f1LInteger +;i')
"! !

!RunArray class methodsFor: '*RVM-Archiving-instance creation'!
archiveVersion
	^3! !

!RunArray class methodsFor: '*RVM-Archiving-instance creation'!
dearchive2From: aStream
	| anInteger  runs values |
	anInteger _ aStream read: Integer.
	runs _ Array new: anInteger.
	values _ Array new: anInteger.
	1 to: anInteger do:
		[:x |
		runs at: x put: (aStream read: Integer).
		values at: x put: aStream next].
	^self runs: runs values: values! !

!RunArray class methodsFor: '*RVM-Archiving-instance creation'!
dearchive: versionNumber from: aStream
	| anInteger  runs values |
	versionNumber = 1 ifTrue:
		[anInteger _ aStream read: Integer.
		runs _ Array new: anInteger.
		values _ Array new: anInteger.
		1 to: anInteger do:
			[:x |
			runs at: x put: (aStream read: Integer).
			values at: x put: (aStream read: Integer)].
		^self runs: runs values: values].
	versionNumber = 2 ifTrue: 
		[^self dearchive2From: aStream].
	versionNumber = self archiveVersion ifTrue:
		[^self dearchiveFrom: aStream].
	self error: 'Can''t dearchive this version.'! !

!RunArray class methodsFor: '*RVM-Archiving-instance creation'!
dearchiveFrom: aStream

	| anObject anInteger runs values |
	anObject _ self basicNew.
	aStream storeObject: anObject.
	anInteger _ aStream read: Integer.
	runs _ Array new: anInteger.
	values _ Array new: anInteger.
	1 to: anInteger do:
		[:x |
		runs at: x put: (aStream read: Integer).
		values at: x put: aStream next].
	^anObject setRuns: runs setValues: values! !

!SMarkAutosizeRunner methodsFor: 'initialization' stamp: 'StefanMarr 3/19/2011 19:59'!
initialize
	super initialize.
	targetTime := self class defaultTargetTime.! !

!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:27'!
performBenchmark: aSelector
	"First determine a useful number of inner loop iterations until the targetTime is reached."
	| execTime i |
	"make sure no timers are recorded for this"
	timers := nil.
	
	i := 1.
	execTime := Time millisecondsToRun: [ suite perform: aSelector. ].
	
	[ execTime > targetTime ] whileFalse: [
		i := i * 2. "Was thinking of doing something fancy here, but just go with this simple staight-forward solution"
		execTime := Time millisecondsToRun: [ 1 to: i do: [:ignored| suite perform: aSelector]].
	].

	innerLoopIterations := i.
	
	"Then start executing the benchmark"
	^ super performBenchmark: aSelector.! !

!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:49'!
runBaseBenchmark
	"baseBenchmark is not supported with autosizing. I do not see how that can be made possible since all different benchmarks will have different number of iterations, and the only way how a consistent baseline could be found would be to normalize the results, but well, incooprorating the baseline measurement with the statistical evaluation is harder than just substracting a one time value..., I am not going to do that here for the moment. Stefan 2011-03-20"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	"I decided to go here with a silent solution to avoid thinking about logging frameworks and Transcript to console convertion..."
	self recordResults: (self class defaultTimer new: 'total') for: #baseBenchmark  ! !

!SMarkAutosizeRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 10:31'!
timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	1 to: innerLoopIterations do: [:ignored|
		suite perform: aSelector.
	].
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !

!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18'!
targetTime
	"Target time in milliseconds"
	^ targetTime! !

!SMarkAutosizeRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/19/2011 19:18'!
targetTime: anIntInMilliseconds
	"Target time in milliseconds"
	targetTime := anIntInMilliseconds! !

!SMarkAutosizeRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/19/2011 19:17'!
defaultTargetTime
	"300 milliseconds seems to be a reasonable target time for most problems.
	 It is a compromise between the general measurment noise as well as timer accuracy
	 and the absolute runtime of benchmarks"
	^ 300! !

!SMarkAutosizeRunnerTest methodsFor: 'as yet unclassified'!
runnerClass
	^ SMarkTestAutosizeRunner! !

!SMarkAutosizeRunnerTest methodsFor: 'as yet unclassified'!
testAutosizing
	"Ensure that the runtime is automatically sized up to a predefined value"
	| runner results big small runTime benchmarkSum |
	
	runner := self runnerClass new.
	
	"sanity check for target time"
	"Not checked since we reduced the targetTime for testing:
	 self assert: self runnerClass defaultTargetTime equals: runner targetTime."
	self assert: (self runnerClass defaultTargetTime > 250).
	
	runner iterations: 3.
	  
	runner suite: SMarkTestRunnerSuiteForAutosizing new.
	
	"Execute the benchmarks and take the overall time it takes"
	runTime := Time millisecondClockValue.
	results := runner execute.
	runTime := Time millisecondClockValue - runTime.
	
	"There should be three benchmarks"
	self assert: 3 equals: results size.
	self assert: (results includesKey: #baseBenchmark).
	big := results at: #Big.
	small := results at: #Small.
	
	self assert: (big respondsTo: #at:).
	self assert: 3 equals: big size.
	
	self assert: (runner targetTime <= (big at: 1) total).
	self assert: (runner targetTime <= (small at: 1) total).
	
	"Calculate the sum of all measurements"
	benchmarkSum := big inject: 0 into: [:sum :result| sum + result total].
	benchmarkSum := small inject: benchmarkSum into: [:sum :result| sum + result total].
	
	"And now make sure that we not try to find the problem size for every but only the first run"
	self assert: (benchmarkSum * 2) > runTime.
	
! !

!SMarkAutosizeRunnerTest methodsFor: 'as yet unclassified'!
testAutosizingBaseBenchmark
	"Ensure that baseBenchmarks are not delivering any data since I do not see how that could be done nicely"
	| runner results |
	runner := self runnerClass new.
	runner iterations: 3.
	runner suite: SMarkTestRunnerSuiteForAutosizing new.
	
	"Execute the benchmarks and take the overall time it takes"
	results := runner execute.
	
	"There should be two benchmarks"
	self assert: 3 equals: results size.
	self assert: 0 equals: ((results at: #baseBenchmark) at: 1) total.
	
! !

!SMarkAutosizeRunnerTest methodsFor: 'as yet unclassified'!
testBaseBenchmark
	"Different from base test: Ensure the base benchmark is NOT executed when available"
	
	| runner |
	runner := self runnerClass execute: SMarkTestSuiteWithBaseBenchmark new.

	self deny: runner baseBenchmarkExecuted  ! !

!SMarkAutosizeRunnerTest methodsFor: 'as yet unclassified'!
testExecute
	"This test is slightly different from the one in the base class"
	| runner results performedBenchmarks |
	runner := self runnerClass new.
	runner suite: SMarkTestRunnerSuiteForPerfromBenchmark new.
	results := runner execute.
	
	performedBenchmarks := runner performedBenchmarks.
		
	self assert: 4 equals: performedBenchmarks size.				"Different from base test"
	self deny: (performedBenchmarks includes: #baseBenchmark).	"Different from base test"
	
	self assert: (results respondsTo: #at:).
	
	"But still we get a result" "Different from base test"
	self assert: (((results at: #baseBenchmark) at: 1) isKindOf: SMarkResult).! !

!SMarkAutosizeRunnerTest methodsFor: 'as yet unclassified'!
testIterations
	| runner |
	"This test is different then the one in the base class, it is not direct, but just looks at the results"
	
	" simple scenario should default to 1 run for now "
	runner := self runnerClass execute: SMarkTestRunnerSuite new.
	
	self assert: 1 equals: (runner results at: #NotifyRunner) size.
	
	" but we can also be more fancy and set the number of iterations "
	runner := self runnerClass new.
	runner suite: SMarkTestRunnerSuite new.
	
	"first check again that the default is as expected"
	self assert: 1 equals: runner iterations.  
	
	runner iterations: 10.
	self assert: runner iterations equals: 10.
	
	runner execute.
	
	self assert: 10 equals: (runner results at: #NotifyRunner) size.! !

!SMarkAutosizeRunnerTest class methodsFor: 'as yet unclassified'!
shouldInheritSelectors
	^ true! !

!SMarkCompiler methodsFor: 'benchmarking'!
benchCompiler
	"was Benchmark>>testCompiler"
	SMarkCompilerTargetClass new compile:
		'somethingDummy: aBlock repeated: nTimes | i emptyBlock emptyTime blockTime |
		nTimes > 1000 ifTrue: [^self time: aBlock repeatedK: nTimes // 1000].
		emptyBlock := [].
		emptyTime := Time millisecondsToRun:
						[i := 0.
						 [(i := i + 1) <= nTimes] whileTrue: [emptyBlock value]].
		blockTime := Time millisecondsToRun:
						[i := 0.
						 [(i := i + 1) <= nTimes] whileTrue: [aBlock value]].
		^blockTime - emptyTime'.! !

!SMarkCompiler class methodsFor: 'script entry'!
defaultNumberOfIterations
	^ 50! !

!SMarkCompiler class methodsFor: 'script entry'!
defaultNumberOfProcesses
	^ 8! !

!SMarkCompilerTargetClass methodsFor: 'compiling'!
acceptsLoggingOfCompilation
	"Answer whether the receiver's method submisions and class defintions should be logged to the changes file and to the current change set."

	^ false! !

!SMarkCompilerTargetClass methodsFor: 'accessing method dictionary'!
addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor
	| priorMethodOrNil oldProtocol newProtocol |
	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [nil].
	self addSelectorSilently: selector withMethod: compiledMethod.
	oldProtocol := self organization categoryOfElement: selector.
	SystemChangeNotifier uniqueInstance 
		doSilently: [self organization classify: selector under: aCategory].
	newProtocol := self organization categoryOfElement: selector.! !

!SMarkCompilerTargetClass methodsFor: 'initialization' stamp: 'sm 1/17/2011 09:38'!
initialize
	super initialize.
	self methodDictionary: MethodDictionary new.! !

!SMarkHarness commentStamp: 'StefanMarr 3/12/2011 21:12' prior: 0!
A benchmark harness stears the execution and reporting of benchmarks.
For that purpose, it will use a designated benchmark runner to do the execution and a benchmark reporter to output the results.
The benchmark harness is also parameterized by the benchmark suites that are to be executed.!
!SMarkHarness class methodsFor: 'defaults'!
defaultOutputDestination
	^ Smalltalk at:       #ScriptConsole
	            ifAbsent: [SMarkReporter defaultOutputDestination]! !

!SMarkHarness class methodsFor: 'defaults'!
defaultReporter
	^ SMarkReporter defaultReporter! !

!SMarkHarness class methodsFor: 'defaults'!
defaultRunner
	^ SMarkSuite defaultRunner! !

!SMarkHarness class methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 17:41'!
execute: runner andReport: reporter
	runner reportConfiguration: self defaultOutputDestination.
	runner execute.
	reporter runner: runner.
	reporter outputStream: self defaultOutputDestination.
	reporter report.! !

!SMarkHarness class methodsFor: 'benchmarking'!
execute: aBenchmarkOrSuite using: aRunnerClass andReport: withAReporterClass
	| parsedBenchmarkOrSuite runner reporter |
	
	parsedBenchmarkOrSuite := self parseBenchmarkOrSuite: aBenchmarkOrSuite.
	
	runner := aRunnerClass new.
	reporter := withAReporterClass new.
	self instructRunner: runner with: parsedBenchmarkOrSuite.
	self execute: runner andReport: reporter.   ! !

!SMarkHarness class methodsFor: 'helper'!
parseArguments: arguments
	| parser |
	parser := SMarkHarnessArgumentParser new.
	^ parser parse: arguments.! !

!SMarkHarness class methodsFor: 'helper'!
shouldShowUsage: arguments
	
	arguments size < 2 ifTrue: [^ true ].
	
	^ arguments anySatisfy: [:elem | (elem = '--help') or: [elem = '-?'] ].  ! !

!SMarkHarness class methodsFor: 'helper'!
usage
	| usage |
	"Example usage: SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	
	usage := self usageHeader.
	
	usage := usage, 'Arguments:', String crlf.
	usage := self usageRunner:   usage.
	usage := self usageReporter: usage.
	usage := usage, ' suiteOrBenchmark   required, either a SMarkSuite with benchmarks,', String crlf.
	usage := usage, '                              or a benchmark denoted by Suite.benchName', String crlf.
	usage := self usageBenchmarkParameters: usage.
	
	ScriptConsole print: usage.! !

!SMarkHarness class methodsFor: 'helper'!
usageBenchmarkParameters: usage
	^ usage,	' iterations         optional, number of times the benchmarks are repeated', String crlf,
				' processes          optional, number of processes/threads used by the benchmarks', String crlf,
				' problemSize        optional, depending on benchmark for instance number of', String crlf,
				'                              inner iterations or size of used data set', String crlf.
! !

!SMarkHarness class methodsFor: 'helper'!
usageHeader
	| usage |
	usage := 'SMark Benchmark Framework, version: ', self version, String crlf.
	usage := usage, String crlf.
	usage := usage, 'Usage: <vm+image> ', self name, ' [runner] [reporter] <suiteOrBenchmark>', String crlf.
	usage := usage, '                               [iterations [processes [problemSize]]]', String crlf.
	usage := usage, String crlf.
	^ usage! !

!SMarkHarness class methodsFor: 'helper'!
usageReporter: usage
	^ usage,	' reporter           optional, a SMarkReporter class that processes', String crlf,
				'                              and displays the results', String crlf.
	! !

!SMarkHarness class methodsFor: 'helper'!
usageRunner: usage
	^ usage, ' runner             optional, a SMarkRunner class that executes the benchmarks', String crlf.! !

!SMarkHarness class methodsFor: 'helper'!
version
	(Smalltalk classNamed: #ConfigurationOfBenchmarking)
		ifNotNilDo: [:cfg |
			"Make sure Monticello is available, too"
			(Smalltalk classNamed: #MCHttpRepository) ifNotNil: [
				^ cfg project currentVersion versionNumber asString.
			].
		].
	  
	(Smalltalk classNamed: #MCPackage)
		ifNotNilDo: [:mcp |
			| package |
			package := mcp named: 'SMark'.
			package hasWorkingCopy ifTrue: [
				^ package workingCopy ancestors first name.
			].
		].
	
	^ ''.! !

!SMarkHarness class methodsFor: 'script entry'!
run: arguments
	"Execcuted from the command line using something similar to
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops\>\>benchIntLoop 1 1 5
	 ./vm my.image SMarkHarness SMarkRunner SMarkReporter SMarkLoops.benchIntLoop 1 1 5"
	| runner reporter runnerAndReporter |
	
	(self shouldShowUsage: arguments)
		ifTrue: [
			self usage.
			^ self.
		].
	
	runnerAndReporter := self parseArguments: arguments.
	runner := runnerAndReporter first.
	reporter := runnerAndReporter second.  
	
	self execute: runner andReport: reporter. ! !

!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:38'!
determineBenchmarkParameters
	"Initialize with defaults, will be overwritten in case
	 it is specified."
	iterations := runner class defaultNumberOfIterations.
	processes  := runner class defaultNumberOfProcesses.
	problemSize:= suiteClass defaultProblemSize.
	
	self determineBenchmarkParametersFromArguments.! !

!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!
determineBenchmarkParametersFromArguments
	i := i + 1.
	i <= numParams ifTrue: [
		iterations := (arguments at: i) asInteger.
		i := i + 1.
		i <= numParams ifTrue: [
			processes := (arguments at: i) asInteger.
			i := i + 1.
			i <= numParams ifTrue: [
				problemSize := arguments at: i.
			]
		]
	].! !

!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!
determineReporter
	(currentObj isKindOf: SMarkReporter)
		ifFalse: [ reporter := harness defaultReporter new. ]
		ifTrue:  [ reporter := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
			]
		].! !

!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!
determineRunner
	(currentObj isKindOf: SMarkRunner)
		ifFalse: [ runner := harness defaultRunner new. ]
		ifTrue:  [ runner := currentObj.
			i := i + 1.
			i <= numParams ifTrue: [
				current := arguments at: i.
				currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
			]
		].! !

!SMarkHarnessArgumentParser methodsFor: 'argument parsing' stamp: 'sm 5/25/2011 17:26'!
determineSuiteOrBenchmark
	self parseBenchmarkOrSuite: current.! !

!SMarkHarnessArgumentParser methodsFor: 'argument parsing'!
parseBenchmarkOrSuite: aBenchmarkOrSuite
	"Identify the benchmark suite or suite and benchmark method
	 that should be executed. The string should be of the format 'Class>>benchName' or 'Class.benchName' for shell/bash compatibility.
	 Accepts a string, class, or array.
	 Returns, a class, or an array of a class and a symbol."
	| parsed |
	(aBenchmarkOrSuite isKindOf: Class)
		ifTrue: [
			suiteClass := aBenchmarkOrSuite.
			^ suiteClass
		].
	  
	(aBenchmarkOrSuite isKindOf: Array)
		ifTrue:  [ parsed := aBenchmarkOrSuite. ]
		ifFalse: [ parsed := aBenchmarkOrSuite findTokens: '>.'. ].
	
	((parsed size > 2) or: [parsed size < 1])
				ifTrue: [ Error signal: 'The passed argument has to represent two elements. A class/classname and a method symbol' ].
	
	suiteClass := parsed first.
	
	(suiteClass isKindOf: Class) 
		ifFalse: [ suiteClass := Smalltalk at: (suiteClass asSymbol) ifAbsent: [Error signal: 'Class that was supposed to represent a benchmark suite was not found: ', suiteClass asString ]].
	
	parsed size = 1
		ifTrue: [^suiteClass].

	specificBenchmark := parsed second asSymbol.
	
	^ { suiteClass. specificBenchmark }
! !

!SMarkHarnessArgumentParser methodsFor: 'accessing'!
harness: aHarness
	harness := aHarness! !

!SMarkHarnessArgumentParser methodsFor: 'parsing' stamp: 'sm 5/25/2011 17:27'!
parse: argumentsArray
	arguments := argumentsArray.
	numParams := arguments size.
	
	i := 2.
	current := arguments at: i.
	currentObj := (Smalltalk classNamed: current) ifNotNilDo: [:cls | cls new].
		
	self determineRunner.
	self determineReporter.
	
	self determineSuiteOrBenchmark.
	
	self determineBenchmarkParameters.
	
	self instructRunner.
	
	^ {runner. reporter}! !

!SMarkHarnessArgumentParser methodsFor: 'helper' stamp: 'sm 5/25/2011 17:29'!
instructRunner
	suite := suiteClass new.
	specificBenchmark ifNotNil: [
		suite runOnly: specificBenchmark.
	].
	
	runner suite: suite.
 	runner iterations: iterations.
	runner processes: processes.
	runner problemSize: problemSize.! !

!SMarkHarnessArgumentParserTest methodsFor: 'as yet unclassified'!
setUp
	parser := SMarkHarnessArgumentParser new.
	parser harness: SMarkHarness.! !

!SMarkHarnessArgumentParserTest methodsFor: 'as yet unclassified'!
testParseArgumentsOnlyBench
	| arguments runnerAndReporter runner reporter runOnly |
	arguments := {#ignored. 'SMarkTestSuite.benchA' }.
	runnerAndReporter := parser parse: arguments.
	
	runner   := runnerAndReporter first.
	reporter := runnerAndReporter second.
	
	self assert: runner notNil.
	self assert: reporter notNil.
	
	self assert: (runner suite isKindOf: SMarkTestSuite).
	runOnly := runner suite selectedBenchmarks.
	self assert: 1 equals: runOnly size.
	self assert: (runOnly includes: #benchA).
! !

!SMarkHarnessArgumentParserTest methodsFor: 'as yet unclassified'!
testParseArgumentsOnlySuite
	| arguments runnerAndReporter runner reporter |
	arguments := {#ignored. 'SMarkTestSuite' }.
	runnerAndReporter := parser parse: arguments.
	
	runner   := runnerAndReporter first.
	reporter := runnerAndReporter second.
	
	self assert: runner notNil.
	self assert: reporter notNil.
	
	self assert: (runner suite isKindOf: SMarkTestSuite).
	self assert: runner suite selectedBenchmarks isNil.
! !

!SMarkHarnessArgumentParserTest methodsFor: 'as yet unclassified'!
testParseArgumentsReporterSuiteIterations
	| arguments runnerAndReporter runner reporter |
	arguments := {#ignored. 'SMarkSimpleStatisticsReporter'. 'SMarkTestSuite'. '13'. }.
	runnerAndReporter := parser parse: arguments.
	
	runner   := runnerAndReporter first.
	reporter := runnerAndReporter second.
	
	self assert: runner notNil.
	self assert: reporter notNil.
	
	self assert: (reporter isKindOf: SMarkSimpleStatisticsReporter).
	self assert: (runner suite isKindOf: SMarkTestSuite).
	self assert: runner suite selectedBenchmarks isNil.
	
	self assert: 13 equals: runner iterations.	! !

!SMarkHarnessArgumentParserTest methodsFor: 'as yet unclassified'!
testParseArgumentsRunnerReporterSuiteIterations
	| arguments runnerAndReporter runner reporter |
	arguments := {#ignored. 'SMarkTestRunner'. 'SMarkSimpleStatisticsReporter'. 'SMarkTestSuite'. '13'. }.
	runnerAndReporter := parser parse: arguments.
	
	runner   := runnerAndReporter first.
	reporter := runnerAndReporter second.
	
	self assert: runner notNil.
	self assert: reporter notNil.
	
	self assert: (runner isKindOf: SMarkTestRunner).
	self assert: (reporter isKindOf: SMarkSimpleStatisticsReporter).
	self assert: (runner suite isKindOf: SMarkTestSuite).
	self assert: runner suite selectedBenchmarks isNil.
	
	self assert: 13 equals: runner iterations.! !

!SMarkHarnessArgumentParserTest methodsFor: 'as yet unclassified'!
testParseArgumentsRunnerSuiteIterations
	| arguments runnerAndReporter runner reporter |
	arguments := {#ignored. 'SMarkTestRunner'. 'SMarkTestSuite'. '13'. }.
	runnerAndReporter := parser parse: arguments.
	
	runner   := runnerAndReporter first.
	reporter := runnerAndReporter second.
	
	self assert: runner notNil.
	self assert: reporter notNil.
	
	self assert: (runner isKindOf: SMarkTestRunner).
	self assert: (runner suite isKindOf: SMarkTestSuite).
	self assert: runner suite selectedBenchmarks isNil.
	
	self assert: 13 equals: runner iterations.! !

!SMarkHarnessArgumentParserTest methodsFor: 'as yet unclassified'!
testParseArgumentsSuiteAndIterations
	| arguments runnerAndReporter runner reporter |
	arguments := {#ignored. 'SMarkTestSuite'. '13' }.
	runnerAndReporter := parser parse: arguments.
	
	runner   := runnerAndReporter first.
	reporter := runnerAndReporter second.
	
	self assert: runner notNil.
	self assert: reporter notNil.
	
	self assert: (runner suite isKindOf: SMarkTestSuite).
	self assert: runner suite selectedBenchmarks isNil.
	
	self assert: 13 equals: runner iterations.! !

!SMarkHarnessArgumentParserTest methodsFor: 'as yet unclassified'!
testParseArgumentsSuiteIterationsProcesses
	| arguments runnerAndReporter runner reporter |
	arguments := {#ignored. 'SMarkTestSuite'. '13'. '91' }.
	runnerAndReporter := parser parse: arguments.
	
	runner   := runnerAndReporter first.
	reporter := runnerAndReporter second.
	
	self assert: runner notNil.
	self assert: reporter notNil.
	
	self assert: (runner suite isKindOf: SMarkTestSuite).
	self assert: runner suite selectedBenchmarks isNil.
	
	self assert: 13 equals: runner iterations.
	self assert: 91 equals: runner processes.
! !

!SMarkHarnessArgumentParserTest methodsFor: 'as yet unclassified'!
testParseArgumentsSuiteIterationsProcessesProblemSize
	| arguments runnerAndReporter runner reporter |
	arguments := {#ignored. 'SMarkTestSuite'. '13'. '91'. 'SSS' }.
	runnerAndReporter := parser parse: arguments.
	
	runner   := runnerAndReporter first.
	reporter := runnerAndReporter second.
	
	self assert: runner notNil.
	self assert: reporter notNil.
	
	self assert: (runner suite isKindOf: SMarkTestSuite).
	self assert: runner suite selectedBenchmarks isNil.
	
	self assert: 13 equals: runner iterations.
	self assert: 91 equals: runner processes.
	self assert: 'SSS' equals: runner problemSize.
! !

!SMarkHarnessArgumentParserTest methodsFor: 'as yet unclassified'!
testParseBenchmarkOrSuite
	| example1 example2 example3 example4 example5 |
	example1 := 'String>>findTokens:'.
	example2 := 'SMarkTestSuite'.
	example3 := { SMarkTestSuite. #benchA }.
	example4 := SMarkTestSuite.
	example5 := 'String.findTokens:'. ". (dot) notation is required to avoid quoting in bash"
	
	self assert: { String. #findTokens: }    equals: (parser parseBenchmarkOrSuite: example1).
	self assert: SMarkTestSuite              equals: (parser parseBenchmarkOrSuite: example2).
	self assert: { SMarkTestSuite. #benchA } equals: (parser parseBenchmarkOrSuite: example3).
	self assert: SMarkTestSuite              equals: (parser parseBenchmarkOrSuite: example4).
	self assert: { String. #findTokens: }    equals: (parser parseBenchmarkOrSuite: example5).
	
	"What to do when the input is not a symbol, array, or class?"
	
	"What to do when the class does not exist"
	self should: [parser parseBenchmarkOrSuite: 'FooBarClassThatDoesNotExist'] raise: Error.! !

!SMarkHarnessClassTest methodsFor: 'tests'!
testShouldShowUsage
	| example1 example2 example3 example4 |
	example1 := { #ignored. '--help' }.
	example2 := { #ignored. }.
	example3 := { #ignored. '-?'}.
	example4 := { #ignored. 1. 2. }.
	
	self assert: (SMarkHarness shouldShowUsage: example1).
	self assert: (SMarkHarness shouldShowUsage: example2).
	self assert: (SMarkHarness shouldShowUsage: example3).
	self deny:   (SMarkHarness shouldShowUsage: example4).
! !

!SMarkLoops methodsFor: 'benchmarking'!
benchFloatLoop
	| a |
	a := 1.23.
	[a < 50000] whileTrue: [
		a := a + 0.6.
		a := a + 0.4.
	].! !

!SMarkLoops methodsFor: 'benchmarking' stamp: 'StefanMarr 7/26/2011 11:46'!
benchIntLoop
	| i |
	i := 25000.
	[i > 0] whileTrue: [
		i := i - 1.
	].! !

!SMarkReporter methodsFor: 'reporting'!
benchmarkFooter: aName
	stream cr.! !

!SMarkReporter methodsFor: 'reporting'!
benchmarkHeader: aName
	stream << 'Benchmark ' << (aName asString); cr.! !

!SMarkReporter methodsFor: 'reporting'!
footer
	"No output at the moment"
	^ self! !

!SMarkReporter methodsFor: 'reporting'!
header
	| suiteName |
	suiteName := runner suite class name asString.
	stream << 'Report for: ' << suiteName; cr.! !

!SMarkReporter methodsFor: 'reporting'!
reportAllRuns: aListOfResults of: benchmark
	aListOfResults do: [:result |
		result criteria keysAndValuesDo: [:benchName :timer |
			stream << benchName << ': ' << (timer totalTime asString, 'ms'); cr.
			]  
		]! !

!SMarkReporter methodsFor: 'initialization'!
initialize
	stream := self class defaultOutputDestination.! !

!SMarkReporter methodsFor: 'accessing'!
outputStream: aStream
	stream := aStream  ! !

!SMarkReporter methodsFor: 'accessing'!
report
	self header.
	
	runner results keysAndValuesDo: [:key :value |
		self benchmarkHeader: key.
		self reportAllRuns: value of: key.
		self benchmarkFooter: key.
	].

	self footer.
	^ self! !

!SMarkReporter methodsFor: 'accessing'!
runner: aRunner
	runner := aRunner.! !

!SMarkReporter commentStamp: 'StefanMarr 3/20/2011 19:55' prior: 0!
PBenchmarkReporter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.

Instance Variables:
	runner	<PBenchmarkRunner>
	stream	<NSDecoderDeflateStream | SocketStream | ThreadSafeTranscript | WriteStream>
		
Example:

	f := TextStream on: String new.
	PBenchmarkSimpleStatisticsReporter reportFor: (PTestBenchmarkRunnerSuiteForAutosizing run: 10) on: f.
	f contents!
!SMarkReporter class methodsFor: 'defaults'!
defaultOutputDestination
	^ ScriptConsole! !

!SMarkReporter class methodsFor: 'defaults'!
defaultReporter
	^ SMarkSimpleStatisticsReporter! !

!SMarkReporter class methodsFor: 'reporting'!
reportFor: aRunner
	self reportFor: aRunner on: self defaultOutputDestination.! !

!SMarkReporter class methodsFor: 'reporting'!
reportFor: aRunner on: aStream
	| reporter |
	reporter := self new.
	reporter runner: aRunner.
	reporter outputStream: aStream.
	reporter report.
	^ reporter.! !

!SMarkReporterTest methodsFor: 'as yet unclassified'!
setUp
	runner := SMarkTestRunnerSuiteForAutosizing run.! !

!SMarkReporterTest methodsFor: 'as yet unclassified'!
testContentOfStream
	"Hm, how to test that robustly?"
	| reporter stream out |
	stream := TextStream on: String new.
	reporter := SMarkReporter reportFor: runner on: stream.
	
	out := stream contents.
	
	self assert: (out includesSubString: 'Small').
	self assert: (out includesSubString: 'Big').
	self assert: (out includesSubString: 'Small').! !

!SMarkReporterTest methodsFor: 'as yet unclassified'!
testConvenienceReportOnRunner
	| stream out |
	stream := TextStream on: String new.
	
	"That should just work, cannot really check whether it is displayed anywhere."
	SMarkTestRunnerSuiteForAutosizing run report.
	
	"Check whether it reported as expected"
	SMarkTestRunnerSuiteForAutosizing run reportOn: stream.
	
	out := stream contents.
	
	self assert: (out includesSubString: 'Small').
	self assert: (out includesSubString: 'Big').
	self assert: (out includesSubString: 'Small').! !

!SMarkResult methodsFor: 'accessing'!
benchmarkName
	^ benchName! !

!SMarkResult methodsFor: 'accessing'!
benchmarkName: aString
	benchName := aString! !

!SMarkResult methodsFor: 'accessing'!
criteria
	^ criteria! !

!SMarkResult methodsFor: 'accessing'!
criteria: aCollectionOfTimers
	criteria := aCollectionOfTimers! !

!SMarkResult methodsFor: 'accessing'!
suite
	^ suite! !

!SMarkResult methodsFor: 'accessing'!
suite: aBenchmarkSuite
	suite := aBenchmarkSuite! !

!SMarkResult methodsFor: 'accessing'!
total
	^ time! !

!SMarkResult methodsFor: 'accessing'!
total: aTime
	time := aTime! !

!SMarkResult commentStamp: 'StefanMarr 3/18/2011 23:45' prior: 0!
A benchmark result is characterized by:
 - the total execution time (#total is the least a benchmark results in)
 - the name of the benchmark that was executed
 - the suite object specifies the used input used for the benchmark
 - dictionary of additional the criteria and the related timings

A benchmark can produced multiple resuts for different criteria. The standard criterion is #total.!
!SMarkResultTest methodsFor: 'as yet unclassified'!
setUp
	| runner |
	runner := SMarkTestRunner execute: SMarkTestRunnerSuite new.
	result := (runner results at: #DoNothing) at: 1.! !

!SMarkResultTest methodsFor: 'as yet unclassified'!
testBenchmarkName
	self assert: (result benchmarkName isKindOf: String)! !

!SMarkResultTest methodsFor: 'as yet unclassified'!
testCriteria
	self assert: (result criteria respondsTo: #at:).
	self assert: (result criteria size > 0).! !

!SMarkResultTest methodsFor: 'as yet unclassified'!
testSuite
	self assert: result suite notNil! !

!SMarkResultTest methodsFor: 'as yet unclassified'!
testTotal
	self assert: (result total isKindOf: Number)! !

!SMarkResultTest commentStamp: 'StefanMarr 3/18/2011 23:29' prior: 0!
This test specifies the data stored in a result object.
The result object does not actually provide behavior on its own.!
!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 10:28'!
createTimer: name
	"Create and register a new timer for the current benchmark"
	| timer |
	timer := self class defaultTimer new: name.
	
	timers ifNotNil: [
		timers at: name put: timer.
	].
	
	^ timer.! !

!SMarkRunner methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 21:01'!
recordResults: timer for: aSelector
	| result name |
	name := suite benchmarkNameForSelector: aSelector.
	
	result := SMarkResult new.
	result total: timer totalTime.
	result benchmarkName: name.
	result suite: suite.
	result criteria: timers.
	
	(results at: name ifAbsentPut: OrderedCollection new) add: result.! !

!SMarkRunner methodsFor: 'execution' stamp: 'StefanMarr 3/13/2011 23:05'!
execute
	suite run.
	self runBaseBenchmark.
	^ results
	! !

!SMarkRunner methodsFor: 'initialization' stamp: 'StefanMarr 5/14/2011 11:10'!
initialize
	super initialize.
	numIterations := self class defaultNumberOfIterations.
	numProcesses  := self class defaultNumberOfProcesses.
	results := Dictionary new.! !

!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20'!
iterations
	^ numIterations! !

!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/21/2011 12:20'!
iterations: anInteger
	numIterations := anInteger! !

!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:08'!
problemSize
	^ problemSize! !

!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:09'!
problemSize: aValue
	problemSize := aValue! !

!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08'!
processes
	"The standard runner does use only a single process, but in case a benchmark supports parallelism it can query for the intended degree of parallelism"
	^ numProcesses! !

!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 5/14/2011 11:08'!
processes: anInt
	"The standard runner does use only a single process, but a benchmark can use that to do its own parallelism"
	numProcesses := anInt! !

!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:46'!
report
	SMarkReporter defaultReporter reportFor: self.  
	! !

!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/18/2011 19:41'!
results
	^ results! !

!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 3/20/2011 18:45'!
suite
	^ suite! !

!SMarkRunner methodsFor: 'accessing' stamp: 'StefanMarr 4/15/2011 16:14'!
suite: aBenchmarkSuite
	suite := aBenchmarkSuite.
	suite runner: self.! !

!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 11:50'!
performBenchmark: aSelector
	currentBenchmark := aSelector.
	
	1 to: numIterations do: [:i|
		"self timedBenchmarkExecution: aSelector."
		suite runBenchmark: aSelector.  
	].	
	
	currentBenchmark := nil.
	
	^ results at: (suite benchmarkNameForSelector: aSelector)! !

!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/18/2011 18:42'!
runBaseBenchmark
	"In certain sitatuations it is one wants a baseline that is incooprated in all 
	 benchmark results to be substracted from the final values.
	
	#baseBenchmark can be used to charaterize such a baseline"
	
	(suite respondsTo: #baseBenchmark) 
		ifFalse: [ ^ nil ].
	
	^ self performBenchmark: #baseBenchmark.! !

!SMarkRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 3/19/2011 22:08'!
timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	timer start.
	suite perform: aSelector.
	timer stop.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !

!SMarkRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50'!
reportConfiguration: aStream
	aStream << 'Runner Configuration:';cr.
	aStream << ('  iterations: ', numIterations asString); cr.
	aStream << ('  processes: ', numProcesses asString); cr.
	aStream << ('  problem size: ', problemSize asString); cr.
! !

!SMarkRunner methodsFor: 'reporting' stamp: 'StefanMarr 4/15/2011 16:47'!
reportOn: aStream
	SMarkReporter defaultReporter reportFor: self on: aStream  
	! !

!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/21/2011 11:43'!
defaultNumberOfIterations
	^ 1! !

!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 5/14/2011 11:09'!
defaultNumberOfProcesses
	^ 1! !

!SMarkRunner class methodsFor: 'defaults' stamp: 'StefanMarr 3/20/2011 20:56'!
defaultTimer
	^ SMarkTimer! !

!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51'!
execute: aSuite
	^ self execute: aSuite with: 1.! !

!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 3/20/2011 19:51'!
execute: aSuite with: nIterations
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner execute.
	^ runner! !

!SMarkRunner class methodsFor: 'benchmarking' stamp: 'StefanMarr 7/25/2011 00:42'!
execute: aSuite with: nIterations for: aProblemSize
	| runner |
	runner := self new.
	aSuite runner: runner.
	runner suite: aSuite.
	runner iterations: nIterations.  
	runner problemSize: aProblemSize.
	runner execute.
	^ runner! !

!SMarkRunnerTest methodsFor: 'as yet unclassified'!
runnerClass
	^ SMarkTestRunner! !

!SMarkRunnerTest methodsFor: 'as yet unclassified'!
testBaseBenchmark
	"Ensure the base benchmark is executed when available"
	
	| runner |
	runner := self runnerClass execute: SMarkTestSuiteWithBaseBenchmark new.

	self assert: runner baseBenchmarkExecuted  ! !

!SMarkRunnerTest methodsFor: 'as yet unclassified'!
testBaseBenchmarkNone
	"Ensure that not having a base benchmark does not pose a problem"

	| runner |
	runner := self runnerClass execute: SMarkTestSuite new.

	self deny: runner baseBenchmarkExecuted  ! !

!SMarkRunnerTest methodsFor: 'as yet unclassified'!
testBenchmarkWithMultipleCriteraTimers
	"Check whether the benchmark benchWithMultipleCriteria, really results in different unrelated timings"
	| runner result |
	runner := self runnerClass execute: SMarkTestSuite new.
	
	result := (runner results at: #WithMultipleCriteria) at: 1.
	self assert: (result isKindOf: SMarkResult).
	
	self assert: result benchmarkName equals: #WithMultipleCriteria.
	self assert: (result total >= 50).
	
	self assert: (result criteria notNil).
	self assert: (result criteria respondsTo: #at:).
	
	self assert: ((result criteria at: 't1') totalTime >= 10).
	self assert: ((result criteria at: 't2') totalTime >= 25).
	self assert: ((result criteria at: 't3') totalTime >= 50).
	! !

!SMarkRunnerTest methodsFor: 'as yet unclassified'!
testClassExecute
	| runner |
	runner := self runnerClass execute: SMarkTestSuiteWithBaseBenchmark new.
	
	self assert: (runner isKindOf: self runnerClass).! !

!SMarkRunnerTest methodsFor: 'as yet unclassified'!
testExecute
	"Ensure all benchmarks are run, including the baseBenchmark and the results are returned"
	| runner results performedBenchmarks |
	runner := self runnerClass new.
	runner suite: SMarkTestRunnerSuiteForPerfromBenchmark new.
	results := runner execute.
	
	performedBenchmarks := runner performedBenchmarks.
		
	self assert: 5 equals: performedBenchmarks size.
	self assert: (performedBenchmarks includes: #baseBenchmark).
	
	self assert: (results respondsTo: #at:).
	self assert: (((results at: #baseBenchmark) at: 1) isKindOf: SMarkResult).! !

!SMarkRunnerTest methodsFor: 'as yet unclassified'!
testIterations
	| runner |
	" simple scenario should default to 1 run for now "
	runner := self runnerClass execute: SMarkTestRunnerSuite new.
	
	self assert: runner countWasExecuted equals: 1.
	
	" but we can also be more fancy and set the number of iterations "
	runner := self runnerClass new.
	runner suite: SMarkTestRunnerSuite new.
	
	"first check again that the default is as expected"
	self assert: runner iterations equals: 1.  
	
	runner iterations: 10.
	self assert: 10 equals: runner iterations.
	
	runner execute.
	
	self assert: 10 equals: runner countWasExecuted.! !

!SMarkRunnerTest methodsFor: 'as yet unclassified'!
testPerformBenchmark
	"Ensure that performBenchmark executes all the defined #bench methods, but for instance not #Bench"
	
	| runner performedBenchmarks |
	runner := self runnerClass execute: SMarkTestRunnerSuiteForPerfromBenchmark new.
	performedBenchmarks := runner performedBenchmarks.

	self assert: (performedBenchmarks includes: #benchAfsdfsdfsdf).
	self assert: (performedBenchmarks includes: #benchBsdfasereSDSfsdfsdfs).
	self assert: (performedBenchmarks includes: #benchC).
	self assert: (performedBenchmarks includes: #benchZZ).

	self deny: (performedBenchmarks includes: #BenchShouldNotBeExecuted).! !

!SMarkRunnerTest methodsFor: 'as yet unclassified'!
testResultStructure
	| runner results resultA resultB suite |
	suite := SMarkTestSuite new.
	runner := self runnerClass execute: suite.
	results := runner results.
	
	"Don't care whether it is a dictionary, but at least it should present us something that maps benchmark names to result objects"
	self assert: (results respondsTo: #at:).

	resultA := (results at: #A) at: 1.
	resultB := (results at: #B) at: 1.


	self assert: (resultA isKindOf: SMarkResult).
	self assert: (resultB isKindOf: SMarkResult).
	self assert: (((results at: #C) at: 1) isKindOf: SMarkResult).
	
	"Make sure some properties of the result objects is ensured"
	self assert: resultA total > 0.
	self assert: #A equals: resultA benchmarkName.
	self assert: suite equals: resultA suite.
	self assert: 1 equals: resultA criteria size.
	
	self assert: resultB total > 0.
	self assert: #B equals: resultB benchmarkName.
	self assert: suite equals: resultB suite.
	self assert: 1 equals: resultB criteria size.
	"Testing for multi-criteria results somewhere else"! !

!SMarkRunnerTest methodsFor: 'as yet unclassified'!
testTimer
	"Simple test whether a timer is created and it is from the expected class.
	 This test is very basic, other tests like testBenchmarkWithMultipleCirteria* need to cover the rest"
	| runner timer |
	runner := self runnerClass new.
	timer := runner createTimer: #foo.

	self assert: timer name equals: #foo.
	self assert: (timer isKindOf: self runnerClass defaultTimer).  ! !

!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:05'!
confidenceVariance: times
	| numMeasurements |
	numMeasurements := times size.
	(numMeasurements >= 30) 
		ifTrue: [
			^ (self gaussianConfidenceFactor) * (times stdev) / (numMeasurements asFloat sqrt)].
		
	"use the students T distribution for small probe counts"
	^ (self studentsTConfidenceFactorFor: numMeasurements) * (times stdev) / (numMeasurements asFloat sqrt)! !

!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:49'!
gaussianConfidenceFactor
	"used for large probe counts >= 30"
	"1 ~ 68.27%"
	"1.644853626951 ~ 90%"
	"2 ~ 95.45%"
	^ 1.644853626951! !

!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 11:46'!
significantDigits: confidenceVariance
	confidenceVariance = 0 
		ifTrue: [ ^ 2].
	
	confidenceVariance >= 10
		ifTrue: [ ^ 0].
	
	^ 1 - (confidenceVariance log floor)! !

!SMarkSimpleStatisticsReporter methodsFor: 'statistics' stamp: 'StefanMarr 3/20/2011 12:03'!
studentsTConfidenceFactorFor: aNumberOfMeasurements
	"used for small probe counts < 30"
	"the students T distribution sucks to calculate since the value depends on the probeCout"
	"these values are for a confidence interval of ~90%"
	| values |
	values := Array new: 30.
	values at: 1  put: 6.314.
	values at: 2  put: 2.920.
	values at: 3  put: 2.353.
	values at: 4  put: 2.132.
	values at: 5  put: 2.015.
	values at: 6  put: 1.943.
	values at: 7  put: 1.895.
	values at: 8  put: 1.860.
	values at: 9  put: 1.833.
	values at: 10 put: 1.812.
	values at: 11 put: 1.796.
	values at: 12 put: 1.782.
	values at: 13 put: 1.771.
	values at: 14 put: 1.761.
	values at: 15 put: 1.753.
	values at: 16 put: 1.746.
	values at: 17 put: 1.740.
	values at: 18 put: 1.734.
	values at: 19 put: 1.729.
	values at: 20 put: 1.725.
	values at: 21 put: 1.721.
	values at: 22 put: 1.717.
	values at: 23 put: 1.714.
	values at: 24 put: 1.711.
	values at: 25 put: 1.708.
	values at: 26 put: 1.706.
	values at: 27 put: 1.703.
	values at: 28 put: 1.701.
	values at: 29 put: 1.699.
	values at: 30 put: 1.697.
	^ values at: aNumberOfMeasurements.
	! !

!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 16:08'!
reportAllRuns: aListOfResults of: benchmark
	| criteria |

	criteria := aListOfResults first criteria.
	
	criteria keysDo: [:criterion |
		| times |
		times := self resultsFor: criterion from: aListOfResults.
		self reportResult: times for: criterion of: benchmark.
		stream cr.
	].! !

!SMarkSimpleStatisticsReporter methodsFor: 'reporting' stamp: 'StefanMarr 5/16/2011 15:54'!
reportResult: anArrayOfResults for: aCriterion of: benchmark
	| convidenceVariance significantDigits quantum total stdev totalSignificantDigits outputLine |

	outputLine := benchmark, ' ', aCriterion, ': iterations=', 
	              anArrayOfResults size asString, ' runtime: '.
	
	anArrayOfResults size < 2 ifTrue: [
		total := anArrayOfResults average printString.
		outputLine := outputLine, total, 'ms'.
		stream << outputLine.
		^ self.
	].
	
	convidenceVariance := self confidenceVariance: anArrayOfResults.  
	
	"only print significant "
	significantDigits := self significantDigits: convidenceVariance.
	quantum := (1/10 asFloat) raisedTo: significantDigits.
	
	"round to significantDigits"
	stdev := convidenceVariance roundTo: quantum.
	
	total := (anArrayOfResults average roundTo: quantum) printString.
	totalSignificantDigits := total size - (total indexOf: $.).

	outputLine := outputLine, total.
	
	"check if the last digit is 0 => padding"
	(totalSignificantDigits < significantDigits) ifTrue: [
	 	(significantDigits - totalSignificantDigits) 
			timesRepeat: [ outputLine := outputLine, '0']].
	outputLine := outputLine, 'ms'.
	
	stream << outputLine.
	stream << ' +/-' << stdev.! !

!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 5/16/2011 16:02'!
resultsFor: aCriterion from: aListOfResults
	^aListOfResults collect: [:result | (result criteria at: aCriterion) totalTime]
	! !

!SMarkSimpleStatisticsReporter methodsFor: 'helper' stamp: 'StefanMarr 3/20/2011 19:40'!
totalResultsFor: aListOfResults
	^aListOfResults collect: [:timer | timer total]
	! !

!SMarkSlopstone methodsFor: 'benchmarking' stamp: 'StefanMarr 7/25/2011 15:08'!
OLDERbenchStone
	"modified by nishis"
	"STEFAN: this version includes the original reporting, and is not used by SMark
	 Only containted for historical purposes."

	| n nTests iters times speeds stones scale printA printB printC param count speed0 expln block time iter speed stone geoMean gm power |
	n := self problemSize.	"Number of times each test block will be evaluated."
	n > SmallInteger maxVal
		ifTrue: [ self error: 'Count exceeded max small int.' ].
	
	nTests := testParams size.
	nTests = testBlocks size
		ifFalse: [ self error: 'Inconsistent test count.' ].
	iters := OrderedCollection new.
	times := OrderedCollection new.
	speeds := OrderedCollection new.
	stones := OrderedCollection new.
	scale := 1000.	"So iterations can be reported as 1000s of iterations"	"The following blocks are restricted to two args by ST/V-DOS."
	printA := [ :t1 :t2 | 
	"[:iter1 :time1 |"
	output cr.
	output nextPutAll: (t1 / scale) rounded printString.
	output nextPutAll: '     '.
	output nextPutAll: t2 printString.
	output nextPutAll: '     ' ]  copy fixTemps.
	printB := [ :t1 :t2 | 
	"[:speed1 :slop1 |"
	output nextPutAll: (t1 / scale) rounded printString.
	output nextPutAll: '     '.
	output nextPutAll: t2 printString.
	output nextPutAll: '     ' ]  copy fixTemps.
	printC := [ :t1 | 
	":expln1 |"
	output nextPutAll: t1 ]  copy fixTemps.
	output
		nextPutAll:
			'

1000s    time    1000s of
itera-   sec-    iterations   slop-
tions    onds    per sec      stones   explanation
'.
	1 to: nTests do: [ :i | 
		param := testParams at: i.
		count := param at: 1.	"repetitions of a test inside its block"
		speed0 := (param at: 2) * scale.	"iters/sec for a one-slopstone machine"
		expln := param at: 3.
		block := (testBlocks at: i)  copy fixTemps.
		time := Time millisecondsToRun: [ n timesRepeat: block ].
		time := (time max: 1) / 1000.0.	"time is now in seconds"
		iter := count * n.
		speed := iter / time.
		stone := speed / speed0.
		iters add: iter.
		times add: time.
		speeds add: speed.
		stones add: stone.
		printA value: iter value: time.
		printB value: speed value: stone.
		printC value: expln ].
	
	
	geoMean := [ :t1 | 
	"[:numbers |"
	gm := 1.
	power := 1 / nTests.	"t2 as number"
	t1 do: [ :t2 | gm := gm * (t2 raisedTo: power) ].
	gm ] copy fixTemps.
	output cr.
	printA value: (geoMean value: iters) value: (geoMean value: times).
	printB value: (geoMean value: speeds) value: (geoMean value: stones).
	printC value: 'geometric mean'.
	output
		cr;
		cr;
		nextPutAll: 'Benchmarks complete.';
		cr! !

!SMarkSlopstone methodsFor: 'benchmarking' stamp: 'StefanMarr 7/25/2011 15:11'!
benchStone
	"modified by nishis"

	| n nTests iters times speeds stones scale param count speed0  block time iter speed stone |
	n := self problemSize.	"Number of times each test block will be evaluated."
	n > SmallInteger maxVal
		ifTrue: [ self error: 'Count exceeded max small int.' ].
	
	nTests := testParams size.
	nTests = testBlocks size
		ifFalse: [ self error: 'Inconsistent test count.' ].
	iters := OrderedCollection new.
	times := OrderedCollection new.
	speeds := OrderedCollection new.
	stones := OrderedCollection new.
	scale := 1000.	"So iterations can be reported as 1000s of iterations"	"The following blocks are restricted to two args by ST/V-DOS."
	
	1 to: nTests do: [ :i | 
		param := testParams at: i.
		count := param at: 1.	"repetitions of a test inside its block"
		speed0 := (param at: 2) * scale.	"iters/sec for a one-slopstone machine"
		block := (testBlocks at: i)  copy fixTemps.
		time := Time millisecondsToRun: [ n timesRepeat: block ].
		time := (time max: 1) / 1000.0.	"time is now in seconds"
		iter := count * n.
		speed := iter / time.
		stone := speed / speed0.
		iters add: iter.
		times add: time.
		speeds add: speed.
		stones add: stone.
	].! !

!SMarkSlopstone methodsFor: 'benchmarking' stamp: 'StefanMarr 7/25/2011 00:54'!
problemSize
	| ps |
	ps := super problemSize.
	
	ps := ps asInteger.
	ps ifNil: [ ^ self defaultProblemSize].
	^ ps! !

!SMarkSlopstone methodsFor: 'benchmarking' stamp: 'nishis 2/14/98 02:33'!
readme

	"INTRODUCTION 
	 
	Slopstone: Smalltalk Low level OPeration Stones 
	Portable Low Level Benchmarks for ST80 and ST/V (using 16-bit 
	SmallIntegers) Placed in public domain January 1993  (c) Bruce 
	Samuelson Permission is given to place this in public Smalltalk archives 
	 
	Use monospaced fonts if possible to view the methods in this class. 
	 
	(1) Collect garbage if supported (2) do 'SlopstoneBenchmark new 
	runBenchmark'. Results are printed in the Transcript window. 
	Post results for your machines to comp.lang.smalltalk or 
	mail them to bruce@ling.uta.edu or bruce@utafll.uta.edu. 
	 
	DISCUSSION 
	    
	This readme method would normally be in the class comment for ST80. 
	ST/V-DOS doesn't support class comments. 
	  
	The benchmarks test strictly low level operations. They do not test 
	higher level operations such as forming sets, sorting, or streaming, nor 
	do they test 
	applications. They also do not test user interface operations because of 
	the non-portability of this area of Smalltalk and its sensitivity to the 
	performance of the video subsystem. The tests are cpu bound. They do 
	not access files and should not cause disk paging. 
	 
	The benchmarks use loop counts of 16000 because SmallIntegers cannot 
	exceed 16383 for ST/V-DOS. 16-bit implementions would perform worse 
	with large loop 
	counts. The benchmarks are also suitable for testing 32-bit versions of 
	Smalltalk. 
	 
	DEFINITION OF REFERENCE MACHINE (ONE SLOPSTONE) 
	 
	The following machine is the one on which I developed these 
	benchmarks. By 
	convention it is defined to operate at one slopstone. It's a mid range 
	performer for current ParcPlace versions of Smalltalk. 
	 
	Hardware: Amax 486DX/33 (includes internal floating point processor 
	and internal 8K cache), 256K external cache, 16MB RAM. 
	 
	Software: ParcPlace VisualWorks 1.0, Windows 3.1, DOS 5.0 (plain vanilla 
	setup). 
	 
	COMPARISON TO XEROX DORADO 
	 
	For reference, the machine runs at 649% of a Dorado on ParcPlace 
	benchmarks for ST80 4.1. Its fast video card helps on these PPS 
	benchmarks. I didn't run 
	them for VisualWorks 1.0. It would be somewhat slower because there 
	are vastly 
	more classes. 
	 
	EXAMPLE RESULTS FOR REFERENCE MACHINE 
	 
	1000s    time    1000s of 
	itera-   sec-    iterations   slop- 
	tions    onds    per sec      stones   explanation 
	 
	3808     0.577   6600         1.0      add integers 
	 544     2.262    240         1.0      add floats 
	 960     1.088    882         1.0      access strings 
	 320     0.908    352         1.0      create objects 
	 160     1.49     107         1.0      copy objects 
	 480     1.129    425         1.0      perform selectors 
	 896     1.237    724         1.0      evaluate blocks 
	 
	 640     1.151    555         1.0      geometric mean"
	^ self! !

!SMarkSlopstone methodsFor: 'benchmarking' stamp: 'StefanMarr 7/25/2011 01:33'!
setUp
 
	"Numbers in testParams represent the following:
 
	Column 1   number of internal repetitions for each test inside its block
	Column 2   thousands of iterations per second for a one-slopstone machine."
 
	output := TextStream with: String new.

	testParams := OrderedCollection new.
 
	testParams
		add: #(238 6600 'add integers');
		add: #( 34  240 'add floats');
		add: #( 60  882 'access strings');
		add: #( 20  352 'create objects');
		add: #( 10  107 'copy objects');
		add: #( 30  425 'perform selectors');
		add: #( 56  724 'evaluate blocks').
 
	testBlocks := OrderedCollection new.
 
	"In the integer addition test, I originally had 340 internal repetitions.
	This caused the Digitalk compiler to blow up. The ParcPlace compiler compiled
	it ok but interestingly addition performed at slightly more than 50% of the
	performance with an internal count of 238. Perhaps something magical happens
	at 256."

	testBlocks
		add: [1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+
			1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+
			1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+
			1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+
			1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+
			1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+
			1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1];
 
		add: [1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+
			1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0];
 
		add: ['a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
			'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
			'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
			'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
			'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
			'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
			'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
			'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
			'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
			'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1];
 
		add: [Object new. Object new. Object new. Object new. Object new.
			Object new. Object new. Object new. Object new. Object new.
			Object new. Object new. Object new. Object new. Object new.
			Object new. Object new. Object new. Object new. Object new];
 
		add: [Object new copy copy copy copy copy copy copy copy copy copy];
 
		add: [0 perform: #yourself. 0 perform: #yourself. 0 perform: #yourself.
			0 perform: #yourself. 0 perform: #yourself. 0 perform: #yourself.
			0 perform: #yourself. 0 perform: #yourself. 0 perform: #yourself.
			0 perform: #yourself. 0 perform: #yourself. 0 perform: #yourself.
			0 perform: #yourself. 0 perform: #yourself. 0 perform: #yourself.
			0 perform: #yourself. 0 perform: #yourself. 0 perform: #yourself.
			0 perform: #yourself. 0 perform: #yourself. 0 perform: #yourself.
			0 perform: #yourself. 0 perform: #yourself. 0 perform: #yourself.
			0 perform: #yourself. 0 perform: #yourself. 0 perform: #yourself.
			0 perform: #yourself. 0 perform: #yourself. 0 perform: #yourself];
 
		add: [[] value. [] value. [] value. [] value. [] value. [] value. [] value.
			[] value. [] value. [] value. [] value. [] value. [] value. [] value.
			[] value. [] value. [] value. [] value. [] value. [] value. [] value.
			[] value. [] value. [] value. [] value. [] value. [] value. [] value.
			[] value. [] value. [] value. [] value. [] value. [] value. [] value.
			[] value. [] value. [] value. [] value. [] value. [] value. [] value.
			[] value. [] value. [] value. [] value. [] value. [] value. [] value.
			[] value. [] value. [] value. [] value. [] value. [] value. [] value]! !

!SMarkSlopstone methodsFor: 'defaults'!
defaultProblemSize
	^ 1! !

!SMarkSlopstone commentStamp: 'nishis 2/21/98 06:26' prior: 0!
modified for Squeak by nishis@urban.ne.jp
I added one class methods.
and modified execute method.  block variables are renamed for Squeak.
Thanx to Mr. Tim Olson, Mr. Kohler Markus, Mr. Tim Rowledge, Mr. John Maloney, Mr. Ian Piumarta.

original comments
	NAME			STones80
	AUTHOR			bruce@utafll.uta.edu (Bruce Samuelson)
	FUNCTION		low and medium level benchmarks for ST80 and ST/V
	ST-VERSIONS		pre R4.0, R4.0, R4.1, ST/V
	PREREQUISITES	need floating point hardware or emulation
	CONFLICTS		none
	DISTRIBUTION	world
	VERSION			1.0
	DATE			April 16, 1993

SUMMARY The filein includes two classes: Slopstones (Smalltalk Low level
OPeration Stones) and Smopstones (Smalltalk Medium level OPeration Stones).
Each includes seven cpu intensive benchmarks. They work equally well with
16-bit and 32-bit implementations and are designed to be portable to all
Smalltalk versions from ParcPlace and Digitalk. They are normalized to the
author's 486/33 Windows 3.1 machine running ParcPlace VisualWorks 1.0.
Results have been posted to the Usenet group comp.lang.smalltalk and form the
basis of an article that is scheduled to be published in the June issue of The
Smalltalk Report.

The only difference between the ST80 (STones80) and ST/V (STonesV) filein is
in the messages that define the classes in the first few lines of code. The
ST80 messages specify the class category and message protocol, which are not
used in ST/V.

Bruce Samuelson

!
!SMarkSmopstone methodsFor: 'benchmarking' stamp: 'StefanMarr 7/25/2011 15:08'!
OLDERbenchStone
	"modified by nishis"
	"STEFAN: this version includes the original reporting, and is not used by SMark
	 Only containted for historical purposes."
	
	| n nTests times stones printA printC param time0 expln block time stone geoMean gm power |
	
	n := self problemSize.	 "Each test is repeated this many times. The smopstone times in
			the test parameters are normalized to a value of one. You may
			set it to a higher number if your machine is really blazing."
	output
		cr;
		cr;
		nextPutAll: 'Starting benchmarks with repetition count = ' , n printString , '.'.
	nTests := testParams size.
	nTests = testBlocks size
		ifFalse: [ self error: 'Inconsistent test count.' ].
	times := OrderedCollection new.
	stones := OrderedCollection new.	"The following blocks are restricted to two args by ST/V-DOS."
	printA := [ :time1 :smop1 | 
	output cr.
	output nextPutAll: time1 printString.
	output nextPutAll: '     '.
	output nextPutAll: smop1 printString.
	output nextPutAll: '     ' ] copy fixTemps..
	printC := [ :expln1 | output nextPutAll: expln1 ] copy fixTemps..
	output
		nextPutAll:
			'

time in    smop-
seconds    stones    explanation
'.
	1 to: nTests do:  [ :i | 
		param := testParams at: i.
		time0 := param at: 1.	"seconds for one-smopstone machine"
		expln := param at: 2.
		block := (testBlocks at: i)  copy fixTemps.
		time := Time millisecondsToRun: [ n timesRepeat: block ].
		time := (time max: 1) / 1000.0.	"time is now in seconds"
		stone := n * time0 / time.
		times add: time.
		stones add: stone.
		printA value: time value: stone.
		printC value: expln ].
	
	
	geoMean := [ :numbers | 
	gm := 1.
	power := 1 / nTests.
	numbers do: [ :number | gm := gm * (number raisedTo: power) ].
	gm ]  copy fixTemps.
	output cr.
	printA value: (geoMean value: times) value: (geoMean value: stones).
	printC value: 'geometric mean'.
	IsSupportRecursiveBlock
		ifFalse: [ output nextPutAll: '*' ].
	output
		cr;
		cr;
		nextPutAll: 'Benchmarks complete.';
		cr.
	IsSupportRecursiveBlock
		ifFalse: [ 
			output
				cr;
				nextPutAll:
						'*** Caution ***
2 test of this benchmark (marked at ''*'') is intended to test the efficiency 
of recursively calling a block, that it isn''t supported by this VM.
So the result would be fairly pointless.';
				cr ]! !

!SMarkSmopstone methodsFor: 'benchmarking' stamp: 'StefanMarr 7/26/2011 11:45'!
benchStone
	"modified by nishis"
	| n primes strings set |
	
	n := self problemSize.	 "Each test is repeated this many times. The smopstone times in
			the test parameters are normalized to a value of one. You may
			set it to a higher number if your machine is really blazing."
	
	
	1 to: n do:  [ :i | 
		self fractonacci: 13/2.
		primes := self primesUpTo: 4000.
		self streamTestsOn: primes.
		strings := self stringsUpTo: 3000.
		set := self setFrom: strings.
		self sort: set.
		self sorcerersApprentice.
	].! !

!SMarkSmopstone methodsFor: 'benchmarking' stamp: 'nishis 2/14/98 02:47'!
fractonacci: n 
	"Return something like the fibonacci function of n but
	using fractional numbers rather than whole ones. The
	reason for this variation is to run long enough to get
	a decent time measurement without exceeding 16383, the
	limit of small integers for ST/V-DOS. Choosing n = 13/2
	takes enough time and computes to 13581.

	Fibonacci uses n-1 and n-2 instead of n-(1/2) and n-(1/3).
	However, I couldn't get it to run in the above constraints.

	This benchmark tests the efficiency of recursively calling
	a method that does a little fractional arithmetic internally."

	^n > 1
		ifTrue: [(self fractonacci: n - (1/2)) + (self fractonacci: n - (1/3))]
		ifFalse: [1]! !

!SMarkSmopstone methodsFor: 'benchmarking' stamp: 'StefanMarr 7/25/2011 01:27'!
primesUpTo: n
	"modified by nishis"

	"Return the prime numbers between 2 and n.

	This method tests the efficiency of recursively calling a block
	that does some collection enumeration based on integer arithmetic."

	| nSqrt lowPrimes highPrimes genNext first nextPrime2 |
	n < 5 | (n > 16363) ifTrue: [self error: 'Prime limit(s) out of range.'].
	nSqrt := n sqrt rounded.
	lowPrimes := OrderedCollection with: 2.
	highPrimes := 5 to: n by: 2.
	IsSupportRecursiveBlock
		ifTrue:
			[genNext :=
				[:nextPrime |
				lowPrimes add: nextPrime.
				highPrimes := highPrimes select: [:k | k \\ nextPrime ~= 0] copy fixTemps.
				(first := highPrimes first) <= nSqrt ifTrue: [genNext value: first]].
			genNext value: 3.]
		ifFalse: 
			[first := highPrimes first.
			nextPrime2 := 3.
			[first <= nSqrt] 
				whileTrue: 
					[lowPrimes add: nextPrime2.
					highPrimes := highPrimes select: [:k | k \\ nextPrime2 ~= 0].
					(first := highPrimes first) <= nSqrt ifTrue: [nextPrime2 := first]]].
	^lowPrimes , highPrimes! !

!SMarkSmopstone methodsFor: 'benchmarking' stamp: 'StefanMarr 7/25/2011 00:54'!
problemSize
	| ps |
	ps := super problemSize.
	
	ps := ps asInteger.
	ps ifNil: [ ^ self defaultProblemSize].
		
	^ ps! !

!SMarkSmopstone methodsFor: 'benchmarking' stamp: 'nishis 2/14/98 02:46'!
readme

	"INTRODUCTION 
	 
	Smopstone: Smalltalk Medium level OPeration Stones 
	Portable Medium level Benchmarks for ST80 and ST/V (using 16-bit 
	SmallInts) Placed in public domain January 1993  (c) Bruce Samuelson 
	Permission is given to place this in public Smalltalk archives 
	 
	Use monospaced fonts if possible to view the methods in this class. 
	 
	(1) Collect garbage if supported (2) do 'SmopstoneBenchmark new 
	runBenchmark'. Results are printed in the Transcript window. 
	Post results for your machines to comp.lang.smalltalk or 
	mail them to bruce@ling.uta.edu or bruce@utafll.uta.edu. 
	 
	DISCUSSION 
	    
	This readme method would normally be in the class comment for ST80. 
	ST/V-DOS doesn't support class comments. 
	 
	These benchmarks are a companion to the SlopstoneBenchmark class 
	posted to 
	comp.lang.smalltalk this month. Slopstones tested low level operations. 
	  
	Smopstones test medium level operations that exercise recursive block 
	and  
	method calls, collection building and enumeration, streaming, and 
	sorting. The 
	lower level operations contained in them exercise arithmetic (mostly 
	integer, with some fractions and floats) string manipulation, and low 
	level streaming. 
	 
	The benchmarks do not test applications. They also do not test user 
	interface performance because of the non-portability of this area of 
	Smalltalk and its  
	sensitivity to the speed of the video subsystem. The tests are cpu bound. 
	They do not access files and should not cause disk paging. 
	 
	The main weaknesses of the benchmarks are (1) they are not high 
	enough level 
	to test actual applications, and (2) they concentrate in too few areas of 
	Smalltalk, omitting many of the diverse capabilities of its class library. 
	My excuse is that one can only devote limited time writing public 
	domain benchmarks. 
	 
	The tests avoid generating integers larger than 16383, the maximum 
	SmallInteger in ST/V-DOS. 16-bit implementions would perform worse 
	with larger 
	integers. The benchmarks are also suitable for testing 32-bit versions of 
	Smalltalk. They try to avoid other pitfalls that would skew the results 
	such as the lack of an adequate hash function for a class. Someone 
	warned of this 
	in comp.lang.smalltalk (I forget who). 
	 
	DEFINITION OF REFERENCE MACHINE (ONE SMOPSTONE) 
	 
	The following machine is the one on which I developed these 
	benchmarks. By 
	convention it is defined to operate at one smopstone. It's a mid range 
	performer for current ParcPlace versions of Smalltalk. 
	 
	Hardware: Amax 486DX/33 (includes internal floating point processor 
	and internal 8K cache), 256K external cache, 16MB RAM. 
	 
	Software: ParcPlace VisualWorks 1.0, Windows 3.1, DOS 5.0 (plain vanilla 
	setup). 
	 
	COMPARISON TO XEROX DORADO 
	 
	For reference, the machine runs at 649% of a Dorado on ParcPlace 
	benchmarks for ST80 4.1. Its fast video card helps on these PPS 
	benchmarks. I didn't run 
	them for VisualWorks 1.0. It would be somewhat slower because there 
	are vastly 
	more classes. 
	 
	EXAMPLE RESULTS FOR REFERENCE MACHINE 
	 
	time in    smop- 
	seconds    stones    explanation 
	 
	 
	3.157      1.0       generating fractonaccis 
	1.123      1.0       generating primes 
	1.091      1.0       generating and parsing streams 
	3.091      1.0       generating strings 
	1.167      1.0       forming sets 
	5.139      1.0       sorting strings 
	5.601      1.0       sorcerer's apprentice 
	 
	2.355      1.0       geometric mean"
	^ self! !

!SMarkSmopstone methodsFor: 'benchmarking' stamp: 'nishis 2/14/98 02:46'!
setFrom: collection
	"Form a set from collection and return it.

	This method tests the efficiency of building a fairly large set
	from strings. It indirectly tests the effectiveness of the string
	hash function. Strings are used often enough as dictionary keys
	that this may be worth including in the benchmark suite.  ST/V-DOS
	has a primitive hash for strings, and ST80 has an elaborate one
	written in Smalltalk."

	^collection asSet! !

!SMarkSmopstone methodsFor: 'benchmarking' stamp: 'StefanMarr 7/25/2011 01:41'!
setUp
	"modified by nishis"

	"Numbers in testParams represent the approximate number of seconds it
	takes to run the tests for a one-smopstone machine.

	Numbers in testBlocks are parameters tuned for each test. Do not
	change them. The times for several tests depend on them non-linearly."

	| primes strings set  |
	
	output := TextStream with: String new.

	testParams := OrderedCollection new.
 
	IsSupportRecursiveBlock 
		ifTrue: 
			[testParams
				add: #(3.157 'generating fractonaccis');
				add: #(1.123 'generating primes');
				add: #(1.091 'generating and parsing streams');
				add: #(3.091 'generating strings');
				add: #(1.167 'forming sets');
				add: #(5.139 'sorting strings');
				add: #(5.601 'sorcerer''s apprentice')] 
		ifFalse: 
			[testParams
				add: #(3.157 'generating fractonaccis');
				add: #(1.123 'generating primes*');
				add: #(1.091 'generating and parsing streams');
				add: #(3.091 'generating strings');
				add: #(1.167 'forming sets');
				add: #(5.139 'sorting strings');
				add: #(5.601 'sorcerer''s apprentice*')].

	testBlocks := OrderedCollection new.

	primes := self primesUpTo: 9000.
	strings := self stringsUpTo: 8000.
	set := self setFrom: strings.

	testBlocks
		add: [self fractonacci: 13/2];
		add: [self primesUpTo: 9000];	"7351 - 1"
		add: [self streamTestsOn: primes];
		add: [self stringsUpTo: 8000];
		add: [self setFrom: strings];
		add: [self sort: set];
		add: [self sorcerersApprentice]! !

!SMarkSmopstone methodsFor: 'benchmarking' stamp: 'StefanMarr 7/25/2011 01:42'!
sorcerersApprentice
	"modified by nishis"

	" FORMATTED FOR MONOSPACED FONT

	Perform various operations on rectangles.

	This method tests the efficiency of recursively calling a block that
	includes lots of integer arithmetic, collection building, and collection
	enumeration. The method:

	(1) Creates a collection of pseudo random rectangles 
	(2) Forms a new collection of all their intersections 
	(3) Recursively continues until there are no more intersections 
	(4) Returns a collection with the counts of rectangles in each generation.

	Because the intersections are forming progressively smaller rectangles
	(we exclude intersections of a rectangle with itself), the algorithm will
	eventually converge. Depending on the choice of numeric parameters, it may
	converge very quickly or very slowly. The parameters used below make it
	converge in a reasonable amount of time (a few seconds on a one-smopstone
	machine). It took some experimentation with different combinations to
	achieve this.

	The pseudo random number generator isn't very good, but it's adequate
	for this benchmark. I had intended the number '87' it uses to be a prime,
	but 87 = 29 * 3. The numbers may have been a bit more random otherwise.

	One could write an algorithm that would converge much more quickly and in
	a more predictable amount of time by sorting the intermediate rectangles
	in two dimensions and not bothering to test for intersections those
	rectangles that are contained in mutually exclusive regions. We have
	chosen algorithmic simplicity over performance optimization. We simply
	perform intersections of each rectangle with every possible partner in
	each generation. The time consumed is quadratic in the number of rectangles.

	The algorithm originally stored rectangles in sets to eliminate duplicates.
	Unfortunately, ST/V-DOS uses the hash function inherited from Object for
	Rectangle, which will allow duplicates to be stored. So we were forced to
	store rectangles in ordered collections and eliminate duplicates by brute
	force. The brutality was heightened because we could not use the test
	collection>>includes: to decide whether to add a rectangle to the ordered
	collections, since ST/V-DOS does not define equality (=) for rectangles
	either. The remaining warts in the code are not worth explaining.

	In an actual application, these shortcomings of ST/V-DOS would have been
	overcome by adding subclasses and methods rather than writing kludgy code."

	| m n firstGen intersection isIncluded counts r random
	a b c d e f g h generate nextGen |
	
	m := 80.
	n := 20 * m.
	firstGen := OrderedCollection new.
	counts := OrderedCollection new.
	r := 50.
	random := [r := r + 1 * 87 \\ n]  copy fixTemps.
	1 to: m do: [:i|
		a := random value.
		b := random value.
		c := random value.
		d := random value.
		e := a min: b.
		f := c min: d.
		g := a max: b.
		h := c max: d.
		firstGen add: (Rectangle origin: e @ f corner: g @ h)].
	generate := 
		[:lastGen |
		counts add: lastGen size.
		nextGen := OrderedCollection new.
		lastGen do:
			[:r1 |
			lastGen do: 
				[:r2 | 
				(r1 origin ~= r2 origin or: [r1 corner ~= r2 corner])
				"In ST80 this test would have simply been r1 ~= r2"
					ifTrue:
						[(r1 intersects: r2)
							ifTrue:
								[intersection := r1 intersect: r2.
								isIncluded := false.                     "All these lines"
								nextGen do:                              "would have been"
									[:rec |                                "avoided if we"
										(rec origin = intersection origin and: "could have used"
										[rec corner = intersection corner])    "a set for"
											ifTrue: [isIncluded := true]].       "nextGen. See"
								isIncluded                               "explanation"
									ifFalse:                               "above."
										[nextGen size > 500
											ifTrue: [self error: 'Converges too slowly.']
											ifFalse: [nextGen add: intersection]]]]]].
			nextGen size > 0 ifTrue: [generate value: nextGen]]  copy fixTemps.
	IsSupportRecursiveBlock
		ifTrue: [generate value: firstGen]
		ifFalse: [^ self generate: firstGen counts: counts].
	^counts! !

!SMarkSmopstone methodsFor: 'benchmarking' stamp: 'nishis 2/14/98 02:39'!
sort: collection
	"Form a sorted collection from collection and return it.

	This method tests the efficiency of sorting a fairly large
	collection of strings. It indirectly measures the efficiency
	of the sorting algorithm and of string comparison operations."

	^collection asSortedCollection! !

!SMarkSmopstone methodsFor: 'benchmarking' stamp: 'StefanMarr 7/25/2011 01:29'!
streamTestsOn: integers 
	"modified by nishis"
	"Test steaming operations on the collection of integers. 
	 
	This method measures the efficiency of integer-to-float conversion, of 
	printing numbers to a write stream, of parsing tokens in a read 
	stream,   and of converting the tokens from strings to numbers. The 
	technique for 
	converting tokens into floats is constrained by portability between 
	ST80 and ST/V. 
	 
	To validate the logic, the original integers are compared with the 
	final   floats. There should be no roundoff errors."
	"The following line accounts for the different implementations of 
	Float>>printString for some versions of Smalltalk. USA versions use 
	the decimal character, while some European versions use the comma 
	char.   Thanks to Marten Feldtmann for pointing this out."

	| delim space s floats float string |
	WhichFloatPrintOn 
		ifTrue: [delim := 1.0 printString at: 2]	"$. for USA, $, for some Europe."
		ifFalse: [delim := $e].					"modified by nishis"

	space := Character value: 32.
	"Can't use Character space in ST/V-DOS"
	s := ReadWriteStream on: String new.
	integers do: 
		[:i | 
		WhichFloatPrintOn 
			ifTrue: [i asFloat printOn: s]
			ifFalse: [i asFloat testPrintOn: s base: 10].
		s space]  copy fixTemps.
	"Now make sure the underlying string size is < 16383, a 16-bit small int."
	s contents size > (SmallInteger maxVal) ifTrue: [self error: 'String too big.'].
	s reset.
	floats := OrderedCollection new: integers size.
	[s atEnd]
		whileFalse: 
			[float := 0.0.
			string := s upTo: delim.
			s upTo: space.
			"In the following, digitValue is portable between ST80 and ST/V-DOS. "
			string do: [:char | float := float * 10.0 + char digitValue].
			floats add: float].
	integers = floats ifFalse: [self error: 'Numbers do not compare.']! !

!SMarkSmopstone methodsFor: 'benchmarking' stamp: 'nishis 2/14/98 02:39'!
stringsUpTo: n 
	"Return a collection of strings representing the integers from 1 
	to n with their digits reversed. 
	 
	This method tests the efficiency of creating small streams, performing 
	string operations, and building collections. It includes a gross kludge 
	to coerce portability between ST80 and ST/V. They vary slightly in the 
	selector used to reverse collections. Subsequent to freezing this code, 
	someone pointed out that it could have been written more simply 
	without   using perform:. It could also have been simplified using 
	select:. It 
	was too late to change. The techniques are left as an exercise for the 
	reader."

	| selector |
	(Array with: #reverse with: #reversed)
		do: [:symbol | (String canUnderstand: symbol)
			ifTrue: [selector := symbol]].
	^ (1 to: n)
		collect: [:m | m printString perform: selector]! !

!SMarkSmopstone methodsFor: 'defaults'!
defaultProblemSize
	^ 1! !

!SMarkSmopstone methodsFor: 'recursive method'!
generate: lastGen counts: counts
	"added by nishis"
	"SmopstoneBenchmark new sorcerersApprentice."

	| intersection isIncluded nextGen |
	
	counts add: lastGen size.
	nextGen := OrderedCollection new.
	lastGen do:
		[:r1 |
		lastGen do: 
			[:r2 | 
			(r1 origin ~= r2 origin or: [r1 corner ~= r2 corner])
			"In ST80 this test would have simply been r1 ~= r2"
				ifTrue:
					[(r1 intersects: r2)
						ifTrue:
							[intersection := r1 intersect: r2.
							isIncluded := false.                     "All these lines"
							nextGen do:                              "would have been"
								[:rec |                                "avoided if we"
									(rec origin = intersection origin and: "could have used"
									[rec corner = intersection corner])    "a set for"
										ifTrue: [isIncluded := true]].       "nextGen. See"
							isIncluded                               "explanation"
								ifFalse:                               "above."
									[nextGen size > 500
										ifTrue: [self error: 'Converges too slowly.']
										ifFalse: [nextGen add: intersection]]]]]].
		nextGen size > 0 ifTrue: [self generate: nextGen counts: counts].
	^counts! !

!SMarkSmopstone commentStamp: 'nishis 2/21/98 06:26' prior: 0!
modified for Squeak by nishis@urban.ne.jp
see the comment of SlopstoneBenchmark class.
I added all class methods and initialization>initilize method,
modified:
	streamTestsOn: method.  In some case use testPrintOn: s base: instead of printOn:,
	primesUpTo: method. From recursively calling a block to whileTrue: block.
	sorcerersApprentice method. From recursively calling a block to  recursive method.
	execute and setup method.
Thanx to Mr. Tim Olson, Mr. Kohler Markus, Mr. Tim Rowledge, Mr. John Maloney, Mr. Ian Piumarta.

originak code by
	NAME			STones80
	AUTHOR			bruce@utafll.uta.edu (Bruce Samuelson)
	FUNCTION		low and medium level benchmarks for ST80 and ST/V
	ST-VERSIONS		pre R4.0, R4.0, R4.1, ST/V
	PREREQUISITES	need floating point hardware or emulation
	CONFLICTS		none
	DISTRIBUTION	world
	VERSION			1.0
	DATE			April 16, 1993

!
!SMarkSmopstone class methodsFor: 'class initialization'!
initialize
	"added by nishis"
	"SmopstoneBenchmark initialize."

	| block |
	WhichFloatPrintOn := 7850 asFloat printString size = '7850.0' size.

	IsSupportRecursiveBlock := true.
	block := [:var | (var < 2) ifTrue: [block value: var + 1]].
	[block value: 1] 
		ifError: 
			[ :msg :rec | 
			IsSupportRecursiveBlock := false]
! !

!SMarkSuite methodsFor: 'helper'!
benchmarkNameForSelector: selector
	"Extracts the actual name of the benchmark from the selector"
	(selector beginsWith: #bench) ifTrue: [ ^ selector copyFrom: 6 to: selector size].
	^ selector asSymbol
	! !

!SMarkSuite methodsFor: 'helper'!
shouldRunSelector: selector
	(selector includes: $:) ifTrue: [ ^ false ].
	^ selector beginsWith: #bench! !

!SMarkSuite methodsFor: 'running'!
cleanUpInstanceVariables
	"Make sure all variables that are 'user variables' get cleaned"
	
	self class allInstVarNames do: [ :name |
		name = 'runner' ifFalse: [
			self instVarNamed: name put: nil ] ]! !

!SMarkSuite methodsFor: 'running'!
setUp
	"subclass responsibility to set up the necessary environment for a benchmark"
	^ self! !

!SMarkSuite methodsFor: 'running'!
tearDown
	"subclass responsibility to clean up the environment after a benchmark"
	^ self! !

!SMarkSuite methodsFor: 'benchmarking'!
performCustomSelector: aSelector with: aPrefix
	| customSelector |
	customSelector := (aPrefix, aSelector capitalized) asSymbol.
	(self respondsTo: customSelector) ifTrue: [ 
		self perform: customSelector].! !

!SMarkSuite methodsFor: 'benchmarking'!
problemSize
	^ runner problemSize! !

!SMarkSuite methodsFor: 'benchmarking'!
run
	"Executes all the benchmarks in the suite, 
	 coordinating with the runner when necessary"
	
	| potentialBenchmarkSelectors |
	selectedBenchmarks
		ifNotNil: [ potentialBenchmarkSelectors := selectedBenchmarks ]
		ifNil:    [ potentialBenchmarkSelectors := self class allSelectors ].				
	
	potentialBenchmarkSelectors
		do: [ :selector |
			(self shouldRunSelector: selector)
				ifTrue: [
					runner performBenchmark: selector ]
		].
	! !

!SMarkSuite methodsFor: 'benchmarking'!
runBenchmark: aSelector
	
	[self setUp.
	 self performCustomSelector: aSelector with: #setUp.
	 runner timedBenchmarkExecution: aSelector] ensure: [
		self performCustomSelector: aSelector with: #tearDown.
		self tearDown.
		self cleanUpInstanceVariables]! !

!SMarkSuite methodsFor: 'benchmarking'!
runOnly: aSymbol
	selectedBenchmarks := IdentitySet newFrom: { aSymbol }.! !

!SMarkSuite methodsFor: 'benchmarking'!
selectedBenchmarks
	^ selectedBenchmarks! !

!SMarkSuite methodsFor: 'accessing'!
runner
	^ runner! !

!SMarkSuite methodsFor: 'accessing'!
runner: aRunner
	runner := aRunner.! !

!SMarkSuite commentStamp: 'StefanMarr 3/20/2011 20:57' prior: 0!
A Benchmark Suite is a set of benchmarks and it knows what exactly needs to be executed.
However, it does not really know how to execute it.
It knows all the magic, that is, how to set up and tear down the environment for the benchmarks, but does not have the knowledge of how many iterations need to be done and how to evaluate any results that might be produced.!
!SMarkSuite class methodsFor: 'defaults'!
defaultProblemSize
	^ nil! !

!SMarkSuite class methodsFor: 'defaults'!
defaultRunner
	^ SMarkRunner! !

!SMarkSuite class methodsFor: 'benchmarking'!
isAbstractClass
	"This is a hack that is necessary in Squeak since it does not provide #isAbstractClass.
	 Actually this class is supposed to be abstract, but well, inheritance..."
	
	^ false! !

!SMarkSuite class methodsFor: 'benchmarking'!
run
	^ self defaultRunner execute: self new.! !

!SMarkSuite class methodsFor: 'benchmarking'!
run: nIterations
	^ self defaultRunner execute: self new with: nIterations.! !

!SMarkSuiteTest methodsFor: 'as yet unclassified'!
testBenchmarkNameForSelector
	| suite |
	suite := SMarkSuite new.
	
	self assert: (suite benchmarkNameForSelector: #benchSomething) equals: #Something.
	self assert: (suite benchmarkNameForSelector: #benchsomeThingElse) equals: #someThingElse.
	
	self assert: (suite benchmarkNameForSelector: #nobenchSomeThing) equals: #nobenchSomeThing.
	self assert: (suite benchmarkNameForSelector: #BenchSomeThing) equals: #BenchSomeThing.! !

!SMarkSuiteTest methodsFor: 'as yet unclassified'!
testClassRun
	| runner |
	
	runner := SMarkTestSuite run.
	self assert: (runner isKindOf: SMarkTestSuite defaultRunner).
	self deny: runner results isNil    ! !

!SMarkSuiteTest methodsFor: 'as yet unclassified'!
testCleanUpInstanceVariables
	| suite |
	suite := SMarkTestSuite new.
	suite runner: #dummy.
	
	self assert: suite runner	equals: #dummy.
	self assert: suite a			equals: 1.
	self assert: suite c			equals: #three.
				
	suite cleanUpInstanceVariables.
	
	self assert: suite runner	equals: #dummy.
	self assert: suite a			equals: nil.
	self assert: suite b			equals: nil.
	self assert: suite c			equals: nil.
	self assert: suite d			equals: nil.
! !

!SMarkSuiteTest methodsFor: 'as yet unclassified'!
testCustomSetUp
	| suite runner |
	
	suite := SMarkTestSuite new.
	runner := SMarkTestRunner execute: suite.  
	
	self assert: runner hasSetUpBenchB! !

!SMarkSuiteTest methodsFor: 'as yet unclassified'!
testCustomTearDown
	| suite runner |
	suite := SMarkTestSuite new.
	runner := SMarkTestRunner execute: suite.  
	
	self assert: runner hasTearDownBenchC.! !

!SMarkSuiteTest methodsFor: 'as yet unclassified'!
testRunOnly
	self assert: false description: 'not yet implemented'.! !

!SMarkSuiteTest methodsFor: 'as yet unclassified'!
testSetUp
	| suite runner |
	suite := SMarkTestSuite new.
	
	self assert: suite a			equals: 1.
	self assert: suite b			equals: 2.
	self assert: suite c			equals: #three.
	
	runner := SMarkTestRunner execute: suite.
	
	"Make sure they are reset after each run,
	 well we test just whether they are reset after the final run"
	self assert: suite a			equals: nil.
	self assert: suite b			equals: nil.
	self assert: suite c			equals: nil.
	self assert: suite d			equals: nil.

	"Make sure setUp was called 4 times."
	
	self assert: 4 equals: runner setUpCount.! !

!SMarkSuiteTest methodsFor: 'as yet unclassified'!
testSetupAndTeaddownCalledForEveryBenchForEveryIteration
	| suite runner |

	"Setup needs to be executed for every benchmark on every iteration.
	 Test with iterations: 1"
	suite := SMarkTestSuite new.
	runner := SMarkTestRunner execute: suite with: 1.

	self assert: 4 equals: runner setUpCount.
	self assert: 4 equals: runner tearDownCount.
	
	"Setup needs to be executed for every benchmark on every iteration.
	 Test with iterations: 4"
	suite := SMarkTestSuite new.
	runner := SMarkTestRunner execute: suite with: 4.

	self assert: (4 * 4) equals: runner setUpCount.
	self assert: (4 * 4) equals: runner tearDownCount.
	
	"Test with iterations: 10"
	suite := SMarkTestSuite new.
	runner := SMarkTestRunner execute: suite with: 10.
	self assert: (4 * 10) equals: runner setUpCount.
	self assert: (4 * 10) equals: runner tearDownCount.! !

!SMarkSuiteTest methodsFor: 'as yet unclassified'!
testShouldRunSelector
	| suite |
	suite := SMarkSuite new.
	
	self assert: (suite shouldRunSelector: #benchSomething).
	self assert: (suite shouldRunSelector: #benchsomeThingElse).
	
	self deny: (suite shouldRunSelector: #nobenchSomeThing).
	self deny: (suite shouldRunSelector: #BenchSomeThing).! !

!SMarkSuiteTest methodsFor: 'as yet unclassified'!
testTearDown
	| suite runner |
	suite := SMarkTestSuite new.
	runner := SMarkTestRunner execute: suite.  
	
	self assert: 4 equals: runner tearDownCount.! !

!SMarkTest methodsFor: 'tests'!
testAllBenchmarksForReturningThemSelf
	"This is a regression test to ensure that the old behavior worked in the first place"
	| allSuites |
	allSuites := SMarkSuite subclasses.
	
	allSuites do: [:suite |
		suite isAbstractClass ifFalse: [
			| runner results |
			Transcript show: (suite class name asString); cr.
			runner := suite run.
			results := runner results.
			self assert: (runner isKindOf: suite defaultRunner).
			self assert: 1 equals: runner iterations.
			self assert: (results size > 0).
		].
	].! !

!SMarkTest methodsFor: 'tests'!
testBasicRun
	| runner results benchResult result |
	
	runner := PBFloat run.
	results := runner results.
	result := (results at: #Add).
	
	self assert: (result isKindOf: Collection).
	self assert: result size equals: 1.
	
	benchResult := result at: 1.
	self assert: (benchResult isKindOf: SMarkResult).
	self assert: (benchResult total notNil).
	! !

!SMarkTest methodsFor: 'running'!
setUp
	"Necessary for Squeak 4.2 compatibility, since method anotations are not supported in the base image."
	(self respondsTo:  #timeout:) ifTrue: [
		self timeout: 300.
	].! !

!SMarkTest commentStamp: 'StefanMarr 3/12/2011 21:57' prior: 0!
A general test to ensure the overall framework works as expected.!
!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 11:01'!
baseBenchmarkExecuted
	^ baseBenchmarkExecuted! !

!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 11:01'!
countSetUpInvoke
	setUpCount := setUpCount + 1! !

!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 11:01'!
countTearDownInvoke
	tearDownCount := tearDownCount + 1! !

!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 11:01'!
countWasExecuted
	^ notifyRunnerWasExecuted ! !

!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 11:01'!
didPerform: aSymbol
	performedBenchmarks add: aSymbol.! !

!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 11:01'!
didRunBaseBenchmark
	baseBenchmarkExecuted := true.! !

!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 11:01'!
didSetUpBenchB
	didSetUpBenchB := true.! !

!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 11:01'!
didTearDownBenchC
	didTearDownBenchC := true.! !

!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 23:24'!
initialize
	super initialize.

	setUpCount := 0.
	tearDownCount := 0.
	notifyRunnerWasExecuted := 0.
	
	baseBenchmarkExecuted := false.

	performedBenchmarks := Set new.
	
	"set the targetTime to something which is more reasonable for testing"
	targetTime := 50.! !

!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 11:01'!
isNotifyRunnerWasExecutedSet
	^ notifyRunnerWasExecuted! !

!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 11:01'!
notifyRunnerWasExecuted
	notifyRunnerWasExecuted := notifyRunnerWasExecuted + 1! !

!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 11:01'!
performedBenchmarks
	^ performedBenchmarks! !

!SMarkTestAutosizeRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 11:01'!
setUp
	notifyRunnerWasExecuted := false! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 18:35'!
baseBenchmarkExecuted
	^ baseBenchmarkExecuted! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 17:36'!
countSetUpInvoke
	setUpCount := setUpCount + 1! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 17:39'!
countTearDownInvoke
	tearDownCount := tearDownCount + 1! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 19:44'!
countWasExecuted
	^ notifyRunnerWasExecuted ! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 19:00'!
didPerform: aSymbol
	performedBenchmarks add: aSymbol.! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 17:56'!
didRunBaseBenchmark
	baseBenchmarkExecuted := true.! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 17:43'!
didSetUpBenchB
	didSetUpBenchB := true.! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 17:42'!
didTearDownBenchC
	didTearDownBenchC := true.! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 12:14'!
hasSetUpBenchB
	^ didSetUpBenchB.! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 12:21'!
hasTearDownBenchC
	^ didTearDownBenchC! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 19:49'!
initialize
	super initialize.

	setUpCount := 0.
	tearDownCount := 0.
	notifyRunnerWasExecuted := 0.
	
	baseBenchmarkExecuted := false.

	performedBenchmarks := OrderedCollection new.! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/15/2011 22:16'!
isNotifyRunnerWasExecutedSet
	^ notifyRunnerWasExecuted! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 19:44'!
notifyRunnerWasExecuted
	notifyRunnerWasExecuted := notifyRunnerWasExecuted + 1! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 19:00'!
performedBenchmarks
	^ performedBenchmarks! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/15/2011 22:15'!
setUp
	notifyRunnerWasExecuted := false! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 12:27'!
setUpCount
	^ setUpCount! !

!SMarkTestRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 12:39'!
tearDownCount
	^ tearDownCount! !

!SMarkTestRunnerSuite methodsFor: 'as yet unclassified'!
benchDoNothing
	"Just a dummy that should be executed and result in some measured value"
	^ self! !

!SMarkTestRunnerSuite methodsFor: 'as yet unclassified'!
benchNotifyRunner
	runner notifyRunnerWasExecuted.
	^ self! !

!SMarkTestRunnerSuite commentStamp: 'StefanMarr 3/13/2011 22:58' prior: 0!
This is a benchmark suite used to test the benchmark runner!
!SMarkTestRunnerSuite class methodsFor: 'as yet unclassified'!
isAbstractClass
	"This is more like a hack, but we do not want to execute this as a benchmark"
	^ true! !

!SMarkTestRunnerSuiteForAutosizing methodsFor: 'as yet unclassified'!
baseBenchmark
	(Delay forMilliseconds: 5) wait.! !

!SMarkTestRunnerSuiteForAutosizing methodsFor: 'as yet unclassified'!
benchBig
	(Delay forMilliseconds: 100) wait.! !

!SMarkTestRunnerSuiteForAutosizing methodsFor: 'as yet unclassified'!
benchSmall
	(Delay forMilliseconds: 5) wait.! !

!SMarkTestRunnerSuiteForAutosizing class methodsFor: 'as yet unclassified'!
defaultRunner
	^ SMarkTestRunner! !

!SMarkTestRunnerSuiteForPerfromBenchmark methodsFor: 'as yet unclassified'!
BenchShouldNotBeExecuted
	"This one should not be executed"
	(Delay forMilliseconds: 5) wait.
	runner didPerform: #BenchShouldNotBeExecuted.! !

!SMarkTestRunnerSuiteForPerfromBenchmark methodsFor: 'as yet unclassified'!
baseBenchmark
	(Delay forMilliseconds: 5) wait.
	runner didPerform: #baseBenchmark.! !

!SMarkTestRunnerSuiteForPerfromBenchmark methodsFor: 'as yet unclassified'!
benchAfsdfsdfsdf
	(Delay forMilliseconds: 5) wait.
	runner didPerform: #benchAfsdfsdfsdf.! !

!SMarkTestRunnerSuiteForPerfromBenchmark methodsFor: 'as yet unclassified'!
benchBsdfasereSDSfsdfsdfs
	(Delay forMilliseconds: 5) wait.
	runner didPerform: #benchBsdfasereSDSfsdfsdfs.! !

!SMarkTestRunnerSuiteForPerfromBenchmark methodsFor: 'as yet unclassified'!
benchC
	(Delay forMilliseconds: 5) wait.
	runner didPerform: #benchC.! !

!SMarkTestRunnerSuiteForPerfromBenchmark methodsFor: 'as yet unclassified'!
benchZZ
	(Delay forMilliseconds: 5) wait.
	runner didPerform: #benchZZ.! !

!SMarkTestRunnerSuiteForPerfromBenchmark class methodsFor: 'as yet unclassified'!
defaultRunner
	^ SMarkTestRunner! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/12/2011 22:15'!
a
	^a! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/12/2011 22:15'!
b
	^b! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 00:35'!
benchA
	a := #executed.
	(Delay forMilliseconds: 1) wait.! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 00:38'!
benchB
	b := #executed.
	(Delay forMilliseconds: 1) wait.! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/12/2011 22:37'!
benchC
	c := #executed.! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/19/2011 01:04'!
benchWithMultipleCriteria
	| t1 t2 t3 |
	t3 := runner createTimer: 't3'.
	t3 start.
	
	(Delay forMilliseconds: 25) wait.
	
	t2:= runner createTimer: 't2'.
	t2 start.
	(Delay forMilliseconds: 15) wait.	
	
	t1 := runner createTimer: 't1'.  
	t1 start.
	(Delay forMilliseconds: 10) wait.
	
	
	t3 stop.
	t2 stop.
	t1 stop.    ! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/12/2011 22:15'!
c
	^c! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/12/2011 22:15'!
d
	^d! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 19:50'!
initialize
	super initialize.
	
	"Filling in some test data"
	a := 1.
	b := 2.
	c := #three.
	d := '42'.
	! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/12/2011 22:39'!
setUp
	runner countSetUpInvoke! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/13/2011 20:29'!
setUpBenchB
	runner didSetUpBenchB! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/12/2011 22:39'!
tearDown
	runner countTearDownInvoke! !

!SMarkTestSuite methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/13/2011 20:30'!
tearDownBenchC
	runner didTearDownBenchC! !

!SMarkTestSuite commentStamp: 'StefanMarr 3/12/2011 22:13' prior: 0!
This class is used for unit testing only.!
!SMarkTestSuite class methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/20/2011 21:09'!
defaultRunner
	^ SMarkTestRunner! !

!SMarkTestSuite class methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/13/2011 20:57'!
isAbstractClass
	"This is more like a hack, but we do not want to execute this as a benchmark"
	^ true! !

!SMarkTestSuiteWithBaseBenchmark methodsFor: 'as yet unclassified' stamp: 'StefanMarr 3/18/2011 18:32'!
baseBenchmark
	runner didRunBaseBenchmark.! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 10:44'!
baseBenchmarkExecuted
	^ baseBenchmarkExecuted! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 10:41'!
countSetUpInvoke
	setUpCount := setUpCount + 1! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 10:41'!
countTearDownInvoke
	tearDownCount := tearDownCount + 1! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 10:41'!
countWasExecuted
	^ notifyRunnerWasExecuted ! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 10:41'!
didPerform: aSymbol
	performedBenchmarks add: aSymbol.! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 10:42'!
didRunBaseBenchmark
	baseBenchmarkExecuted := true.! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 10:42'!
didSetUpBenchB
	didSetUpBenchB := true.! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 10:42'!
didTearDownBenchC
	didTearDownBenchC := true.! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 10:42'!
initialize
	super initialize.

	setUpCount := 0.
	tearDownCount := 0.
	notifyRunnerWasExecuted := 0.
	
	baseBenchmarkExecuted := false.

	performedBenchmarks := OrderedCollection new.! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 13:20'!
isNotifyRunnerWasExecutedSet
	^ notifyRunnerWasExecuted > 0! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 10:42'!
notifyRunnerWasExecuted
	notifyRunnerWasExecuted := notifyRunnerWasExecuted + 1! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 10:42'!
performedBenchmarks
	^ performedBenchmarks! !

!SMarkTestWeakScalingRunner methodsFor: 'as yet unclassified' stamp: 'StefanMarr 4/15/2011 10:43'!
setUp
	notifyRunnerWasExecuted := false! !

!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24'!
currentMillis
	"hack to make it work under most Smalltalkses and Pinocchio"
	"STEFAN: had to take this out, since my images do not support pragmas
	 <pPrimitive: #millisecondClock plugin: #'Chronology.Time' >"
	^ Time millisecondClockValue! !

!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/14/2011 08:54'!
reset
	startTime := 0.
	elapsedTime := 0.! !

!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:24'!
start
	startTime := self currentMillis.! !

!SMarkTimer methodsFor: 'timing' stamp: 'StefanMarr 3/20/2011 12:25'!
stop
	| elapsedInThisPeriod current |
	current := self currentMillis.
	
	elapsedInThisPeriod := Time milliseconds: current since: startTime.
	
	elapsedTime := elapsedTime + elapsedInThisPeriod.! !

!SMarkTimer methodsFor: 'initialization' stamp: 'StefanMarr 3/14/2011 08:54'!
initialize
	elapsedTime := 0! !

!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54'!
name
	^name! !

!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54'!
name: aString
	name := aString ! !

!SMarkTimer methodsFor: 'accessing' stamp: 'StefanMarr 3/14/2011 08:54'!
totalTime
	^elapsedTime! !

!SMarkTimer class methodsFor: 'instance creation' stamp: 'StefanMarr 3/14/2011 08:54'!
new: aName
	| timer |
	
	timer := super new.
	timer name: aName.
	
	^timer! !

!SMarkTimerTest methodsFor: 'as yet unclassified'!
testName
	| timer |
	timer := SMarkTimer new.
	
	self assert: timer name equals: nil.
	
	timer name: #foo.
	
	self assert: timer name equals: #foo.! !

!SMarkTimerTest methodsFor: 'as yet unclassified'!
testReset
	| timer |
	timer := SMarkTimer new.
	
	timer start.
	(Delay forMilliseconds: 10) wait.
	timer stop.
	
	self assert: (timer totalTime >= 10).
	
	timer reset.
	
	self assert: timer totalTime equals: 0.! !

!SMarkTimerTest methodsFor: 'as yet unclassified'!
testStartStop
	| timer |
	timer := SMarkTimer new.
	
	self assert: timer totalTime equals: 0.
	
	timer start.
	
	(Delay forMilliseconds: 10) wait.
	
	timer stop.
	
	self assert: (timer totalTime >= 10).! !

!SMarkTimerTest methodsFor: 'as yet unclassified'!
testTotalTimeWithResume
	| timer |
	timer := SMarkTimer new.
	self assert: timer totalTime equals: 0.
	
	timer start.
	(Delay forMilliseconds: 10) wait.
	timer stop.
	
	self assert: (timer totalTime >= 10).
	
	timer start.
	(Delay forMilliseconds: 10) wait.
	timer stop.
	
	self assert: (timer totalTime >= 20).
	
	timer start.
	(Delay forMilliseconds: 10) wait.
	timer stop.
	
	self assert: (timer totalTime >= 30).! !

!SMarkTransporter commentStamp: 'sm 5/25/2011 14:09' prior: 0!
SMarkTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!
!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 17:13'!
execute: aSelector withProcesses: numberOfProcesses withTimer: timer
	"This case is meant for all cases. REM: this is also used for numProc==1 to be able to measure the process start overhead in all cases.
	 It will start the processes and wait for their completion."
	
	| processes |
	processes			:= Array new: numberOfProcesses.
	runningProcessesMtx := Semaphore forMutualExclusion.
	completionSignal		:= Semaphore new.
	runningProcesses := numberOfProcesses.
	
	"First initialize the processes"
	1 to: numberOfProcesses do: [ :procNum |
		| proc |
		proc := SMarkWeakScalingRunnerExecutor createFor: aSelector for: numInnerIterations with: self and: suite.
		proc priority: Processor highestPriority.
		proc name: (self class name, '-',  procNum asString).
		processes at: procNum put: proc.
		"On: procNum"
	].
	
	"Now, execute the benchmark and do the timing now"
	timer start.
	1 to: numberOfProcesses do: [ :procNum |
		(processes at: procNum) resume.
	].
	completionSignal wait.
	timer stop.
	! !

!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:17'!
executorCompleted
	runningProcessesMtx critical: [
		runningProcesses := runningProcesses - 1.
		(runningProcesses == 0) ifTrue: [
			completionSignal signal.
		]
	]! !

!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43'!
innerIterations
	"The number of inner iterations the benchmark is executed inside a processes"
	^ numInnerIterations! !

!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 15:43'!
innerIterations: anInteger
	"The number of inner iterations the benchmark is executed inside a processes"
	numInnerIterations := anInteger! !

!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:54'!
processes
	^ numProcesses! !

!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'StefanMarr 4/15/2011 10:53'!
processes: anInteger
	numProcesses := anInteger! !

!SMarkWeakScalingRunner methodsFor: 'benchmarking' stamp: 'sm 5/25/2011 18:31'!
timedBenchmarkExecution: aSelector
	"Will do a timed execution of the benchmark and return the result timer"
	| timer |
	timers := Dictionary new.

	timer := self createTimer: 'total'.
	
	self execute: aSelector withProcesses: numProcesses withTimer: timer.
	
	self recordResults: timer for: aSelector.
	
	^ timer! !

!SMarkWeakScalingRunner methodsFor: 'initialization' stamp: 'StefanMarr 4/15/2011 15:43'!
initialize
	super initialize.
	numProcesses			:= self class defaultNumberOfProcesses.
	numInnerIterations	:= self class defaultNumberOfInnerIterations.
! !

!SMarkWeakScalingRunner methodsFor: 'reporting' stamp: 'sm 5/25/2011 17:50'!
reportConfiguration: aStream
	super reportConfiguration: aStream.
	aStream << ('inner iterations: ', numInnerIterations asString); cr.! !

!SMarkWeakScalingRunner class methodsFor: 'defaults' stamp: 'StefanMarr 4/15/2011 15:42'!
defaultNumberOfInnerIterations
	"The number of iterations of the inner loop
	 in which the benchmark is executed."
	^ 1! !

!SMarkWeakScalingRunnerExecutor methodsFor: 'benchmarking' stamp: 'sm 5/30/2011 16:22'!
run
	1 to: numInnerIterations do: [:i |
		suite perform: benchmarkSelector.].
	
	runner executorCompleted.! !

!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20'!
benchmarkSelector: aSelector
	benchmarkSelector := aSelector! !

!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:20'!
innerIterations: anInt
	numInnerIterations := anInt! !

!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21'!
runner: aRunner
	runner := aRunner! !

!SMarkWeakScalingRunnerExecutor methodsFor: 'accessing' stamp: 'sm 5/30/2011 16:21'!
suite: aSuite
	suite := aSuite! !

!SMarkWeakScalingRunnerExecutor class methodsFor: 'as yet unclassified' stamp: 'sm 5/30/2011 16:33'!
createFor: aSelector for: numIterations with: aRunner and: aSuite
	| o |
	o := self new.
	o runner: aRunner.
	o suite: aSuite.
	o innerIterations: numIterations.
	o benchmarkSelector: aSelector.
	^ ([ o run ] newProcess)! !

!SMarkWeakScalingRunnerTest methodsFor: 'as yet unclassified'!
runnerClass
	^ SMarkTestWeakScalingRunner! !

!SMarkWeakScalingRunnerTest methodsFor: 'as yet unclassified'!
testInnerIterations
	"Test the semantics of the inner loop parameter"
	| runner results |
	
	"Setup"
	runner := self runnerClass new.
	runner iterations: 1.
	runner innerIterations: 1.  
	runner processes: 10.
	runner suite: SMarkTestRunnerSuite new.
	results := runner execute.
	
	self assert: 10 equals: runner countWasExecuted.
	self assert: 1  equals: (results at: #NotifyRunner) size.
	
	runner := self runnerClass new.
	runner iterations: 2.
	runner innerIterations: 1.  
	runner processes: 10.
	runner suite: SMarkTestRunnerSuite new.
	results := runner execute.
	
	self assert: 20 equals: runner countWasExecuted.
	self assert: 2  equals: (results at: #NotifyRunner) size.
	
	
	runner := self runnerClass new.
	runner iterations: 2.
	runner innerIterations: 4.  
	runner processes: 10.
	runner suite: SMarkTestRunnerSuite new.
	results := runner execute.
	
	self assert: (20 * 4) equals: runner countWasExecuted.
	self assert: 2  equals: (results at: #NotifyRunner) size.
	
	runner := self runnerClass new.
	runner iterations: 4.
	runner innerIterations: 7.  
	runner processes: 10.
	runner suite: SMarkTestRunnerSuite new.
	results := runner execute.
	
	self assert: (40 * 7) equals: runner countWasExecuted.
	self assert: 4           equals: (results at: #NotifyRunner) size.! !

!SMarkWeakScalingRunnerTest methodsFor: 'as yet unclassified'!
testWeakScaling3Processes
	"test with small number of processes and varying number of iterations"
	| runner results |
	
	"Setup for 2 iteration, and 3 process"
	runner := self runnerClass new.
	runner iterations: 2.
	runner processes: 3.
	runner suite: SMarkTestRunnerSuite new.
	results := runner execute.
	
	self assert: 6 equals: runner countWasExecuted.
	self assert: 2 equals: (results at: #NotifyRunner) size.! !

!SMarkWeakScalingRunnerTest methodsFor: 'as yet unclassified'!
testWeakScalingFewProcesses
	"test with small number of processes and varying number of iterations"
	| runner results |
	
	"Setup for 1 iteration, and 1 process"
	runner := self runnerClass new.
	runner iterations: 1.
	runner processes: 1.
	runner suite: SMarkTestRunnerSuite new.
	results := runner execute.
	
	self assert: 1 equals: runner countWasExecuted.
	! !

!SMarkWeakScalingRunnerTest methodsFor: 'as yet unclassified'!
testWeakScalingManyProcesses
	"test with large number of processes and varying number of iterations"
	| runner results |
	
	"Setup"
	runner := self runnerClass new.
	runner iterations: 1.
	runner processes: 10.
	runner suite: SMarkTestRunnerSuite new.
	results := runner execute.
	
	self assert: 10 equals: runner countWasExecuted.
	self assert: 1  equals: (results at: #NotifyRunner) size.
	
	runner := self runnerClass new.
	runner iterations: 2.
	runner processes: 10.
	runner suite: SMarkTestRunnerSuite new.
	results := runner execute.
	
	self assert: 20 equals: runner countWasExecuted.
	self assert: 2  equals: (results at: #NotifyRunner) size.
	
	runner := self runnerClass new.
	runner iterations: 4.
	runner processes: 10.
	runner suite: SMarkTestRunnerSuite new.
	results := runner execute.
	
	self assert: 40 equals: runner countWasExecuted.
	self assert: 4  equals: (results at: #NotifyRunner) size.! !

!SMarkWeakScalingRunnerTest class methodsFor: 'as yet unclassified'!
shouldInheritSelectors
	^ true! !

!SUnitAPIDocumentation class methodsFor: 'accessing' stamp: 'tbn 12/16/2010 22:39'!
bookName
	^'API Documentation'! !

!SUnitAPIDocumentation class methodsFor: 'accessing' stamp: 'tbn 12/16/2010 22:40'!
packages
	^#('SUnit-Core-Announcements' 'SUnit-Core-Extensions' 'SUnit-Core-Kernel' 'SUnit-Core-Kernel' 'SUnit-Core-Utilities' 'SUnit-Tests' 'SUnit-UI')! !

!SUnitAPIDocumentation class methodsFor: 'defaults' stamp: 'tbn 12/16/2010 22:39'!
builder
	^PackageAPIHelpBuilder! !

!SUnitExtensionsTest methodsFor: 'accessing' stamp: 'GuillermoPolito 9/1/2010 18:24'!
stream
	^stream ifNil: [stream := String new writeStream].! !

!SUnitExtensionsTest methodsFor: 'as yet unclassified' stamp: 'md 4/2/2006 14:02'!
testExceptionWithMatchingString
	self should: [ Object obsolete ] raise: Error whoseDescriptionIncludes: 'NOT obsolete' description: 'tested obsoleting Object'! !

!SUnitExtensionsTest methodsFor: 'as yet unclassified' stamp: 'md 4/2/2006 14:02'!
testExceptionWithoutMatchingString
	self should: [ Object obsolete ] raise: Error whoseDescriptionDoesNotInclude: 'Zero' description: 'tested obsoleting Object'! !

!SUnitExtensionsTest methodsFor: 'as yet unclassified' stamp: 'md 4/2/2006 14:02'!
testNoExceptionWithMatchingString
	self shouldnt: [ Object obsolete ] raise: Error whoseDescriptionIncludes: 'Zero' description: 'tested obsoleting Object'! !

!SUnitExtensionsTest methodsFor: 'as yet unclassified' stamp: 'md 4/2/2006 14:02'!
testNoExceptionWithNoMatchingString
	self shouldnt: [ Object obsolete ] raise: Error whoseDescriptionDoesNotInclude: 'NOT' description: 'tested obsoleting Object'! !

!SUnitExtensionsTest methodsFor: 'real tests' stamp: 'mx 3/20/2006 23:47'!
assertionFailedInRaiseWithExceptionDoTest

	self 
		should: [ Error signal ]
		raise: Error
		withExceptionDo: [ :anException | self assert: false ]! !

!SUnitExtensionsTest methodsFor: 'real tests' stamp: 'mx 3/20/2006 23:47'!
differentExceptionInShouldRaiseWithExceptionDoTest

	[ self 
		should: [ Error signal ]
		raise: Halt
		withExceptionDo: [ :anException | self assert: false description: 'should:raise:withExceptionDo: handled an exception that should not handle'] ]
	on: Error
	do: [ :anException | anException return: nil ]! !

!SUnitExtensionsTest methodsFor: 'real tests' stamp: 'mx 3/20/2006 23:47'!
errorInRaiseWithExceptionDoTest

	self 
		should: [ Error  signal ]
		raise: Error
		withExceptionDo: [ :anException | Error signal: 'A forced error' ]! !

!SUnitExtensionsTest methodsFor: 'real tests' stamp: 'EstebanLorenzano 11/11/2010 17:13'!
invalidShouldNotTakeMoreThan

	self should: [(Delay forMilliseconds: 100) wait] notTakeMoreThan: 50 milliSeconds.! !

!SUnitExtensionsTest methodsFor: 'real tests'!
invalidShouldNotTakeMoreThanMilliseconds

	self should: [(Delay forMilliseconds: 100) wait] notTakeMoreThanMilliseconds: 50! !

!SUnitExtensionsTest methodsFor: 'real tests' stamp: 'mx 3/20/2006 23:47'!
noExceptionInShouldRaiseWithExceptionDoTest

	self 
		should: [  ]
		raise: Error
		withExceptionDo: [ :anException | Error signal: 'Should not get here' ]! !

!SUnitExtensionsTest methodsFor: 'real tests'!
shouldFixTest

	self shouldFix: [ Error signal: 'any kind of error' ]
! !

!SUnitExtensionsTest methodsFor: 'real tests' stamp: 'mx 3/20/2006 23:47'!
shouldRaiseWithExceptionDoTest

	self 
		should: [ Error signal: '1' ]
		raise: Error
		withExceptionDo: [ :anException | self assert: anException messageText = '1' ]! !

!SUnitExtensionsTest methodsFor: 'real tests' stamp: 'mx 3/20/2006 23:47'!
shouldRaiseWithSignalDoTest

	self 
		should: [ Error signal: '1' ]
		raise: Error
		withExceptionDo: [ :anException | self assert: anException messageText = '1' ]! !

!SUnitExtensionsTest methodsFor: 'real tests' stamp: 'md 8/2/2006 11:05'!
validShouldNotTakeMoreThan

	self should: [(Delay forMilliseconds: 100) wait] notTakeMoreThan:  200 milliSeconds.! !

!SUnitExtensionsTest methodsFor: 'real tests'!
validShouldNotTakeMoreThanMilliseconds

	self should: [(Delay forMilliseconds: 100) wait] notTakeMoreThanMilliseconds: 200! !

!SUnitExtensionsTest methodsFor: 'test' stamp: 'mx 3/20/2006 23:39'!
testAssertionFailedInRaiseWithExceptionDo

	| testCase testResult  |
	
	testCase := self class selector: #assertionFailedInRaiseWithExceptionDoTest.
	testResult := testCase run.
	
	self assert: (testResult failures includes: testCase).
	self assert: testResult failures size=1.
	self assert: testResult passed isEmpty.
	self assert: testResult errors isEmpty.
	
	! !

!SUnitExtensionsTest methodsFor: 'test' stamp: 'mx 3/20/2006 21:15'!
testAutoAssertFalse
	| booleanCondition |
	self assert: self isLogging.
	self should: [ self assert: 1 = 2 description: 'self assert: 1 = 2' ] raise: TestResult failure.
	booleanCondition := (self stream contents subStrings: {Character cr}) last = 'self assert: 1 = 2'.
	self assert: booleanCondition! !

!SUnitExtensionsTest methodsFor: 'test'!
testAutoAssertTrue
	self assert: 1 = 1.
	self assert: true! !

!SUnitExtensionsTest methodsFor: 'test' stamp: 'mx 3/20/2006 21:16'!
testAutoDenyFalse
	| booleanCondition |
	self assert: self isLogging.
	self should: [ self deny: 1 = 1 description: 'self deny: 1 = 1'.] raise: TestResult failure.
	booleanCondition := (self stream contents subStrings:  {Character cr}) last = 'self deny: 1 = 1'.
	self assert: booleanCondition! !

!SUnitExtensionsTest methodsFor: 'test'!
testAutoDenyTrue
	self deny: 1 = 2.
	self deny: false! !

!SUnitExtensionsTest methodsFor: 'test' stamp: 'mx 3/20/2006 23:40'!
testDifferentExceptionInShouldRaiseWithExceptionDo

	| testCase testResult  |
	
	testCase := self class selector: #differentExceptionInShouldRaiseWithExceptionDoTest.
	testResult := testCase run.
	
	self assert: (testResult passed includes: testCase).
	self assert: testResult errors isEmpty.
	self assert: testResult failures isEmpty.
	self assert: testResult passed size=1! !

!SUnitExtensionsTest methodsFor: 'test' stamp: 'mx 3/20/2006 23:40'!
testErrorInRaiseWithExceptionDo

	| testCase testResult  |
	
	testCase := self class selector: #errorInRaiseWithExceptionDoTest.
	testResult := testCase run.
		
	self assert: (testResult errors includes: testCase).
	self assert: testResult errors size=1.
	self assert: testResult failures isEmpty.
	self assert: testResult passed isEmpty.
	
	! !

!SUnitExtensionsTest methodsFor: 'test' stamp: 'md 8/2/2006 11:06'!
testInvalidShouldNotTakeMoreThan

	| testCase testResult |

	testCase := self class selector: #invalidShouldNotTakeMoreThan.
	testResult := testCase run.

	self assert: testResult passed isEmpty.
	self assert: testResult failures size = 1.
	self assert: (testResult failures includes: testCase).
	self assert: testResult errors isEmpty

! !

!SUnitExtensionsTest methodsFor: 'test'!
testInvalidShouldNotTakeMoreThanMilliseconds

	| testCase testResult |

	testCase := self class selector: #invalidShouldNotTakeMoreThanMilliseconds.
	testResult := testCase run.

	self assert: testResult passed isEmpty.
	self assert: testResult failures size = 1.
	self assert: (testResult failures includes: testCase).
	self assert: testResult errors isEmpty

! !

!SUnitExtensionsTest methodsFor: 'test' stamp: 'mx 3/20/2006 23:40'!
testNoExceptionInShouldRaiseWithExceptionDo

	| testCase testResult  |
	
	testCase := self class selector: #noExceptionInShouldRaiseWithExceptionDoTest.
	testResult := testCase run.
	
	self assert: (testResult failures includes: testCase).
	self assert: testResult failures size=1.
	self assert: testResult passed isEmpty.
	self assert: testResult errors isEmpty.
	
	! !

!SUnitExtensionsTest methodsFor: 'test'!
testShouldFix

	| testCase testResult  |
	
	testCase := self class selector: #shouldFixTest.
	testResult := testCase run.
	
	self assert: (testResult passed includes: testCase).
	self assert: testResult passed size=1.
	self assert: testResult failures isEmpty.
	self assert: testResult errors isEmpty.
	
	! !

!SUnitExtensionsTest methodsFor: 'test' stamp: 'mx 3/20/2006 23:40'!
testShouldRaiseWithExceptionDo

	| testCase testResult  |
	
	testCase := self class selector: #shouldRaiseWithExceptionDoTest.
	testResult := testCase run.
	
	self assert: (testResult passed includes: testCase).
	self assert: testResult passed size=1.
	self assert: testResult failures isEmpty.
	self assert: testResult errors isEmpty.
	
	! !

!SUnitExtensionsTest methodsFor: 'test' stamp: 'md 8/2/2006 11:06'!
testValidShouldNotTakeMoreThan
	| testCase testResult |

	testCase := self class selector: #validShouldNotTakeMoreThan.
	testResult := testCase run.

	self assert: (testResult passed includes: testCase).
	self assert: testResult passed size = 1.
	self assert: testResult failures isEmpty.
	self assert: testResult errors isEmpty

! !

!SUnitExtensionsTest methodsFor: 'test'!
testValidShouldNotTakeMoreThanMilliseconds

	| testCase testResult |

	testCase := self class selector: #validShouldNotTakeMoreThanMilliseconds.
	testResult := testCase run.

	self assert: (testResult passed includes: testCase).
	self assert: testResult passed size = 1.
	self assert: testResult failures isEmpty.
	self assert: testResult errors isEmpty

! !

!SUnitExtensionsTest methodsFor: 'test support'!
failureLog
	^self stream! !

!SUnitExtensionsTest methodsFor: 'testing'!
isLogging
	^true! !

!SUnitExtensionsTest class methodsFor: 'history' stamp: 'simon.denier 11/22/2008 22:13'!
lastStoredRun
	^ ((Dictionary new) add: (#passed->((Set new) add: #testNoExceptionWithMatchingString; add: #testNoExceptionWithNoMatchingString; add: #testExceptionWithMatchingString; add: #testExceptionWithoutMatchingString; add: #testValidShouldNotTakeMoreThan; add: #testInvalidShouldNotTakeMoreThanMilliseconds; add: #testDifferentExceptionInShouldRaiseWithExceptionDo; add: #testShouldRaiseWithExceptionDo; add: #testShouldFix; add: #testAssertionFailedInRaiseWithExceptionDo; add: #testAutoDenyFalse; add: #testAutoDenyTrue; add: #testAutoAssertFalse; add: #testAutoAssertTrue; add: #testValidShouldNotTakeMoreThanMilliseconds; add: #testErrorInRaiseWithExceptionDo; add: #testNoExceptionInShouldRaiseWithExceptionDo; add: #testInvalidShouldNotTakeMoreThan; yourself)); add: (#timeStamp->'22 November 2008 10:11:35 pm'); add: (#failures->((Set new))); add: (#errors->((Set new))); yourself)! !

!SUnitHelp commentStamp: 'tbn 12/16/2010 22:26' prior: 0!
This is a custom help book for the SUnit framework.
!
!SUnitHelp class methodsFor: 'accessing' stamp: 'tbn 12/16/2010 22:19'!
bookName
	^'SUnit framework'! !

!SUnitHelp class methodsFor: 'accessing' stamp: 'tbn 4/26/2011 15:37'!
pages
	^#(introduction running SUnitTutorial SUnitAPIDocumentation links)! !

!SUnitHelp class methodsFor: 'pages' stamp: 'tbn 12/16/2010 23:31'!
introduction
	"This method was automatically generated. Edit it using:"
	"SUnitHelp edit: #introduction"
	^HelpTopic
		title: 'Introduction'
		contents: 
'SUnit is the mother of all unit testing frameworks, and serves as one of the cornerstones of test-driven development methodologies such as eXtreme Programming. 

The culture of testing has always been part of the philosophy of development in Smalltalk:
You write a method, accept the code and test it by writing a small script in a workspace, in a comment or an example as a class method. But this approach does not allow to automatically repeat the testing or ensure that the code is working. SUnit is a framework you can use to describe and execute unit tests. Unit testing is a method by which individual units of source code are tested to determine if they are fit for use. A unit is the smallest testable part of an application.!!' readStream nextChunkText! !

!SUnitHelp class methodsFor: 'pages' stamp: 'tbn 4/26/2011 15:37'!
links
	"This method was automatically generated. Edit it using:"
	"SUnitHelp edit: #links"
	^HelpTopic
		title: 'Links'
		contents: 
'Visit the following sites to get more informations on SUnit

- http://sunit.sourceforge.net/
- http://www.iam.unibe.ch/~ducasse/Programmez/OnTheWeb/Eng-Art8-SUnit-V1.pdf
- http://en.wikipedia.org/wiki/SUnit!!' readStream nextChunkText! !

!SUnitHelp class methodsFor: 'pages' stamp: 'tbn 12/16/2010 23:31'!
running
	"This method was automatically generated. Edit it using:"
	"SUnitHelp edit: #running"
	^HelpTopic
		title: 'Running tests'
		contents: 
'SUnit allows writing tests on Smalltalk source code and checking results. This is usually done in a tool called TestRunner which you can either open from the Pharo world menu or by evaluating:

   TestRunner open

in a Smalltalk workspace.

By writing tests and checking them with the test runner you can ensure the sustainability of your applications.

!!' readStream nextChunkText! !

!SUnitTest methodsFor: 'accessing'!
hasRun
	^hasRun! !

!SUnitTest methodsFor: 'accessing'!
hasSetup
	^hasSetup! !

!SUnitTest methodsFor: 'running'!
setUp
	hasSetup := true! !

!SUnitTest methodsFor: 'testing' stamp: 'md 2/22/2006 14:17'!
errorShouldntRaise
	self 
		shouldnt: [self someMessageThatIsntUnderstood] 
		raise: Notification new
			! !

!SUnitTest methodsFor: 'testing'!
expectedFailures
	^#(expectedFailureFails expectedFailurePasses)! !

!SUnitTest methodsFor: 'testing'!
testAssert
	self assert: true.
	self deny: false! !

!SUnitTest methodsFor: 'testing'!
testDefects
	| result suite error failure |
	suite := TestSuite new.
	suite addTest: (error := self class selector: #error).
	suite addTest: (failure := self class selector: #fail).
	result := suite run.
	self assert: result defects asArray = (Array with: error with: failure).
	self
		assertForTestResult: result
		runCount: 2
		passed: 0
		failed: 1
		errors: 1! !

!SUnitTest methodsFor: 'testing'!
testDialectLocalizedException

	self
		should: [TestResult signalFailureWith: 'Foo']
		raise: TestResult failure.
	self
		should: [TestResult signalErrorWith: 'Foo']
		raise: TestResult error.! !

!SUnitTest methodsFor: 'testing'!
testError

	| case result |

	case := self class selector: #error.
	result := case run.
	self
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 0
		errors: 1.

	case := self class selector: #errorShouldntRaise.
	result := case run.
	self 
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 0
		errors: 1! !

!SUnitTest methodsFor: 'testing'!
testException

	self
		should: [self error: 'foo']
		raise: TestResult error! !

!SUnitTest methodsFor: 'testing'!
testExpectedFailure

	| case result |
	case := self class selector: #expectedFailureFails.
	self deny: case shouldPass.
	result := case run.
	self
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 0
		errors: 0
		expectedFailures: 1.! !

!SUnitTest methodsFor: 'testing'!
testExpectedFailureDetection
	self assert: self expectedFailures size = 2.
	self assert: (self expectedFailures includesAllOf: #(expectedFailureFails expectedFailurePasses))! !

!SUnitTest methodsFor: 'testing'!
testExpectedFailurePass

	| case result |
	case := self class selector: #expectedFailurePasses.
	self deny: case shouldPass.
	result := case run.
	self
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 1
		errors: 0
		expectedFailures: 0.! !

!SUnitTest methodsFor: 'testing'!
testFail

	| case result |

	case := self class selector: #fail.
	result := case run.

	self
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 1
		errors: 0! !

!SUnitTest methodsFor: 'testing'!
testFileOutResult
	| suite result fileout |
	
	suite := TestSuite new.
	suite 
		addTest: (self class selector: #noop);
		addTest: (self class selector: #fail);
		addTest: (self class selector: #error).

	result := suite run.
	fileout := String streamContents: [:aStream| result fileOutOn: aStream].
	self 
		assert: fileout 
		equals: 
 '3 run, 1 passes, 0 expected failures, 1 failures, 1 errors, 0 unexpected passes
Failures:
SUnitTest>>#fail

Errors:
SUnitTest>>#error
'
			! !

!SUnitTest methodsFor: 'testing'!
testIsNotRerunOnDebug

	| case |

	case := self class selector: #testRanOnlyOnce.
	case run.
	case debug! !

!SUnitTest methodsFor: 'testing'!
testRan

	| case |

	case := self class selector: #setRun.
	case resources do: [:each | each availableFor: case].
	[case setUp.
	case performTest] ensure: [
		self assert: case hasSetup.
		self assert: case hasRun.
		case tearDown.
		case cleanUpInstanceVariables].
	self assert: case hasSetup isNil.
	self assert: case hasRun isNil.! !

!SUnitTest methodsFor: 'testing'!
testRanOnlyOnce

	self assert: hasRanOnce ~= true.
	hasRanOnce := true! !

!SUnitTest methodsFor: 'testing'!
testResult

	| case result |

	case := self class selector: #noop.
	result := case run.

	self
		assertForTestResult: result
		runCount: 1
		passed: 1
		failed: 0
		errors: 0! !

!SUnitTest methodsFor: 'testing' stamp: 'md 2/22/2006 14:16'!
testRunning

	(Delay forSeconds: 2) wait
			! !

!SUnitTest methodsFor: 'testing' stamp: 'md 2/22/2006 14:19'!
testSelectorWithArg: anObject
	"should not result in error"! !

!SUnitTest methodsFor: 'testing'!
testShould

	self
		should: [true];
		shouldnt: [false]! !

!SUnitTest methodsFor: 'testing'!
testSuite

	| suite result |

	suite := TestSuite new.
	suite 
		addTest: (self class selector: #noop);
		addTest: (self class selector: #fail);
		addTest: (self class selector: #error).

	result := suite run.

	self
		assertForTestResult: result
		runCount: 3
		passed: 1
		failed: 1
		errors: 1! !

!SUnitTest methodsFor: 'testing' stamp: 'DF 3/17/2006 01:30'!
testWithExceptionDo

	self
		should: [self error: 'foo']
		raise: TestResult error
		withExceptionDo: [:exception |
			self assert: (exception description includesSubString: 'foo')
		]
			! !

!SUnitTest methodsFor: 'private'!
assertForTestResult: aResult runCount: aRunCount passed: aPassedCount failed: aFailureCount errors: anErrorCount

	self
		assert: aResult runCount = aRunCount;
		assert: aResult passedCount = aPassedCount;
		assert: aResult failureCount = aFailureCount;
		assert: aResult errorCount = anErrorCount! !

!SUnitTest methodsFor: 'private'!
assertForTestResult: aResult runCount: aRunCount passed: aPassedCount failed: aFailureCount errors: anErrorCount expectedFailures: anExpectedFailureCount

	self
		assert: aResult runCount = aRunCount;
		assert: aResult expectedPassCount = aPassedCount;
		assert: aResult failureCount = aFailureCount;
		assert: aResult errorCount = anErrorCount;
		assert: aResult expectedDefectCount = anExpectedFailureCount! !

!SUnitTest methodsFor: 'private'!
error
	3 zork! !

!SUnitTest methodsFor: 'private' stamp: 'NikoSchwarz 10/23/2010 14:34'!
expectedFailureFails
	"<expectedFailure>"
	self assert: false.! !

!SUnitTest methodsFor: 'private' stamp: 'NikoSchwarz 10/23/2010 15:34'!
expectedFailurePasses
	"<expectedFailure>"
	self assert: true.! !

!SUnitTest methodsFor: 'private' stamp: 'BaseSystem 8/30/2009 09:40'!
fail
	self assert: false! !

!SUnitTest methodsFor: 'private' stamp: 'BaseSystem 8/30/2009 09:40'!
noop! !

!SUnitTest methodsFor: 'private' stamp: 'BaseSystem 8/30/2009 09:40'!
setRun
	hasRun := true! !

!SUnitTest commentStamp: '<historical>' prior: 0!
This is both an example of writing tests and a self test for the SUnit. The tests 
here are pretty strange, since you want to make sure things blow up. You should 
not generally have to write tests this complicated in structure, although they 
will be far more complicated in terms of your own objects- more assertions, more 
complicated setup. Kent says: "Never forget, however, that if the tests are hard 
to write, something is probably wrong with the design".!
!SUnitTest class methodsFor: 'history' stamp: 'AdrianLienhard 10/19/2009 10:49'!
lastStoredRun
	^ ((Dictionary new) add: (#passed->((Set new) add: #testWithExceptionDo; add: #testAssert; add: #testRanOnlyOnce; add: #testDialectLocalizedException; add: #testFail; add: #testDefects; add: #testIsNotRerunOnDebug; add: #testResult; add: #testRunning; add: #testError; add: #testException; add: #testShould; add: #testSuite; yourself)); add: (#timeStamp->'22 November 2008 10:11:35 pm'); add: (#failures->((Set new))); add: (#errors->((Set new))); yourself)! !

!SUnitTransporter commentStamp: 'sm 5/25/2011 00:01' prior: 0!
SUnitTransporter is not actually a Transporter class, since there are currently no needs for customization.
Thus, it is just a dummy class for future use, and to hold #transportersForFileOutMenu.
!
!SUnitTransporter class methodsFor: 'transporter' stamp: 'sm 5/25/2011 00:02'!
transportersForFileOutMenu
	^ { Transporter forPackage: (PackageInfo named: 'SUnit') }! !

!SUnitTutorial commentStamp: 'tbn 12/16/2010 22:38' prior: 0!
This is a custom help book providing a tutorial for the SUnit framework.
!
!SUnitTutorial class methodsFor: 'accessing' stamp: 'tbn 12/16/2010 22:37'!
bookName
	^'Tutorial'! !

!SUnitTutorial class methodsFor: 'accessing' stamp: 'tbn 4/26/2011 15:56'!
pages
	^#(step1 step2 step3 step4 step5)! !

!SUnitTutorial class methodsFor: 'pages' stamp: 'tbn 12/16/2010 23:29'!
step1
	"This method was automatically generated. Edit it using:"
	"SUnitTutorial edit: #step1"
	^HelpTopic
		title: 'Step 1 - Define a test class'
		contents: 
'To define a series of tests in SUnit one typically creates a subclass of class TestCase. The idea is that the methods of this class will implement several tests, the instance variables represent the objects and / or the context in which these tests will be performed. 

In our example we want to write a test on a simple Person class (which is not yet in our image). If the unit under test is a single class one convention is to name the test like the class but followed with the postfix "Test". 

So to create a test for the Person class we subclass TestCase with a custom "PersonTest" class.

	TestCase subclass: #PersonTest
		instanceVariableNames: ''''
		classVariableNames: ''''
		poolDictionaries: ''''
		category: ''MyApp-Tests-Model''

Note that we havent created the class Person yet - so one idea of ExtremeProgramming (XP) is to write the test first as a way to describe a use case that your application has to cover. After that you write the code and the test will show you if the scenario is fullfilled. You dont have to follow this programming style and can also write tests to cover existing code.
	!!' readStream nextChunkText! !

!SUnitTutorial class methodsFor: 'pages' stamp: 'tbn 4/26/2011 15:42'!
step2
	"This method was automatically generated. Edit it using:"
	"SUnitTutorial edit: #step2"
	^HelpTopic
		title: 'Step 2 - Define a first test method'
		contents: 
'To define a test we create a new instance side method for our first test scenario. By convention any method (in a subclass of TestCase) whose selector starts with ''test'' is supposed to be a test and can be run using the TestRunner tool:

	testInstanceCreation
		|person|
		person := Person named: ''Beck''.
		person firstName: ''Kent''.
		self assert: person fullName = ''Kent Beck''.
		
A good style is to put this method into the method category ''testing''.

When you accept the code the system may ask you about the new class Person. It''s not yet defined - but you can easily create it using the following class definition:

	Object subclass: #Person
		instanceVariableNames: ''name firstName'' 
		classVariableNames: ''''
		poolDictionaries: ''''
		category: ''MyApp-Core-Model''!!' readStream nextChunkText! !

!SUnitTutorial class methodsFor: 'pages' stamp: 'tbn 4/26/2011 15:55'!
step3
	"This method was automatically generated. Edit it using:"
	"SUnitTutorial edit: #step3"
	^HelpTopic
		title: 'Step 3 - Running our first test method'
		contents: 
'To run our test case method we can evaluate the following code snippet in a workspace:

	PersonTest run: #testInstanceCreation

If you print the result then the following will appear:

      1 run, 0 passes, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes

This tells us that one test has been run and one error occured while testing. Currently we dont have all messages implemented - so the test has to fail. 

If you want to debug the test to see whats happened you can evaluate:

     PersonTest debug: #testInstanceCreation



 
	!!' readStream nextChunkText! !

!SUnitTutorial class methodsFor: 'pages' stamp: 'tbn 4/26/2011 16:01'!
step4
	"This method was automatically generated. Edit it using:"
	"SUnitTutorial edit: #step4"
	^HelpTopic
		title: 'Step 4 - Using the TestRunner'
		contents: 
'Testing by evaluating an expression as we is not very convenient - so it is better to open the TestRunner - a user interface tool displaying all the tests in the system. You can start it either using the world menu or by evaluating 

    TestRunner open

in a workspace.

Scroll down until you find the class category ''MyApp-Tests-Model'' and select the test by clicking on the class PersonTest. It is possible to select more than one test/category. Now click on "Run selected". 

If you run the test in the test runner it will be marked red since it contains errors. The test runner will also show you the result of the test run:

     1 run, 0 passes, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes

If you click on the failed method in the lower right pane the debugger will open.!!' readStream nextChunkText! !

!SUnitTutorial class methodsFor: 'pages' stamp: 'tbn 4/26/2011 16:19'!
step5
	"This method was automatically generated. Edit it using:"
	"SUnitTutorial edit: #step5"
	^HelpTopic
		title: 'Step 5 - Getting the test green'
		contents: 
'To get our test green we have to implement the missing methods. First the debugger tells us that the Person class does not understand the message #named: 

We dont have to go back into a standard browser to implement it, we just select ''Create'' in the walkback window. The system now asks us where #named: should be defined in the inheritance hierarchy. We select the Person class and categorize the method in a new method category ''instance creation''.

Finally we have a debugger open where we can implement the code like this:

  named: aString
 	^(self new)
		name: aString;
		yourself
		
Note that after accepting the method in the debugger you can instantly step through it or hit ''Proceed'' to continue execution. The system tell us that there is no setter method #name:, so we implement it too on the instance side:
	
   name: aString
	name := aString

Next the #firstName: message is missing:
	
   firstName: aString
	firstName := aString
	
At any point in time we can control if the test is already green in the TestRunner. Finally when we implement
the missing #fullName method by concatenating first name and surename:

	fullName
		^firstName, '' '', name  
		
Now out test should be green.!!' readStream nextChunkText! !

!SUnitUnloader methodsFor: 'unloading'!
unloadAll
	self unloadTestPackages.
	self unloadSUnit.! !

!SUnitUnloader methodsFor: 'unloading'!
unloadSUnit
	Smalltalk globals
		at: #TestCase
		ifPresent: [ :class | SystemChangeNotifier uniqueInstance noMoreNotificationsFor: class ].
	#(#SUnitGUI #SUnit) do: [ :each | (MCPackage named: each) unload ].
	AppRegistry removeObsolete.	! !

!SUnitUnloader methodsFor: 'unloading'!
unloadTestPackages
        #('Tests' 'CollectionsTests' 'CompilerTests' 'FreeTypeTests' 'Graphics-Tests' 'KernelTests' 'MorphicTests' 'MultilingualTests' 'NetworkTests' 'ToolsTest' 'Gofer-Tests' 'Announcements-Tests-Core' 'CompressionTests' 'HelpSystem-Tests' 'Multilingual-Tests' 'Regex-Tests-Core' 'HelpSystem-Tests'  'Balloon-Collections-Tests' 'StratifiedProxy-Tests' 'Finder-Tests' 'Zinc-Tests')
                do: [ :each | (MCPackage named: each) unload ]. 
! !

!SUnitUnloader commentStamp: 'LaurentLaffont 4/15/2011 20:20' prior: 0!
I am SUnitUnloader, a little tool to unload SUnit and a fixed set of Tests from the current image.

Usage: SUnitUnloader new unloadAll

Caveat: #unloadTestPackages uses a fixed and probably ill maintained list of what packages hold unit tests.
!
!Scanner class methodsFor: '*Sly3' stamp: 'ssa 4/19/2010 20:31'!
initialize
	| newTable |
	newTable _ Array new: 256 withAll: #xBinary. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"
	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.

	1 to: 255
		do: [:index |
			(Character value: index) isLetter
				ifTrue: [newTable at: index put: #xLetter]].

	newTable at: 30 put: #doIt.
	newTable at: $" asciiValue put: #xDoubleQuote.
	newTable at: $# asciiValue put: #xLitQuote.
	newTable at: $% asciiValue put: #percent.
	newTable at: $$ asciiValue put: #xDollar.
	newTable at: $' asciiValue put: #xSingleQuote.
	newTable at: $: asciiValue put: #xColon.
	newTable at: $( asciiValue put: #leftParenthesis.
	newTable at: $) asciiValue put: #rightParenthesis.
	newTable at: $. asciiValue put: #period.
	newTable at: $; asciiValue put: #semicolon.
	newTable at: $[ asciiValue put: #leftBracket.
	newTable at: $] asciiValue put: #rightBracket.
	newTable at: ${ asciiValue put: #leftBrace.
	newTable at: $} asciiValue put: #rightBrace.
	newTable at: $^ asciiValue put: #upArrow.
	newTable at: $_ asciiValue put: #leftArrow.
	newTable at: $| asciiValue put: #verticalBar.
	TypeTable _ newTable "bon voyage!!"

	"Scanner initialize"! !

!ScreenController methodsFor: 'fast window closing' stamp: 'ssa 3/10/2010 10:26'!
closeAllUnlockedWindows
	"ScreenController new closeAllUnlockedWindows"
	"Close any window that isn't locked."

	| toClose |
	toClose _ ScheduledControllers scheduledControllers select: [:c | c preventClosing not].
	(SelectionMenu confirm:'Do you really want to close all unlocked windows?')
		ifFalse: [^ self].
	toClose do: [:c | c closeAndUnscheduleIfOkWithModelNoTerminate].
	self restoreDisplay.
! !

!ScreenController methodsFor: 'fast window closing' stamp: 'ssa 3/9/2010 15:26'!
closeTopWindow

	| closeable |
	closeable _ ScheduledControllers scheduledControllers detect:[:controller| controller preventClosing not] ifNone:[^self].
	closeable view flash.
	sensor commandKeyPressed ifTrue:[closeable closeAndUnscheduleIfOkWithModel]! !

!ScreenController methodsFor: 'fast window closing' stamp: 'ssa 3/9/2010 15:27'!
preventClosing
	^true! !

!ScreenController methodsFor: 'control defaults' stamp: 'ssa 3/3/2010 14:37'!
controlActivity
	"Any button opens the screen's menu.
	If the shift key is down, do find window."

	sensor leftShiftDown ifTrue: [^ self findWindow].
	sensor controlKeyPressed ifTrue: [^self closeTopWindow].
	(self projectScreenMenu invokeOn: self) ifNil: [super controlActivity]! !

!ScreenController methodsFor: 'control defaults' stamp: 'ssa 3/3/2010 13:42'!
isControlWanted
	^ self viewHasCursor and: [sensor anyButtonPressed]! !

!ScreenController methodsFor: 'menu messages' stamp: 'ssa 1/21/2010 12:17'!
exploreViewFromUser
	"Explore the selected window"
	| controller |
	(controller _ ScheduledControllers windowFromUser) notNil
		ifTrue:
			[controller view explore]! !

!ScreenController methodsFor: 'menu messages' stamp: 'ssa 9/4/2008 15:11'!
openProcessBrowser
	"Create and schedule"

	ProcessBrowser  open! !

!ScreenController methodsFor: 'menu messages' stamp: 'tk 5/4/1998 17:25'!
openWorkspace 
	"Create and schedule workspace."

	Workspace open! !

!ScreenController methodsFor: 'menu messages' stamp: 'ssa 3/24/2010 16:34'!
recolorWindows

	Smalltalk recolorWindows! !

!ScreenController methodsFor: 'menu messages' stamp: 'ssa 9/3/2008 11:12'!
restoreDisplay 
	"Clear the screen to gray and then redisplay all the scheduled views."

	Display extent = DisplayScreen actualScreenSize
		ifFalse:
			[DisplayScreen startUp.
			ScheduledControllers unCacheWindows].
	ScheduledControllers restore! !

!ScreenController methodsFor: 'nested menus' stamp: 'ssa 3/24/2010 16:33'!
appearanceMenu 
	"Answer the appearance menu to be put up as a screen submenu"

	^ SelectionMenu labelList:
		#('system fonts...'
			'full screen on'
			'full screen off'
			'recolor windows'
			'set display depth...'
			'set desktop color...' ) 

		lines: #(1 3)
		selections: #( configureFonts
fullScreenOn fullScreenOff recolorWindows setDisplayDepth setDesktopColor)
"
ScreenController new appearanceMenu startUp
"! !

!ScreenController methodsFor: 'nested menus' stamp: 'ssa 9/4/2008 15:11'!
openMenu
	^ SelectionMenu labelList:
		#(	'browser'
			'package browser'
			'method finder'
			'process browser'
			'workspace'
			'file list'
			'file...'
			'transcript'

			'simple change sorter'
			'dual change sorter'

			'mvc project'
			)
		lines: #(8 10 )
		selections: #(
openBrowser openPackageBrowser openSelectorBrowser openProcessBrowser openWorkspace openFileList openFile openTranscript 
openSimpleChangeSorter openChangeManager
openProject    )
"
ScreenController  new openMenu startUp
"! !

!ScreenController methodsFor: 'nested menus' stamp: 'ssa 3/10/2010 10:01'!
windowMenu
	"Answer a menu for windows-related items.  "

	^ SelectionMenu labelList:
		#(	'find window...'
			'find changed browsers...'
			'find changed windows...'

			'collapse all windows'
			'expand all windows'
			'close unchanged windows' 
			'close unlocked windows' ) , 
			(Array
				with: self bitCachingString
				with: self staggerPolicyString)
		lines: #(3 7)
		selections: #(
findWindow chooseDirtyBrowser chooseDirtyWindow
collapseAll expandAll closeUnchangedWindows closeAllUnlockedWindows
fastWindows changeWindowPolicy )
"
ScreenController new windowMenu startUp
"! !

!ScreenController methodsFor: '*RVM' stamp: 'dmu 1/29/2011 16:31'!
dashboardMenu
	| labels selections |
	labels _ #('RVM dashboard') asOrderedCollection.
	selections _ #(openRVMDashboard) asOrderedCollection.
	(Smalltalk includesKey: #Sly3) ifTrue:[
			labels add: 'Sly dashboard'.
			selections add:#openSlyDashboard].
	(Smalltalk includesKey: #Ly) ifTrue:[
			labels add: 'Ly dashboard'.
			selections add:#openLyDashboard].
	(Smalltalk includesKey: #Qube) ifTrue:[
			labels add: 'Qube dashboard'.
			selections add:#openQubeDashboard].

		
	^ SelectionMenu labelList: labels
		lines: #()
		selections: selections
"
ScreenController  new dashboardMenu startUp
"! !

!ScreenController methodsFor: '*RVM' stamp: 'ssa 4/20/2010 09:50'!
openRVMDashboard
	"Create and schedule a RVM dashboard."

	RVMMonitor dashboard! !

!ScreenController methodsFor: '*RVM' stamp: 'ssa 7/7/2010 11:20'!
presentDashboardMenu
	self popUpMenuFor: #dashboardMenu! !

!ScreenController methodsFor: '*RVM' stamp: 'ads 1/12/2011 16:37'!
projectScreenMenu
	"Answer the project screen menu."

	^ SelectionMenu labelList:
		#(	'previous project'
			'jump to project...'
			'restore display'

			'dashboards...'
			'file out package...'

			'open...'
			'windows...'
			'changes...'
			'help...'
			'appearance...'
			'do...'

			'save'
			'save as...'
			'save and quit'
			'quit')
		lines: #(3 5 12)
		selections: #(
returnToPreviousProject jumpToProject restoreDisplay presentDashboardMenu presentPackageMenu
presentOpenMenu presentWindowMenu presentChangesMenu presentHelpMenu presentAppearanceMenu commonRequests
snapshot saveAs snapshotAndQuit quit )
"
ScreenController new projectScreenMenu startUp
"! !

!ScreenController methodsFor: '*Sly' stamp: 'dmu 8/30/2010 10:44'!
openSlyDashboard
	"Create and schedule a Sly dashboard."

	Sly3 dashboard! !

!ScreenController methodsFor: '*Sly' stamp: 'ssa 3/24/2010 14:13'!
presentSlyMenu
	self popUpMenuFor: #slyMenu! !

!ScreenController methodsFor: '*Sly' stamp: 'ssa 3/24/2010 14:12'!
slyMenu
	^ SelectionMenu labelList:
		#(	'dashboard'
			)
		lines: #()
		selections: #(openSlyDashboard)
"
ScreenController  new slyMenu startUp
"! !

!ScreenController methodsFor: '*Transporter' stamp: 'sm 3/11/2011 11:38'!
presentPackageMenu
	| transportersByName packageNames selectedIndex |
	transportersByName := Transporter getAllTransporters.
	
	packageNames := transportersByName keys asSortedCollection.
	packageNames addLast: 'All'.
	packageNames := packageNames asArray.
	selectedIndex := (PopUpMenu labelArray: packageNames lines: {(packageNames size) - 1}) startUpWithCaption: 'Which package do you want to file out?'.
	selectedIndex = 0 ifFalse: [
		selectedIndex = packageNames size
			ifTrue: [transportersByName valuesDo: [:transporter| transporter saveNoPopup]]
			ifFalse: [
				| selectedPackageName selectedTransporter |
				selectedPackageName := packageNames at: selectedIndex.
				selectedTransporter := transportersByName at: selectedPackageName.
				selectedTransporter save.
			].
	].! !

!ScriptConsole class methodsFor: 'as yet unclassified'!
<< aString
	self print: aString! !

!ScriptConsole class methodsFor: 'as yet unclassified'!
cr
	self println: ''.! !

!ScriptConsole class methodsFor: 'as yet unclassified' stamp: 'sm 6/1/2011 14:50'!
detectAvailableMechanismForStdout
	"The RoarVM has its own primitive"
	| cls |
	cls := Smalltalk at: #RVMOperations ifAbsent: [nil].
	IsRVM := (cls notNil and: [cls perform: #isRVM]).
	IsRVM 
		ifTrue: [ 
			PrintTarget := cls.
			^ self.
		]
		ifFalse: [
			"Squeak 4.2 provides a stream at FileStream>>stdout"
			(FileStream respondsTo: #stdout)
				ifTrue: [
					PrintTarget := FileStream stdout.
					^ self.
				].
		].
	
	PrintTarget := nil.
	^ nil! !

!ScriptConsole class methodsFor: 'as yet unclassified'!
initialize
	OutputToTranscript := false.
	self detectAvailableMechanismForStdout.! !

!ScriptConsole class methodsFor: 'as yet unclassified'!
outputToTranscript
	^ OutputToTranscript! !

!ScriptConsole class methodsFor: 'as yet unclassified'!
outputToTranscript: aBool
	OutputToTranscript := aBool! !

!ScriptConsole class methodsFor: 'as yet unclassified'!
print: somethingAsString
	self print: somethingAsString withLineEnding: ''.! !

!ScriptConsole class methodsFor: 'as yet unclassified' stamp: 'sm 6/1/2011 14:47'!
print: somethingAsString withLineEnding: lineEnd
	"Will output the somethingAsString to stdout using one of the available mechansims and to the transcript if requested"
	| output |
	output := somethingAsString asString.
	
	PrintTarget ifNotNil: [
		IsRVM ifTrue: [ PrintTarget print: output. ]
			   ifFalse: [ PrintTarget nextPutAll: (output, lineEnd) ].
	].

	(OutputToTranscript or: [PrintTarget isNil])
		ifTrue: [
			Transcript show: output, lineEnd.
		].! !

!ScriptConsole class methodsFor: 'as yet unclassified'!
println: somethingAsString
	self print: somethingAsString withLineEnding: String crlf.! !

!ScriptStarter commentStamp: 'StefanMarr 5/14/2011 16:29' prior: 0!
ScriptStarter provides a startUp method and registers itself on the startUpList to enable scripting using command-line arguments.

The first argument on the command-line is used to identify a class on which #run: is invoked with the arguments as an array.

#run: can be used similar to classic main(String[] args) methods in other languages. !
!ScriptStarter class methodsFor: 'system startup entry' stamp: 'sm 5/25/2011 12:41'!
install
	"Will register ScriptStarter on the StartUpList to activate it on VM startup."
	| pref |
	Smalltalk addToStartUpList: ScriptStarter.
	
	"Disable the loading of documents on startup"
	pref := Smalltalk at: #Preferences ifAbsent: [nil].
	pref	ifNotNil: [
			(pref respondsTo: #disable:)
				ifTrue: [	pref disable: #readDocumentAtStartup. ]
			]
		ifNil: [
			(Smalltalk globals at: #AbstractLauncer ifAbsent: [nil])
				ifNotNilDo: [:launcher |
					launcher readDocumentAtStartup: false
				]
			].! !

!ScriptStarter class methodsFor: 'system startup entry' stamp: 'sm 5/30/2011 22:35'!
startUp
	"startUp is invoked during startup.
	 ScriptStarter has to be registered in the SystemDirectory's StartUpList
	 See ScriptStarter>>install"
	
	| arguments scriptClassName |
	"Ok, only, and really only during startup"
	IsResuming ifFalse: [ Transcript show: 'ScriptStarter did not execute a given script, since it assumes to be executed after a snapshot and not during startup.'.
		^ self. ].
	
	"First make sure that stdout output can be used if available."
	ScriptConsole detectAvailableMechanismForStdout.
	
	arguments := self getSystemAttributes.
	arguments size > 0
		ifTrue: [scriptClassName := arguments at: 1.
			self executeRunFor: scriptClassName with: arguments.]! !

!ScriptStarter class methodsFor: 'system startup entry' stamp: 'sm 5/30/2011 22:30'!
startUp: resuming
	IsResuming := resuming.
	^ super startUp: resuming.! !

!ScriptStarter class methodsFor: 'system startup entry'!
uninstall
	"Will remove ScriptStarter from the StartUpList"
	Smalltalk removeFromStartUpList: ScriptStarter.
	
	self flag: 'TODO: restore original setting for readDocumentAtStartup, see >>install.'.
	Transcript show: 'You might need to restore the original setting for readDocumentAtStartup'.! !

!ScriptStarter class methodsFor: 'helper'!
executeRunFor: scriptClassName with: arguments
	| scriptClass |
	scriptClass := Smalltalk classNamed: scriptClassName.
	scriptClass ifNotNil: [
		scriptClass run: arguments.
		QuitVM ifTrue: [
			Smalltalk snapshot: SafeBeforeQuit andQuit: true.
		].
	].! !

!ScriptStarter class methodsFor: 'helper'!
getSystemAttributes
	| arguments arg i |
	arguments := OrderedCollection new.
	i := 2.
	[[arg := SmalltalkImage current getSystemAttribute: i] value == nil]
		whileFalse: [arguments addLast: arg.
			i := i + 1].
	^ arguments! !

!ScriptStarter class methodsFor: 'transporter' stamp: 'sm 2/13/2011 19:09'!
transportersForFileOutMenu
	^ { Transporter forPackage: (PackageInfo named: 'Scripting') }! !

!ScriptStarter class methodsFor: 'initialization' stamp: 'sm 5/30/2011 22:33'!
initialize
	"Automatically install ScriptStarter when the code is filed in."
	self install.
	
	QuitVM := true.
	SafeBeforeQuit := false.
	IsResuming := false.! !

!ScriptStarter class methodsFor: 'configuration'!
quitVMAfterScriptExecution
	^ QuitVM! !

!ScriptStarter class methodsFor: 'configuration'!
quitVMAfterScriptExecution: aBool
	QuitVM := aBool! !

!ScriptStarter class methodsFor: 'configuration'!
saveImageBeforeQuit
	^ SafeBeforeQuit! !

!ScriptStarter class methodsFor: 'configuration'!
saveImageBeforeQuit: aBool
	SafeBeforeQuit := aBool! !

!ScrollController methodsFor: 'basic control sequence' stamp: 'ssa 9/9/2009 17:06'!
controlInitialize
        "Recompute scroll bars.  Save underlying image unless it is already saved."
        "Hacked to disable flop-out scroll bars when inside an MSWScrollBarView - ssa 12/10/97 15:21"

        super controlInitialize.
        scrollBar region: (0 @ 0 extent: 24 @ view apparentDisplayBox height).
        scrollBar insideColor: view backgroundColor.
        marker region: self computeMarkerRegion.
        scrollBar _ scrollBar align: scrollBar topRight with: view apparentDisplayBox topLeft.
        marker _ marker align: marker topCenter with: self upDownLine @ (scrollBar top + 2).
        savedArea isNil ifTrue: [savedArea _ Form fromDisplay: scrollBar].

        (self view superView isKindOf: MSWScrollBarView) "_______HERE IS THE HACK"
                ifFalse:[scrollBar displayOn: Display].

        "Show a border around yellow-button (menu) region"
"
        yellowBar _ Rectangle left: self yellowLine right: scrollBar right + 1
                top: scrollBar top bottom: scrollBar bottom.
        Display border: yellowBar width: 1 mask: Form veryLightGray.
"
        self moveMarker
! !

!ScrollController methodsFor: 'basic control sequence' stamp: 'ssa 9/9/2009 17:07'!
controlTerminate

	super controlTerminate.
	savedArea notNil 	
		ifTrue: 
			[ (self view superView isKindOf: MSWScrollBarView) "_______HERE IS THE HACK"
				ifFalse:[savedArea displayOn: Display at: scrollBar topLeft].
			savedArea _ nil].! !

!ScrollController methodsFor: 'control defaults'!
controlActivity
        "Hacked to supprt MSWScrollBarView - ssa 12/10/97 17:07"

        (self view superView isKindOf: MSWScrollBarView)
                ifFalse:[
        self scrollBarContainsCursor
                                ifTrue: [self scroll]
                                ifFalse: [super controlActivity]]
                ifTrue:[super controlActivity]! !

!ScrollController methodsFor: 'control defaults'!
isControlActive 
        "Viva la Junta!!"
        "HACKED to ignore scrollbar in the activity test if contained in a ScrollbarView - ssa 1/8/98 16:24"
        view isNil ifTrue: [^ false].

        (self view superView isKindOf: MSWScrollBarView) "_______HERE IS THE HACK"
                ifFalse:["original code" ^(view insetDisplayBox merge: scrollBar inside) containsPoint: sensor cursorPoint]
                ifTrue:[^view insetDisplayBox containsPoint: sensor cursorPoint]! !

!ScrollController methodsFor: 'marker adjustment'!
moveMarker
        "The view window has changed. Update the marker."
        "Hacked to suppress flop-out scrollbar updates when the view is encapsulated by an MSWScrollBarView - ssa 12/10/97 15:24"

        (self view superView isKindOf: MSWScrollBarView) "_______HERE IS THE HACK"
                ifFalse:[self moveMarker: self markerDelta negated anchorMarker: nil]! !

!ScrollController methodsFor: 'marker adjustment'!
moveMarkerTo: aRectangle 
        "Same as markerRegion: aRectangle; moveMarker, except a no-op if the marker
         would not move."
        "Hacked to suppress flop-out scrollbar updates when the view is encapsulated by an MSWScrollBarView - ssa 12/10/97 15:24"

        (self view superView isKindOf: MSWScrollBarView) "_______HERE IS THE HACK"
                ifFalse:[       (aRectangle height = marker height and: [self viewDelta = 0])
                                        ifFalse:
                                                [self markerRegion: aRectangle.
                                                self moveMarker]]! !

!SelectionMenu class methodsFor: 'instance creation' stamp: 'ssa 8/22/2009 16:21'!
labels: labels lines: linesArray selectors: selectionsArray
	"ST80 Compatibility"

	^ self labels: labels lines: linesArray selections: selectionsArray! !

!SequenceableCollection methodsFor: 'converting' stamp: 'ssa 10/18/2008 23:18'!
asCircularCollection
	"Answer a circular version of myself"
	^RVMCircularCollection withAll: self! !

!SequenceableCollection methodsFor: 'converting' stamp: 'ssa 10/27/2008 20:34'!
rotateBackward
	"Answer a copy of the receiver with elements rotated toward the front."
	" 'frog' rotateBackward"

	| n result |
	n _ self size.
	result _ self species new: n.
	n = 0 ifTrue:[^result].
	n = 1 ifTrue:[result at: 1 put: (self at: 1).  ^result].
	1 to: n-1  do: [:i | result at: i put: (self at: i + 1)].
	result at: n put: self first.

	^ result
! !

!SequenceableCollection methodsFor: 'converting' stamp: 'ssa 10/27/2008 20:33'!
rotateForward
	"Answer a copy of the receiver with elements rotated toward the end."
	" 'frog' rotateForward"

	| n result |
	n _ self size.
	result _ self species new: n.
	n = 0 ifTrue:[^result].
	n = 1 ifTrue:[result at: 1 put: (self at: 1).  ^result].
	2 to: n  do: [:i | result at: i put: (self at: i - 1)].
	result at: 1 put: self last.

	^ result
! !

!SequenceableCollection methodsFor: 'copying' stamp: 'dmu 5/5/2009 01:05'!
shuffled
	^ self shuffledBy: Collection randomForPicking copy

"Examples:
	($A to: $Z) shuffled
"! !

!SequenceableCollection methodsFor: 'enumerating' stamp: 'ssa 5/28/2010 13:51'!
with: secondCollection with: thirdCollection do: threeArgBlock 
	"Evaluate threeArgBlock with corresponding elements from this collection, secondCollection and thirdCollection."
	secondCollection size = self size ifFalse: [self error: 'secondCollection must be the same size'].
	thirdCollection size = self size ifFalse: [self error: 'thirdCollection must be the same size'].
	1 to: self size do:
		[:index |
		threeArgBlock value: (self at: index)
				value: (secondCollection at: index)
				value: (thirdCollection at: index)]! !

!SequenceableCollection methodsFor: 'enumerating' stamp: 'ssa 5/28/2010 14:01'!
with: secondCollection with: thirdCollection withIndexDo: fourArgBlock 
	"Evaluate fourArgBlock with corresponding elements from this collection, secondCollection and thirdCollection."
	secondCollection size = self size ifFalse: [self error: 'secondCollection must be the same size'].
	thirdCollection size = self size ifFalse: [self error: 'thirdCollection must be the same size'].
	1 to: self size do:
		[:index |
		fourArgBlock value: (self at: index)
				value: (secondCollection at: index)
				value: (thirdCollection at: index)
				value: index]! !

!SequenceableCollection methodsFor: 'enumerating' stamp: 'ssa 5/28/2010 15:34'!
with: secondCollection withIndexDo: threeArgBlock 
	"Evaluate threeArgBlock with corresponding elements from this collection and secondCollection."
	secondCollection size = self size ifFalse: [self error: 'secondCollection must be the same size'].
	1 to: self size do:
		[:index |
		threeArgBlock value: (self at: index)
				value: (secondCollection at: index)
				value: index]! !

!SequenceableCollection methodsFor: 'enumerating' stamp: 'ssa 1/20/2009 14:08'!
without: anObject collect: aBlock 
	"Evaluate aBlock with each of the receiver's elements except anObject as the argument.  
	Collect the resulting values into a collection like the receiver. Answer  
	the new collection."

	| newCollection  |
	newCollection _ self species new: self size - 1.
	1 to: self size do:
		[:index |
		anObject = (self at: index) ifFalse:[newCollection add: (aBlock value: (self at: index))]].
	^ newCollection! !

!SequenceableCollection methodsFor: 'enumerating' stamp: 'ssa 1/20/2009 14:11'!
without: anObject select: aBlock 
	"Evaluate aBlock with each of the receiver's elements except anObject as the argument.  
	Select the resulting values that pass into a collection like the receiver. Answer  
	the new collection."

	| newCollection  item |
	newCollection _ self species new: self size - 1.
	1 to: self size do:
		[:index |
		item _ self at:index.
		(anObject ~= item and:[aBlock value: item]) ifTrue:[newCollection add: item]].
	^ newCollection! !

!SequenceableCollection methodsFor: 'testing' stamp: 'ssa 8/27/2009 12:44'!
is: anObject after: anotherObject

	^(self indexOf: anObject)<(self indexOf: anotherObject)! !

!SequenceableCollection methodsFor: '*connectors-enumerating' stamp: 'ssa 1/1/1970 00:18'!
groupsOfNoMoreThan: n atATimeDo: aBlock 
	"Evaluate aBlock with my elements taken n at a time. Handle leftovers at the end."
	| args remaining |
	n
		to: self size
		by: n
		do: [:index | 
			args := (self copyFrom: index - n + 1 to: index) asArray.
			 aBlock value: args].
	(remaining _ self size \\ n)  = 0 ifFalse:["handle leftovers"
		args := (self copyFrom: self size - remaining + 1 to: self size) asArray.
		aBlock value: args]! !

!SequenceableCollection methodsFor: '*packageinfo-base' stamp: 'ab 9/17/2002 01:02'!
do: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor cursorPoint
		from: 0 to: self size
		during:
			[:bar |
			self withIndexDo:
				[:each :i |
				bar value: i.
				aBlock value: each]]! !

!SequenceableCollection methodsFor: '*Ly-Explorer' stamp: 'hg 9/7/2001 12:01'!
explorerContents

	^self asOrderedCollection withIndexCollect: [:value :index |
		ObjectExplorerWrapper
			with: value
			name: index printString
			model: self]! !

!Set methodsFor: '*RVM-Archiving'!
archiveOn: aStream

	aStream
		storeObject: self;
		storeClass: self class;
		store: self size.
	self do: [:each | aStream nextPut: each]! !

!Set methodsFor: '*Ly-Explorer' stamp: 'hg 9/7/2001 11:51'!
explorerContents 

	^self asOrderedCollection withIndexCollect: [:each :index |
		ObjectExplorerWrapper
			with: each
			name: index printString
			model: self]! !

!Set class methodsFor: '*RVM-Archiving'!
dearchiveFrom: aStream

	| anObject anInteger |
	anInteger _ aStream read: Integer.
	anObject _ self new: (anInteger * 2 max: 2).
	aStream storeObject: anObject.
	anInteger timesRepeat:
		[anObject add: aStream next].
	^anObject! !

!SimpleTestResource methodsFor: 'accessing'!
runningState

	^runningState! !

!SimpleTestResource methodsFor: 'accessing'!
runningState: aSymbol

	runningState := aSymbol! !

!SimpleTestResource methodsFor: 'running'!
setRun
	hasRun := true! !

!SimpleTestResource methodsFor: 'running'!
setUp
	
	self runningState: self startedStateSymbol.
	hasSetup := true! !

!SimpleTestResource methodsFor: 'running'!
startedStateSymbol

	^#started! !

!SimpleTestResource methodsFor: 'running'!
stoppedStateSymbol

	^#stopped! !

!SimpleTestResource methodsFor: 'running'!
tearDown

	self runningState: self stoppedStateSymbol! !

!SimpleTestResource methodsFor: 'testing'!
hasRun
	^hasRun! !

!SimpleTestResource methodsFor: 'testing'!
hasSetup
	^hasSetup! !

!SimpleTestResource methodsFor: 'testing' stamp: ' 17/7/10 17:28'!
isAvailable
	^self class allowAvailability
		and: [self runningState == self startedStateSymbol]! !

!SimpleTestResource class methodsFor: 'accessing' stamp: ' 17/7/10 17:28'!
allowAvailability
	^preventAvailability isNil! !

!SimpleTestResource class methodsFor: 'accessing' stamp: 'nfr 1/3/2010 18:13'!
rawCurrentForTest
	^current! !

!SimpleTestResource class methodsFor: 'utility' stamp: ' 17/7/10 17:28'!
preventAvailabilityDuring: aBlock
	"Only setter of preventAvailability."
	
	preventAvailability := false.
	^aBlock ensure: [preventAvailability := nil]! !

!SimpleTestResourceA class methodsFor: 'accessing' stamp: 'nfr 1/3/2010 18:13'!
resources
	^Array with: SimpleTestResourceA1 with: SimpleTestResourceA2! !

!SimpleTestResourceB class methodsFor: 'accessing' stamp: 'nfr 1/3/2010 18:13'!
resources
	^Array with: SimpleTestResourceA1 with: SimpleTestResourceB1! !

!SimpleTestResourceCircular class methodsFor: 'accessing' stamp: 'nfr 1/3/2010 18:12'!
resources
	^preventAvailability isNil
		ifTrue: [super resources , (Array with: SimpleTestResourceA1)]
		ifFalse:
			[super resources
				, (Array with: SimpleTestResourceA1 with: SimpleTestResourceCircular1)]! !

!SimpleTestResourceCircular1 class methodsFor: 'accessing' stamp: 'nfr 1/3/2010 18:12'!
resources
	"Circular prereq:  C wants C1 which wants C."
	
	^Array with: SimpleTestResourceCircular! !

!SimpleTestResourceTestCase methodsFor: 'not categorized'!
testResourceInitRelease
	| result suite error failure |
	suite := TestSuite new.
	suite addTest: (error := self class selector: #error).
	suite addTest: (failure := self class selector: #fail).
	suite addTest: (self class selector: #dummy).
	result := suite run.
	self assert: resource hasSetup
			! !

!SimpleTestResourceTestCase methodsFor: 'running' stamp: ' 17/7/10 17:28'!
setUp
	"Ensure that we error, not just fail, if resource is nil so that #should:raise: checks cannot mistake such an error for what they are trapping."
	
	resource := SimpleTestResource rawCurrentForTest.
	self
		deny: resource isNil
		description: 'SimpleTestResource has no current value in test'.
	self
		assert: resource class == SimpleTestResource
		description: 'SimpleTestResource current is not an instance of itself'.
	self
		assert: resource hasSetup
		description: 'This test uses a resource but it was not set up'! !

!SimpleTestResourceTestCase methodsFor: 'running' stamp: 'nfr 1/3/2010 18:09'!
testDebugTestWithResource
	"The debug will raise an error if the resource is not set up properly."
	
	self clearOuterResourceStateDuring: [(self class selector: #setRun) debug]! !

!SimpleTestResourceTestCase methodsFor: 'running' stamp: 'NiallRoss 7/18/2010 12:28'!
testResourceCollection
	self assert: self class buildSuiteFromSelectors resources size = self resources size
		description: 'The suite should have the same number of resources as its test'.
	self class buildSuiteFromSelectors resources do:
		[:each |
		self assert: (self resources includes: each)
			description: each name , ':  I have this resource but my suite does not'].! !

!SimpleTestResourceTestCase methodsFor: 'running' stamp: 'NiallRoss 7/18/2010 12:30'!
testRunSuiteWithResource
	| suite |
	suite := TestSuite new.
	suite addTest: (SimpleTestResourceTestCase selector: #error).
	suite addTest: (SimpleTestResourceTestCase selector: #fail).
	suite addTest: (self class selector: #dummy).
	self clearOuterResourceStateDuring:
		[self
			assert: suite run printString = '3 run, 1 passes, 0 expected failures, 1 failures, 1 errors, 0 unexpected passes'
			description: 'A suite of tests needing SimpleTestResource did not run as expected'].! !

!SimpleTestResourceTestCase methodsFor: 'running' stamp: 'NiallRoss 7/18/2010 12:31'!
testRunTestWithResource
	self clearOuterResourceStateDuring:
		[self
			assert: (self class selector: #dummy) run printString =
							'1 run, 1 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes'
			description: 'A dummy test that needed a resource did not pass']! !

!SimpleTestResourceTestCase methodsFor: 'utility' stamp: 'NiallRoss 7/18/2010 11:53'!
clearOuterResourceStateDuring: aBlock
	"This self-testing test must clear the outer state of its resources before starting and after finishing, so that it can construct test cases and suites of itself and test them."
	
	self
		assert: SimpleTestResource isAlreadyAvailable
		description: 'The resource was not set up for the test'.
	SimpleTestResource reset.
	self
		deny: SimpleTestResource isAlreadyAvailable
		description: 'The resource was still set up before we began the run'.
	^aBlock
		ensure:
			[self
				deny: SimpleTestResource isAlreadyAvailable
				description: 'The resource was still set up after we finished the run'.
			SimpleTestResource isAvailable.
			self
				assert: SimpleTestResource isAlreadyAvailable
				description: 'The resource was not set up again after the test']! !

!SimpleTestResourceTestCase methodsFor: 'private' stamp: 'BaseSystem 8/30/2009 09:40'!
dummy
	self assert: resource hasSetup
		description: 'This test uses a resource but it was not set up'.
	self setRun.
	self assert: resource hasRun
		description: 'This test uses a resource but we could not interact with it'.! !

!SimpleTestResourceTestCase methodsFor: 'private' stamp: 'BaseSystem 8/30/2009 09:40'!
error
	'foo' odd! !

!SimpleTestResourceTestCase methodsFor: 'private' stamp: 'BaseSystem 8/30/2009 09:40'!
fail
	self assert: false! !

!SimpleTestResourceTestCase methodsFor: 'private' stamp: 'BaseSystem 8/30/2009 09:40'!
setRun
	resource setRun! !

!SimpleTestResourceTestCase class methodsFor: 'accessing' stamp: 'BaseSystem 8/30/2009 09:40'!
resources
	^Array with: SimpleTestResource! !

!SimpleTestResourceTestCase class methodsFor: 'history' stamp: 'AdrianLienhard 10/19/2009 10:49'!
lastStoredRun
	^ ((Dictionary new) add: (#passed->((Set new) add: #testResourceInitRelease; add: #testResourcesCollection; yourself)); add: (#timeStamp->'22 November 2008 10:11:35 pm'); add: (#failures->((Set new))); add: (#errors->((Set new))); yourself)! !

!Sly class methodsFor: 'testing' stamp: 'dmu 8/27/2010 13:38'!
isSlySelector: aSelector
	"True if its has SlySelectorModifers"
	^(aSelector beginsWith: SlySelectorModifier asAWhole)
		or:[(aSelector includesSubString: SlySelectorModifier adverbColon)
		or:[aSelector includesSubString: SlySelectorModifier gerundColon]]! !

!Sly class methodsFor: 'user interfacing' stamp: 'dmu 8/27/2010 14:15'!
dashboard 
	"Sly dashboard      "   
	| topView  buttons lastView subViewCount |
	topView := RVMStandardSystemView new  .
	topView borderWidth:1. 
	buttons _ {
		Transcript showInConsoleSwitch.
		self keepFlyingSwitch.
		RVMButtonView label:'[ SlyBoids new run ] fork' 
					action:[[ SlyBoids new run ] fork].
		RVMButtonView label:'Restore normal cursor' 
					action:[Cursor normal show].
		RVMButtonView label:'process browser' 
					action:[ProcessBrowser  open].
		RVMButtonView label: 'SlySyntaxTests runAll'
					action: [SlySyntaxTests runAll].
	}.
	lastView _ nil.
	buttons do:[:view| topView addSubView: view below: lastView.
		lastView _ view].
	topView label: 'Sly'.
	subViewCount _ topView subViews size.
	topView minimumSize: 165@(subViewCount*27).
	topView maximumSize: topView minimumSize.
	topView controller open! !

!Sly class methodsFor: 'user interfacing' stamp: 'dmu 8/30/2010 10:44'!
keepFlyingSwitch
	"Sly3 keepFlyingSwitch demo"
	^RVMCheckBoxView on: self label: 'Keep SlyBoids Flying' 
						checkState: [Sly3 keepFlying] 
						whenChecked: [Sly3 keepFlying:true] 
						whenUnchecked: [Sly3 keepFlying:false].! !

!Sly class methodsFor: 'accessing' stamp: 'ssa 3/25/2010 16:29'!
keepFlying

	KeepFlying isNil ifTrue:[KeepFlying _ true].
	^KeepFlying! !

!Sly class methodsFor: 'accessing' stamp: 'ssa 3/25/2010 16:32'!
keepFlying: aBoolean

	KeepFlying _ aBoolean! !

!Sly class methodsFor: 'accessing' stamp: 'ssa 3/25/2010 16:32'!
toggleKeepFlying

	self keepFlying: self keepFlying not! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/12/2010 10:58'!
actualSelector
	"Answer the value of actualSelector"

	actualSelector isNil ifTrue:[self determineActualSelector].
	^ actualSelector! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 7/16/2010 19:19'!
actualSelector: anObject
	"Set the value of actualSelector"

	actualSelector _ anObject asSymbol.
		"(actualSelector = #readStream) ifTrue:[self halt:'FOUND IT!!']"! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 7/16/2010 19:34'!
argumentAdverbs
	"Answer the value of argumentAdverbs"

	argumentAdverbs isNil ifTrue:[self argumentAdverbs: "OrderedCollection new "(self arguments collect:[:e| nil])].
	^ argumentAdverbs! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 4/20/2010 16:19'!
argumentAdverbs: anObject
	"Set the value of argumentAdverbs"

	argumentAdverbs _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/28/2010 14:23'!
argumentSources
	"Answer the value of argumentSources"

	argumentSources isNil ifTrue:[self argumentSources: Dictionary new].
	^ argumentSources! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/28/2010 14:23'!
argumentSources: anObject
	"Set the value of argumentSources"

	argumentSources _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/28/2010 15:41'!
arguments
	"Answer the value of arguments"

	arguments isNil ifTrue:[self arguments: self  originalArguments].
	^ arguments! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 6/1/2010 16:30'!
arguments: anObject
	"Set the value of arguments"

	arguments _ anObject asOrderedCollection! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 7/14/2010 13:50'!
executingSerially
	"Answer the value of executingSerially"

	executingSerially isNil ifTrue:[self executingSerially: false].
	^ executingSerially! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 7/14/2010 13:50'!
executingSerially: anObject
	"Set the value of executingSerially"

	executingSerially _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 6/1/2010 16:27'!
gerund
	"Answer the value of gerund, nil, a #symbol, or a block"

	gerund isNil ifTrue:[self gerund: nil].
	^ gerund! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 6/1/2010 16:27'!
gerund: anObject
	"Set the value of gerund"

	gerund _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 6/1/2010 16:27'!
hasGerund
	"Answer true if we have a gerund"

	^self gerund notNil! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/27/2010 14:28'!
isAsAWhole
	"Answer the value of isAsAWhole"

	isAsAWhole isNil ifTrue:[self isAsAWhole: false].
	^ isAsAWhole! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/27/2010 14:28'!
isAsAWhole: anObject
	"Set the value of isAsAWhole"

	isAsAWhole _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 3/28/2010 23:04'!
members
	"Answer the value of members"

	members isNil ifTrue:[self members: nil].
	^ members! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 3/28/2010 23:04'!
members: anObject
	"Set the value of members"

	members _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 3/28/2010 23:04'!
message
	"Answer the value of message"

	message isNil ifTrue:[self message: nil].
	^ message! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/27/2010 15:55'!
message: anObject
	"Set the value of message"

	message _ anObject.
	"force initialization"
	self arguments.! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 4/20/2010 16:19'!
messageAdverb
	"Answer the value of messageAdverb"

	messageAdverb isNil ifTrue:[self messageAdverb: nil].
	^ messageAdverb! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 4/20/2010 16:19'!
messageAdverb: anObject
	"Set the value of messageAdverb"

	messageAdverb _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/12/2010 16:08'!
messageEnvelopes: anObject
	"Set the value of messageEnvelopes"

	messageEnvelopes _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/12/2010 15:28'!
originalArguments

	^ self message arguments! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 4/20/2010 16:22'!
originalSelector
	"Answer the value of originalSelector"

	originalSelector isNil ifTrue:[self originalSelector: self message selector].
	^ originalSelector! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 7/16/2010 18:48'!
originalSelector: anObject
	"Set the value of originalSelector"
"anObject = #selector ifTrue:[self halt]."    "useful for debugging"
	Transcript cr;show:'Dispatching #',anObject.
	originalSelector _ anObject ! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/12/2010 19:32'!
randomNumberSource

	RandomNumberSource isNil ifTrue:[RandomNumberSource _ Random new].
	^RandomNumberSource! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/28/2010 14:36'!
receiverSource
	"Answer the value of receiverSource"

	receiverSource isNil ifTrue:[self receiverSource: self determineReceiverSource].
	^ receiverSource! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/28/2010 14:35'!
receiverSource: anObject
	"Set the value of receiverSource"

	receiverSource _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/28/2010 14:41'!
receivers
	"Answer the value of receivers"

	receivers isNil ifTrue:[self receivers: self determineReceivers].
	^ receivers! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/28/2010 14:41'!
receivers: anObject
	"Set the value of receivers"

	receivers _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/11/2010 11:11'!
return
	"Answer the value of return"

	self halt:'Special case...hould never access this way'.
	return isNil ifTrue:[self return: nil].
	^ return! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/28/2010 16:54'!
robinCount
	"Answer the value of robinCount"

	robinCount isNil ifTrue:[self robinCount: 0].
	^ robinCount! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/28/2010 16:54'!
robinCount: anObject
	"Set the value of robinCount"

	robinCount _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/27/2010 14:29'!
setAsAWhole

	self isAsAWhole: true! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/27/2010 16:00'!
theEnsemble
	"Answer the value of theEnsemble"
	^ theEnsemble! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/27/2010 16:00'!
theEnsemble: anObject
	"Set the value of theEnsemble"

	theEnsemble _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/28/2010 15:16'!
usingRoundRobin
	"Answer the value of usingRoundRobin"

	usingRoundRobin isNil ifTrue:[self usingRoundRobin: self determineRoundRobin].
	^ usingRoundRobin! !

!Sly2EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/28/2010 14:47'!
usingRoundRobin: anObject
	"Set the value of usingRoundRobin"

	usingRoundRobin _ anObject! !

!Sly2EnsembleMessageDispatcher methodsFor: 'applying adverbs' stamp: 'ssa 5/28/2010 14:26'!
applyAdverb: adverb toArgument: argument inEnvelope: envelope
	"Answer the final argument to send with the message being dispatched via this envelope.
	Common cases are 
		#wholly (batch all args to each member with the message)
		#singly (distributed arguments one-to-one over members).  Issue here with count mismatch.
		#roundly (distribute args over members round-robin fashion, repeating members as needed.  Think of members here as a Resource Pool.  This will require collaboration with any message adverbs.
		#duplicatively (each member gets a copy of the arguments).

	Default case is #wholly"

	adverb isSymbol ifTrue:[^self perform: ('ARG',adverb,':inEnvelope:') asSymbol  with: argument with: envelope].
	adverb isBlock ifTrue:[^ adverb value: argument value: envelope].
	self error:'adverbs can only be unarySelectors or Blocks at this point'! !

!Sly2EnsembleMessageDispatcher methodsFor: 'applying adverbs' stamp: 'ssa 5/28/2010 17:04'!
determineArgumentsForEachReceiver
	"Support for argument adverbs that allow arguments to be distributed/shared/paired/etc across members."
	
	| finalArg |
	self messageEnvelopes  do:[:env|
		self arguments with: self argumentAdverbs 
			withIndexDo:[:arg :adv :index|
				finalArg _ adv isNil 
					ifTrue: [arg]
					ifFalse:["use adverb to determine and process the argument"
						self applyAdverb: adv toArgument: arg inEnvelope: env].
				env message arguments at: index put: finalArg]]
			! !

!Sly2EnsembleMessageDispatcher methodsFor: 'applying adverbs' stamp: 'ssa 7/16/2010 19:35'!
determineRoundRobin
	"Do any of my argument adverbs imply a round-robin use of my receivers?"
	self argumentAdverbs isEmpty ifTrue:[^false].
	self argumentAdverbs with: self arguments do:[:adv :arg| 
		adv = #roundly ifTrue:[self robinCount: arg ENSsize. ^true]].
	^false! !

!Sly2EnsembleMessageDispatcher methodsFor: 'applying adverbs' stamp: 'ssa 5/12/2010 19:51'!
determineSelectorForEachReceiver
	"Support for message adverbs that allow members to modify the message selector being sent.
	Expect this case rarely.  Implement later.
	Default case is to use the actualSelector"
	self messageEnvelopes do:[:each| each message selector: self actualSelector]! !

!Sly2EnsembleMessageDispatcher methodsFor: 'applying adverbs' stamp: 'ssa 5/12/2010 19:27'!
receiversForAdverb: anAdverb
	"Answer the (sub)set of my members to send a message to based on this adverb"
	
	anAdverb isSymbol ifTrue:[^self perform: anAdverb].
	anAdverb isArray ifTrue:[^self perform: anAdverb first withArguments: anAdverb allButFirst].
	anAdverb isBlock ifTrue:[^anAdverb value: self members].
	self error:'Expected a #symbol or aBlock for an adverb'! !

!Sly2EnsembleMessageDispatcher methodsFor: 'applying gerunds' stamp: 'ssa 5/11/2010 16:38'!
anding:results
	"AND the elements in results and return the result.
	Assumes these elements understand &."
	
	| result |
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	result _ results first.
	results allButFirst do:[:each| result _ each & result].
	^result! !

!Sly2EnsembleMessageDispatcher methodsFor: 'applying gerunds' stamp: 'ssa 7/7/2010 22:06'!
applyGerundTo: results
	"use the gerund that was supplied by the sender to post-process the results of the message.
	ALL gerund processing starts here"
	
	self gerund isSymbol ifTrue:[^self perform: self gerund asKeyword with: results].
	self gerund isBlock ifTrue:[^ gerund value: results].
	self error:'gerunds can only be unarySelectors or Blocks at this point'! !

!Sly2EnsembleMessageDispatcher methodsFor: 'applying gerunds' stamp: 'ssa 5/11/2010 15:47'!
averaging:results
	"Average the elements in results and return the result.
	Assumes these elements understand +."
	
	| sum |
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	sum _ self totalling: results.
	^sum / results size! !

!Sly2EnsembleMessageDispatcher methodsFor: 'applying gerunds' stamp: 'ssa 5/11/2010 15:35'!
concatenating: results
	"Concatenate each element in results and return the result.
	Assumes these elements are collections of some kind."
	
	| result |
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	result _ results first.
	results allButFirst do:[:each| result _ result , each].
	^result! !

!Sly2EnsembleMessageDispatcher methodsFor: 'applying gerunds' stamp: 'ssa 5/11/2010 16:39'!
oring:results
	"OR the elements in results and return the result.
	Assumes these elements understand |."
	
	| result |
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	result _ results first.
	results allButFirst do:[:each| result _ each | result].
	^result! !

!Sly2EnsembleMessageDispatcher methodsFor: 'applying gerunds' stamp: 'ssa 5/11/2010 15:41'!
totalling:results
	"Sum the elements in results and return the result.
	Assumes these elements understand +."
	
	| result |
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	result _ 0.
	results do:[:each| result _ each + result].
	^result! !

!Sly2EnsembleMessageDispatcher methodsFor: 'argument adverbs' stamp: 'ssa 5/28/2010 14:27'!
ARGReadMe
	"Argument adverbs set policies/strategies for how arguments participate in ensemble messages to the members.
	The ARG selector prefix is used to separate possible naming conflicts between message adverbs and argument adverbs.  All argument adverbs found in a selector will get prefixed with ARG before being called.
	All argument adverb methods should begin with ARG 
		and be of the form 'ARGadverbName: origArg inEnvelope: envelope'"! !

!Sly2EnsembleMessageDispatcher methodsFor: 'argument adverbs' stamp: 'ssa 5/28/2010 14:26'!
ARGduplicatively: originalArgument inEnvelope: envelope
	"Each message uses a copy of the original argument"
	^originalArgument copy! !

!Sly2EnsembleMessageDispatcher methodsFor: 'argument adverbs' stamp: 'ssa 5/28/2010 14:51'!
ARGroundly: originalArgument inEnvelope: envelope
	"Each message uses one of the argument elements.  Reuse receivers as needed in round-robin fashion.  "
	^self nextArgumentFromSource: originalArgument ifAtEnd:[^self]
	! !

!Sly2EnsembleMessageDispatcher methodsFor: 'argument adverbs' stamp: 'ssa 5/28/2010 14:11'!
ARGwholly: originalArgument inEnvelope: envelope
	"Each message uses original argument"
	^originalArgument! !

!Sly2EnsembleMessageDispatcher methodsFor: 'receiver sourcing' stamp: 'ssa 5/28/2010 14:46'!
determineReceiverSource
	"Answer the stream(like) object that serves up my receivers"
	self usingRoundRobin ifTrue:[^RVMCircularCollection withAll: self receivers].
	^self receivers readStream! !

!Sly2EnsembleMessageDispatcher methodsFor: 'receiver sourcing' stamp: 'ssa 5/28/2010 14:42'!
determineReceivers
	"identify the (sub)set of my members that will actually be sent a message.
	This can change based on message adverbs (completely, randomly, stochastically:aProbability, selectively:aBooleanBlock, aBlock etc)
	and argument adverbs (singly, aBlock, etc)"
	
	"only handle message adverbs for now, otherwise default to all members"
	^self hasMessageAdverb 
		ifTrue:[self receiversForAdverb: self messageAdverb]
		ifFalse:[self members asOrderedCollection].
! !

!Sly2EnsembleMessageDispatcher methodsFor: 'receiver sourcing' stamp: 'ssa 5/28/2010 14:35'!
nextReceiver
	"Answer the next receiver from a stream set up over my receivers.
	This stream will be linear in normal cases and circular in #roundly(round-robin) cases"
	
	| source |
	source _ self receiverSource.
	source atEnd ifTrue:[self error:'not enough receivers!!'].
	^source next! !

!Sly2EnsembleMessageDispatcher methodsFor: 'argument sourcing' stamp: 'ssa 5/28/2010 14:50'!
nextArgumentFromSource: argument
	"Answer the next element from a stream set up over argument.
	NOTE: this implementation assumes that the argument source understands #readStream.
	May want to have an alternative version passing in a block to do the stream creation"

	^self nextArgumentFromSource: argument ifAtEnd: [self error:'not enough argument elements for members'].
! !

!Sly2EnsembleMessageDispatcher methodsFor: 'argument sourcing' stamp: 'ssa 7/16/2010 19:28'!
nextArgumentFromSource: argument ifAtEnd: aBlock
	"Answer the next element from a stream set up over argument.
	NOTE: this implementation assumes that the argument source understands #readStream.
	May want to have an alternative version passing in a block to do the stream creation"
	
	| source |
	source _ self argumentSources 
			at: argument 
			ifAbsentPut:[argument ENSisEnsemble
						ifTrue:[argument ENSmembers readStream]
						ifFalse:[argument readStream]].
	source atEnd ifTrue:[aBlock value].
	^source next! !

!Sly2EnsembleMessageDispatcher methodsFor: 'dispatching' stamp: 'dmu 8/27/2010 14:30'!
dispatch
	|   results |
	"NOTE: using non-local return to allow immediate exit from this method upon return determination"
	return _ [:result | ^ result].
	"(self originalSelector endsWith:'equals:') ifTrue:[self halt]."
	self  determineActualSelector.  "gets selector to send to members and finds adverbs, gerunds and ENS"
	self isAsAWhole ifTrue:[self tryReflectiveMessages ].
	self onlyHasGerund ifTrue:[self return: (self applyGerundTo: self members)].
	results _ self sendMessageToMembersModeratedByAdverbs.
	self hasGerund ifTrue:[self return: (self applyGerundTo: results)].
	self returnEnsembleContaining: results 
! !

!Sly2EnsembleMessageDispatcher methodsFor: 'dispatching' stamp: 'dmu 3/29/2010 00:01'!
return: r
	return value: r! !

!Sly2EnsembleMessageDispatcher methodsFor: 'dispatching' stamp: 'dmu 8/27/2010 16:04'!
returnEnsembleContaining: membersOfResult

	"self return: ((self theEnsemble perform: #ensembleSpecies) with: membersOfResult)"
	
	self return: (SlyEnsemble with: membersOfResult)
! !

!Sly2EnsembleMessageDispatcher methodsFor: 'reflection' stamp: 'dmu 8/27/2010 15:56'!
OLDtryReflectiveMessages
	| reflectiveMessages r |
	self actualSelector = #members ifTrue:[self return: self members].
	self actualSelector = #size ifTrue:[self return: self members size].
	self actualSelector = #inspect ifTrue:[self return: self theEnsemble mirror inspect].
	self actualSelector = #storeString ifTrue:[self return: self storeStringForMyEnsemble].
	self actualSelector = #printString ifTrue:[self return: self storeStringForMyEnsemble].
	self actualSelector = #printOn: ifTrue:[self return: (self originalArguments first nextPutAll: self storeStringForMyEnsemble)].
	reflectiveMessages _ #( #isNil #isNotNil #isKindOf:  #isInMemory #pointsTo: #nextObject  #mustBeBooleanIn: #class #inspect #explore #hash #printString #printOn:).
	(reflectiveMessages includes: self actualSelector)   ifTrue: [
		0 primitiveSetExtraPreheaderWord:  self theEnsemble.
		r _ self theEnsemble perform: self actualSelector asSymbol withArguments: self originalArguments.
		self members primitiveSetExtraPreheaderWord:  self theEnsemble.
		self return: r
	].! !

!Sly2EnsembleMessageDispatcher methodsFor: 'reflection' stamp: 'dmu 8/27/2010 15:56'!
tryReflectiveMessages
	"disable messaging dispatching to members and just send it to the ensemble object itself"
	| result |
	0 primitiveSetExtraPreheaderWord:  self message lookupClass "was theEnsemble".
	result _ self theEnsemble perform: self actualSelector asSymbol withArguments: self originalArguments.
	self theEnsemble members: self theEnsemble members.  "force preheader update"
	self return: result! !

!Sly2EnsembleMessageDispatcher methodsFor: 'ensemble behavior' stamp: 'ssa 6/17/2010 10:12'!
storeStringForMyEnsemble
	"Answer a string that should compile back into an ensemble like me"
	| out |
	out _ WriteStream on:''.
	out nextPutAll:'%{'.
	self members  do:[:mem|
		mem storeOn: out.
		out nextPutAll:'. '].
	out nextPutAll:'}'.
	^out contents! !

!Sly2EnsembleMessageDispatcher methodsFor: 'member messaging' stamp: 'ssa 5/28/2010 17:08'!
determineEnvelopes
	"Determine the number of envelopes needed and create them.
	NOTE: #roundly argument adverb will impact this number"
	self usingRoundRobin 
		ifFalse:[self receivers do:[:each|
				self messageEnvelopes add: (SlyMessageEnvelope  
											receiver: each 
											selector: self actualSelector 
											arguments: self arguments asArray copy)]]
		ifTrue:[self robinCount timesRepeat:[
				self messageEnvelopes add: (SlyMessageEnvelope  
											receiver: self nextReceiver 
											selector: self actualSelector 
											arguments: self arguments asArray copy)]]! !

!Sly2EnsembleMessageDispatcher methodsFor: 'member messaging' stamp: 'ssa 7/8/2010 00:43'!
sendMessageToMembersModeratedByAdverbs
	"default behavior when no adverbs found in message"
	self hasAdverbs ifFalse:[  self actualSelector = #members ifTrue:[self halt:'should never dispatch #members to members'].
		^self members parallelCollect: [:elem| elem perform: self actualSelector withArguments: self arguments asArray]].
	
	"now handle the general case for all possible adverbs"
	self determineEnvelopes.
	self determineSelectorForEachReceiver.
	self determineArgumentsForEachReceiver.
	self relocateReceiversIfNeeded.
	self relocateArgumentsIfNeeded.
	^self sendMessages! !

!Sly2EnsembleMessageDispatcher methodsFor: 'member messaging' stamp: 'ssa 7/14/2010 13:49'!
sendMessages
	"Deliver the message envelopes and collect results.
	This must eventually handle adverbs for timing and recurring messages, determining when the ensemble message is 'done'. etc.
	For now, do the simplest thing, a parallelCollect:"
	
	"check for serially flag and handle appropriately"
	^self executingSerially 
		ifTrue:[self messageEnvelopes collect:[:env| env deliver]]
		ifFalse:[self messageEnvelopes parallelCollect: [:env| env deliver]]! !

!Sly2EnsembleMessageDispatcher methodsFor: 'message adverbs' stamp: 'ssa 5/27/2010 14:36'!
completely
	"A message level adverb indicating all members are to receive the message"
	^self members! !

!Sly2EnsembleMessageDispatcher methodsFor: 'message adverbs' stamp: 'ssa 5/12/2010 19:35'!
exclusively: aBlock 
	"A message level adverb indicating to exclude certain members from receiving the message"
	^self rejectively: aBlock! !

!Sly2EnsembleMessageDispatcher methodsFor: 'message adverbs' stamp: 'ssa 5/12/2010 19:36'!
inclusively: aBlock 
	"A message level adverb indicating to include certain members for receiving the message"
	^self selectively: aBlock! !

!Sly2EnsembleMessageDispatcher methodsFor: 'message adverbs' stamp: 'ssa 5/12/2010 19:37'!
randomly
	"A message level adverb indicating one member at random to receive the message"
	^self randomly: 1! !

!Sly2EnsembleMessageDispatcher methodsFor: 'message adverbs' stamp: 'ssa 5/27/2010 10:42'!
randomly: n
	"A message level adverb indicating n members at random to receive the message"
	| remainders chosen picked |
	remainders _ self members asOrderedCollection.
	chosen _ OrderedCollection new.
	n timesRepeat:[ remainders isEmpty ifTrue:[^chosen].
		chosen add: (picked _ remainders atRandom).
		remainders remove: picked].
	^chosen! !

!Sly2EnsembleMessageDispatcher methodsFor: 'message adverbs' stamp: 'dmu 8/27/2010 15:56'!
reflectively
	"A message level adverb indicating the ensemble itself is to receive the message.
	This duplicates the ENS prefix protocol using message adverbs to make it possible for programmatic
	reflective messaging without hacking the selector.
	This approach has the effect of making the ensemble itself appear as the single member of an ensemble"
	^self theEnsemble! !

!Sly2EnsembleMessageDispatcher methodsFor: 'message adverbs' stamp: 'ssa 5/12/2010 19:35'!
rejectively: aBlock 
	"A message level adverb indicating to exclude certain members from receiving the message"
	^self members reject: aBlock! !

!Sly2EnsembleMessageDispatcher methodsFor: 'message adverbs' stamp: 'ssa 5/12/2010 19:36'!
selectively: aBlock 
	"A message level adverb indicating to select certain members to receive the message"
	^self members select: aBlock! !

!Sly2EnsembleMessageDispatcher methodsFor: 'message adverbs' stamp: 'ssa 7/14/2010 13:55'!
serially
	"Execute this message serially to all my members.
	This is a hack since currently all message adverbs must return the members to make envelopes for"
	self executingSerially:true.
	^self members! !

!Sly2EnsembleMessageDispatcher methodsFor: 'message adverbs' stamp: 'ssa 6/1/2010 16:38'!
stochastically: aProbability
	"A message level adverb indicating some probalilty (0.0-1.0) for each members to receive the message"
	^self members select:[:each| self randomNumberSource next <= aProbability]! !

!Sly2EnsembleMessageDispatcher methodsFor: 'relocating' stamp: 'ssa 5/27/2010 11:28'!
relocateArgumentsIfNeeded
	"Supports argument adverbs that desire to be in special core locations relative to each other or to their receiving members.
	Examples:
		#locally (same core)
		#globally (anywhere is fine)
		#closely (nearby cores)
		#distantly (on distant cores from each other.  may need a parameter here for Manhattan distance apart)
		#evenly (spread over cores so each core has same number)
		#statically (don't relocate under any circumstances)
	Default case is #globally, i.e., no relocation.
	Others to be implemented later."
	
		! !

!Sly2EnsembleMessageDispatcher methodsFor: 'relocating' stamp: 'ssa 5/27/2010 11:28'!
relocateReceiversIfNeeded
	"Supports message adverbs that desire to have member in special core locations relative to each other or to arguments.
	Examples:
		#locally (same core)
		#globally (anywhere is fine)
		#closely (nearby cores)
		#distantly (on distant cores from each other.  may need a parameter here for Manhattan distance apart)
		#evenly (spread over cores so each core has same number)
		#statically (don't relocate under any circumstances)
	Default case is #globally, i.e., no relocation.
	Others to be implemented later."
	
		! !

!Sly2EnsembleMessageDispatcher methodsFor: 'selector deconstruction' stamp: 'dmu 8/27/2010 14:30'!
determineActualKeywordSelector
	"Answer the selector to actually send to the members, with all the LY/ING/ENS stuff removed
	Cases follow at end of method"
	
	| orig actual |
	orig _ self originalSelector.
	actual _ orig copy asString.
	(orig beginsWith: SlySelectorModifier asAWhole)  
		ifTrue:[self setAsAWhole.  
			actual _ actual withoutFirst: SlySelectorModifier asAWholeSize].
	((actual includesSubString: SlySelectorModifier adverbColon) or:
	  [actual includesSubString: SlySelectorModifier gerundColon]) 
		ifFalse:[^actual ]
		ifTrue:[self isAsAWhole ifTrue:[self error:'reflective ENS sends can''t have adverbs or gerunds'].
			"handle gerund case"
			(actual last: SlySelectorModifier gerundColonSize)= SlySelectorModifier gerundColon
				ifTrue:[self gerund: self arguments removeLast.
					actual _ actual withoutLast: SlySelectorModifier gerundColonSize.
					].
			"handle adverb cases"
			^(actual includesSubString: SlySelectorModifier adverbColon) ifTrue:[self handleAdverbKeywordIn: actual]
				ifFalse:[actual].
			]
	

	"Cases:
		Normal Smalltalk support:
		+   => +
		unary  =>  unary
		keyword:  => keyword:
		
		Adverb support:
		unaryLY:   =>   unary
		LY:keyword:    =>   keyword:
		LY:keyword:LY:   =>   keyword:
		LY:keyword:LY:keyword:keyword:   =>   keyword:keyword:keyword:
		LY:keyword:LY:keyword:LY:keyword:   =>   keyword:keyword:keyword:
		LY:keyword:LY:keyword:LY:keyword:LY:   =>   keyword:keyword:keyword:
		LY:keyword:keyword:LY:keyword:LY:   =>   keyword:keyword:keyword:
		etc., strip all LY:s
		
		Gerund (reducer) support:
		unaryING:  => unary
		keyword:ING:   => keyword:
		keyword:keyword:keyword:keyword:ING:  =>  keyword:keyword:keyword:keyword:
		etc., strip all ING:s, though there should only be one per selector
		
		DotDot, reflective send support:
		ENSunary  => unary
		ENSkeyword:  =>  keyword:
		ENSkeywordLY:  =>  error, smae with ING
		"
		! !

!Sly2EnsembleMessageDispatcher methodsFor: 'selector deconstruction' stamp: 'ssa 5/12/2010 15:51'!
determineActualSelector
	"Answer the selector to actually send to the members, with all the LY/ING/ENS stuff removed"
	self actualSelector: self findActualSelector! !

!Sly2EnsembleMessageDispatcher methodsFor: 'selector deconstruction' stamp: 'dmu 8/27/2010 14:28'!
determineActualUnarySelector
	"Answer the selector to actually send to the members, with all the LY/ING/ENS stuff removed
	Cases follow at end of method"
	
	| orig |
	orig _ self originalSelector.
	(orig beginsWith: SlySelectorModifier asAWhole) ifTrue:[self isAsAWhole: true.
			orig _ orig copyFrom:  SlySelectorModifier asAWholeSize + 1  to: orig size].
	^orig.
	
	
	"Cases:
		Normal Smalltalk support:
		unary  =>  unary
		
		Adverb support:
		unaryLY:   =>   unary
		
		Gerund (reducer) support:
		unaryING:  => unary
		
		DotDot, reflective send support:
		ENSunary  => unary
		"
		! !

!Sly2EnsembleMessageDispatcher methodsFor: 'selector deconstruction' stamp: 'ssa 5/12/2010 15:45'!
findActualSelector
	"Answer the selector to actually send to the members, with all the LY/ING/ENS stuff removed
	Cases follow at end of method"
	
	| orig |
	orig _ self originalSelector.
	orig isInfix ifTrue:[^orig].  "strategy extensions not supported on binary messages"
	orig isUnary ifTrue:[^self determineActualUnarySelector].
	orig isKeyword ifTrue:[^self determineActualKeywordSelector].
	self error:'Unknown selector type for ',orig.

	"Cases:
		Normal Smalltalk support:
		+   => +
		unary  =>  unary
		keyword:  => keyword:
		
		Adverb support:
		unaryLY:   =>   unary
		LY:keyword:    =>   keyword:
		LY:keyword:LY:   =>   keyword:
		LY:keyword:LY:keyword:keyword:   =>   keyword:keyword:keyword:
		LY:keyword:LY:keyword:LY:keyword:   =>   keyword:keyword:keyword:
		LY:keyword:LY:keyword:LY:keyword:LY:   =>   keyword:keyword:keyword:
		LY:keyword:keyword:LY:keyword:LY:   =>   keyword:keyword:keyword:
		etc., strip all LY:s
		
		Gerund (reducer) support:
		unaryING:  => unary
		keyword:ING:   => keyword:
		keyword:keyword:keyword:keyword:ING:  =>  keyword:keyword:keyword:keyword:
		etc., strip all ING:s, though there should only be one per selector
		
		DotDot, reflective send support:
		ENSunary  => unary
		ENSkeyword:  =>  keyword:
		ENSkeywordLY:  =>  error, same with ING
		"
		! !

!Sly2EnsembleMessageDispatcher methodsFor: 'selector deconstruction' stamp: 'dmu 8/27/2010 15:33'!
handleAdverbKeywordIn: selector
	"Locate the *LY: keywords and extract adverb arguments, and set real arguments,
	Answer the selector stripped of LY:s "
	| keywords adverbOffset keyword argIndex strippedSelector realArgs lastWasAdverb |
	lastWasAdverb _ true.
	keywords _  selector subStrings: {$:}.
	adverbOffset _ 0.
	realArgs _ OrderedCollection new.
	strippedSelector _ ''.
	1 to: keywords size do:[:index|
		keyword _  keywords at: index.
		(keyword endsWith: SlySelectorModifier adverb) ifTrue:["found an adverb keyword"
			index = 1 ifTrue:["its the message adverb"	
						self messageAdverb: (self arguments first).
						adverbOffset _ 1.
						keyword = SlySelectorModifier adverb
							ifFalse:[" the unary case,  e.g., oddLY "
								strippedSelector _ (keyword withoutLast: SlySelectorModifier adverbSize).
								keywords size > 1 ifTrue:[strippedSelector _ strippedSelector,':']]
							ifTrue:["the keyword case LY: adv foo: bar"
								"do nothing, let the first keyword drop"]]
					ifFalse:["its an argument adverb"
						lastWasAdverb _ true.
						argIndex _ index - adverbOffset.
						self argumentAdverbs at: argIndex put:(self arguments at: argIndex).
						"DO NOTHING HERE  was:   strippedSelector _ strippedSelector,(keyword withoutLast: SlySelectorModifier adverbSize),':'"]]
				ifFalse:["normal keyword found or ING found"
					(keyword endsWith: SlySelectorModifier gerund) ifFalse:[
						lastWasAdverb ifFalse:[self argumentAdverbs add: nil].
						lastWasAdverb _ false.
						realArgs add:(self arguments at: index).
						strippedSelector _ strippedSelector,keyword,':']]].
			self arguments: realArgs.
	^strippedSelector! !

!Sly2EnsembleMessageDispatcher methodsFor: 'testing' stamp: 'ssa 5/12/2010 11:12'!
hasAdverbs

	^self hasMessageAdverb or:[self hasArgumentAdverbs]! !

!Sly2EnsembleMessageDispatcher methodsFor: 'testing' stamp: 'ssa 5/12/2010 11:13'!
hasArgumentAdverbs

	self argumentAdverbs detect:[:each| each notNil] ifNone:[^false].
	^true! !

!Sly2EnsembleMessageDispatcher methodsFor: 'testing' stamp: 'ssa 5/12/2010 11:13'!
hasMessageAdverb

	^self messageAdverb notNil! !

!Sly2EnsembleMessageDispatcher methodsFor: 'testing' stamp: 'ssa 5/11/2010 15:45'!
onlyHasGerund
	"True is the selector is only #ING: "
	^self originalSelector == #ING:! !

!Sly2EnsembleMessageDispatcher class methodsFor: 'dispatching' stamp: 'dmu 8/27/2010 16:01'!
dispatch: aMessage members: aCollection theEnsemble: anObject
	^ self new theEnsemble: anObject; message: aMessage; members: aCollection; dispatch! !

!Sly3 class methodsFor: 'user interfacing' stamp: 'dmu 9/23/2010 13:41'!
dashboard 
	"Sly3 dashboard      "   
	| topView  buttons lastView subViewCount |
	topView := RVMStandardSystemView new  .
	topView borderWidth:1. 
	buttons _ {
		Transcript showInConsoleSwitch.
		self keepFlyingSwitch.
		self serializeForDebuggingSwitch.
		RVMButtonView label: 'Suspend member processes' action: [Processor suspendMemberProcesses].
		RVMButtonView label: 'Terminate member processes' action: [Processor terminateMemberProcesses].
		RVMButtonView label: 'Debug member processes' action: [Processor suspendMemberProcesses. ProcessBrowser open].
		
		RVMButtonView label:'[ Sly3Boids new run ] fork' 
					action:[[ Sly3Boids new run ] fork].
		RVMButtonView label: '[Sly3aBoids new run ] fork'
					action: [[Sly3aBoids new run ] fork ].
		RVMButtonView label:'Restore normal cursor' 
					action:[Cursor normal show].
		RVMButtonView label:'process browser' 
					action:[ProcessBrowser  open].
		RVMButtonView label: 'Sly3SyntaxTests runAll'
					action: [Sly3SyntaxTests runAll].
	}.
	lastView _ nil.
	buttons do:[:view| topView addSubView: view below: lastView.
		lastView _ view].
	topView label: 'Sly3'.
	subViewCount _ topView subViews size.
	topView minimumSize: 165@(subViewCount*27).
	topView maximumSize: topView minimumSize.
	topView controller open! !

!Sly3 class methodsFor: 'user interfacing' stamp: 'ssa 3/25/2010 16:41'!
keepFlyingSwitch
	"Sly3 keepFlyingSwitch demo"
	^RVMCheckBoxView on: self label: 'Keep SlyBoids Flying' 
						checkState: [Sly3 keepFlying] 
						whenChecked: [Sly3 keepFlying:true] 
						whenUnchecked: [Sly3 keepFlying:false].! !

!Sly3 class methodsFor: 'user interfacing' stamp: 'dmu 9/7/2010 17:25'!
serializeForDebuggingSwitch
	"Sly3 serializeForDebuggingSwitch demo"
	^RVMCheckBoxView on: self label: 'Serialize for debugging' 
						checkState: [Sly3 serializeForDebugging] 
						whenChecked: [Sly3 serializeForDebugging:true] 
						whenUnchecked: [Sly3 serializeForDebugging:false].! !

!Sly3 class methodsFor: 'accessing' stamp: 'ssa 3/25/2010 16:29'!
keepFlying

	KeepFlying isNil ifTrue:[KeepFlying _ true].
	^KeepFlying! !

!Sly3 class methodsFor: 'accessing' stamp: 'ssa 3/25/2010 16:32'!
keepFlying: aBoolean

	KeepFlying _ aBoolean! !

!Sly3 class methodsFor: 'accessing' stamp: 'dmu 9/7/2010 17:24'!
serializeForDebugging
	^ SerializeForDebugging ifNil: [SerializeForDebugging _ false] ifNotNil: [SerializeForDebugging]! !

!Sly3 class methodsFor: 'accessing' stamp: 'dmu 9/7/2010 17:25'!
serializeForDebugging: aBool
	SerializeForDebugging _ aBool! !

!Sly3 class methodsFor: 'accessing' stamp: 'ssa 3/25/2010 16:32'!
toggleKeepFlying

	self keepFlying: self keepFlying not! !

!Sly3AbstractEnsembleMessageDispatcher methodsFor: 'dispatching' stamp: 'dmu 8/29/2010 18:28'!
dispatch
! !

!Sly3AbstractEnsembleMessageDispatcher methodsFor: 'ensemble behavior' stamp: 'dmu 8/29/2010 12:56'!
storeStringForMyEnsemble
	"Answer a string that should compile back into an ensemble like me"
	| out |
	out _ WriteStream on:''.
	out nextPutAll:'%{'.
	self unprocessedMessage members  do:[:mem|
		mem storeOn: out.
		out nextPutAll:'. '].
	out nextPutAll:'}'.
	^out contents! !

!Sly3AbstractEnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/29/2010 18:24'!
doneBlock
	"Answer the value of doneBlock"

	doneBlock isNil ifTrue:[self doneBlock: [:r | ^ r]].
	^ doneBlock! !

!Sly3AbstractEnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/29/2010 18:24'!
doneBlock: anObject
	"Set the value of doneBlock"

	doneBlock _ anObject! !

!Sly3AbstractEnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/29/2010 12:56'!
unprocessedMessage
	"Answer the value of unprocessedMessage"

	unprocessedMessage isNil ifTrue:[self unprocessedMessage: Sly3UnprocessedEnsembleMessage new].
	^ unprocessedMessage! !

!Sly3AbstractEnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/29/2010 12:55'!
unprocessedMessage: anObject
	"Set the value of unprocessedMessage"

	unprocessedMessage _ anObject! !

!Sly3AbstractEnsembleMessageDispatcher methodsFor: 'created processed message' stamp: 'dmu 8/29/2010 18:32'!
justReturn: anObject
	self doneBlock value: anObject! !

!Sly3AbstractEnsembleMessageDispatcher methodsFor: 'created processed message' stamp: 'dmu 9/1/2010 23:30'!
sendToMembers: selector
	self doneBlock value: (Sly3MessageEnvelope receiver: self unprocessedMessage members selector: selector arguments: self unprocessedMessage arguments) deliver! !

!Sly3AbstractEnsembleMessageDispatcher methodsFor: 'as yet unclassified' stamp: 'dmu 8/29/2010 13:29'!
setUnprocessedSelector: sel
	self unprocessedMessage selector: sel! !

!Sly3AbstractEnsembleMessageDispatcher class methodsFor: 'dispatching' stamp: 'dmu 8/29/2010 18:27'!
dispatch: anUnprocessedMessage 
	self dispatch: anUnprocessedMessage andDo: [:r | ^ r].
	self error: 'unhandled'! !

!Sly3AbstractEnsembleMessageDispatcher class methodsFor: 'dispatching' stamp: 'dmu 8/29/2010 18:26'!
dispatch: anUnprocessedMessage andDo: doneBlock
	^ self new unprocessedMessage: anUnprocessedMessage; doneBlock: [:r | ^ doneBlock value: r]; dispatch! !

!Sly3AbstractIndirectOperandDistributor methodsFor: 'accessing' stamp: 'dmu 9/4/2010 23:01'!
isIndirect
	^ true! !

!Sly3AbstractIndirectOperandDistributor methodsFor: 'accessing' stamp: 'dmu 9/4/2010 23:00'!
parameter
	"Answer the value of parameter"

	parameter isNil ifTrue:[self parameter: nil].
	^ parameter! !

!Sly3AbstractIndirectOperandDistributor methodsFor: 'accessing' stamp: 'dmu 9/4/2010 23:00'!
parameter: anObject
	"Set the value of parameter"

	parameter _ anObject! !

!Sly3AbstractModifier methodsFor: 'testing' stamp: 'dmu 8/30/2010 18:33'!
isAdverb
	^ self class isAdverb! !

!Sly3AbstractModifier methodsFor: 'testing' stamp: 'dmu 8/30/2010 18:34'!
isArgumentModifier
	^ self class isArgumentModifier! !

!Sly3AbstractModifier methodsFor: 'testing' stamp: 'dmu 9/3/2010 22:16'!
isDirect
	^ self isIndirect not! !

!Sly3AbstractModifier methodsFor: 'testing' stamp: 'dmu 8/30/2010 18:34'!
isGerund
	^ self class isGerund! !

!Sly3AbstractModifier methodsFor: 'testing' stamp: 'dmu 8/30/2010 18:34'!
isMessageModifier
	^ self class isMessageModifier! !

!Sly3AbstractModifier methodsFor: 'testing' stamp: 'dmu 9/11/2010 16:58'!
isOperandDistributor ^ false! !

!Sly3AbstractModifier methodsFor: 'accessing' stamp: 'dmu 8/30/2010 18:39'!
allUppercaseSuffixes
	^ self class allUppercaseSuffixes! !

!Sly3AbstractModifier methodsFor: 'accessing' stamp: 'dmu 8/30/2010 18:35'!
lowercaseSuffix
	^ self class lowercaseSuffix! !

!Sly3AbstractModifier methodsFor: 'accessing' stamp: 'dmu 8/30/2010 18:36'!
stringWithLowercaseSuffix
	^ self class stringWithLowercaseSuffix! !

!Sly3AbstractModifier methodsFor: 'accessing' stamp: 'dmu 8/30/2010 19:41'!
suffixSize
	^ self class suffixSize! !

!Sly3AbstractModifier methodsFor: 'accessing' stamp: 'dmu 8/30/2010 18:37'!
uppercaseSuffix
	^ self class uppercaseSuffix! !

!Sly3AbstractModifier class methodsFor: 'accessing' stamp: 'dmu 8/30/2010 18:39'!
allUppercaseSuffixes
	^ {Sly3Adverb. Sly3Gerund} collect: [:x | x uppercaseSuffix]! !

!Sly3AbstractModifier class methodsFor: 'accessing' stamp: 'dmu 8/30/2010 19:52'!
lowercaseSuffix
	^ self uppercaseSuffix asLowercase! !

!Sly3AbstractModifier class methodsFor: 'accessing' stamp: 'dmu 8/30/2010 19:56'!
membersSelector
	^#members! !

!Sly3AbstractModifier class methodsFor: 'accessing' stamp: 'dmu 9/3/2010 12:31'!
modifySelector: sel
	^ (self stringWithUppercaseSuffix, sel) asSymbol! !

!Sly3AbstractModifier class methodsFor: 'accessing' stamp: 'dmu 8/30/2010 18:36'!
stringWithLowercaseSuffix
	"Sly3ModWholly  stringWithLowercaseSuffix"
	^ (self  name copyFrom: 'Sly3Mod' size + 1 to: self  name size) asLowercase! !

!Sly3AbstractModifier class methodsFor: 'accessing' stamp: 'dmu 8/30/2010 18:46'!
stringWithUppercaseSuffix
	^ self stringWithoutSuffix, self uppercaseSuffix! !

!Sly3AbstractModifier class methodsFor: 'accessing' stamp: 'dmu 8/30/2010 18:47'!
stringWithoutSuffix
	| s ss |
	s _ self stringWithLowercaseSuffix.
	ss _ self suffixSize.
	^ s copyFrom: 1 to: s size - ss! !

!Sly3AbstractModifier class methodsFor: 'accessing' stamp: 'dmu 8/30/2010 19:41'!
suffixSize
	^ self uppercaseSuffix size! !

!Sly3AbstractModifier class methodsFor: 'accessing' stamp: 'dmu 8/30/2010 18:37'!
uppercaseSuffix
	^self subclassResponsibility! !

!Sly3AbstractModifier class methodsFor: 'testing' stamp: 'dmu 8/30/2010 18:33'!
isAdverb
	^ false! !

!Sly3AbstractModifier class methodsFor: 'testing' stamp: 'dmu 8/30/2010 18:34'!
isArgumentModifier
	^ false! !

!Sly3AbstractModifier class methodsFor: 'testing' stamp: 'dmu 8/30/2010 18:34'!
isGerund
	^ false! !

!Sly3AbstractModifier class methodsFor: 'testing' stamp: 'dmu 8/30/2010 18:34'!
isMessageModifier
	^ false! !

!Sly3AbstractModifier class methodsFor: 'testing' stamp: 'dmu 8/30/2010 19:00'!
isSlySelector: aString
	"  Sly3AbstractModifier isSlySelector: 'abdc'  "
	^ self allUppercaseSuffixes anySatisfy: [:s | aString includesSubString: s]! !

!Sly3AbstractModifier class methodsFor: 'instance creation' stamp: 'dmu 9/1/2010 10:59'!
instantiateSpecificFromBaseName: baseName includingSuffix: suffix
	| specificClassName cls |
	specificClassName _ 'Sly3Mod', baseName capitalized, suffix asLowercase.
	cls _ Smalltalk at: specificClassName asSymbol ifAbsent: [self error: 'could not find modifier class: ', specificClassName].
	^ cls new! !

!Sly3Adverb methodsFor: 'testing' stamp: 'dmu 9/3/2010 18:15'!
isIndirect
	^ false! !

!Sly3Adverb class methodsFor: 'testing' stamp: 'dmu 8/30/2010 18:40'!
isAdverb
	^ true! !

!Sly3Adverb class methodsFor: 'testing' stamp: 'dmu 8/30/2010 18:38'!
uppercaseSuffix
	^ 'LY'! !

!Sly3Adverb class methodsFor: 'nil' stamp: 'dmu 9/12/2010 22:08'!
defaultArgumentOperandDistributor
	^Sly3ModWholly! !

!Sly3Adverb class methodsFor: 'nil' stamp: 'dmu 4/12/2011 12:30'!
defaultReceiverOperandDistributor
	^Sly3ModIndividually! !

!Sly3Adverb class methodsFor: 'nil' stamp: 'dmu 9/3/2010 14:33'!
reflectiveAdverb
	^Sly3ModPlainly! !

!Sly3Boid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:51'!
flock
	"Answer the value of flock"

	flock isNil ifTrue:[self flock: #()].
	^ flock! !

!Sly3Boid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 22:38'!
flock: anObject
	"Set the value of flock"

	flock _ anObject! !

!Sly3Boid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:57'!
lastDrawnPosition
	"Answer the value of lastDrawnPosition"

	lastDrawnPosition isNil ifTrue:[self lastDrawnPosition: self position].
	^ lastDrawnPosition! !

!Sly3Boid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:00'!
lastDrawnPosition: anObject
	"Set the value of lastDrawnPosition"

	lastDrawnPosition _ anObject! !

!Sly3Boid methodsFor: 'accessing' stamp: 'dmu 3/23/2010 00:05'!
lastLastDrawnPosition
	"Answer the value of lastLastDrawnPosition"

	lastLastDrawnPosition isNil ifTrue:[self lastLastDrawnPosition: self lastDrawnPosition].
	^ lastLastDrawnPosition! !

!Sly3Boid methodsFor: 'accessing' stamp: 'dmu 3/22/2010 23:53'!
lastLastDrawnPosition: anObject
	"Set the value of lastLastDrawnPosition"

	lastLastDrawnPosition _ anObject! !

!Sly3Boid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:53'!
neighbors
	"Answer the value of neighbors"

	neighbors isNil ifTrue:[self neighbors: #()].
	^ neighbors! !

!Sly3Boid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 22:38'!
neighbors: anObject
	"Set the value of neighbors"

	neighbors _ anObject! !

!Sly3Boid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 22:39'!
position
	"Answer the value of position"

	position isNil ifTrue:[self position: 500@500].
	^ position! !

!Sly3Boid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 22:38'!
position: anObject
	"Set the value of position"

	position _ anObject! !

!Sly3Boid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 22:39'!
velocity
	"Answer the value of velocity"

	velocity isNil ifTrue:[self velocity: 0@0].
	^ velocity! !

!Sly3Boid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 22:38'!
velocity: anObject
	"Set the value of velocity"

	velocity _ anObject! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 9/3/2010 00:00'!
computeCentroid
["buttonize next two lines for a trigger setting button"
"Click To Set Trigger"
"  ONEHALT _ true"     
].

"ONEHALT ifTrue:[ONEHALT _ false. self halt]."

	^ (self flock boids members collect: [:m| m position]) average! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 9/3/2010 00:01'!
computeNeighbors
	^self flock boids members select:[:m| m isNear: self]! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 9/8/2010 02:07'!
draw
	| p |
	self lastDrawnPosition = self position ifTrue: [^ self].
	p _ self position.
	
	false ifTrue: [
		Sly3Graphics drawWhiteCircle: self lastDrawnPosition.
		Sly3Graphics drawCircle: p.
		"Sly3Graphics drawFrom: self lastDrawnPosition to: p."
	]
	ifFalse: [
		Sly3Graphics drawFrom: self lastDrawnPosition to: p. 
		Sly3Graphics eraseFrom: self lastLastDrawnPosition to: self lastDrawnPosition.
	].
	
	self lastLastDrawnPosition: self lastDrawnPosition.
	self lastDrawnPosition: p! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 9/8/2010 02:22'!
fly
	| centroid |
	[Sly3 keepFlying] whileTrue:[
		centroid _ self computeCentroid.
		self moveToNewPosition: centroid.
		self flock maybeYield
	]! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:15'!
go
	self fly! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 22:43'!
isNear: aBoid
	^ (self ~== aBoid) and: [(self position dist: aBoid position) <= 10]! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 9/3/2010 00:04'!
keepAwayFromNeighbors
	| sum |
	self neighbors ifEmpty: [^ 0@0].
	sum _ 0.
	self neighbors  do: [:m | sum _ sum + (self position - m position)].
	^ sum / self neighbors size asFloat! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 3/24/2010 15:30'!
limitPositionFrom: min to: max
	| r pos |
	pos _ self position.
	r _ ((pos max: min@min) min: max@max).
	r = pos ifTrue: [^ self].
	pos x < min ifTrue: [r _                 min + (min - pos x)  @  pos y. self velocity: self velocity x negated @ self velocity y].
	pos y < min ifTrue: [r _ pos x @ (min + (min - pos y)).               self velocity: self velocity x             @ self velocity y negated].
	pos x > max ifTrue: [r _                 max - (pos x - max) @ pos y.  self velocity: self velocity x negated @ self velocity y ].
	pos y > max ifTrue: [r _ pos x @ (max - (pos y - max)).              self velocity: self velocity x              @ self velocity y negated].
	self position: r! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 3/24/2010 15:36'!
limitVelocityTo: n
	| ns v vs q |
	ns _ n * n * 2.
	v _ self velocity.
	vs _ v x squared + v y squared.
	vs <= ns ifTrue: [^ self].
	q _ (ns / vs) sqrt.
	self velocity: v * q.! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 9/3/2010 15:54'!
matchVelocityWithNeighbors
	self neighbors  size = 0 ifTrue:  [^ 0@0].
	^ (self neighbors  collect: [:m| m velocity]) average / 8.0! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 3/24/2010 15:04'!
moveToNewPosition: centroid
	| a b c |
	self neighbors: self computeNeighbors.
	a _ self moveTowardCentroidOfAllOthers: centroid.
	b _ self keepAwayFromNeighbors.
	c _ self matchVelocityWithNeighbors.
	self velocity: self velocity + a + b + c.
	self limitVelocityTo: 10.
	self position: self position + self velocity.
	self limitPositionFrom: 0 to: 1000! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 9/8/2010 02:16'!
moveTowardCentroidOfAllOthers: centroid
	| perceivedCentroid s |
	"collectionLYSize introduces overhead."
	s _ self flock boids collectionLYsize.
	s < 2 ifTrue: [^ 0@0].
	perceivedCentroid _ (centroid * s - self position) / (s - 1).
	^ (perceivedCentroid - self position) / 100.0! !

!Sly3Boid methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 22:54'!
perturb
	self position: (self position perturb: 100).
	self velocity: (self velocity perturb: 2).! !

!Sly3Boids methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 15:52'!
boidClass
	^ Sly3Boid! !

!Sly3Boids methodsFor: 'as yet unclassified' stamp: 'dmu 9/8/2010 02:29'!
drawerClass ^ Sly3Drawer! !

!Sly3Boids methodsFor: 'as yet unclassified' stamp: 'ads 2/2/2011 14:55'!
flockSize
	"RVMOperations coreCount - 6 max: 10".
	^ 30! !

!Sly3Boids methodsFor: 'as yet unclassified' stamp: 'dmu 9/16/2010 23:58'!
run
	"Transcript show: (Time millisecondsToRun: [Sly3Boids new run]); cr"
	"[ Sly3Boids new run ] fork"
	| c flock drawer flockAndDrawer n |
	c _ OrderedCollection new.
	n _ self flockSize.
	1 to: n do: [:i| c add: self boidClass new perturb].
	flock _ Sly3Flock boids: c asEnsembleOfElements.
	flock boids flock: flock.
	drawer _ self drawerClass flock: flock.
	flockAndDrawer _ %{flock. drawer}.
	"SlyGraphics clearScreen."
	flockAndDrawer  go ! !

!Sly3Boids class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 22:30'!
run
	^ self new run! !

!Sly3Drawer methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:06'!
flock
	"Answer the value of flock"

	flock isNil ifTrue:[self flock: nil].
	^ flock! !

!Sly3Drawer methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:06'!
flock: anObject
	"Set the value of flock"

	flock _ anObject! !

!Sly3Drawer methodsFor: 'as yet unclassified' stamp: 'dmu 9/8/2010 02:28'!
go
	Processor thisProcess useOnlyMainCore. "for bitblt efficiency"
	[flock isDone] whileFalse: [flock boids members do: [:b| b draw]]! !

!Sly3Drawer class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:07'!
flock: f
	^ self new flock: f! !

!Sly3Ensemble methodsFor: 'as yet unclassified' stamp: 'dmu 3/25/2010 23:48'!
select: aBlock
	^ self members select: aBlock! !

!Sly3Ensemble methodsFor: 'as yet unclassified' stamp: 'dmu 3/25/2010 21:25'!
totalWithIdentity: id
	^ self plus: id adverb: #reductively! !

!Sly3Ensemble methodsFor: 'environment support' stamp: 'dmu 8/29/2010 12:53'!
doesNotUnderstand: aMessage
	"Try to process this message as an ensemble dispatch message to help in the case of inlined primitive calls  like perform:with:with:"
	^ Sly3EnsembleMessageDispatcher dispatch: (Sly3UnprocessedEnsembleMessage fromMessage: aMessage theEnsemble: self)! !

!Sly3Ensemble methodsFor: 'environment support' stamp: 'dmu 3/29/2010 01:04'!
ensembleSpecies
	^ Sly3Ensemble! !

!Sly3Ensemble methodsFor: 'exploring' stamp: 'ssa 6/15/2010 16:14'!
explorerContents

	^self members asOrderedCollection withIndexCollect: [:value :index |
		ObjectExplorerWrapper
			with: value
			name: index printString
			model: self]! !

!Sly3Ensemble methodsFor: 'exploring' stamp: 'ssa 6/15/2010 16:15'!
hasContentsInExplorer
	^self members isEmpty not! !

!Sly3Ensemble methodsFor: 'membership' stamp: 'dmu 9/23/2010 13:05'!
add: anObject
	members add: anObject! !

!Sly3Ensemble methodsFor: 'membership' stamp: 'ssa 6/17/2010 10:29'!
members
	"you should never trust that the members collection stays the same within the ensemble"
	^members copy! !

!Sly3Ensemble methodsFor: 'membership' stamp: 'dmu 9/19/2010 22:53'!
members: aCollection
	"crude check:"
	self primitiveSetExtraWordSelector: #sentToEnsemble:.
	aCollection primitiveSetExtraPreheaderWord: self.
	members _ aCollection.
	^ self! !

!Sly3Ensemble methodsFor: 'membership' stamp: 'dmu 9/23/2010 13:05'!
remove: anObject
	members remove: anObject! !

!Sly3Ensemble methodsFor: 'membership' stamp: 'dmu 9/23/2010 13:06'!
remove: anObject ifAbsent: blk
	^ members remove: anObject ifAbsent: blk! !

!Sly3Ensemble methodsFor: 'membership' stamp: 'dmu 8/30/2010 01:53'!
size
	^ members size! !

!Sly3Ensemble methodsFor: 'printing' stamp: 'ssa 6/17/2010 16:35'!
asExplorerString

	^self printString! !

!Sly3Ensemble methodsFor: 'printing' stamp: 'dmu 9/3/2010 16:50'!
printOn: out
	"Add a string that should compile back into an ensemble like me"
	out nextPutAll:'%{'.
	self members  do:[:mem|
		mem printOn: out.
		out nextPutAll:'. '].
	out nextPutAll:'}'.
! !

!Sly3Ensemble methodsFor: 'printing' stamp: 'dmu 9/3/2010 16:51'!
storeOn: out
	"Write a string on aStream that should compile back into an ensemble like me"
	out nextPut:$%;nextPut:${.
	self members  do:[:mem|
		mem storeOn: out.
		out nextPut:$.].
	out nextPut:$}.
! !

!Sly3Ensemble methodsFor: 'testing' stamp: 'dmu 9/3/2010 15:55'!
ifEmpty: blk
	^ self collecitonLYsize = 0 ifTrue: [blk value]! !

!Sly3Ensemble methodsFor: 'testing' stamp: 'dmu 9/3/2010 14:54'!
isEnsemble
	"Sly3Ensemble overrides to true"
	^true! !

!Sly3Ensemble class methodsFor: 'as yet unclassified' stamp: 'dmu 9/7/2010 11:13'!
deactivateEnsembleSendsFor: anEnsemble during: aBlock
	"disable messaging dispatching to members and just send it to the ensemble object itself during aBlock"
	| members r |
	members _ anEnsemble members.
	0 primitiveSetExtraPreheaderWord:  anEnsemble.
	r _ aBlock ensure: [members primitiveSetExtraPreheaderWord:  anEnsemble. 
].
	^ r

	! !

!Sly3Ensemble class methodsFor: 'as yet unclassified' stamp: 'dmu 9/16/2010 23:37'!
withMembersFrom: aCollection
	^ self new members: aCollection! !

!Sly3Ensemble class methodsFor: 'as yet unclassified' stamp: 'dmu 9/16/2010 23:39'!
withSoleMember: anObject
	^ self withMembersFrom: {anObject}! !

!Sly3EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/29/2010 19:04'!
originalArguments

	^ self unprocessedMessage arguments! !

!Sly3EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/29/2010 18:49'!
parsedMessage
	"Answer the value of parsedMessage"

	parsedMessage isNil ifTrue:[self parsedMessage: nil].
	^ parsedMessage! !

!Sly3EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/29/2010 18:49'!
parsedMessage: anObject
	"Set the value of parsedMessage"

	parsedMessage _ anObject! !

!Sly3EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'ssa 5/12/2010 19:32'!
randomNumberSource

	RandomNumberSource isNil ifTrue:[RandomNumberSource _ Random new].
	^RandomNumberSource! !

!Sly3EnsembleMessageDispatcher methodsFor: 'accessing' stamp: 'dmu 8/27/2010 14:29'!
setAsAWhole

	self isAsAWhole: true! !

!Sly3EnsembleMessageDispatcher methodsFor: 'dispatching' stamp: 'dmu 9/1/2010 23:18'!
dispatch
	self parsedMessage: self parseMessage.
         self parsedMessage ifNil: [^ self].
         ^ self doneBlock value:  ( Sly3MessageEvaluator evaluate: self parsedMessage )
! !

!Sly3EnsembleMessageDispatcher methodsFor: 'ensemble behavior' stamp: 'dmu 8/29/2010 19:00'!
storeStringForMyEnsemble
	"Answer a string that should compile back into an ensemble like me"
	| out |
	out _ WriteStream on:''.
	out nextPutAll:'%{'.
	self unprocessedMessage members  do:[:mem|
		mem storeOn: out.
		out nextPutAll:'. '].
	out nextPutAll:'}'.
	^out contents! !

!Sly3EnsembleMessageDispatcher methodsFor: 'parsing message' stamp: 'dmu 8/29/2010 21:54'!
parseMessage
	^ Sly3MessageParser parse: self unprocessedMessage
! !

!Sly3EnsembleMessageDispatcher class methodsFor: 'dispatching' stamp: 'dmu 9/3/2010 12:27'!
dispatch: anUnprocessedMessage andDo: doneBlock
	| newMessage |
	Sly3ReflectiveMessageDispatcher dispatch: anUnprocessedMessage andDo: [:r|  ^ doneBlock value: r].
	newMessage _ Sly3ReflectiveSelectorChanger modifyAsNeeded: anUnprocessedMessage.
	^super dispatch: newMessage andDo: doneBlock! !

!Sly3EnsembleMirror methodsFor: 'accessing' stamp: 'dmu 9/5/2010 15:25'!
members
	"Answer the value of members"

	members isNil ifTrue:[self members: nil].
	^ members! !

!Sly3EnsembleMirror methodsFor: 'accessing' stamp: 'dmu 9/5/2010 15:25'!
members: anObject
	"Set the value of members"

	members _ anObject! !

!Sly3EnsembleMirror methodsFor: 'accessing' stamp: 'dmu 9/5/2010 15:25'!
theEnsemble
	"Answer the value of theEnsemble"

	theEnsemble isNil ifTrue:[self theEnsemble: nil].
	^ theEnsemble! !

!Sly3EnsembleMirror methodsFor: 'accessing' stamp: 'dmu 9/5/2010 15:25'!
theEnsemble: anObject
	"Set the value of theEnsemble"

	theEnsemble _ anObject! !

!Sly3EnsembleMirror class methodsFor: 'as yet unclassified' stamp: 'dmu 9/5/2010 15:27'!
forEnsemble: e members: m
	^ self new theEnsemble: e; members: m; yourself! !

!Sly3EnsembleMirror class methodsFor: 'as yet unclassified' stamp: 'dmu 9/5/2010 15:27'!
forObject: obj
	self new theEnsemble: obj; members: (obj wholLYisEnsemble ifTrue: [obj collectionLY] ifFalse: [obj]); yourself! !

!Sly3Flock methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:39'!
boids
	"Answer the value of boids"

	^ boids! !

!Sly3Flock methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:11'!
boids: anObject
	"Set the value of boids"

	boids _ anObject! !

!Sly3Flock methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:12'!
isDone
	"Answer the value of isDone"

	isDone isNil ifTrue:[self isDone: false].
	^ isDone! !

!Sly3Flock methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:12'!
isDone: anObject
	"Set the value of isDone"

	isDone _ anObject! !

!Sly3Flock methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:13'!
go
	self isDone: false.
	boids fly.
	self isDone: true! !

!Sly3Flock methodsFor: 'as yet unclassified' stamp: 'dmu 9/7/2010 17:32'!
maybeYield
	| n |
	"[Processor yield. ^self]value."
	Sly3 serializeForDebugging ifTrue: [Processor yield. ^ self].
	n _self boids collectionLYsize + 1 "1 for Drawer".
	Processor yieldIfFewerCoresThan: n! !

!Sly3Flock class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:11'!
boids: b
	^ self new boids: b! !

!Sly3Gerund methodsFor: 'testing' stamp: 'dmu 9/3/2010 22:16'!
isIndirect
	^ false! !

!Sly3Gerund methodsFor: 'as yet unclassified' stamp: 'dmu 9/3/2010 14:13'!
reduceForEvaluator: ev
	self subclassResponsibility! !

!Sly3Gerund class methodsFor: 'testing' stamp: 'dmu 9/1/2010 23:44'!
isGerund
	^ true! !

!Sly3Gerund class methodsFor: 'testing' stamp: 'dmu 8/30/2010 18:38'!
uppercaseSuffix
	^ 'ING'! !

!Sly3Gerund class methodsFor: 'as yet unclassified' stamp: 'dmu 9/12/2010 21:24'!
defaultGerund
	^Sly3ModEnsembling! !

!Sly3Graphics class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:05'!
clearScreen
	Display fillWhite! !

!Sly3Graphics class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:05'!
drawCircle: pt
	Display drawDot5At: pt! !

!Sly3Graphics class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:03'!
drawFrom: ptA to: ptB
	Display drawLineFrom: ptA to: ptB color: Color black! !

!Sly3Graphics class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:04'!
drawWhiteCircle: pt
	Display eraseDot5At: pt! !

!Sly3Graphics class methodsFor: 'as yet unclassified' stamp: 'dmu 3/23/2010 00:02'!
eraseFrom: ptA to: ptB
	Display eraseLineFrom: ptA to: ptB color: Color black! !

!Sly3MessageEnvelope methodsFor: 'delivering' stamp: 'dmu 9/21/2010 00:24'!
deliver
	"send my message to my receiver and return the reply"
	| e |
	1 to: deactivateEnsembleBehaviorFlags size do: [:i|
		(deactivateEnsembleBehaviorFlags at: i) ifTrue: [
			e _ i = 1 ifTrue: [ receiver] ifFalse: [message arguments at: i - 1].
			^ Sly3Ensemble deactivateEnsembleSendsFor: e during: [(self copy at: i putDeactivateEnsembleBehaviorFlag: false) deliver]
			]
		].
	self message arguments: self message arguments asArray.
	^self message sentTo: self receiver! !

!Sly3MessageEnvelope methodsFor: 'accessing' stamp: 'dmu 9/3/2010 15:43'!
at: rcvrArgIndex putDeactivateEnsembleBehaviorFlag: aBool
	deactivateEnsembleBehaviorFlags at: rcvrArgIndex put: aBool! !

!Sly3MessageEnvelope methodsFor: 'accessing' stamp: 'dmu 9/3/2010 15:35'!
deactivateEnsembleBehaviorFlags: x
	deactivateEnsembleBehaviorFlags _ x! !

!Sly3MessageEnvelope methodsFor: 'accessing' stamp: 'ssa 5/12/2010 15:24'!
message
	"Answer the value of message"

	message isNil ifTrue:[self message: nil].
	^ message! !

!Sly3MessageEnvelope methodsFor: 'accessing' stamp: 'ssa 7/16/2010 19:03'!
message: anObject
	"Set the value of message"

	message _ anObject.
! !

!Sly3MessageEnvelope methodsFor: 'accessing' stamp: 'dmu 9/3/2010 21:27'!
receiver
	^ receiver! !

!Sly3MessageEnvelope methodsFor: 'accessing' stamp: 'ssa 5/12/2010 15:24'!
receiver: anObject
	"Set the value of receiver"

	receiver _ anObject! !

!Sly3MessageEnvelope methodsFor: 'printing' stamp: 'dmu 9/3/2010 16:51'!
printOn: aStream

	aStream nextPutAll:'MsgEnv|rcvr:',self receiver wholLYprintString,'|message: ',self message printString! !

!Sly3MessageEnvelope class methodsFor: 'instance creation' stamp: 'dmu 9/3/2010 15:35'!
argumentCount: n

	^self new
		message: (Message selector: #none arguments: (Array new: n));
		deactivateEnsembleBehaviorFlags: ((Array new: n + 1) collect: [:x| false]);
		yourself! !

!Sly3MessageEnvelope class methodsFor: 'instance creation' stamp: 'ssa 5/27/2010 10:46'!
receiver: anObject selector: aSymbol arguments: anArray

	^self new
		receiver: anObject;
		message: (Message selector: aSymbol arguments: anArray);
		yourself! !

!Sly3MessageEvaluator methodsFor: 'accessing' stamp: 'dmu 8/29/2010 21:55'!
message
	"Answer the value of message"

	message isNil ifTrue:[self message: nil].
	^ message! !

!Sly3MessageEvaluator methodsFor: 'accessing' stamp: 'dmu 8/29/2010 21:55'!
message: anObject
	"Set the value of message"

	message _ anObject! !

!Sly3MessageEvaluator methodsFor: 'accessing' stamp: 'dmu 9/22/2010 22:05'!
putResultsIntoAnEnsemble
	^ putResultsIntoAnEnsemble! !

!Sly3MessageEvaluator methodsFor: 'accessing' stamp: 'dmu 9/4/2010 15:34'!
result
	^ result! !

!Sly3MessageEvaluator methodsFor: 'accessing' stamp: 'dmu 9/4/2010 15:33'!
result: r
	result _ r! !

!Sly3MessageEvaluator methodsFor: 'post-processing' stamp: 'dmu 9/4/2010 15:34'!
evaluateGerunds
	message gerunds reverseDo: [:g| g reduceForEvaluator: self].
	^ result! !

!Sly3MessageEvaluator methodsFor: 'evaluating-modified' stamp: 'dmu 9/23/2010 16:26'!
buildOperandTuples
	| mems |
	operandTuples _ OrderedCollection new.
	operandTuples _ self operandTuplesForObject: message receiver membersOrNil: message members adverbs: message messageAdverbs operandTuplesSoFar: operandTuples.
	message arguments with: message argumentAdverbs do: [:arg :ads | 
		mems _ arg collectionLY.
		operandTuples _ 
			self operandTuplesForObject: arg 
			membersOrNil: mems 
			adverbs: ads 
			operandTuplesSoFar: operandTuples].
	^ operandTuples! !

!Sly3MessageEvaluator methodsFor: 'evaluating-modified' stamp: 'dmu 9/23/2010 15:54'!
calculatePutResultsIntoAnEnsemble
	((message messageAdverbs select: [:mm| mm isOperandDistributor]) anySatisfy: [:m | m putResultsIntoAnEnsemble])
		ifTrue: [^ true].
	^ message argumentAdverbs anySatisfy: [:aa|
		(aa select: [:mm| mm isOperandDistributor]) anySatisfy: [:m | m putResultsIntoAnEnsemble]
		]
! !

!Sly3MessageEvaluator methodsFor: 'evaluating-modified' stamp: 'sm 2/19/2011 11:53'!
evaluate
	| r  | 
	"message selector = #particle:ofSize:movedTo: ifTrue: [self halt]."
	putResultsIntoAnEnsemble _ false.
	operandTuples _ self buildOperandTuples.
	envelopes _ self makeEnvelopes.
	self stuffSelectors.
	self stuffReceivers.
	self stuffArguments.
	self relocateReceiversIfNeeded.
	self relocateArgumentsIfNeeded.
	self setDisableEnsembleBehaviorFlags.
	result _ self sendMessages.
	putResultsIntoAnEnsemble _ self calculatePutResultsIntoAnEnsemble.
	r _ self evaluateGerunds.
	^ r
! !

!Sly3MessageEvaluator methodsFor: 'evaluating-modified' stamp: 'dmu 9/23/2010 16:16'!
operandTuplesForObject: operand membersOrNil: mems adverbs: ads operandTuplesSoFar: operandTuplesSoFar
	| ods operandTuplesIncludingThisOne | 
	"Return the factor by which to multiply the number of envelopes for this operand."
	ods _ ads select: [:ad| ad isOperandDistributor].
	operandTuplesIncludingThisOne _ ods last extendOperandTuples: operandTuplesSoFar operand: operand membersOrNil: mems.
	ods removeLast.
	ods  reverseDo: [:operandDistributor | 
		operandTuplesIncludingThisOne _ operandDistributor amendOperandTuples: operandTuplesIncludingThisOne
	].
	^ operandTuplesIncludingThisOne! !

!Sly3MessageEvaluator methodsFor: 'evaluating-modified' stamp: 'dmu 8/30/2010 01:27'!
relocateArgumentsIfNeeded
	"Supports argument adverbs that desire to be in special core locations relative to each other or to their receiving members.
	Examples:
		#locally (same core)
		#globally (anywhere is fine)
		#closely (nearby cores)
		#distantly (on distant cores from each other.  may need a parameter here for Manhattan distance apart)
		#evenly (spread over cores so each core has same number)
		#statically (don't relocate under any circumstances)
	Default case is #globally, i.e., no relocation.
	Others to be implemented later."
	
		! !

!Sly3MessageEvaluator methodsFor: 'evaluating-modified' stamp: 'dmu 8/30/2010 01:26'!
relocateReceiversIfNeeded
	"Supports message adverbs that desire to have member in special core locations relative to each other or to arguments.
	Examples:
		#locally (same core)
		#globally (anywhere is fine)
		#closely (nearby cores)
		#distantly (on distant cores from each other.  may need a parameter here for Manhattan distance apart)
		#evenly (spread over cores so each core has same number)
		#statically (don't relocate under any circumstances)
	Default case is #globally, i.e., no relocation.
	Others to be implemented later."
	
		! !

!Sly3MessageEvaluator methodsFor: 'evaluating-modified' stamp: 'dmu 9/21/2010 00:26'!
sendMessages
	"Deliver the message envelopes and collect results.
	This must eventually handle adverbs for timing and recurring messages, determining when the ensemble message is 'done'. etc.
	For now, do the simplest thing, a parallelCollect:"
	
	| payloadBlock |
	payloadBlock _ [:env| 
		Processor thisProcess creatorEnsemble: env receiver. 
		env deliver].

	"check for serially flag and handle appropriately"
	^(message messageAdverbs anySatisfy: [:ad| ad isKindOf: Sly3ModSerially])
		ifTrue:[ envelopes collect: payloadBlock]
		ifFalse:[ envelopes parallelCollect: payloadBlock]! !

!Sly3MessageEvaluator methodsFor: 'evaluating-modified' stamp: 'dmu 9/23/2010 15:21'!
stuffArguments
 	envelopes with: operandTuples do: [:e :ot| 
		1 to: ot size -1 do: [:i|
			e message arguments at: i put: (ot at: i + 1)]]! !

!Sly3MessageEvaluator methodsFor: 'evaluating-modified' stamp: 'dmu 9/23/2010 15:18'!
stuffReceivers
 	envelopes with: operandTuples do: [:e :ot| e receiver: ot first]! !

!Sly3MessageEvaluator methodsFor: 'evaluating-modified' stamp: 'dmu 9/13/2010 00:13'!
stuffSelectors
	"placeholder; could vary"
	envelopes do: [:e| e message setSelector: message selector]! !

!Sly3MessageEvaluator methodsFor: 'as yet unclassified' stamp: 'dmu 9/23/2010 15:17'!
makeEnvelopes
	^ (Array new: operandTuples size) collect: [:x|Sly3MessageEnvelope argumentCount: message arguments size]! !

!Sly3MessageEvaluator methodsFor: 'as yet unclassified' stamp: 'dmu 9/24/2010 00:35'!
setDisableEnsembleBehaviorFlags
	| deactivateEnsembleBehaviorFlags |
	deactivateEnsembleBehaviorFlags _ ((OrderedCollection with: message messageAdverbs) addAll: message argumentAdverbs; yourself)
		collect: [:adverbs | adverbs anySatisfy: [:adverb| adverb isOperandDistributor and: [adverb shouldDisableEnsembleBehavior]]].
	envelopes do: [:e|e deactivateEnsembleBehaviorFlags: deactivateEnsembleBehaviorFlags]! !

!Sly3MessageEvaluator class methodsFor: 'as yet unclassified' stamp: 'dmu 9/8/2010 21:55'!
evaluate: message
	| r |
	r _  self new message: message; evaluate.
	^ r! !

!Sly3MessageParser methodsFor: 'accessing' stamp: 'dmu 9/3/2010 19:44'!
arguments
	^ arguments! !

!Sly3MessageParser methodsFor: 'accessing' stamp: 'dmu 8/29/2010 21:21'!
parsedMessage
	"Answer the value of parsedMessage"

	parsedMessage isNil ifTrue:[self parsedMessage: nil].
	^ parsedMessage! !

!Sly3MessageParser methodsFor: 'accessing' stamp: 'dmu 8/29/2010 21:21'!
parsedMessage: anObject
	"Set the value of parsedMessage"

	parsedMessage _ anObject! !

!Sly3MessageParser methodsFor: 'accessing' stamp: 'dmu 8/29/2010 21:22'!
unparsedMessage
	"Answer the value of unparsedMessage"

	unparsedMessage isNil ifTrue:[self unparsedMessage: nil].
	^ unparsedMessage! !

!Sly3MessageParser methodsFor: 'accessing' stamp: 'dmu 8/29/2010 21:22'!
unparsedMessage: anObject
	"Set the value of unparsedMessage"

	unparsedMessage _ anObject! !

!Sly3MessageParser methodsFor: 'assigning modifiers to arguments' stamp: 'dmu 9/12/2010 21:17'!
breakKeywordModifiersForArguments
	| s allOperandMods directsAndStrings argDirectMods argIndirectMods |
	s _ ReadStream on: foldedFlatStringsAndModifiers.
	allOperandMods _ OrderedCollection with: (self breakModifiersForReceiverIn: s).
						
	[s atEnd] whileFalse: [
		directsAndStrings _ self nextOnesIn: s suchThat: [:x| (self isDirect: x) or: [self isNonKeywordString: x]].
		argDirectMods _ directsAndStrings select: [:x | self isDirect: x].
		(self isKeyword: s peek) ifFalse: [self error: 'expected keyword'].
		s next.
		argIndirectMods _ self nextOnesIn: s suchThat: [:x | self isIndirect: x].
		allOperandMods addLast: argDirectMods, argIndirectMods.
	].
	^ allOperandMods! !

!Sly3MessageParser methodsFor: 'assigning modifiers to arguments' stamp: 'dmu 9/16/2010 23:24'!
breakModifiersForArguments
		| |
	arguments isEmpty ifTrue: [ ^ self breakUnaryModifiersForArguments].
	unparsedSelector isInfix ifTrue: [ ^ OrderedCollection with: (OrderedCollection new) with: (OrderedCollection new)
		].
	^ self breakKeywordModifiersForArguments! !

!Sly3MessageParser methodsFor: 'assigning modifiers to arguments' stamp: 'dmu 9/12/2010 20:54'!
breakModifiersForReceiverIn: s
	| rcvrDirectMods rcvrIndirectMods |
	rcvrDirectMods _ self nextOnesIn: s suchThat: [:x| self isDirect: x].
	rcvrIndirectMods _ self nextOnesIn: s suchThat: [:x| self isIndirect: x].
	^ rcvrDirectMods, rcvrIndirectMods! !

!Sly3MessageParser methodsFor: 'assigning modifiers to arguments' stamp: 'dmu 9/12/2010 20:45'!
breakUnaryModifiersForArguments
	^ OrderedCollection with: (foldedFlatStringsAndModifiers select: [:x | x isKindOf: Sly3AbstractModifier])! !

!Sly3MessageParser methodsFor: 'assigning modifiers to arguments' stamp: 'dmu 9/13/2010 00:02'!
foldInIndirectModifiers: blk
	| stringsAndMods args inStringsAndMods inArgs s |
	stringsAndMods _ OrderedCollection new.
	args _ OrderedCollection new.
	inStringsAndMods _ ReadStream on: flatKeywordsAndModifiers.
	inArgs _ ReadStream on: arguments.

	[inStringsAndMods atEnd] whileFalse: [
		s _ inStringsAndMods next.
		(s isKindOf: String) ifTrue: [
			stringsAndMods addLast: s.
			(s notEmpty and: [(s last = $:) or: [s first isLetter not]]) ifTrue: [args addLast: inArgs next].
			]
		ifFalse: [
			s isIndirect  ifTrue: [
				s parameter: inArgs next.
				].
			stringsAndMods addLast: s.
		]
	].
	blk value: stringsAndMods contents value: args  asArray! !

!Sly3MessageParser methodsFor: 'testing' stamp: 'dmu 9/12/2010 20:18'!
isDirect: x
	^ (self isModifier: x) and: [x isDirect]! !

!Sly3MessageParser methodsFor: 'testing' stamp: 'dmu 9/12/2010 20:18'!
isIndirect: x
	^ (self isModifier: x) and: [x isIndirect]! !

!Sly3MessageParser methodsFor: 'testing' stamp: 'dmu 9/12/2010 20:17'!
isKeyword: x
	^ (self isString: x) and: [x last = $:]! !

!Sly3MessageParser methodsFor: 'testing' stamp: 'dmu 9/12/2010 20:17'!
isModifier: x
	^ x isKindOf: Sly3AbstractModifier! !

!Sly3MessageParser methodsFor: 'testing' stamp: 'dmu 9/13/2010 00:03'!
isNonKeywordString: x
	^ (self isString: x) and: [x isEmpty or: [x last ~= $:]]! !

!Sly3MessageParser methodsFor: 'testing' stamp: 'dmu 9/12/2010 20:16'!
isString: x
	^ x isKindOf: String! !

!Sly3MessageParser methodsFor: 'testing' stamp: 'dmu 9/12/2010 20:21'!
nextOnesIn: aStream suchThat: testBlk
	| result |
	result _ OrderedCollection new.
	[
		(aStream atEnd not and:  [testBlk value: aStream peek]) ifFalse: [^ result].
		result addLast: aStream next
	] repeat! !

!Sly3MessageParser methodsFor: 'parsing' stamp: 'dmu 9/21/2010 00:23'!
addDefaultModifiersTo:  allMods
	| r rcvr ms defaultClass ods addDefault |
	r _ OrderedCollection new.
	rcvr _ true.
	allMods do: [:mods | 
		ms _ mods copy.
		defaultClass _ rcvr ifTrue: [Sly3Adverb defaultReceiverOperandDistributor] ifFalse: [Sly3Adverb defaultArgumentOperandDistributor].
		ods _ mods select: [:x|x isOperandDistributor].
		addDefault _ ods isEmpty.
		addDefault ifTrue: [ms addFirst: defaultClass new].
		(rcvr and: [mods noneSatisfy:[:x| x isGerund]]) ifTrue: [ms addFirst: Sly3Gerund defaultGerund new].
		r addLast: ms.
		rcvr _ false.
	].
	^ r! !

!Sly3MessageParser methodsFor: 'parsing' stamp: 'dmu 9/3/2010 19:44'!
createParsedMessage.
	^ Sly3ParsedMessage 
		receiver: self unparsedMessage receiver 
		members: self unparsedMessage members 
		messageModifiers: messageModifiers  
		selector: actualSelector  
		arguments: self  arguments 
		argumentAdverbs: argumentModifiers
	
! !

!Sly3MessageParser methodsFor: 'parsing' stamp: 'dmu 9/3/2010 19:52'!
gatherActualSelector
	| sel |
	sel _ ((foldedFlatStringsAndModifiers select: [:a| a isKindOf: String]) gather: [:a | a ]) as: Symbol.
	^ sel ifEmpty: [#yourself] ifNotEmpty: [sel]! !

!Sly3MessageParser methodsFor: 'parsing' stamp: 'dmu 4/12/2011 14:13'!
parse
	unparsedSelector _  self unparsedMessage selector. 
	[unparsedSelector = #mustBeBoolean ifTrue: [self halt].].
	arguments _ self unparsedMessage arguments.
	flatStringsAndModifiers _ self  dissectSelectorIntoStringsAndModifiers: unparsedSelector.
	flatKeywordsAndModifiers _ self breakStringsIntoKeywords: flatStringsAndModifiers.
	self foldInIndirectModifiers: [:s :a | foldedFlatStringsAndModifiers _ s. arguments _ a].
	actualSelector _  self gatherActualSelector.
	modifiersForRcvrAndArgs _ self breakModifiersForArguments.
	modifiersWithDefaults _ self addDefaultModifiersTo: modifiersForRcvrAndArgs.
	messageModifiers _ modifiersWithDefaults first.
	argumentModifiers _ modifiersWithDefaults copyWithoutFirst.
	parsedMessage _ self createParsedMessage.! !

!Sly3MessageParser methodsFor: 'dissecting selector' stamp: 'dmu 9/13/2010 00:09'!
breakStringsIntoKeywords: inCol
	| in out x inin outout c |
	in _ ReadStream on: inCol.
	out _ WriteStream on: (Array new: inCol size * 2).
	[in atEnd] whileFalse: [
		x _ in next.
		(x isKindOf: String) ifFalse: [ out nextPut: x] ifTrue: [
			inin _ ReadStream on: x.
			outout _ WriteStream on:  (String new: x size).
			[inin atEnd] whileFalse: [
				c _ inin next.
				outout nextPut: c.
				c = $: ifTrue: [
					out nextPut:  (outout contents).
					outout _ WriteStream on:  (String new: x size).
				]
			].
			outout isEmpty ifFalse: [out nextPut: (outout contents)]
		]
	].
	^ out contents asOrderedCollection! !

!Sly3MessageParser methodsFor: 'dissecting selector' stamp: 'dmu 5/30/2011 12:11'!
dissectSelectorIntoStringsAndModifiers: aString
	"break up a sequence of characters that are part of a selector"
	"returns a collection of Strings and Sly3AbstractModifier s"
	"Examples:    snortLY -> adverb is snort selectorPart is empty
		snortLYfoo -> adverb is snort selectorPart is foo
		fooSnortLY -> selector part is foo, adverb is Snort"
		
	"Sly3MessageParser new breakIntoStringsAndModifiers:  #serialLYRoundLYatRoundLY:atRoundLY:atRoundLY:atRoundLY:put:valueLY:"

	| lastStart i parts modifierString foundSuffix end nextWord c endWord charAfterSuffixIndex pastModifierIndex |
	parts _ OrderedCollection new.
	lastStart _ 1.
	i _ 1.
	[i <= aString size]  whileTrue: [
		foundSuffix _ nil.
		Sly3AbstractModifier allUppercaseSuffixes do: [:suffix|
			end _ i + suffix size - 1.
			(aString size >= end  and: [ (aString copyFrom: i to: i + suffix size - 1) = suffix ])
				ifTrue: [
					foundSuffix ifNil: [foundSuffix _ suffix] ifNotNil: [self error: 'ambiguous']
				]
		].
		foundSuffix ifNotNil: [
			charAfterSuffixIndex _ i + foundSuffix size.
			modifierString _ aString copyFrom: lastStart to: i - 1.
			parts addLast: (Sly3AbstractModifier instantiateSpecificFromBaseName: modifierString includingSuffix: foundSuffix).
			parts last isIndirect ifTrue: [
				((aString size >= charAfterSuffixIndex) and: [(aString at: charAfterSuffixIndex) = $:])
					ifFalse: [self error: 'indirect modifier should have colon'].
				].
			pastModifierIndex _ charAfterSuffixIndex + (parts last isIndirect ifTrue: [1] ifFalse: [0]).
			lastStart _ i _ pastModifierIndex.
			] ifNil: [
				c _ aString at: i.
				(c isUppercase or: [c = $:]) ifTrue: [
					endWord _ c = $: ifTrue: [i] ifFalse: [i - 1].
					nextWord _ aString copyFrom: lastStart to: endWord. 
					parts addLast: (
						(parts notEmpty and: [(parts last isKindOf: String) and: [('X', parts last) last ~= $:]]) ifFalse: [nextWord] ifTrue: [parts removeLast, nextWord ]).
					lastStart _ endWord + 1
					].
				i _ i + 1
			]
		].
	lastStart <= aString size ifTrue: [
		nextWord _ aString copyFrom: lastStart to: aString size.
		parts addLast: (
			(parts notEmpty and: [parts last isKindOf: String]) ifFalse: [nextWord] ifTrue: [parts removeLast, nextWord capitalized])].
	^ parts
			! !

!Sly3MessageParser class methodsFor: 'as yet unclassified' stamp: 'dmu 8/29/2010 21:22'!
parse: m
	^self new unparsedMessage: m; parse; parsedMessage! !

!Sly3ModAnding methodsFor: 'as yet unclassified' stamp: 'dmu 9/4/2010 15:35'!
reduceForEvaluator: ev
	| result results |
	results _ ev result.
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	result _ results first.
	results allButFirst do:[:each| result _ each & result].
	ev result: result! !

!Sly3ModAveraging methodsFor: 'as yet unclassified' stamp: 'dmu 9/8/2010 02:42'!
reduceForEvaluator: ev
	| sum results |
	results _ ev result.
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	sum _ results sum.
	ev result: sum  / results size ! !

!Sly3ModCollectionly methodsFor: 'multiple adverb support' stamp: 'dmu 9/24/2010 00:46'!
amendOperandTuples: operandTuplesIncludingThisOne
	| ens |
	ens _ (operandTuplesIncludingThisOne collect: [:ot| ot last]).
	^ operandTuplesIncludingThisOne collect: [:ot|
		ot copy removeLast; addLast: ens; yourself]! !

!Sly3ModCollectionly methodsFor: 'result handling' stamp: 'dmu 9/22/2010 22:03'!
putResultsIntoAnEnsemble
	^ false! !

!Sly3ModCollectionly methodsFor: 'as yet unclassified' stamp: 'dmu 9/23/2010 16:01'!
extendOperandTuples: operandTuplesSoFar operand: operand membersOrNil: operandMembers
	| mems |
	mems _ operandMembers ifNil: [operand] ifNotNil: [operandMembers].
	^ operandTuplesSoFar
	 ifEmpty: [OrderedCollection with: (OrderedCollection with: mems)]
	ifNotEmpty: [ operandTuplesSoFar collect: [:tuple | tuple copy addLast: mems; yourself]]! !

!Sly3ModCollectionly commentStamp: 'dmu 9/3/2010 16:55' prior: 0!
Use members collection of the ensemble!
!Sly3ModConcatenating methodsFor: 'as yet unclassified' stamp: 'dmu 9/4/2010 15:33'!
reduceForEvaluator: ev
	"Concatenate each element in results and return the result.
	Assumes these elements are collections of some kind."
	
	| result results |
	results _ ev result.
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	result _ results first.
	results allButFirst do:[:each| result _ result , each].
	ev result: result! !

!Sly3ModDuplicatively methodsFor: 'as yet unclassified' stamp: 'dmu 9/23/2010 15:15'!
amendOperandTuples: operandTuplesIncludingThisOne
	^ operandTuplesIncludingThisOne collect: [:ot| ot copy removeLast; addLast: ot last copy; yourself]! !

!Sly3ModDuplicatively methodsFor: 'as yet unclassified' stamp: 'dmu 9/24/2010 14:46'!
extendOperandTuples: operandTuplesSoFar operand: operand membersOrNil: operandMembers
	| r mems |
	mems _ operandMembers ifNil: [OrderedCollection with: operand] ifNotNil: [operandMembers].
	^ operandTuplesSoFar
	 ifEmpty: [operandMembers collect: [:m| OrderedCollection with: m copy]]
	ifNotEmpty: [ 
		operandTuplesSoFar size = mems size ifFalse: [self error: 'mismatch in number'].
		r _ OrderedCollection new.
		operandTuplesSoFar with: mems do: [:ot :m| r addLast: (ot copy addLast: m copy; yourself)].
		r]! !

!Sly3ModDuplicatively commentStamp: 'dmu 9/1/2010 15:58' prior: 0!
each member gets a copy of the arguments!
!Sly3ModEnsembling methodsFor: 'result handling' stamp: 'dmu 9/22/2010 22:05'!
reduceForEvaluator: ev
	| results |
	results _ ev result.
	ev result: ( ev putResultsIntoAnEnsemble ifTrue: [results asEnsembleOfElements]
	ifFalse: [results size = 1 ifTrue: [results first] ifFalse: [self error: 'no ensembles dismembered, but yet results have ', results size printString, ' elements']])! !

!Sly3ModGathering methodsFor: 'as yet unclassified' stamp: 'dmu 11/29/2010 19:37'!
reduceForEvaluator: ev
	| results |
	results _ ev result.
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	ev result: (results gather: [:x | x]) asEnsembleOfElements! !

!Sly3ModIndividually methodsFor: 'multiple adverb support' stamp: 'dmu 9/23/2010 15:10'!
amendOperandTuples: operandTuplesIncludingThisOne
	operandTuplesIncludingThisOne size > 1 ifTrue: [^ self error: 'what?'].
	^ operandTuplesIncludingThisOne first last members collect: [:m|
			operandTuplesIncludingThisOne first copy addLast: m; yourself
			]! !

!Sly3ModIndividually methodsFor: 'as yet unclassified' stamp: 'dmu 9/24/2010 00:53'!
extendOperandTuples: operandTuplesSoFar operand: operand membersOrNil: operandMembers
	|  mems |
	mems _ operandMembers ifNil: [OrderedCollection with: operand] ifNotNil: [operandMembers].
	^ operandTuplesSoFar
	 ifEmpty: [operandMembers collect: [:m| OrderedCollection with: m]]
	ifNotEmpty: [ 
		operandTuplesSoFar size = mems size  ifFalse: [self error: 'mismatch in number'].
		operandTuplesSoFar with: mems collect: [:ot :m| ot copy addLast: m; yourself].
		]! !

!Sly3ModIndividually commentStamp: 'dmu 4/12/2011 12:32' prior: 0!
Meaning: use my members in parallel.
This is the default modifier for the receiver.
For arguments, it creates a parallel thread for each member of the argument ensemble.
The receiver arity must match this argument's arity.!
!Sly3ModMaxing methodsFor: 'as yet unclassified' stamp: 'dmu 11/29/2010 18:53'!
reduceForEvaluator: ev
	"Sum the elements in results and return the result.
	Assumes these elements understand +."
	
	| results |
	results _ ev result.
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	ev result: results max! !

!Sly3ModMining methodsFor: 'as yet unclassified' stamp: 'dmu 11/29/2010 18:53'!
reduceForEvaluator: ev
	"Sum the elements in results and return the result.
	Assumes these elements understand +."
	
	| results |
	results _ ev result.
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	ev result: results min! !

!Sly3ModOring methodsFor: 'as yet unclassified' stamp: 'dmu 9/4/2010 15:35'!
reduceForEvaluator: ev
	"OR the elements in results and return the result.
	Assumes these elements understand |."
	
	| result results |
	results _ ev result.
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	result _ results first.
	results allButFirst do:[:each| result _ each | result].
	ev result: result! !

!Sly3ModPlainly methodsFor: 'testing' stamp: 'dmu 9/3/2010 15:41'!
shouldDisableEnsembleBehavior
	^ true! !

!Sly3ModPlainly commentStamp: 'dmu 9/3/2010 14:28' prior: 0!
Disable all ensemble processing for the recursive duration of this send!
!Sly3ModRandomly methodsFor: 'accessing' stamp: 'dmu 9/3/2010 18:12'!
parameter
	"Answer the value of parameter"

	parameter isNil ifTrue:[self parameter: 1].
	^ parameter! !

!Sly3ModRandomly methodsFor: 'accessing' stamp: 'dmu 9/3/2010 19:46'!
randomNumberSource

	RandomNumberSource isNil ifTrue:[RandomNumberSource _ Random new].
	^RandomNumberSource! !

!Sly3ModRandomly methodsFor: 'multiple adverb support' stamp: 'dmu 9/23/2010 15:16'!
amendOperandTuples: operandTuplesIncludingThisOne
	self error: 'unimp'! !

!Sly3ModRandomly methodsFor: 'multiple adverb support' stamp: 'dmu 9/24/2010 00:44'!
extendOperandTuples: operandTuplesSoFar operand: operand membersOrNil: operandMembers
	| r mems |
	mems _ operandMembers ifNil: [OrderedCollection with: operand] ifNotNil: [operandMembers].

	^ operandTuplesSoFar
	 ifEmpty: [
		(1 to: parameter) collect: [:m| OrderedCollection with: (mems atRandom: self randomNumberSource)]
		]
	ifNotEmpty: [ 
		r _ OrderedCollection new.
		parameter timesRepeat: [
			r addAll: (operandTuplesSoFar collect: [:t| t copy addLast: (mems atRandom: self randomNumberSource); yourself]).
			].
		r ]! !

!Sly3ModRoundly methodsFor: 'as yet unclassified' stamp: 'dmu 9/23/2010 15:14'!
amendOperandTuples: operandTuplesIncludingThisOne
	| mems r |
	mems _ operandTuplesIncludingThisOne collect: [:tup | tup last].
	r _ OrderedCollection new.
	operandTuplesIncludingThisOne do: [:ot|
		mems do: [:m|
			r add: (ot copy removeLast; addLast: m; yourself)
		]
	].
	^ r! !

!Sly3ModRoundly methodsFor: 'as yet unclassified' stamp: 'dmu 9/23/2010 16:32'!
extendOperandTuples: operandTuplesSoFar operand: operand membersOrNil: operandMembers
	| r mems |
	mems _ operandMembers ifNil: [OrderedCollection with: operand] ifNotNil: [operandMembers].
	^ operandTuplesSoFar
	 ifEmpty: [mems asOrderedCollection collect: [:m| OrderedCollection with: m]]
	ifNotEmpty: [ 
		r _ OrderedCollection new.
		1 to: operandMembers size do: [:i |
			r addAll: (operandTuplesSoFar collect: [:t| t copy addLast: (mems at: i); yourself])..
			].
		r ]! !

!Sly3ModRoundly commentStamp: 'dmu 9/1/2010 15:58' prior: 0!
distribute args over members round-robin fashion, repeating members as needed.  Think of members here as a Resource Pool.  This will require collaboration with any message adverbs.!
!Sly3ModSelecting methodsFor: 'as yet unclassified' stamp: 'dmu 9/16/2010 23:59'!
reduceForEvaluator: ev
	| results members r |
	results _ ev result.
	members _ ev message members.
	r _ OrderedCollection new.
	members with: results do: [:m :res | res ifTrue: [r add: m]].
	ev result: r asEnsembleOfElements! !

!Sly3ModSelectively methodsFor: 'as yet unclassified' stamp: 'dmu 9/23/2010 15:12'!
amendOperandTuples: operandTuplesIncludingThisOne
	self error: 'unimp'! !

!Sly3ModSelectively methodsFor: 'as yet unclassified' stamp: 'dmu 9/23/2010 16:03'!
extendOperandTuples: operandTuplesSoFar operand: operand membersOrNil: operandMembers
	| mems |
	mems _ operandMembers ifNil: [OrderedCollection with: operand] ifNotNil: [operandMembers].

	^ operandTuplesSoFar
	 ifEmpty: [self error: 'cannot be used for receiver']
	ifNotEmpty: [ 
		operandTuplesSoFar size = mems size ifFalse: [self error: 'sizes'].
		mems _ mems copy asOrderedCollection.
		operandTuplesSoFar select: [:ot | mems removeFirst]
	]! !

!Sly3ModSerially methodsFor: 'accessing' stamp: 'dmu 9/1/2010 15:51'!
cachedEns
	self unimplemented: 'must get receiver and arg ens and construct a selected ensemble'.
	^ cachedEns! !

!Sly3ModSerially methodsFor: 'accessing' stamp: 'dmu 9/1/2010 15:49'!
cachedEns: anObject
	"Set the value of cachedEns"

	cachedEns _ anObject! !

!Sly3ModSerially methodsFor: 'accessing' stamp: 'dmu 9/1/2010 15:49'!
cachedMod
	"Answer the value of cachedMod"

	cachedMod isNil ifTrue:[self cachedMod: nil].
	^ cachedMod! !

!Sly3ModSerially methodsFor: 'accessing' stamp: 'dmu 9/1/2010 15:49'!
cachedMod: anObject
	"Set the value of cachedMod"

	cachedMod _ anObject! !

!Sly3ModStandardDeviationing methodsFor: 'as yet unclassified' stamp: 'dmu 11/29/2010 18:53'!
reduceForEvaluator: ev
	"Sum the elements in results and return the result.
	Assumes these elements understand +."
	
	| results |
	results _ ev result.
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	ev result: results standardDeviation! !

!Sly3ModTotalling methodsFor: 'as yet unclassified' stamp: 'dmu 9/4/2010 15:35'!
reduceForEvaluator: ev
	"Sum the elements in results and return the result.
	Assumes these elements understand +."
	
	| result results |
	results _ ev result.
	results isEmpty ifTrue:[self error:'No members, how should we handle?  proceed for nil'.  ^nil].
	result _ 0.
	results do:[:each| result _ each + result].
	ev result: result! !

!Sly3ModValuely methodsFor: 'multiple adverb support' stamp: 'dmu 9/23/2010 15:16'!
amendOperandTuples: operandTuplesIncludingThisOne
	self error: 'unimp'! !

!Sly3ModValuely methodsFor: 'multiple adverb support' stamp: 'dmu 9/24/2010 14:48'!
extendOperandTuples: operandTuplesSoFar operand: operand membersOrNil: operandMembers
	| r mems |
	mems _ operandMembers ifNil: [OrderedCollection with: operand] ifNotNil: [operandMembers].

	^ operandTuplesSoFar
	 ifEmpty: [mems collect: [:m| OrderedCollection with: (parameter value: m)]]
	ifNotEmpty: [ 
		operandTuplesSoFar size = mems size ifFalse: [self error: 'mismatch in number'].
		r _ OrderedCollection new.
		operandTuplesSoFar with: mems do: [:ot :m| r addLast: (ot copy addLast: (parameter value: m); yourself)].
		r]! !

!Sly3ModWholly methodsFor: 'as yet unclassified' stamp: 'dmu 9/24/2010 00:47'!
amendOperandTuples: operandTuplesIncludingThisOne
	| ens |
	ens _ (operandTuplesIncludingThisOne collect: [:ot| ot last]) asEnsembleOfElements.
	^ operandTuplesIncludingThisOne collect: [:ot|
		ot copy removeLast; addLast: ens; yourself]! !

!Sly3ModWholly methodsFor: 'as yet unclassified' stamp: 'dmu 9/22/2010 22:00'!
doNotDismember
	^ true! !

!Sly3ModWholly methodsFor: 'as yet unclassified' stamp: 'dmu 9/23/2010 14:46'!
extendOperandTuples: operandTuplesSoFar operand: operand membersOrNil: operandMembers
	^ operandTuplesSoFar
	 ifEmpty: [OrderedCollection with: (OrderedCollection with: operand)]
	ifNotEmpty: [ operandTuplesSoFar collect: [:tuple | tuple copy addLast: operand; yourself]]! !

!Sly3ModWholly methodsFor: 'result handling' stamp: 'dmu 9/22/2010 22:03'!
putResultsIntoAnEnsemble
	^ false! !

!Sly3ModWholly commentStamp: 'dmu 9/1/2010 15:57' prior: 0!
batch all args to each member with the message!
!Sly3OperandDistributor methodsFor: 'result handling' stamp: 'dmu 9/22/2010 22:03'!
putResultsIntoAnEnsemble
	^ true! !

!Sly3OperandDistributor methodsFor: 'testing' stamp: 'dmu 9/19/2010 20:52'!
isOperandDistributor ^ true! !

!Sly3OperandDistributor methodsFor: 'testing' stamp: 'dmu 9/19/2010 20:59'!
shouldDisableEnsembleBehavior
	^ false! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/1/2010 23:05'!
argumentAdverbs
	"Answer the value of argumentAdverbs"

	argumentAdverbs isNil ifTrue:[self argumentAdverbs: nil].
	^ argumentAdverbs! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/3/2010 20:29'!
argumentAdverbs: collectionPerArgument
	"Set the value of argumentModifiers"
	(collectionPerArgument anySatisfy: [:x | x anySatisfy: [:a | a isAdverb not]]) ifTrue: [self error: 'only adverbs for arguments'].
	argumentAdverbs _ collectionPerArgument asArray! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/5/2010 15:32'!
argumentMirrors
	"Answer the value of argumentMirrors"

	argumentMirrors isNil ifTrue:[self argumentMirrors: nil].
	^ argumentMirrors! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/5/2010 15:32'!
argumentMirrors: anObject
	"Set the value of argumentMirrors"

	argumentMirrors _ anObject! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/19/2010 21:36'!
arguments
	"Answer the value of arguments"
	false ifTrue: [SupportMultipleAdverbs. self error: 'should rm this inst var after mirror switch'].


	arguments isNil ifTrue:[self arguments: nil].
	^ arguments! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/6/2010 16:47'!
arguments: anObject
	"Set the value of arguments"

	arguments _ anObject! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/1/2010 16:34'!
gerunds
	gerunds ifNil: [gerunds _ {}].
	^ gerunds! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/1/2010 23:05'!
gerunds: anObject
	"Set the value of gerunds"

	gerunds _ anObject! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/19/2010 21:36'!
members
	"Answer the value of members"
	false ifTrue: [SupportMultipleAdverbs. self error: 'should rm this inst var after mirror switch'].


	members isNil ifTrue:[self members: nil].
	^ members! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/6/2010 16:47'!
members: anObject
	"Set the value of members"

	members _ anObject! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/1/2010 16:46'!
messageAdverbs
	^ messageAdverbs ifNil: [messageAdverbs _ {}] ifNotNil: [messageAdverbs]! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/1/2010 23:05'!
messageAdverbs: anObject
	"Set the value of messageAdverbs"

	messageAdverbs _ anObject! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/12/2010 21:19'!
messageModifiers: anObject
	"Set the value of messageModifiers"

	| |
	gerunds _ anObject select: [:x|x isGerund].
	messageAdverbs _ anObject select: [:x| x isAdverb]
		! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/19/2010 21:37'!
receiver
	"Answer the value of receiver"
	false ifTrue: [SupportMultipleAdverbs. self error: 'should rm this inst var after mirror switch'].

	
	^ receiver! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/6/2010 16:47'!
receiver: anObject
	"Set the value of receiver"

	receiver _ anObject! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/5/2010 15:32'!
receiverMirror
	"Answer the value of receiverMirror"

	receiverMirror isNil ifTrue:[self receiverMirror: nil].
	^ receiverMirror! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 9/5/2010 15:32'!
receiverMirror: anObject
	"Set the value of receiverMirror"

	receiverMirror _ anObject! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 8/29/2010 21:08'!
selector
	"Answer the value of selector"

	selector isNil ifTrue:[self selector: #noSelector].
	^ selector! !

!Sly3ParsedMessage methodsFor: 'accessing' stamp: 'dmu 8/29/2010 21:08'!
selector: anObject
	"Set the value of selector"

	selector _ anObject! !

!Sly3ParsedMessage methodsFor: 'testing' stamp: 'dmu 9/1/2010 16:09'!
hasGerund
	^ gerunds notEmpty ! !

!Sly3ParsedMessage methodsFor: 'printing' stamp: 'dmu 9/1/2010 11:15'!
printOn: aStream
	super printOn: aStream.
	aStream nextPutAll: ': ', self selector! !

!Sly3ParsedMessage class methodsFor: 'as yet unclassified' stamp: 'dmu 9/19/2010 21:35'!
receiver: ens members: mems messageModifiers: m  selector: s  arguments: args  argumentAdverbs: argumentAdverbs
	| r |
	false  ifFalse: [
		^ self new receiver: ens; members: mems; messageModifiers: m; selector: s; arguments: args; argumentAdverbs: argumentAdverbs; yourself
		].
	SupportMultipleAdverbs. "come back here later"
	r _ self new.
	r receiverMirror: (Sly3EnsembleMirror forEnsemble: ens members: mems).
	r messageModifiers: m.
	r selector: s.
	r argumentMirrors: (args collect: [:a| Sly3EnsembleMirror forObject: a]).
	r argumentAdverbs: argumentAdverbs.
	^ r! !

!Sly3ReflectiveMessageDispatcher methodsFor: 'dispatching' stamp: 'dmu 8/29/2010 18:40'!
dispatch
	self tryReflectiveMessageSend.
! !

!Sly3ReflectiveMessageDispatcher methodsFor: 'dispatching' stamp: 'dmu 9/8/2010 02:54'!
tryReflectiveMessageSend
	| message selector |
	
	message _ self unprocessedMessage.
	selector _ message selector.
	
	selector = #members ifTrue: [self justReturn: message members].
	
	((selector = #isKindOf:  and:[message arguments first = FakeClassPool])
		           or: [(selector = #==          ) and:[message arguments first = #failedDoit] ] )
				ifTrue:[self justReturn: false].
				
	(#(hash halt error: halt: identityHash == isNil) includes: selector) ifTrue: [self justReturn: (message receiver class deactivateEnsembleSendsFor: message receiver during: [message receiver perform: message selector withArguments: message arguments])].
	
	(selector = #isKindOf:) ifTrue: [self justReturn: (Sly3Ensemble includesBehavior: message arguments first)]! !

!Sly3ReflectiveSelectorChanger methodsFor: 'accessing' stamp: 'dmu 9/3/2010 12:17'!
message: m
	message _ m! !

!Sly3ReflectiveSelectorChanger methodsFor: 'accessing' stamp: 'dmu 9/3/2010 17:49'!
selector: x
	selector _ x! !

!Sly3ReflectiveSelectorChanger methodsFor: 'dispatching' stamp: 'dmu 9/3/2010 17:46'!
modifyMessageAsNeeded
	| newSelector |
	selector _ message selector.
	newSelector _ self modifySelectorAsNeeded.
	^ selector = newSelector ifTrue: [message] ifFalse: [message copy selector: newSelector]! !

!Sly3ReflectiveSelectorChanger methodsFor: 'dispatching' stamp: 'dmu 9/3/2010 17:51'!
modifySelectorAsNeeded
	(self isReflective or: [self isWholly or: [self isCollectionly]]) ifTrue: [^ selector].
	^ (self isEquals or: [self isToolMessage or: [self isToolProcess]]) ifTrue: [self modifiedSelector] ifFalse: [selector]
! !

!Sly3ReflectiveSelectorChanger methodsFor: 'modifying reflective selectors' stamp: 'dmu 9/3/2010 17:52'!
isCollectionly
	^ selector beginsWith: Sly3ModCollectionly stringWithUppercaseSuffix! !

!Sly3ReflectiveSelectorChanger methodsFor: 'modifying reflective selectors' stamp: 'dmu 9/8/2010 21:09'!
isEquals
	^ selector = #= ifTrue:[self selector: #equals:. true] ifFalse: [false]! !

!Sly3ReflectiveSelectorChanger methodsFor: 'modifying reflective selectors' stamp: 'dmu 9/3/2010 14:35'!
isReflective
	^ selector beginsWith: Sly3Adverb reflectiveAdverb stringWithUppercaseSuffix! !

!Sly3ReflectiveSelectorChanger methodsFor: 'modifying reflective selectors' stamp: 'dmu 9/3/2010 12:12'!
isToolMessage
	| toolMessages |
	toolMessages _ #(inspect explore printString asExplorerString hasContentsInExplorer explorerContents  halt error: halt: isKindOf:).
	^ toolMessages includes: selector! !

!Sly3ReflectiveSelectorChanger methodsFor: 'modifying reflective selectors' stamp: 'dmu 9/3/2010 12:13'!
isToolProcess
	| foundContext toolClasses |	
	toolClasses _ { Inspector. Debugger.  PluggableListController}.
	foundContext _ thisContext findContextSuchThat:[:ctxt|  toolClasses includes: ctxt receiver class].
	^ foundContext notNil! !

!Sly3ReflectiveSelectorChanger methodsFor: 'modifying reflective selectors' stamp: 'dmu 9/3/2010 17:52'!
isWholly
	^ selector beginsWith: Sly3ModWholly stringWithUppercaseSuffix! !

!Sly3ReflectiveSelectorChanger methodsFor: 'modifying reflective selectors' stamp: 'dmu 9/3/2010 14:34'!
modifiedSelector
	^ Sly3Adverb reflectiveAdverb modifySelector: selector! !

!Sly3ReflectiveSelectorChanger commentStamp: 'dmu 8/27/2010 14:38' prior: 0!
No matter what Sly is, ST depends on some reflective messages. Handle them here. -- dmu

Possible useful expressions for doIt or printIt.

Structure:
 instVar1		type -- comment about the purpose of instVar1
 instVar2		type -- comment about the purpose of instVar2

Any further useful comments about the general approach of this implementation.!
!Sly3ReflectiveSelectorChanger class methodsFor: 'as yet unclassified' stamp: 'dmu 9/3/2010 12:25'!
modifyAsNeeded: aMessage
	^self new message: aMessage; modifyMessageAsNeeded! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/23/2010 13:11'!
addTest
	"Sly3SyntaxTests addTest run"
	"Sly3SyntaxTests runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ {{1. 2}. {3. 4}. {5. 6}} asOrderedCollection asEnsembleOfElements.
			result _ ens wholLYadd: {7. 8}.
			test assert:  result members asArray  = {{1. 2}. {3. 4}. {5. 6}. {7. 8}}.
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'addTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:50'!
adverbKeywordTest
	"Sly3SyntaxTests adverbKeywordTest run"
	"Sly3SyntaxTests runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{{1. 2}. {3. 4}. {5. 6}}.
			result _ ens commaWholLY: {9. 10}.
			test assert:  result members asArray  = #(#(1 2 9 10) #(3 4 9 10) #(5 6 9 10)).
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'adverbKeywordTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:50'!
adverbUnaryTest
	"self adverbUnaryTest run" 
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens oddRandomLY: 1.
			test assert:  (result members size = 1) & (result members first isBoolean).
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'adverbUnaryTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/22/2010 22:50'!
argAdverbRoundlyTest
	"self argAdverbRoundlyTest run"
	"self runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{10. 20. 30}.
			result _ ens plusRoundLY: %(4. 5. 6. 7. 8. 9}.
			test assert:  result members asArray = {14. 24. 34. 15. 25. 35. 16. 26. 36. 17. 27. 37. 18. 28. 38. 19. 29. 39. }.
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'argAdverbRoundlyTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:50'!
argAdverbWhollyTest
	"self argAdverbWhollyTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{{1. 2}. {3. 4}. {5. 6}}.
			result _ ens commaWholLY: {9. 10}.
			test assert:  result members asArray  = #(#(1 2 9 10) #(3 4 9 10) #(5 6 9 10)).
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'argAdverbWhollyTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/17/2010 00:02'!
binaryTest
	"Sly3SyntaxTests binaryTest run"
	"Sly3SyntaxTests runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens + 10.
			test assert:  result members asArray  = #(11 12 13).
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'binaryTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 5/30/2011 12:46'!
doubleAdverbParsingTest
	"Sly3SyntaxTests doubleAdverbParsingTest run"
	"Sly3SyntaxTests runAll"
	| theTest result p |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			p _ 3@4.
			result _ %{ ( %{p}  roundLYDuplicativeLYx: 10) members. p}.
			test assert:  result members asArray  =  { {10@4}. 3@4}.
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'doubleAdverbParsingTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:50'!
gerundAndingTest 
	"self gerundAndingTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens andINGodd.
			test assert:  result = false.
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundAndingTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/17/2010 16:49'!
gerundDoubleKeywordTest
	"self gerundDoubleKeywordTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{#(1). #(2)}.
			result _ ens concatenatINGat: 1 put: #(12 13).
			test assert:  result  = #( 12 13 12 13)
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundDoubleKeywordTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:50'!
gerundOnlyAveragingTest
	"self gerundOnlyAveragingTest run"
	"self runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens averagING.
			test assert:  result = 2.
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundOnlyAveragingTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:50'!
gerundOnlyConcatenatingTest
	"self gerundOnlyConcatenatingTest run"
	"self runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{'hello'. ' '. 'world'}.
			result _ ens concatenatING.
			test assert:  result = 'hello world'
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundOnlyConcatenatingTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:50'!
gerundOnlyTest
	"self gerundOnlyTest run"
	"self runAll" 
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens totallING.
			test assert:  result = 6
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundOnlyTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:50'!
gerundOnlyTotallingTest
	"self gerundOnlyTotallingTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"] 
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens totallING.
			test assert:  result = 6
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundOnlyTotallingTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:50'!
gerundOringTest
	"self gerundOringTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens orINGodd.
			test assert:  result = true
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundOringTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:50'!
gerundSingleKeywordTest
	"self gerundSingleKeywordTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens totallINGplus: 1.
			test assert:  result = 9
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundSingleKeywordTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:50'!
gerundUnaryTest
	"self gerundUnaryTest run"
	"self runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens andINGodd.
			test assert:  result = false
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundUnaryTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:50'!
membersTest
	"Sly3SyntaxTests ensMembersTest run"
	"Sly3SyntaxTests runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{{1. 2}. {3. 4}. {5. 6}}.
			result _ ens members.
			test assert:  result = {{1. 2}. {3. 4}. {5. 6}}
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'ensMembersTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:51'!
msgAdvKeywordTest
	"self msgAdvKeywordTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens randomLY: 1 plus:1.
			test assert:  (result members size = 1)
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'msgAdvKeywordTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:51'!
msgAdvOnlyRandomlyTest
	"self msgAdvOnlyRandomlyTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens randomLY: 1.
			test assert:  (result members size = 1)
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'msgAdvOnlyRandomlyTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:51'!
msgAdvRandomly2Test
	"self msgAdvRandomly2Test run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env|  
			ens _ %{1. 2. 3}.
			result _ ens oddRandomLY: 2.
			test assert:  (result members size = 2)
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'msgAdvRandomly2Test'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:51'!
msgAdvRandomlyTest
	"self msgAdvRandomlyTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"] 
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens oddRandomLY: 1.
			test assert:  (result members size = 1)
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'msgAdvRandomlyTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:51'!
msgAdvSeriallyTest
	"self msgAdvSeriallyTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"] 
		test:[:test :env| 
			ens _ %{1. 2. 3. 4. 5. 6. 7. 8. 9}.
			result _ ens serialLY.
			test assert:  (result members asArray = {1. 2. 3. 4. 5. 6. 7. 8. 9})
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'msgAdvSeriallyTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:51'!
normalBinaryTest
	"self normalBinaryTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"] 
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens +1.
			test assert:  result members = {2. 3. 4}
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'normalBinaryTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:51'!
normalKeywordTest
	"self normalKeywordTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens plus: 1.
			test assert:  result members = {2. 3. 4}
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'normalKeywordTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/22/2010 22:54'!
normalUnaryTest
	"self normalUnaryTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens odd.
			test assert:  result members = {true. false. true}
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'normalUnaryTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:59'!
plainlyTest
	"Sly3SyntaxTests plainlyTest run"
	"Sly3SyntaxTests runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{}.
			result _ ens plainLYisEnsemble.
			
			test assert:  result.
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'adverbKeywordTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/24/2010 00:37'!
printStringTest
	"Sly3SyntaxTests printStringTest run"
	"Sly3SyntaxTests runAll" 
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens plainLYprintString.
			test assert:  result = '%{1. 2. 3. }'
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'printStringTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/23/2010 13:12'!
removeTest
	"Sly3SyntaxTests removeTest run"
	"Sly3SyntaxTests runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ {{1. 2}. {3. 4}. {5. 6}} asOrderedCollection asEnsembleOfElements.
			result _ ens wholLYremove: {3. 4}.
			test assert:  result members asArray  = {{1. 2}.  {5. 6}. }.
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'removeTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/24/2010 00:41'!
severalIndirectAdverbTests
	"self severalIndirectAdverbTests run"
	"self runAll" 
	| theTest |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			%{1. 2. 3} randomLY: 2.
			%{1. 2. 3} oddRandomLY: 2.
			%{1. 3. 4} plus: %{4. 5} randomLY: 3.
			%{2. 4} randomLY: 3 plus: %{2. 6} randomLY: 4 .
			test assert:  true.
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'severalIndirectAdverbTests'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 4/12/2011 12:34'!
singlyTest
	"Sly3SyntaxTests singlyTest run"
	"Sly3SyntaxTests runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens plusIndividualLY: %{10. 20. 30 }.
			test assert:  result members asArray  = {11. 22. 33}.
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'singlyTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:51'!
sizeTest
	"Sly3SyntaxTests sizeTest run"
	"Sly3SyntaxTests runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{{1. 2}. {3. 4}. {5. 6}}.
			result _ ens collectionLYsize.
			test assert:  result = 3
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'sizeTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/24/2010 14:51'!
strategyMultipleAdverbTest
	"Sly3SyntaxTests strategyMultipleAdverbTest run"
	"Sly3SyntaxTests runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{{3. 30}. {4. 40}. {5. 50}}.
			result _ ens serialLYatRoundLY: %{1. 2} put: %{1. 2. 3. 4. 5. 6} valueLY: [:x| x + 17].
			test assert:  result members asArray  = {18. 19. 20. 21. 22. 23. }.
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'strategyMultipleAdverbTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'isolated failures' stamp: 'dmu 9/16/2010 23:50'!
gerundPerformWithWithTest
	"CURRENTLY FAILS"
	"self gerundPerformWithWithTest run"
	"self runAll" 
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{#(1). #(2)}.
			result _ ens perform: #at:put: with: 1 with: 4 ING:#totalling.
			test assert:  result = 8
				 ifFail:[test log:' failed: %{#(1). #(2)} perform: #at:put: with: 1 with 4 ING:#totalling  ==> ', result  printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundPerformWithWithTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'isolated failures' stamp: 'dmu 9/16/2010 23:51'!
msgAdvSelectivelyTest
	"self msgAdvSelectivelyTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens serialLYselectiveLYvalueLY:  [:mbr| mbr odd].
			test assert:  result members asArray = #(1 3)
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'msgAdvSelectivelyTest'.
	^theTest! !

!Sly3SyntaxTests class methodsFor: 'tutorial' stamp: 'dmu 9/16/2010 23:51'!
tutorialExamples

	%{1. 2. 3} isNil. "%{false. false. false}."
	%{1. 2. 3} totallING. "6" 
	%{1. 2. 3} randomLY: 2. "%{1. 3}"
	%{1. 2. 3} oddRandomLY: 2.  "%{true. false}"
	%{1. 3. 4} plus: %{4. 5} randomLY: 3.   "%{5. 8. 8. 6. 7. 8. 6. 8. 8. }"
	%{2. 4} randomLY: 3 plus: %{2. 6} randomLY: 4. "  %{10. 8. 8. 6. 10. 8. 10. 6. 4. 6. 10. 10. }"
	%{{1. 2}. {3. 4}. {5. 6}} commaWholLY: {9. 10}.  "%{#(1 2 9 10). #(3 4 9 10). #(5 6 9 10). }"
  	%{1. 2. 3} collectionLY. " #(1 2 3)"
 	%{10. 20. 30} plusRoundLY: %{4. 5. 6.7. 8. 9} . " %{14. 24. 34. 15. 25. 35. 16.7. 26.7. 36.7. 18. 28. 38. 19. 29. 39. }"! !

!Sly3SyntaxTests class methodsFor: 'harness' stamp: 'dmu 9/3/2010 11:50'!
runAll
	super runAll! !

!Sly3UnprocessedEnsembleMessage methodsFor: 'accessing' stamp: 'dmu 8/29/2010 12:46'!
arguments
	"Answer the value of arguments"

	arguments isNil ifTrue:[self arguments: #()].
	^ arguments! !

!Sly3UnprocessedEnsembleMessage methodsFor: 'accessing' stamp: 'dmu 8/29/2010 12:45'!
arguments: anObject
	"Set the value of arguments"

	arguments _ anObject! !

!Sly3UnprocessedEnsembleMessage methodsFor: 'accessing' stamp: 'dmu 8/29/2010 12:46'!
members
	"Answer the value of members"

	members isNil ifTrue:[self members: #()].
	^ members! !

!Sly3UnprocessedEnsembleMessage methodsFor: 'accessing' stamp: 'dmu 8/29/2010 12:45'!
members: anObject
	"Set the value of members"

	members _ anObject! !

!Sly3UnprocessedEnsembleMessage methodsFor: 'accessing' stamp: 'dmu 9/16/2010 23:59'!
receiver
	"Answer the value of receiver"
	"Send no messages; might be an ensemble"

	nil == receiver ifTrue:[self receiver: ( %{})].
	^ receiver! !

!Sly3UnprocessedEnsembleMessage methodsFor: 'accessing' stamp: 'dmu 8/30/2010 19:35'!
receiver: anObject
	"Set the value of receiver"

	receiver _ anObject! !

!Sly3UnprocessedEnsembleMessage methodsFor: 'accessing' stamp: 'dmu 8/29/2010 12:46'!
selector
	"Answer the value of selector"

	selector isNil ifTrue:[self selector: #noSelector].
	^ selector! !

!Sly3UnprocessedEnsembleMessage methodsFor: 'accessing' stamp: 'dmu 8/29/2010 12:45'!
selector: anObject
	"Set the value of selector"

	selector _ anObject! !

!Sly3UnprocessedEnsembleMessage methodsFor: 'printing' stamp: 'dmu 9/1/2010 10:35'!
printOn: aStream
	super printOn: aStream.
	aStream nextPutAll: '(', self selector, ')'! !

!Sly3UnprocessedEnsembleMessage class methodsFor: 'instance creation' stamp: 'dmu 8/30/2010 19:37'!
fromMessage: m members: members
	^ self new receiver: m lookupClass "VM hack"; selector: m selector; arguments: m arguments; members: members; yourself! !

!Sly3UnprocessedEnsembleMessage class methodsFor: 'instance creation' stamp: 'dmu 8/30/2010 19:38'!
fromMessage: m theEnsemble: e
	^ self new receiver: e; selector: m selector; arguments: m arguments; members: e members; yourself! !

!Sly3aBoid methodsFor: 'as yet unclassified' stamp: 'dmu 9/2/2010 23:59'!
computeCentroid
["buttonize next two lines for a trigger setting button"
"Click To Set Trigger"
"  ONEHALT _ true"     
].

"ONEHALT ifTrue:[ONEHALT _ false. self halt]."
	^ self flock boids averagINGserialLYposition! !

!Sly3aBoid methodsFor: 'as yet unclassified' stamp: 'dmu 9/3/2010 00:01'!
computeNeighbors
	"should return ensemble"
	^ self flock boids selectINGisNear: self! !

!Sly3aBoid methodsFor: 'as yet unclassified' stamp: 'dmu 9/3/2010 15:56'!
keepAwayFromNeighbors
	self neighbors collectionLYsize = 0 ifTrue: [^ 0@0].
	^ self position - self neighbors averagINGserialLYposition! !

!Sly3aBoid methodsFor: 'as yet unclassified' stamp: 'dmu 9/8/2010 03:02'!
matchVelocityWithNeighbors
	self neighbors  collectionLYsize = 0 ifTrue:  [^ 0@0].
	^ self neighbors averagINGvelocity / 8.0! !

!Sly3aBoids methodsFor: 'as yet unclassified' stamp: 'dmu 9/8/2010 02:27'!
boidClass ^ Sly3aBoid! !

!Sly3aBoids methodsFor: 'as yet unclassified' stamp: 'dmu 9/8/2010 02:30'!
drawerClass ^ Sly3aDrawer! !

!Sly3aBoids methodsFor: 'as yet unclassified' stamp: 'dmu 9/8/2010 03:03'!
flockSize ^ 30! !

!Sly3aDrawer methodsFor: 'as yet unclassified' stamp: 'dmu 9/8/2010 02:28'!
go
	Processor thisProcess useOnlyMainCore. "for bitblt efficiency"
	[flock isDone] whileFalse: [flock boids serialLYdraw]! !

!SlyBoid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:51'!
flock
	"Answer the value of flock"

	flock isNil ifTrue:[self flock: #()].
	^ flock! !

!SlyBoid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 22:38'!
flock: anObject
	"Set the value of flock"

	flock _ anObject! !

!SlyBoid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:57'!
lastDrawnPosition
	"Answer the value of lastDrawnPosition"

	lastDrawnPosition isNil ifTrue:[self lastDrawnPosition: self position].
	^ lastDrawnPosition! !

!SlyBoid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:00'!
lastDrawnPosition: anObject
	"Set the value of lastDrawnPosition"

	lastDrawnPosition _ anObject! !

!SlyBoid methodsFor: 'accessing' stamp: 'dmu 3/23/2010 00:05'!
lastLastDrawnPosition
	"Answer the value of lastLastDrawnPosition"

	lastLastDrawnPosition isNil ifTrue:[self lastLastDrawnPosition: self lastDrawnPosition].
	^ lastLastDrawnPosition! !

!SlyBoid methodsFor: 'accessing' stamp: 'dmu 3/22/2010 23:53'!
lastLastDrawnPosition: anObject
	"Set the value of lastLastDrawnPosition"

	lastLastDrawnPosition _ anObject! !

!SlyBoid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:53'!
neighbors
	"Answer the value of neighbors"

	neighbors isNil ifTrue:[self neighbors: #()].
	^ neighbors! !

!SlyBoid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 22:38'!
neighbors: anObject
	"Set the value of neighbors"

	neighbors _ anObject! !

!SlyBoid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 22:39'!
position
	"Answer the value of position"

	position isNil ifTrue:[self position: 500@500].
	^ position! !

!SlyBoid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 22:38'!
position: anObject
	"Set the value of position"

	position _ anObject! !

!SlyBoid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 22:39'!
velocity
	"Answer the value of velocity"

	velocity isNil ifTrue:[self velocity: 0@0].
	^ velocity! !

!SlyBoid methodsFor: 'accessing' stamp: 'dmu 3/16/2010 22:38'!
velocity: anObject
	"Set the value of velocity"

	velocity _ anObject! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 15:42'!
computeCentroid
["buttonize next two lines for a trigger setting button"
"Click To Set Trigger"
"  ONEHALT _ true"     
].

"ONEHALT ifTrue:[ONEHALT _ false. self halt]."

	"^500@500"
	"^ self flock boids  positionING: #averaging"
	"^ self flock boids  positionLY: #serially ING: #averaging"
	^ (self flock boids members collect: [:m| m position]) average! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 15:43'!
computeNeighbors
	"^self flock boids yourselfLY:{ #selectively:. [:b| b isNear: self]}"

	^self flock boids members select:[:m| m isNear: self]! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'dmu 3/22/2010 23:55'!
draw
	| p |
	self lastDrawnPosition = self position ifTrue: [^ self].
	p _ self position.
	
	false ifTrue: [
		SlyGraphics drawWhiteCircle: self lastDrawnPosition.
		SlyGraphics drawCircle: p.
		"SlyGraphics drawFrom: self lastDrawnPosition to: p."
	]
	ifFalse: [
		SlyGraphics drawFrom: self lastDrawnPosition to: p.
		SlyGraphics eraseFrom: self lastLastDrawnPosition to: self lastDrawnPosition.
	].
	
	self lastLastDrawnPosition: self lastDrawnPosition.
	self lastDrawnPosition: p! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'ssa 3/25/2010 16:28'!
fly
	| centroid |
	[Sly keepFlying] whileTrue:[
		centroid _ self computeCentroid.
		self moveToNewPosition: centroid.
		self flock maybeYield
	]! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:15'!
go
	self fly! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 22:43'!
isNear: aBoid
	^ (self ~== aBoid) and: [(self position dist: aBoid position) <= 10]! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'dmu 3/17/2010 00:10'!
keepAwayFromNeighbors
	| sum |
	self neighbors ifEmpty: [^ 0@0].
	sum _ 0.
	self neighbors  do: [:m | sum _ sum + (self position - m position)].
	^ sum / self neighbors size asFloat! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'dmu 3/24/2010 15:30'!
limitPositionFrom: min to: max
	| r pos |
	pos _ self position.
	r _ ((pos max: min@min) min: max@max).
	r = pos ifTrue: [^ self].
	pos x < min ifTrue: [r _                 min + (min - pos x)  @  pos y. self velocity: self velocity x negated @ self velocity y].
	pos y < min ifTrue: [r _ pos x @ (min + (min - pos y)).               self velocity: self velocity x             @ self velocity y negated].
	pos x > max ifTrue: [r _                 max - (pos x - max) @ pos y.  self velocity: self velocity x negated @ self velocity y ].
	pos y > max ifTrue: [r _ pos x @ (max - (pos y - max)).              self velocity: self velocity x              @ self velocity y negated].
	self position: r! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'dmu 3/24/2010 15:36'!
limitVelocityTo: n
	| ns v vs q |
	ns _ n * n * 2.
	v _ self velocity.
	vs _ v x squared + v y squared.
	vs <= ns ifTrue: [^ self].
	q _ (ns / vs) sqrt.
	self velocity: v * q.! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:53'!
matchVelocityWithNeighbors
	self neighbors  ifEmpty: [^ 0@0].
	^ (self neighbors  collect: [:m| m velocity]) average / 8.0! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'dmu 3/24/2010 15:04'!
moveToNewPosition: centroid
	| a b c |
	self neighbors: self computeNeighbors.
	a _ self moveTowardCentroidOfAllOthers: centroid.
	b _ self keepAwayFromNeighbors.
	c _ self matchVelocityWithNeighbors.
	self velocity: self velocity + a + b + c.
	self limitVelocityTo: 10.
	self position: self position + self velocity.
	self limitPositionFrom: 0 to: 1000! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 15:43'!
moveTowardCentroidOfAllOthers: centroid
	| perceivedCentroid s |
	s _ self flock boids members size. "was ENSsize"
	s < 2 ifTrue: [^ 0@0].
	perceivedCentroid _ (centroid * s - self position) / (s - 1).
	^ (perceivedCentroid - self position) / 100.0! !

!SlyBoid methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 22:54'!
perturb
	self position: (self position perturb: 100).
	self velocity: (self velocity perturb: 2).! !

!SlyBoids methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 15:52'!
boidClass
	^ SlyBoid! !

!SlyBoids methodsFor: 'as yet unclassified' stamp: 'ads 2/2/2011 14:55'!
flockSize
	"RVMOperations coreCount - 6 max: 10".
	^ 250! !

!SlyBoids methodsFor: 'as yet unclassified' stamp: 'dmu 9/16/2010 23:59'!
run
	"Transcript show: (Time millisecondsToRun: [SlyBoids new run]); cr"
	"[ SlyBoids new run ] fork"
	| c flock drawer flockAndDrawer n |
	c _ OrderedCollection new.
	n _ self flockSize.
	1 to: n do: [:i| c add: self boidClass new perturb].
	flock _ SlyFlock boids: c asEnsembleOfElements.
	flock boids flock: flock.
	drawer _ SlyDrawer flock: flock.
	flockAndDrawer _ SlyEnsemble with: {flock. drawer}.
	"SlyGraphics clearScreen."
	flockAndDrawer  go ! !

!SlyBoids class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 22:30'!
run
	^ self new run! !

!SlyDrawer methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:06'!
flock
	"Answer the value of flock"

	flock isNil ifTrue:[self flock: nil].
	^ flock! !

!SlyDrawer methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:06'!
flock: anObject
	"Set the value of flock"

	flock _ anObject! !

!SlyDrawer methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 15:49'!
go
	Processor thisProcess useOnlyMainCore. "for bitblt efficiency"
	[flock isDone] whileFalse: [flock boids members do: [:m | m draw. "self flock maybeYield"] ]! !

!SlyDrawer class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:07'!
flock: f
	^ self new flock: f! !

!SlyEnsemble methodsFor: 'as yet unclassified' stamp: 'ssa 7/8/2010 00:50'!
ENSsize
	^members size! !

!SlyEnsemble methodsFor: 'as yet unclassified' stamp: 'dmu 8/29/2010 12:53'!
doesNotUnderstand: aMessage
	"Try to process this message as an ensemble dispatch message to help in the case of inlined primitive calls  like perform:with:with:"
	^ Sly3EnsembleMessageDispatcher dispatch: (Sly3UnprocessedEnsembleMessage fromMessage: aMessage theEnsemble: self)! !

!SlyEnsemble methodsFor: 'as yet unclassified' stamp: 'dmu 3/29/2010 01:04'!
ensembleSpecies
	^ SlyEnsemble! !

!SlyEnsemble methodsFor: 'as yet unclassified' stamp: 'dmu 3/26/2010 00:34'!
ifEmpty: blk
	^ self sizeAsAWhole = 0 ifTrue: [blk value]! !

!SlyEnsemble methodsFor: 'as yet unclassified' stamp: 'ssa 6/11/2010 14:50'!
isEnsemble
	"Object answers false"
	^true! !

!SlyEnsemble methodsFor: 'as yet unclassified' stamp: 'ssa 6/17/2010 10:29'!
members
	"you should never trust that the members collection stays the same within the ensemble"
	^members copy! !

!SlyEnsemble methodsFor: 'as yet unclassified' stamp: 'ssa 7/7/2010 13:57'!
members: aCollection
	self primitiveSetExtraWordSelector: #sentToEnsemble:.
	aCollection primitiveSetExtraPreheaderWord: self.
	members _ aCollection.
	^ self! !

!SlyEnsemble methodsFor: 'as yet unclassified' stamp: 'dmu 3/25/2010 23:48'!
select: aBlock
	^ self members select: aBlock! !

!SlyEnsemble methodsFor: 'as yet unclassified' stamp: 'dmu 3/25/2010 21:13'!
size
	^ self members size! !

!SlyEnsemble methodsFor: 'as yet unclassified' stamp: 'dmu 3/25/2010 21:25'!
totalWithIdentity: id
	^ self plus: id adverb: #reductively! !

!SlyEnsemble methodsFor: 'printing' stamp: 'ssa 6/17/2010 16:35'!
asExplorerString

	^self printString! !

!SlyEnsemble methodsFor: 'printing' stamp: 'ssa 6/17/2010 13:48'!
printOn: out
	"Add a string that should compile back into an ensemble like me"
	out nextPutAll:'%{'.
	self members  do:[:mem|
		mem ENSprintOn: out.
		out nextPutAll:'. '].
	out nextPutAll:'}'.
! !

!SlyEnsemble methodsFor: 'printing' stamp: 'ssa 6/17/2010 13:51'!
storeOn: out
	"Write a string on aStream that should compile back into an ensemble like me"
	out nextPut:$%;nextPut:${.
	self members  do:[:mem|
		mem ENSstoreOn: out.
		out nextPut:$.].
	out nextPut:$}.
! !

!SlyEnsemble methodsFor: 'exploring' stamp: 'ssa 6/15/2010 16:14'!
explorerContents

	^self members asOrderedCollection withIndexCollect: [:value :index |
		ObjectExplorerWrapper
			with: value
			name: index printString
			model: self]! !

!SlyEnsemble methodsFor: 'exploring' stamp: 'ssa 6/15/2010 16:15'!
hasContentsInExplorer
	^self members isEmpty not! !

!SlyEnsemble methodsFor: 'disabling' stamp: 'ssa 7/7/2010 19:13'!
deactivateEnsembleSendsDuring: aBlock
	"disable messaging dispatching to members and just send it to the ensemble object itself during aBlock"
	
	0 primitiveSetExtraPreheaderWord:  self.
	aBlock value.
	self members primitiveSetExtraPreheaderWord:  self. 
! !

!SlyEnsemble class methodsFor: 'as yet unclassified' stamp: 'dmu 3/28/2010 23:48'!
with: aCollection
	^ self new members: aCollection! !

!SlyField methodsFor: 'as yet unclassified' stamp: 'max 9/29/2010 13:55'!
add: aParticle 
	particles members add: aParticle.
	aParticle setHomeField: self.
	simulation running
		ifTrue: [aParticle go]! !

!SlyField methodsFor: 'as yet unclassified'!
displayOn: t1 
	self shouldNotImplement! !

!SlyField methodsFor: 'as yet unclassified' stamp: 'max 9/29/2010 14:33'!
initialize
	super initialize.
	particles := OrderedCollection new asEnsembleOfElements! !

!SlyField methodsFor: 'as yet unclassified'!
particle: t1 ofSize: t2 movedTo: t3 
	| t4 |
	t4 := self localFieldsUnderParticleAt: t3 size: t2.
	self hand: t1 to: t4 first.
	((t4
		reject: [:t5 | t5 isNil])
		collect: [:t5 | t5 particles]) asEnsembleOfElements
		particle: t1
		ofSize: t2
		movedTo: t3! !

!SlyFlock methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:39'!
boids
	"Answer the value of boids"

	^ boids! !

!SlyFlock methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:11'!
boids: anObject
	"Set the value of boids"

	boids _ anObject! !

!SlyFlock methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:12'!
isDone
	"Answer the value of isDone"

	isDone isNil ifTrue:[self isDone: false].
	^ isDone! !

!SlyFlock methodsFor: 'accessing' stamp: 'dmu 3/16/2010 23:12'!
isDone: anObject
	"Set the value of isDone"

	isDone _ anObject! !

!SlyFlock methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:13'!
go
	self isDone: false.
	boids fly.
	self isDone: true! !

!SlyFlock methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 17:09'!
maybeYield
	| n |
	"[Processor yield. ^self]value."
	n _self boids ENSsize + 1 "1 for Drawer".
	Processor yieldIfFewerCoresThan: n! !

!SlyFlock class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:11'!
boids: b
	^ self new boids: b! !

!SlyGraphics class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:05'!
clearScreen
	Display fillWhite! !

!SlyGraphics class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:05'!
drawCircle: pt
	Display drawDot5At: pt! !

!SlyGraphics class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:03'!
drawFrom: ptA to: ptB
	Display drawLineFrom: ptA to: ptB color: Color black! !

!SlyGraphics class methodsFor: 'as yet unclassified' stamp: 'dmu 3/16/2010 23:04'!
drawWhiteCircle: pt
	Display eraseDot5At: pt! !

!SlyGraphics class methodsFor: 'as yet unclassified' stamp: 'dmu 3/23/2010 00:02'!
eraseFrom: ptA to: ptB
	Display eraseLineFrom: ptA to: ptB color: Color black! !

!SlyMessageEnvelope methodsFor: 'delivering' stamp: 'ssa 6/1/2010 16:31'!
deliver
	"send my message to my receiver and return the reply"
	self message arguments: self message arguments asArray.
	^self message sentTo: self receiver! !

!SlyMessageEnvelope methodsFor: 'accessing' stamp: 'ssa 5/12/2010 15:24'!
message
	"Answer the value of message"

	message isNil ifTrue:[self message: nil].
	^ message! !

!SlyMessageEnvelope methodsFor: 'accessing' stamp: 'ssa 7/16/2010 19:03'!
message: anObject
	"Set the value of message"

	message _ anObject.
! !

!SlyMessageEnvelope methodsFor: 'accessing' stamp: 'ssa 5/12/2010 15:24'!
receiver
	"Answer the value of receiver"

	receiver isNil ifTrue:[self receiver: nil].
	^ receiver! !

!SlyMessageEnvelope methodsFor: 'accessing' stamp: 'ssa 5/12/2010 15:24'!
receiver: anObject
	"Set the value of receiver"

	receiver _ anObject! !

!SlyMessageEnvelope methodsFor: 'printing' stamp: 'ssa 5/28/2010 16:17'!
printOn: aStream

	aStream nextPutAll:'MsgEnv|rcvr:',self receiver printString,'|message: ',self message printString! !

!SlyMessageEnvelope class methodsFor: 'instance creation' stamp: 'dmu 9/1/2010 15:32'!
argumentCount: n

	^self new
		message: (Message selector: #none arguments: (Array new: n));
		yourself! !

!SlyMessageEnvelope class methodsFor: 'instance creation' stamp: 'ssa 5/27/2010 10:46'!
receiver: anObject selector: aSymbol arguments: anArray

	^self new
		receiver: anObject;
		message: (Message selector: aSymbol arguments: anArray);
		yourself! !

!SlyParticle methodsFor: 'as yet unclassified'!
homeField
	^ homeField! !

!SlyParticle methodsFor: 'as yet unclassified'!
particle: t1 ofSize: t2 movedTo: t3 
	((location dist: t3)
				<= (size + t2 // 2)
			and: [t1 ~= self])
		ifTrue: [[self collideWith: t1] fork.
			[t1 collideWith: self] fork]! !

!SlyParticleSim methodsFor: 'as yet unclassified'!
add: t1 
	particles members add: t1.
	super add: t1! !

!SlyParticleSim methodsFor: 'as yet unclassified'!
addRandom: t1 
	t1
		timesRepeat: [self
				add: (SlyParticle
						c: Color random
						s: (10 to: 30) atRandom
						l: (0 to: extent x - 1) atRandom @ (0 to: extent y - 1) atRandom
						v: (1 to: 10) atRandom @ (1 to: 10) atRandom)]! !

!SlyParticleSim methodsFor: 'as yet unclassified' stamp: 'max 9/29/2010 14:33'!
clear
	particles := OrderedCollection  new asEnsembleOfElements.
	super clear! !

!SlyParticleSim methodsFor: 'as yet unclassified'!
go
	running := true.
	[[running]
		whileTrue: [self refresh.
			(Delay forMilliseconds: 50) wait].
	nil] fork.
	particles go! !

!SlyParticleSim methodsFor: 'as yet unclassified'!
particles
	^ particles! !

!SlyParticleSim methodsFor: 'as yet unclassified'!
refresh
	blankForm displayOn: form.
	particles displayOn: form.
	canvas displayView! !

!SlyParticleSim methodsFor: 'as yet unclassified' stamp: 'max 9/29/2010 14:31'!
setExtent: t1 fields: t2 
	| t3 |
	particles := OrderedCollection new asEnsembleOfElements.
	running := false.
	extent := t1.
	t3 := t1 // t2.
	form := Form extent: t1 depth: 8.
	fields := Matrix rows: t2 x columns: t2 y.
	fields
		indicesDo: [:t4 :t5 | fields
				at: t4
				at: t5
				put: (SlyField origin: t4 @ t5 - (1 @ 1) * t3 extent: t3)].
	fields
		indicesDo: [:t4 :t5 | (fields at: t4 at: t5)
				setNeighborN: (fields
						at: t4
						at: t5 - 1
						ifInvalid: nil);
				
				setNeighborNE: (fields
						at: t4 + 1
						at: t5 - 1
						ifInvalid: nil);
				
				setNeighborNW: (fields
						at: t4 - 1
						at: t5 - 1
						ifInvalid: nil);
				
				setNeighborS: (fields
						at: t4
						at: t5 + 1
						ifInvalid: nil);
				
				setNeighborSE: (fields
						at: t4 + 1
						at: t5 + 1
						ifInvalid: nil);
				
				setNeighborSW: (fields
						at: t4 - 1
						at: t5 + 1
						ifInvalid: nil);
				
				setNeighborE: (fields
						at: t4 + 1
						at: t5
						ifInvalid: nil);
				
				setNeighborW: (fields
						at: t4 - 1
						at: t5
						ifInvalid: nil);
				 setSimulation: self].
	self makeBlankForm! !

!SlyParticleSim methodsFor: 'as yet unclassified'!
step
	particles step.
	self refresh! !

!SlyParticleSim methodsFor: 'as yet unclassified'!
stop
	running := false.
	particles stop! !

!SlySamBoid methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 15:42'!
computeCentroid
["buttonize next two lines for a trigger setting button"
"Click To Set Trigger"
"  ONEHALT _ true"     
].

"ONEHALT ifTrue:[ONEHALT _ false. self halt]."

	"^500@500"
	"^ self flock boids  positionING: #averaging"
	^ self flock boids  positionLY: #serially ING: #averaging
	"^ (self flock boids ENSmembers collect: [:m| m position]) average"! !

!SlySamBoid methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 15:43'!
computeNeighbors
	"^self flock boids yourselfLY:{ #selectively:. [:b| b isNear: self]}"

	^self flock boids ING:[:members| members select:[:m| m isNear: self]]! !

!SlySamBoid methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 15:44'!
moveTowardCentroidOfAllOthers: centroid
	| perceivedCentroid s |
	s _ self flock boids ENSsize.
	s < 2 ifTrue: [^ 0@0].
	perceivedCentroid _ (centroid * s - self position) / (s - 1).
	^ (perceivedCentroid - self position) / 100.0! !

!SlySamBoids methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 15:52'!
boidClass
	^ SlySamBoid! !

!SlySamBoids methodsFor: 'as yet unclassified' stamp: 'dmu 8/23/2010 15:46'!
flockSize
	^ 10! !

!SlySelectorModifier class methodsFor: 'basic modifiers' stamp: 'dmu 8/27/2010 13:30'!
adverb ^ 'LY'! !

!SlySelectorModifier class methodsFor: 'basic modifiers' stamp: 'dmu 8/27/2010 13:30'!
asAWhole ^ 'ENS'! !

!SlySelectorModifier class methodsFor: 'extended modifiers' stamp: 'dmu 8/27/2010 13:35'!
adverbColon 
	^ self adverb, ':'! !

!SlySelectorModifier class methodsFor: 'extended modifiers' stamp: 'dmu 8/27/2010 13:35'!
gerundColon 
	^ self gerund, ':'! !

!SlySelectorModifier class methodsFor: 'sizes' stamp: 'dmu 8/27/2010 13:35'!
adverbColonSize
	^ self adverbColon size! !

!SlySelectorModifier class methodsFor: 'sizes' stamp: 'dmu 8/27/2010 13:44'!
adverbSize
	^ self adverb size! !

!SlySelectorModifier class methodsFor: 'sizes' stamp: 'dmu 8/27/2010 13:40'!
asAWholeSize
	^ self asAWhole size! !

!SlySelectorModifier class methodsFor: 'sizes' stamp: 'dmu 8/27/2010 14:17'!
gerundColonSize
	^ self gerundColon size! !

!SlySelectorModifier class methodsFor: 'commonly modified selectors' stamp: 'dmu 8/29/2010 18:36'!
asAWholeify: selector
	(selector beginsWith: self asAWhole) ifTrue: [^ self].
	^ (self asAWhole, selector) asSymbol! !

!SlySelectorModifier class methodsFor: 'commonly modified selectors' stamp: 'dmu 8/27/2010 13:52'!
sizeAsAWhole
	^ self asAWholeify: #size! !

!SlySelectorModifier class methodsFor: 'accessing' stamp: 'dmu 8/27/2010 13:30'!
gerund ^ 'ING'! !

!SlySelectorModifier class methodsFor: 'special selectors' stamp: 'dmu 8/27/2010 13:59'!
equalsAsAWhole
	^ ( self asAWhole, 'equals:' ) asSymbol! !

!SlySelectorModifier class methodsFor: 'special selectors' stamp: 'dmu 8/27/2010 13:56'!
members
	^ #members! !

!SlySelectorModifier class methodsFor: 'testing' stamp: 'dmu 8/30/2010 10:01'!
isSlySelector: aSelector
	"True if its has SlySelectorModifers"
	^ {self asAWhole. self adverb. self gerundColon} anySatisfy: [:ss | aSelector includesSubString: ss]! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:51'!
adverbKeywordTest
	"SlySyntaxTests adverbKeywordTest run"
	"SlySyntaxTests runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{{1. 2}. {3. 4}. {5. 6}}.
			self halt.
			result _ ens comma: {9. 10} LY:#wholly.
			test assert:  result ENSmembers asArray  = #(#(1 2 9 10) #(3 4 9 10) #(5 6 9 10))
				 ifFail:[test log:' failed: %{{1. 2}. {3. 4}. {5. 6}} comma: {9. 10} LY:#wholly ==> ', result ENSmembers asArray printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'adverbKeywordTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:51'!
adverbUnaryTest
	"self adverbUnaryTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens oddLY:#randomly.
			test assert:  (result ENSmembers size = 1) & (result ENSmembers first isBoolean)
				 ifFail:[test log:' failed: %{1. 2. 3} oddLY:#randomly ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'adverbUnaryTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:51'!
argAdverbRoundlyTest
	"self argAdverbRoundlyTest run"
	"self runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens plus: #(4 5 6 7 8 9) LY:#roundly.
			test assert:  result ENSmembers asArray = #(5 7 9 8 10 12)
				 ifFail:[test log:' failed: %{1. 2. 3} plus: #(4 5 6 7 8 9) LY:#roundly ==> ', result ENSmembers asArray printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'argAdverbRoundlyTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
argAdverbWhollyTest
	"self argAdverbWhollyTest run"
	"self runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{{1. 2}. {3. 4}. {5. 6}}.
			result _ ens comma: {9. 10} LY:#wholly.
			test assert:  result ENSmembers asArray  = #(#(1 2 9 10) #(3 4 9 10) #(5 6 9 10))
				 ifFail:[test log:' failed: %{{1. 2}. {3. 4}. {5. 6}} comma: {9. 10} LY:#wholly ==> ', result ENSmembers asArray printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'argAdverbWhollyTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
ensMembersTest
	"SlySyntaxTests ensMembersTest run"
	"SlySyntaxTests runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{{1. 2}. {3. 4}. {5. 6}}.
			result _ ens ENSmembers.
			test assert:  result = {{1. 2}. {3. 4}. {5. 6}}
				 ifFail:[test log:' failed: %{{1. 2}. {3. 4}. {5. 6}} ENSmembers ==> ', result ENSmembers size printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'ensMembersTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
ensPrintStringTest
	"SlySyntaxTests ensPrintStringTest run"
	"SlySyntaxTests runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens ENSprintString.
			test assert:  result = '%{1. 2. 3. }'
				 ifFail:[test log:' failed: %{1. 2. 3} ENSprintString ==> ', result ENSmembers size printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'ensPrintStringTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
ensSizeTest
	"SlySyntaxTests ensSizeTest run"
	"SlySyntaxTests runAll" 
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{{1. 2}. {3. 4}. {5. 6}}.
			result _ ens ENSsize.
			test assert:  result = 3
				 ifFail:[test log:' failed: %{{1. 2}. {3. 4}. {5. 6}} ENSsize ==> ', result ENSmembers size printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'ensSizeTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
gerundAndingTest
	"self gerundAndingTest run"
	"self runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens oddING: #anding.
			test assert:  result = false
				 ifFail:[test log:' failed: %{1. 2. 3} oddING: #anding ==> ', result  printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundAndingTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
gerundDoubleKeywordTest
	"self gerundDoubleKeywordTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{#(1). #(2)}.
			result _ ens at: 1 put: 4 ING:#totalling.
			test assert:  result = 8
				 ifFail:[test log:' failed:  %{#(1). #(2)} at: 1 put: 4 ING:#totalling  ==> ', result  printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundDoubleKeywordTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
gerundOnlyAveragingTest
	"self gerundOnlyAveragingTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"] 
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens ING: #averaging.
			test assert:  result = 2
				 ifFail:[test log:' failed: %{1. 2. 3} ING: #averaging ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundOnlyAveragingTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
gerundOnlyConcatenatingTest
	"self gerundOnlyConcatenatingTest run" 
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{'hello'. ' '. 'world'}.
			result _ ens ING: #concatenating.
			test assert:  result = 'hello world'
				 ifFail:[test log:' failed: %{''hello''. '' ''. ''world''} ING:#concatenating ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundOnlyConcatenatingTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
gerundOnlyTest
	"self gerundOnlyTest run"
	"self runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens ING: #totalling.
			test assert:  result = 6
				 ifFail:[test log:' failed: %{1. 2. 3} ING: #totalling ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundOnlyTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
gerundOnlyTotallingTest
	"self gerundOnlyTotallingTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens ING: #totalling.
			test assert:  result = 6
				 ifFail:[test log:' failed: %{1. 2. 3} ING: #totalling ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundOnlyTotallingTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
gerundOringTest
	"self gerundOringTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"] 
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens oddING: #oring.
			test assert:  result = true
				 ifFail:[test log:' failed: %{1. 2. 3} oddING: #oring ==> ', result  printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundOringTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
gerundSingleKeywordTest
	"self gerundSingleKeywordTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"] 
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens plus: 1 ING:#totalling.
			test assert:  result = 9
				 ifFail:[test log:' failed: %{1. 2. 3} plus: 1 ING:#totalling ==> ', result  printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundSingleKeywordTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
gerundTripleKeywordTest
	"self gerundTripleKeywordTest run"
	"self runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{#(1). #(2)}.
			result _ ens changed:#foo with:#bar from:self ING:#concatenating.
			test assert:  result  = #( 1 2)
				 ifFail:[test log:' failed: %{#(1). #(2)} changed:#foo with:#bar from:self ING:#concatenating  ==> ', result  printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundTripleKeywordTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
gerundUnaryTest
	"self gerundUnaryTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"] 
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens oddING: #anding.
			test assert:  result = false
				 ifFail:[test log:' failed: %{1. 2. 3} oddING: #anding ==> ', result  printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundUnaryTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
msgAdvKeywordTest
	"self msgAdvKeywordTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}. 
			result _ ens LY:#randomly plus:1.
			test assert:  (result ENSmembers size = 1)
				 ifFail:[test log:' failed: %{1. 2. 3} LY:#randomly plus:1 ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'msgAdvKeywordTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
msgAdvOnlyRandomlyTest
	"self msgAdvOnlyRandomlyTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env|  
			ens _ %{1. 2. 3}.
			result _ ens yourselfLY:#randomly.
			test assert:  (result ENSmembers size = 1)
				 ifFail:[test log:' failed: %{1. 2. 3} LY:#randomly ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'msgAdvOnlyRandomlyTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
msgAdvRandomly2Test
	"self msgAdvRandomly2Test run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"] 
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens oddLY:#(#randomly: 2).
			test assert:  (result ENSmembers size = 2)
				 ifFail:[test log:' failed: %{1. 2. 3} oddLY:#(#randomly: 2) ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'msgAdvRandomly2Test'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:52'!
msgAdvRandomlyTest
	"self msgAdvRandomlyTest run"
	"self runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens oddLY:#randomly.
			test assert:  (result ENSmembers size = 1)
				 ifFail:[test log:' failed: %{1. 2. 3} oddLY:#randomly ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'msgAdvRandomlyTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:53'!
msgAdvSelectivelyTest
	"self msgAdvSelectivelyTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env|  
			ens _ %{1. 2. 3}.
			result _ ens yourselfLY:{#selectively:. [:mbr| mbr odd]}.
			test assert:  result ENSmembers asArray = #(1 3)
				 ifFail:[test log:' failed: %{1. 2. 3} yourselfLy:{#selectively:. [:mbr| mbr odd]} ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'msgAdvSelectivelyTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:53'!
msgAdvSeriallyTest
	"self msgAdvSeriallyTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3. 4. 5. 6. 7. 8. 9}.
			result _ ens yourselfLY:#serially.
			test assert:  (result ENSmembers asArray = {1. 2. 3. 4. 5. 6. 7. 8. 9})
				 ifFail:[test log:' failed: %{1. 2. 3. 4. 5. 6. 7. 8. 9} yourselfLY:#serially ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'msgAdvSeriallyTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:53'!
normalBinaryTest
	"self normalBinaryTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"] 
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens +1.
			test assert:  result ENSmembers = {2. 3. 4}
				 ifFail:[test log:' failed: %{1. 2. 3} + 1 ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'normalBinaryTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:53'!
normalKeywordTest
	"self normalKeywordTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens plus: 1.
			test assert:  result ENSmembers = {2. 3. 4}
				 ifFail:[test log:' failed: %{1. 2. 3} plus: 1 ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'normalKeywordTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'tests' stamp: 'dmu 9/16/2010 23:53'!
normalUnaryTest
	"self normalUnaryTest run"
	"self runAll"
	| theTest ens result |
	theTest _ RVMTest  
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{1. 2. 3}.
			result _ ens odd.
			test assert:  result ENSmembers = {true. false. true}
				 ifFail:[test log:' failed: %{1. 2. 3} odd ==> ', result ENSmembers printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'normalUnaryTest'.
	^theTest! !

!SlySyntaxTests class methodsFor: 'isolated failures' stamp: 'dmu 9/16/2010 23:52'!
gerundPerformWithWithTest
	"CURRENTLY FAILS"
	"self gerundPerformWithWithTest run"
	"self runAll"
	| theTest ens result | 
	theTest _ RVMTest 
		setUp: [:test|   "no setup needed"]
		test:[:test :env| 
			ens _ %{#(1). #(2)}.
			result _ ens perform: #at:put: with: 1 with: 4 ING:#totalling.
			test assert:  result = 8
				 ifFail:[test log:' failed: %{#(1). #(2)} perform: #at:put: with: 1 with 4 ING:#totalling  ==> ', result  printString].
			]
		asserting:[:test :outcome| true "assertions will also be checked"].
	theTest name: 'gerundPerformWithWithTest'.
	^theTest! !

!SlyTransporter methodsFor: 'as yet unclassified' stamp: 'sm 4/22/2011 00:52'!
extensionInOtherPackages
	^ {
		{ 'EnsembleNode' }.
		{ 'EnsembleNode'. 'printOn:indent:' }.
		{ 'EnsembleNode'. 'sizeForValue:' }.
		{ 'EnsembleNode'. 'emitForValue:on:' }.
		{ 'Scanner class'. 'initialize' }.
	}! !

!SlyTransporter methodsFor: 'as yet unclassified' stamp: 'sm 3/11/2011 20:48'!
fiddleWithClassLoadingOrder: classes
	| classesThatNeedToGoAtTheEnd |
	"Blecch. Need to make sure the Parser changes aren't loaded until after the classes needed to support those changes.
	 And that the classes that depend on the Parser changes aren't loaded until after that. Maybe we want to split
	 stuff up into separate packages? -- Adam, Dec. 2010"
	classesThatNeedToGoAtTheEnd := {Parser. 
								Sly3UnprocessedEnsembleMessage. 
								SlySyntaxTests. 
								Sly3SyntaxTests. 
								Sly3Boids. 
								Sly3aBoids}.
	^ (classes asOrderedCollection reject: [:class | classesThatNeedToGoAtTheEnd includes: class])
		addAllLast: classesThatNeedToGoAtTheEnd;
		yourself! !

!SlyTransporter methodsFor: 'as yet unclassified' stamp: 'sm 3/11/2011 23:15'!
initialize
	self initializePackage.
	self initializePreambleAndPostscript.! !

!SlyTransporter methodsFor: 'as yet unclassified' stamp: 'sm 3/11/2011 21:24'!
initializePackage
	self package: (CompositePackageInfo new
					name: 'Sly';
					packages: {
						PackageInfo named: 'Sly'.
						PackageInfo named: 'Sly2'.
						PackageInfo named: 'Sly3'.
					};
					yourself).
! !

!SlyTransporter methodsFor: 'as yet unclassified' stamp: 'sm 4/22/2011 01:03'!
initializePreambleAndPostscript
	self
		preambleBlock: [:file | PackageWhoseContentsMustBeTransportedInOrder new
								trickyModificationsThatNeedToBeDoneInOrder: self extensionInOtherPackages;
								saveTrickyModificationsToFile: file.
								
								file cr.
								file nextChunkPut: 
'"Make sure the Scanner gets initialized"
Scanner initialize.'; cr.]! !

!SmalltalkImage methodsFor: 'image, changes names' stamp: 'ssa 9/3/2008 14:28'!
sourcesName
	"Answer the full path to the version-stable source code"
	^  SourceFileVersionString , FileDirectory dot , 'sources'! !

!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'dmu 9/7/2010 14:25'!
snapshot: save andQuit: quit embedded: embeddedFlag
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	| resuming msg |

	"Save a copy of the image file before you save the new one"
	save ifTrue:[(FileDirectory default fileExists:    SmalltalkImage current imageName  ) ifTrue:[FileDirectory default 
	rename: SmalltalkImage current imageName 
		toBe: SmalltalkImage current imageName , '.prev',Time now hhmm24]].

	Object flushDependents.
	Object flushEvents.

	(SourceFiles at: 2) ifNotNil:[
		msg _ String streamContents: [ :s |
			s nextPutAll: '----';
			nextPutAll: (save ifTrue: [ quit ifTrue: [ 'QUIT' ] ifFalse: [ 'SNAPSHOT' ] ]
							ifFalse: [quit ifTrue: [ 'QUIT/NOSAVE' ] ifFalse: [ 'NOP' ]]);
			nextPutAll: '----';
			print: Date dateAndTimeNow; space;
			nextPutAll: (FileDirectory default localNameFor: self imageName);
			nextPutAll: ' priorSource: ';
			print: LastQuitLogPosition ].
		self assureStartupStampLogged.
		save ifTrue: [ LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position ].
		self logChange: msg.
		Transcript cr; show: msg
	].

	Smalltalk processShutDownList: quit.
	Cursor write show.
	save ifTrue: [resuming _ embeddedFlag 
					ifTrue: [self snapshotEmbeddedPrimitive] 
					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"
				resuming == false "guard against failure" ifTrue:
					["Time to reclaim segment files is immediately after a save"
					Smalltalk at: #ImageSegment
						ifPresent: [:theClass | theClass reclaimObsoleteSegmentFiles]]]
		ifFalse: [resuming _ false].
	quit & (resuming == false) ifTrue: [self quitPrimitive].
	Cursor normal show.
	Smalltalk setGCParameters.
	resuming == true ifTrue: [Smalltalk clearExternalObjects].
	Smalltalk processStartUpList: resuming == true.
	resuming == true ifTrue:[
		self setPlatformPreferences.
		self readDocumentFile].
	"Now it's time to raise an error"
	resuming == nil ifTrue: [self error:'Failed to write image file (disk full?)'].
	^ resuming! !

!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'dmu 9/7/2010 14:25'!
assureStartupStampLogged
	"If there is a startup stamp not yet actually logged to disk, do it now."
	| changesFile |
	StartupStamp ifNil: [^ self].
	(SourceFiles isNil or: [(changesFile _ SourceFiles at: 2) == nil]) ifTrue: [^ self].
	changesFile isReadOnly ifTrue:[^self].
	changesFile safelyDo: [
		changesFile setToEnd; cr; cr.
		changesFile nextChunkPut: StartupStamp asString; cr.
		StartupStamp _ nil.
		self forceChangesToDisk.
	]! !

!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'ssa 9/3/2008 11:25'!
forceChangesToDisk
	"Ensure that the changes file has been fully written to disk by closing and re-opening it. This makes the system more robust in the face of a power failure or hard-reboot."

	| changesFile |
	changesFile _ SourceFiles at: 2.
	(changesFile isKindOf: FileStream) ifTrue: [
		changesFile flush.
		true ifTrue:[
			changesFile close.
			changesFile open: changesFile name forWrite: true].
		changesFile setToEnd.
	].
! !

!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'dmu 9/7/2010 14:25'!
logChange: aStringOrText 
	"Write the argument, aString, onto the changes file."
	| aString changesFile |
	(SourceFiles isNil or: [(SourceFiles at: 2) == nil]) ifTrue: [^ self].
	self assureStartupStampLogged.

	aStringOrText isText
		ifTrue: [aString _ aStringOrText string]
		ifFalse: [aString _ aStringOrText].
	(aString isKindOf: String)
		ifFalse: [self error: 'can''t log this change'].
	(aString findFirst: [:char | char isSeparator not]) = 0
		ifTrue: [^ self].  "null doits confuse replay"
	(changesFile _ SourceFiles at: 2).
	changesFile isReadOnly ifTrue:[^self].
	changesFile safelyDo: [
		changesFile setToEnd; cr; cr.
		changesFile nextChunkPut: aString.
			"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"
		self forceChangesToDisk.
	]! !

!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'ads 1/12/2011 16:40'!
saveAs: newName
	"Save the image  under the new name."

	(SourceFiles at: 2) ifNotNil:
		[self closeSourceFiles; "so copying the changes file will always work"
			 saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].
	self saveImageInFileNamed: (self fullNameForImageNamed: newName)! !

!StandardFileMenu methodsFor: 'private'!
oldFileFrom: aDirectory withPattern: aPattern

	canTypeFileName _ false.
	pattern _ aPattern.
	^self makeFileMenuFor: aDirectory! !

!StandardFileMenu class methodsFor: 'instance creation' stamp: 'ssa 10/18/2008 22:56'!
oldFileMenu: aDirectory withPattern: aPattern

	Smalltalk isMorphic ifFalse: [^PluggableFileList oldFileMenu: aDirectory withPattern: aPattern].
	^super new oldFileFrom: aDirectory withPattern: aPattern! !

!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'ssa 10/18/2008 23:01'!
oldFileFrom: aDirectory withPattern: aPattern

	^(self oldFileMenu: aDirectory withPattern: aPattern)
		startUpWithCaption: 'Select a File:' translated! !

!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'ssa 10/18/2008 23:12'!
oldFileStreamFrom: aDirectory  withPattern: aPattern

	| sfmResult fileStream |
	sfmResult _ self oldFileFrom: aDirectory  withPattern: aPattern. 
	sfmResult ifNil: [^nil].
	fileStream _ sfmResult directory oldFileNamed: sfmResult name.
	[fileStream isNil] whileTrue:
		[sfmResult _ self oldFileFrom: aDirectory.
		sfmResult ifNil: [^nil].
		fileStream _ sfmResult directory oldFileNamed: sfmResult name].
	^fileStream
! !

!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'ssa 10/18/2008 23:12'!
oldFileStreamWithPattern: aPattern

	^self oldFileStreamFrom: (FileDirectory default) withPattern: aPattern
! !

!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'ssa 10/18/2008 22:54'!
oldFileWithPattern: aPattern

	^self oldFileFrom: (FileDirectory default) withPattern: aPattern! !

!StandardFileStream methodsFor: 'read, write, position' stamp: 'ssa 10/26/2008 23:47'!
nextPut: char
	"Write the given character to this file."

	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].
	buffer1 byteAt: 1 put: char.
	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.
	^ char
! !

!StandardFileStream methodsFor: '*RVMBootstrap' stamp: 'dmu 9/7/2010 14:07'!
interlock
	interlock ifNil: [self interlock: Semaphore forMutualExclusion].
	^ interlock! !

!StandardFileStream methodsFor: '*RVMBootstrap' stamp: 'dmu 9/7/2010 14:07'!
interlock: aSemaphore
	interlock _ aSemaphore! !

!StandardFileStream methodsFor: '*RVMBootstrap' stamp: 'dmu 9/7/2010 14:14'!
resetInterlock
	self interlock signal.
	self interlock: nil! !

!StandardFileStream methodsFor: '*RVMBootstrap' stamp: 'dmu 9/7/2010 14:09'!
safelyDo: aBlock
	^ self interlock critical: aBlock! !

!StandardFileStream class methodsFor: '*RVMBootstrap' stamp: 'dmu 9/7/2010 14:14'!
resetAllInterlocks
	"self resetAllInterlocks"
	self allSubInstancesDo: [:sfs| sfs resetInterlock]! !

!StandardSourceFileArray class methodsFor: 'initialize-release' stamp: 'dmu 9/7/2010 14:12'!
install
	"Replace SourceFiles by an instance of me with the standard sources and changes files.
	This only works if SourceFiles is either an Array or an instance of this class"
	"StandardSourceFileArray install"
	StandardFileStream resetAllInterlocks.
	SourceFiles _ self new initialize! !

!StandardSystemController methodsFor: 'accessing' stamp: 'ssa 3/9/2010 12:56'!
preventClosing
	"Answer the value of preventClosing"

	preventClosing isNil ifTrue:[self preventClosing: false].
	^ preventClosing! !

!StandardSystemController methodsFor: 'accessing' stamp: 'ssa 3/9/2010 12:25'!
preventClosing: anObject
	"Set the value of preventClosing"

	preventClosing _ anObject! !

!StandardSystemController methodsFor: 'accessing' stamp: 'ssa 3/9/2010 12:25'!
status
	"Answer the value of status"

	status isNil ifTrue:[self status: nil].
	^ status! !

!StandardSystemController methodsFor: 'borders'!
adjustWindowCorners 
        | box cornerBox p clicked f2 |
        box _ view windowBox.
        clicked _ false.
        #(topLeft topRight bottomRight bottomLeft)
                do: [:readCorner |
                        cornerBox _ ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.
                        (cornerBox containsPoint: sensor cursorPoint)
                                ifTrue: 
                                ["Display reverse: cornerBox."
                                (Cursor perform: readCorner) showWhile:
                                        [[(cornerBox containsPoint: (p _ sensor cursorPoint))
                                                and: [(clicked _ sensor anyButtonPressed) not]]
                                                whileTrue.
                                "Display reverse: cornerBox."
                                clicked ifTrue:
                                        [view newFrame:
                                                [:f | p _ sensor cursorPoint.
                                                readCorner = #topLeft ifTrue:
                                                        [f2 _ p corner: f bottomRight].
                                                readCorner = #bottomLeft ifTrue:
                                                        [f2 _ (f withBottom: p y) withLeft: p x].
                                                readCorner = #bottomRight ifTrue:
                                                        [f2 _ f topLeft corner: p].
                                                readCorner = #topRight ifTrue:
                                                        [f2 _ (f withTop: p y) withRight: p x].
                                                f2]]]]].
        ^ clicked! !

!StandardSystemController methodsFor: 'borders'!
checkForReframe
        "2/18/97 ssa - added a leftshift hack to prevent over aggressive offerings of reframing help for subpanes."

        | cp |
        view isCollapsed ifTrue: [^ self].
        cp _ sensor cursorPoint.
        ((view closeBoxFrame expandBy: 2) containsPoint: cp)
                | ((view growBoxFrame expandBy: 2) containsPoint: cp)
                ifTrue: [^ self].  "Dont let reframe interfere with close/grow"
        self adjustWindowCorners.
        self cursorOnBorder ifFalse: [^ self].
        ((view insetDisplayBox insetBy: 2@2) containsPoint: cp)
                ifFalse: [^ self adjustWindowBorders].

        Sensor leftShiftDown 
                ifTrue:[        
                        (view subviewWithLongestSide: [:s | ] near: cp) == nil
                                ifFalse: [^ self adjustPaneBorders]].! !

!StandardSystemController methodsFor: 'control defaults' stamp: 'ssa 3/9/2010 12:58'!
blueButtonActivity
	self blueButtonMenu invokeOn: self! !

!StandardSystemController methodsFor: 'control defaults' stamp: 'dmu 5/3/2009 12:12'!
isClosed
	^ status == #closed! !

!StandardSystemController methodsFor: 'control defaults' stamp: 'ssa 3/12/2010 09:50'!
redButtonActivity
	"If cursor is in label of a window when red button is pushed,
	check for closeBox or growBox, else drag the window frame
	or edit the label."

	| box p |
	p _ sensor cursorPoint.
	self labelHasCursor ifFalse: [super redButtonActivity. ^ self].
	((box _ view closeBoxFrame) containsPoint: p)
		ifTrue:
			[Utilities
				awaitMouseUpIn: box
				repeating: []
				ifSucceed: [Sensor shiftPressed ifFalse:[self close.  ^ self]ifTrue:[^self togglePreventClosing]].
			^ self].
	((box _ view growBoxFrame) containsPoint: p)
		ifTrue:
			[Utilities
				awaitMouseUpIn: box
				repeating: []
				ifSucceed:
					[Sensor controlKeyPressed ifTrue: [^ self expand; fullScreen].
					^ view isCollapsed
						ifTrue: [self expand]
						ifFalse: [self collapse]].
			^ self].
	(((box _ view labelTextRegion expandBy: 1) containsPoint: p)
			and: [Preferences clickOnLabelToEdit or: [sensor leftShiftDown]])
		ifTrue:
			[Utilities
				awaitMouseUpIn: box
				repeating: []
				ifSucceed: [^ self label].
			^ self].
	self move! !

!StandardSystemController methodsFor: 'menu messages' stamp: 'ssa 3/24/2010 16:12'!
close
	"The receiver's view should be removed from the screen and from the 
	collection of scheduled views."

	self preventClosing ifTrue:[^self].
	model okToChange ifFalse: [^self].
	self closeForReal! !

!StandardSystemController methodsFor: 'menu messages' stamp: 'ssa 3/12/2010 09:47'!
closeForReal
	"The receiver's view should be removed from the screen and from the 
	collection of scheduled views."

	status _ #closed.
	view erase! !

!StandardSystemController methodsFor: 'menu messages' stamp: 'ssa 3/9/2010 13:00'!
togglePreventClosing
	
	self preventClosing: self preventClosing not.
	self view emphasizeLabel.! !

!StandardSystemController methodsFor: 'pluggable menus' stamp: 'ssa 3/12/2010 09:46'!
blueButtonMenu

	^SelectionMenu
		labels:
'edit label
choose color...
two-tone/full color
move
frame
full screen
collapse
', (self preventClosing ifTrue:['enable closing']ifFalse:['disable closing
close'])
	lines: #(3 7)
	selections: #(label chooseColor toggleTwoTone move reframe fullScreen collapse togglePreventClosing close).
! !

!StandardSystemController methodsFor: 'scheduling' stamp: 'ssa 3/3/2010 13:57'!
closeAndUnscheduleIfOkWithModel
	"Erase the receiver's view and remove it from the collection of scheduled 
	views. IF its ok with my model.  This catches unsaved changes"

	model okToChange ifFalse: [^self].
	self closeAndUnschedule! !

!StandardSystemController methodsFor: 'scheduling' stamp: 'ssa 3/10/2010 10:07'!
closeAndUnscheduleIfOkWithModelNoTerminate
	"Erase the receiver's view and remove it from the collection of scheduled 
	views. IF its ok with my model.  This catches unsaved changes"

	model okToChange ifFalse: [^self].
	self closeAndUnscheduleNoTerminate! !

!StandardSystemView methodsFor: 'displaying' stamp: 'ssa 8/24/2009 07:49'!
cacheBitsAsTwoTone
	^ false! !

!StandardSystemView methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:42'!
deEmphasizeLabel
	"Un-Highlight the label."
	labelFrame height = 0 ifTrue: [^ self].  "no label"
	self critical: [
		self displayLabelBackground: false.
		self displayClosingGuardBoxIfNeeded.
		self displayLabelText.
	]! !

!StandardSystemView methodsFor: 'displaying' stamp: 'ssa 3/9/2010 12:52'!
displayClosingGuardBoxIfNeeded
	"display closing guard active, if true"
	
	| aRect |
	self controller preventClosing ifTrue:[
		aRect _ self closeBoxFrame.
		self closingGuardIcon displayOn: Display at: aRect origin clippingBox: aRect rule: Form over fillColor: nil].
! !

!StandardSystemView methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:30'!
displayDeEmphasized 
	"Display this view with emphasis off.
	If windowBits is not nil, then simply BLT if possible,
		but force full display for top window so color is preserved."
	self  critical: [
		(bitsValid and: [controller ~~ ScheduledControllers activeController])
			ifTrue: [self lock.
					windowBits displayAt: self windowOrigin]
			ifFalse: [Display deferUpdates: true.
					super display.
					Display deferUpdates: false; forceToScreen: self windowBox.
					CacheBits ifTrue: [self cacheBitsAsIs]]
	]
! !

!StandardSystemView methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:31'!
displayEmphasized
	"Display with label highlighted to indicate that it is active."
	self  critical: [
		self displayDeEmphasized; emphasize.
		isLabelComplemented _ true
	]! !

!StandardSystemView methodsFor: 'displaying' stamp: 'ssa 3/9/2010 12:52'!
displayLabelBackground: emphasized
	"Clear or emphasize the inner region of the label"
	| r1 r2 r3 c3 c2 c1 |
	emphasized ifFalse:
		["Just clear the label if not emphasized"
		Display fill: (self labelDisplayBox insetBy: 2) fillColor: self labelColor.
		^self displayClosingGuardBoxIfNeeded].
	r1 _ self labelDisplayBox insetBy: 2.
	r2 _ r1 insetBy: 0@2.
	r3 _ r2 insetBy: 0@3.
	c3 _ self labelColor.
	c2 _ c3 dansDarker.
	c1 _ c2 dansDarker.
	Display fill: r1 fillColor: c1.
	Display fill: r2 fillColor: c2.
	Display fill: r3 fillColor: c3.
 
"	Here is the Mac racing stripe code
	stripes _ Bitmap with: (self labelColor pixelWordForDepth: Display depth)
					with: (Form black pixelWordForDepth: Display depth).
	self windowOrigin y even ifTrue: [stripes swap: 1 with: 2].
	Display fill: (self labelDisplayBox insetBy: 3) fillColor: stripes.
"! !

!StandardSystemView methodsFor: 'displaying' stamp: 'ssa 3/9/2010 12:52'!
displayLabelBoxes
	"closeBox,closingGuard box growBox."
	| aRect smallRect backColor |
	aRect _ self closeBoxFrame.
	backColor _ self labelColor.
	Display fill: (aRect insetBy: -2) fillColor: backColor.
	Display fillBlack: aRect.
	Display fill: (aRect insetBy: 1) fillColor: backColor.

	"display closing guard active, if true"
	self displayClosingGuardBoxIfNeeded.
	
	aRect _ self growBoxFrame.
	smallRect _ aRect origin extent: 7@7.
	Display fill: (aRect insetBy: -2) fillColor: backColor.
	aRect _ aRect insetOriginBy: 2@2 cornerBy: 0@0.
	Display fillBlack: aRect.
	Display fill: (aRect insetBy: 1) fillColor: backColor.
	Display fillBlack: smallRect.
	Display fill: (smallRect insetBy: 1) fillColor: backColor! !

!StandardSystemView methodsFor: 'displaying' stamp: 'ssa 3/9/2010 15:41'!
displayView
	"Refer to the comment in View|displayView. "
	labelFrame height = 0 ifTrue: [^ self].  "no label"
	self displayBox width = labelFrame width ifFalse:
		["recompute label width when window changes size"
		self setLabelRegion].
	(labelFrame align: labelFrame topLeft with: self windowOrigin)
		insideColor: self labelColor;
		displayOn: Display.
	self displayClosingGuardBoxIfNeeded.
	self displayLabelText! !

!StandardSystemView methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:42'!
emphasizeLabel
	"Highlight the label."
	labelFrame height = 0 ifTrue: [^ self].  "no label"
	self critical: [
		self displayLabelBackground: true.
		self displayLabelBoxes.
		self displayLabelText.
	]! !

!StandardSystemView methodsFor: 'framing' stamp: 'ssa 1/1/1970 00:05'!
initialFrame
        "Find a plausible initial screen area for the receiver, taking into account user preference, the size needed, and other windows currently on the screen.  5/22/96 sw: let RealEstateAgent do it for us"

       | rect |
rect _ Rectangle originFromUser: self initialExtent + (0@self labelHeight).
^rect origin + (0@ self labelHeight) extent: self initialExtent
"RealEstateAgent initialFrameFor: self world: nil"! !

!StandardSystemView methodsFor: 'label access' stamp: 'ssa 3/9/2010 12:49'!
closingGuardIcon

^(ColorForm
	extent: 11@11
	depth: 1
	fromArray: #( 0 520093696 1065353216 830472192 830472192 2143289344 2143289344 2143289344 2143289344 2143289344 0)
	offset: 0@0)
	colorsFromArray: #(#(1.0 1.0 1.0)#(0.0 0.0 0.0)   )! !

!StandardSystemView methodsFor: 'label access'!
labelColor
	"Answer the color to use as the background for the receiver's label.  By default, this is the same as the background color of the window, but need not be.  7/16/96 sw"

	^ self backgroundColor! !

!StandardSystemView methodsFor: 'updating' stamp: 'ssa 8/21/2009 12:58'!
setUpdatablePanesFrom: getSelectors
	| aList aPane |
	"Set my updatablePanes inst var to the list of panes which are list panes with the given get-list selectors.  Order is important here!!  Note that the method is robust in the face of panes not found, but a warning is printed in the transcript in each such case"

	aList _ OrderedCollection new.
	getSelectors do:
		[:sel | aPane _ self subViewSatisfying:
				[:pane | ((pane isKindOf: PluggableListView) or:[pane isKindOf: MSWScrollBarView]) and: [pane getListSelector == sel]].
			aPane
				ifNotNil:
					[aList add: aPane]
				ifNil:
					[Transcript cr; show: 'Warning: view ', sel, ' not found.']].
	updatablePanes _ aList asArray! !

!StandardSystemView methodsFor: '*Sly3Bootstrap' stamp: 'dmu 9/17/2010 12:37'!
critical: aBlock
	^self displayInterlock critical: aBlock! !

!StandardSystemView methodsFor: '*Sly3Bootstrap' stamp: 'dmu 9/17/2010 12:37'!
displayInterlock
	displayInterlock ifNil: [self displayInterlock: Mutex new].
	^ displayInterlock! !

!StandardSystemView methodsFor: '*Sly3Bootstrap' stamp: 'dmu 9/17/2010 12:24'!
displayInterlock: aSemaphore
	displayInterlock _ aSemaphore! !

!StandardSystemView methodsFor: '*Sly3Bootstrap' stamp: 'dmu 9/17/2010 12:47'!
resetDisplayInterlock
	self displayInterlock: nil! !

!StandardSystemView class methodsFor: 'instance creation' stamp: 'ssa 8/15/2008 17:42'!
model: aModel label: aString minimumSize: aPoint

	^self new
		model: aModel;
		label: aString;
		minimumSize: aPoint;
		yourself! !

!StandardSystemView class methodsFor: 'instance creation' stamp: 'ssa 3/24/2010 15:17'!
new
        "This is a rather dirty hack -- but we don't have a window builder
yet. (ar 1/22/98 23:36)"

        ^Preferences nicerSystemViews
                ifTrue:[MSWSystemView basicNew initialize]
                ifFalse:[self basicNew initialize]! !

!StartupBench methodsFor: 'as yet unclassified' stamp: 'StefanMarr 1/16/2011 19:55'!
runBench
	RVMOperations print: 'This Benchmark is not to be used with the harness, but requiries time measurment to be done outside of the VM. Use it directly, it works like the Harness and implements class>>#run:'.
	self notYetImplemented.  ! !

!StartupBench class methodsFor: 'script entry' stamp: 'SM 9/13/2009 15:22'!
run: args
	"Instantly quit the VM after Startup, this will measure only the time to initalize
	  the image and start its execution. This includes the time spend on object distribution"

	SmalltalkImage current snapshot: false andQuit: true! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
ascent: anObject
	"Set the value of ascent"

	ascent _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
characterToGlyphMap: anObject
	"Set the value of characterToGlyphMap"

	characterToGlyphMap _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
derivativeFonts
	"Answer the value of derivativeFonts"

	derivativeFonts isNil ifTrue:[self derivativeFonts: nil].
	^ derivativeFonts! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
derivativeFonts: anObject
	"Set the value of derivativeFonts"

	derivativeFonts _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
descent: anObject
	"Set the value of descent"

	descent _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
emphasis
	"Answer the value of emphasis"

	emphasis isNil ifTrue:[self emphasis: nil].
	^ emphasis! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
glyphs: anObject
	"Set the value of glyphs"

	glyphs _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
maxAscii: anObject
	"Set the value of maxAscii"

	maxAscii _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
maxWidth: anObject
	"Set the value of maxWidth"

	maxWidth _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
minAscii: anObject
	"Set the value of minAscii"

	minAscii _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
pointSize: anObject
	"Set the value of pointSize"

	pointSize _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
raster
	"Answer the value of raster"

	raster isNil ifTrue:[self raster: nil].
	^ raster! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
raster: anObject
	"Set the value of raster"

	raster _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
strikeLength
	"Answer the value of strikeLength"

	strikeLength isNil ifTrue:[self strikeLength: nil].
	^ strikeLength! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
strikeLength: anObject
	"Set the value of strikeLength"

	strikeLength _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
subscript
	"Answer the value of subscript"

	subscript isNil ifTrue:[self subscript: nil].
	^ subscript! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
subscript: anObject
	"Set the value of subscript"

	subscript _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
superscript
	"Answer the value of superscript"

	superscript isNil ifTrue:[self superscript: nil].
	^ superscript! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
superscript: anObject
	"Set the value of superscript"

	superscript _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
type
	"Answer the value of type"

	type isNil ifTrue:[self type: nil].
	^ type! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
type: anObject
	"Set the value of type"

	type _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
xOffset
	"Answer the value of xOffset"

	xOffset isNil ifTrue:[self xOffset: nil].
	^ xOffset! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
xOffset: anObject
	"Set the value of xOffset"

	xOffset _ anObject! !

!StrikeFont methodsFor: 'accessing' stamp: 'ssa 2/15/2010 11:35'!
xTable: anObject
	"Set the value of xTable"

	xTable _ anObject! !

!StrikeFont methodsFor: '*RVM-Archiving'!
archiveOn: aStream
	"record this instance by its name. On dearchive, the name corresponding to this instance will be looked up."

	aStream
		storeObject: self;
		storeClass: self class;
		store: self name! !

!StrikeFont class methodsFor: '*RVM-Archiving'!
archiveVersion
	"This version archives only the name of the strikeFont. On dearchive, the name will be looked up and the appropriate strike font existing in that image will be returned."

	^3! !

!StrikeFont class methodsFor: '*RVM-Archiving'!
dearchive: versionNumber from: aStream

	| aString sf |
	versionNumber = self archiveVersion
		ifFalse:[^super dearchiveFrom: aStream].
	aString _ aStream read: String.
	sf _ self allInstances
			detect:[:inst| inst name = aString]
			ifNone:[self error:'missing strike font for this image'].
	aStream storeObject: sf.
	^sf! !

!String methodsFor: 'converting' stamp: 'ssa 1/20/2010 10:34'!
asParagraphWithStyle: aTextStyle
	"Answer a Paragraph whose text string is the receiver."

	^Paragraph withText: self asText style: aTextStyle! !

!String methodsFor: 'converting' stamp: 'ssa 9/7/2009 09:29'!
asSmalltalkObject

	^Compiler evaluate: self! !

!String methodsFor: 'converting' stamp: 'ssa 7/7/2010 20:26'!
withoutFirst: n
	"Answer a string without my first n characters."
	^self size > n 
		ifFalse:['']
		ifTrue:[self copyFrom: n+1 to: self size]! !

!String methodsFor: 'converting' stamp: 'ssa 4/20/2010 15:52'!
withoutLast: n
	"Answer a string without my last n characters."
	^self size > n 
		ifFalse:['']
		ifTrue:[self copyFrom: 1 to: self size-n]! !

!String methodsFor: '*RVM-UI-Generic' stamp: 'ssa 1/21/2010 11:47'!
buttonIt
	"  'Display reverse' buttonIt  "
	"launch a button to evaluate this string"
	| topView someCode extent |
	someCode _ self.
	extent _ (someCode asText asDisplayText extent + (30@20)) max: 80@30.
	topView := RVMStandardSystemView new.
	topView noLabel.
	topView borderWidth:1.
	topView minimumSize: extent .
	topView maximumSize: extent.
	
	topView addSubView: (RVMButtonView label: someCode action:[Compiler evaluate: someCode]).
	topView controller open! !

!String methodsFor: '*packageinfo-base' stamp: 'nk 8/30/2004 09:02'!
escapeEntities
	^ self species streamContents: [:s | self do: [:c | s nextPutAll: c escapeEntities]]
! !

!String methodsFor: '*RVM-Archiving'!
archiveOn: aStream
	aStream
		storeObject: self;
		storeClass: self class;
		store: self! !

!String class methodsFor: '*RVM-Archiving-instance creation'!
dearchiveFrom: aStream

	| anObject |
	anObject _ aStream read: self.
	aStream storeObject: anObject.
	^anObject! !

!StringHolder methodsFor: 'accessing' stamp: 'tk 4/3/98 22:50'!
contentsSelection
	"Return the interval of text in the code pane to select when I set the pane's contents"

	^ 1 to: 0  "null selection"! !

!StringHolderView methodsFor: 'initialize-release' stamp: 'ssa 1/20/2010 10:35'!
initialize 
	"Refer to the comment in View|initialize."

	super initialize.
	displayContents _ '' asParagraphWithStyle: self textStyle.
	hasUnacceptedEdits _ false.
	askBeforeDiscardingEdits _ true.
! !

!StringHolderView methodsFor: 'updating'!
updateDisplayContents
        "Make the text that is displayed be the contents of the receiver's model."
        "VIVA LA JUNTA!!!!  hack this to update the scroll bar when the contents changes  - ssa 1/15/98 14:39"

        self editString: model contents.
        self displayView.
        (self superView isKindOf: MSWScrollBarView)
                ifTrue:[self superView updateElevator]! !

!StringHolderView methodsFor: 'model access' stamp: 'ssa 1/20/2010 10:43'!
editString: aString 
	"The paragraph to be displayed is created from the characters in aString."

	displayContents _ Paragraph withText: aString asText
		style: self textStyle copy
		compositionRectangle: (self insetDisplayBox insetBy: 6 @ 0)
		clippingRectangle: self insetDisplayBox
		foreColor: self foregroundColor backColor: self backgroundColor.
	(self controller isKindOf: ParagraphEditor)
		ifTrue: [controller changeParagraph: displayContents]! !

!StringHolderView methodsFor: 'accessing' stamp: 'ssa 1/20/2010 10:31'!
askBeforeDiscardingEdits
	"Answer the value of askBeforeDiscardingEdits"

	askBeforeDiscardingEdits isNil ifTrue:[self askBeforeDiscardingEdits: nil].
	^ askBeforeDiscardingEdits! !

!StringHolderView methodsFor: 'accessing' stamp: 'ssa 1/20/2010 10:48'!
changeTextStyle: aTextStyle

	self textStyle: aTextStyle.
	self displayContents setWithText: self displayContents asText style: self textStyle ! !

!StringHolderView methodsFor: 'accessing' stamp: 'ssa 1/27/2010 17:12'!
defaultTextStyle

	^TextStyle default ! !

!StringHolderView methodsFor: 'accessing' stamp: 'ssa 1/20/2010 10:31'!
displayContents: anObject
	"Set the value of displayContents"

	displayContents _ anObject! !

!StringHolderView methodsFor: 'accessing' stamp: 'ssa 1/20/2010 10:36'!
textStyle
	"Answer the value of textStyle"

	textStyle isNil ifTrue:[self textStyle: self defaultTextStyle].
	^ textStyle! !

!StringHolderView methodsFor: 'accessing' stamp: 'ssa 1/20/2010 10:31'!
textStyle: anObject
	"Set the value of textStyle"

	textStyle _ anObject! !

!StringHolderView methodsFor: '*Interface-MSWLook'!
percentPreceedingContent
        "Answer the percent of my content that not visible since it has been scrolled of the top of the screen.  ssa 12/5/97 15:37"
        | para lineIndex |
        para _ self displayContents.
        lineIndex _ para lineIndexOfTop: para visibleRectangle top.
        lineIndex = 1 ifTrue:[^0.0].
        ^lineIndex / para numberOfLines asFloat
! !

!StringHolderView methodsFor: '*Interface-MSWLook'!
totalContentHeight
        "Answer the total height of my contents. ssa 12/5/97 15:16"
        ^ self displayContents compositionRectangle height / self unitContentHeight! !

!StringHolderView methodsFor: '*Interface-MSWLook'!
unitContentHeight
        "Answer the unit height of my contents. ssa 12/5/97 15:16"
        ^ self displayContents lineGrid asFloat! !

!StringHolderView methodsFor: '*Interface-MSWLook'!
visibleContentHeight
        "Answer the total height of my contents. ssa 12/5/97 15:16"
        ^ self displayContents clippingRectangle height / self unitContentHeight! !

!StringHolderView class methodsFor: 'instance creation'!
open: aStringHolder label: aString 
        "Create a standard system view of the model, aStringHolder, as viewed by 
        an instance of me. The label of the view is aString."
        "VIVA LA JUNTA!!  Modified to use MSWScrollBarViews - ssa 12/11/97 12:00"
        | aStringHolderView topView shv |
        aStringHolderView _ self container: aStringHolder.
        topView _ StandardSystemView new.
        topView model: aStringHolderView model.
        topView addSubView: (shv _ MSWScrollBarView on: aStringHolderView ).
        shv borderWidth: 2.
        topView label: aString.
        topView minimumSize: 100 @ 50.
        topView controller open! !

!Symbol methodsFor: 'converting' stamp: 'ssa 5/11/2010 15:14'!
asKeyword

	^self last == $:
		ifTrue:[self]
		ifFalse:[(self  copyWith:$:) asSymbol]! !

!Symbol class methodsFor: 'instance creation' stamp: 'ssa 10/26/2008 08:08'!
readFrom: aStream
	"Correctly read a Symbol from aStream."
	| string | 
	aStream skipSeparators.
	^(aStream peekFor: $#)
		ifTrue: [(aStream upTo: Character space) asSymbol]
		ifFalse: 
			[string _ super readFrom: aStream.
			(aStream next: 9) = ' asSymbol'
				ifTrue: [string asSymbol]
				ifFalse: [self error: 'This ain''t no ', self class name]]! !

!SyntaxError class methodsFor: 'instance creation' stamp: 'dmu 11/25/2008 00:25'!
open: aSyntaxError
	"Answer a standard system view whose model is an instance of me."
	| topView |
	<primitive: 19> "Simulation guard"
	
	topView _ self buildMVCViewOn: aSyntaxError.
	topView controller openNoTerminateDisplayAt: Display extent // 2.
	Cursor normal show.
	Processor thisProcess suspend.
! !

!SystemDictionary methodsFor: 'memory space' stamp: 'sm 2/24/2011 16:41'!
installLowSpaceWatcher
	"Start a process to watch for low-space conditions."
	"Smalltalk installLowSpaceWatcher"

	self primSignalAtBytesLeft: 0.  "disable low-space interrupts"
	LowSpaceProcess == nil ifFalse: [LowSpaceProcess terminate].
	LowSpaceProcess _ [self lowSpaceWatcher] newProcess.
	LowSpaceProcess priority: Processor lowIOPriority.
	LowSpaceProcess name: 'LowSpaceWatcher'.
	LowSpaceProcess resume.

! !

!SystemDictionary methodsFor: 'miscellaneous' stamp: 'dmu 9/17/2010 16:39'!
handleUserInterrupt
	Preferences cmdDotEnabled ifTrue:
		[Smalltalk isMorphic
			ifTrue: []
			ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] forkAt: Processor thisProcess priority + 1]]! !

!SystemDictionary methodsFor: 'miscellaneous' stamp: 'sm 5/25/2011 20:59'!
logError: errMsg inContext: aContext onConsoleAndQuitWithSaving: doSave
	"Log the error message and a stack trace to the given file."

	| stream cnt ctx |
	
	RVMOperations print: 'Error occured in Headless mode:'.
	RVMOperations print: errMsg.
	
	stream := TextStream on: ''.
	
	"aContext printOn: stream."
	ctx := aContext.
	cnt := 0.
	[ctx notNil and: [(cnt := cnt + 1) < 40]] 
		whileTrue: [ctx printOn: stream.
					stream cr.
					ctx := ctx sender].

	RVMOperations print: stream contents.
	self snapshot: doSave andQuit: true.
	! !

!SystemDictionary methodsFor: '*Sly' stamp: 'dmu 8/23/2010 15:38'!
allClassesDoInParallel: aBlock
	"Evaluate the argument, aBlock, for each class in the system."

	(self classNames collect: [:name | self at: name]) doInParallel: aBlock! !

!SystemDictionary methodsFor: 'shrinking' stamp: 'ssa 10/8/2008 13:14'!
majorShrinkClassesToLeave

	| manual categoryNames classNames classNameSets |
	manual := #(True False ReadOnlyVariableBinding SystemOrganizer ClassOrganizer View Switch Button EndOfStream ValueHolder EventSensorConstants ChronologyConstants InstructionPrinter Color Form ColorForm DisplayMedium DisplayObject Rectangle Point  Pen OrderedCollection Array SortedCollection Dictionary Association SequenceableCollection Collection String Text DisplayText ArrayedCollection Object GIFReadWriter ImageReadWriter 
	"Benchmark BinaryChoice "  
ChangeSet ChangeSorter DualChangeSorter ChangeList Inspector BasicInspector CompiledMethodInspector DictionaryInspector OrderedCollectionInspector).
	categoryNames := "(SystemOrganization categoriesMatching:'RVM-*'), "
					(SystemOrganization categoriesMatching:'PluggableGauges*'), 
					(SystemOrganization categoriesMatching:'Tools-FileList'),
					(SystemOrganization categoriesMatching:'Tools-Browser'),
					(SystemOrganization categoriesMatching:'Kernel-ST80 Remnants'), 
					(SystemOrganization categoriesMatching:'ST80-Framework'), 
					(SystemOrganization categoriesMatching:'ST80-Support'), 
					(SystemOrganization categoriesMatching:'ST80-Pluggable Views'), 
					(SystemOrganization categoriesMatching:'ST80-Views'), 
					(SystemOrganization categoriesMatching:'ST80-Editors'), 
					(SystemOrganization categoriesMatching:'Tools-Process Browser').
	classNameSets := categoryNames collect:[:each| SystemOrganization listAtCategoryNamed: each].
	classNames := OrderedCollection new.
	classNameSets do:[:set| set do:[:n| classNames add: n]].
	^(manual, classNames) asSet asOrderedCollection! !

!SystemDictionary methodsFor: 'shrinking' stamp: 'ssa 9/3/2008 12:00'!
majorShrinkClassesToZap

	^#(BDFFontReader 
		InstanceBrowser 
		Lexicon 
		TarArchiveMember 
		CRLookupResult
	"	PluggableDictionary
		 PluggableSet "
		MimeConverter
		QuotedPrintableMimeConverter
		RFC2047MimeConverter
		AbstractLauncher
		AutoStart
		AcornFileDirectory
		 " AssertionFailure "
		CachedHTTPRequest 
		CachingCodeLoader
		CodeLoader
		CanvasEncoder
		EToyVectorVocabulary
		EToyVocabulary
        	FileList2
		FontCache
		FTPConnectionException
		FullVocabulary
		HTTPClient
		HTTPLoader
		HTTPRequest 
		HtmlFileStream
		"MacFileDirectory"
		"MacHFSPlusFileDirectory"
		PluginHTTPRequest
		SUnitNameResolver
		ScreenedVocabulary
		ScriptNameType
		SoundType
		StringType
		SymbolListType
		TestCase
		TestFailure
		TestResource
		TestResult
		TestRunner
		TestSuite
		TestCaseDebugger
		TestViaMethodCall
		TextSqkPageLink
		TextSqkProjectLink
		TextURL 
		UnknownType
		Verifier
		VerifierOfProperty
		Vocabulary
		BooleanType
		ButtonPhaseType
		ColorType
		DataType
		GraphicType
		MenuType
		NumberType
		PlayerType)! !

!SystemDictionary methodsFor: 'shrinking' stamp: 'ssa 9/3/2008 13:42'!
presumedSentMessages   | sent |
"Smalltalk presumedSentMessages"

	"The following should be preserved for doIts, etc"
	sent _ IdentitySet new.
	#( 
	"menu messages from Debugger>>contextStackMenu: aMenu shifted: shifted"
	fullStack restart proceed doStep stepIntoBlock send where peelToFirst
browseSendersOfMessages browseMessages methodHierarchy browseVersions
browseInstVarRefs browseInstVarDefs
browseClassVarRefs browseClassVariables browseClassRefs
browseMethodFull fileOutMessage 
shiftedYellowButtonActivity

	"menu messages from Preferences>>presentMvcFontConfigurationMenu"
	chooseSystemFont chooseListFont chooseMenuFont chooseWindowTitleFont chooseCodeFont restoreDefaultFonts

	"others"
	
	rehashWithoutBecome compactSymbolTable rebuildAllProjects
		browseAllSelect: printSpaceAnalysis lastRemoval
		scrollBarValue: scrollBarMenuButtonPressed: 
		withSelectionFrom:  to: removeClassNamed: instVarNamed:put:
		breakDependents
          maximumSize: redButtonMenu:redButtonMessages:
		dragon: hilberts: mandala: web test3 factorial tinyBenchmarks benchFib
		newDepth: restoreAfter: forgetDoIts zapAllMethods obsoleteClasses
		removeAllUnSentMessages abandonSources removeUnreferencedKeys
		reclaimDependents zapOrganization condenseChanges browseObsoleteReferences
		renameClassNamed:as:  " this method is used in change sets "
		subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
		variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
    " subclass creation: "
		variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
		variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
		weakSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:
		startTimerInterruptWatcher unusedClasses
		widthOfString: widthOfString:from:to: clipHeight clipHeight: 
		clipWidth clipWidth: clipX clipX: clipY clipY: 
          newDay:monthIndex:year: abandon pixelForValueAt:put:
          magnifyBy: replaceColor:withColor: dotOfSize:  "DisplayScreen> " fullBoundingBox
          originFromUser:
     " finalization "
          toFinalizeSend:to:with:
	" StrikeFont> "
		maxAscii minAscii maxWidth firstIndent:
          restIndent: rightIndent: newFontArray: fontArray:
          readStrikeFont2Family:  familySizeFace writeAsStrike2Named:
	"  Paragraph  "
		compositionRectangle: 
   " Form: these methods are meeded for gif creation "
		colorReduced colorsUsed
   " protocol from Pen class: "
		inkBrush simplePressurePen testMouseTracking testTabletTracking
   " two methods that are hidden from the method tracer "
		method: preamble:
		inspectElement
		inspectSelection inspectBasic fileOutAllChangeSets fillAggregateChangeSet
   " convenience methods in True and False: "
		and:and: and:and:and: and:and:and:and:
		or:or: or:or:or: or:or:or:or:
  " mics "
     	pairsDo: font:  notEmpty 
  " ExternalEvent class: "
		registerClient:
     ) do:
		[:sel | sent add: sel].
	"The following may be sent by perform: in dispatchOnChar..."
	(ParagraphEditor classPool at: #CmdActions) asSet do:
		[:sel | sent add: sel].
	(ParagraphEditor classPool at: #ShiftCmdActions) asSet do:
		[:sel | sent add: sel].
 Smalltalk majorShrinkClassesToLeave do:
  [:symbol | sent addAll: (Smalltalk at: symbol) selectors;
                 addAll: (Smalltalk at: symbol) class selectors.].
	^ sent! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'dmu 9/7/2010 14:26'!
snapshot: save andQuit: quit embedded: embeddedFlag
	"Mark the changes file and close all files. If save is true, save the current state of this Smalltalk in the image file. If quit is true, then exit to the outer shell. The latter part of this method runs when resuming a previously saved image. The resume logic checks for a document file to process when starting up."

	| resuming msg sourceLink |
	Object flushDependents.
	Object flushEvents.
	save & (SourceFiles at: 2) notNil ifTrue:
		[msg _  (quit
			ifTrue: ['----QUIT----']
			ifFalse: ['----SNAPSHOT----'])
			, Date dateAndTimeNow printString, ' ', (FileDirectory default localNameFor: self imageName).
		sourceLink _ ' priorSource: ' , LastQuitLogPosition printString.
		self assureStartupStampLogged.
		(SourceFiles at: 2) safelyDo: [
			LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position.
			self logChange: msg , sourceLink.
		].
		Transcript cr; show: msg].

	self processShutDownList: quit.
	Cursor write show.
	save ifTrue: [resuming _ embeddedFlag 
					ifTrue: [self snapshotEmbeddedPrimitive] 
					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"
				resuming == false "guard against failure" ifTrue:
					["Time to reclaim segment files is immediately after a save"
					Smalltalk at: #ImageSegment
						ifPresent: [:theClass | theClass reclaimObsoleteSegmentFiles]]]
		ifFalse: [resuming _ false].
	quit & (resuming == false) ifTrue: [self quitPrimitive].
	Cursor normal show.
	self setGCParameters.
	resuming == true ifTrue: [self clearExternalObjects].
	self processStartUpList: resuming == true.
	resuming == true ifTrue:[
		self setPlatformPreferences.
		self readDocumentFile].
	"Now it's time to raise an error"
	resuming == nil ifTrue: [self error:'Failed to write image file (disk full?)'].
	^ resuming! !

!SystemDictionary methodsFor: 'sources, change log' stamp: 'ssa 9/3/2008 11:25'!
forceChangesToDisk
	"Ensure that the changes file has been fully written to disk by closing and re-opening it. This makes the system more robust in the face of a power failure or hard-reboot."

	| changesFile |
	changesFile _ SourceFiles at: 2.
	(changesFile isKindOf: FileStream) ifTrue: [
		changesFile flush.
		true ifTrue:[
			changesFile close.
			changesFile open: changesFile name forWrite: true].
		changesFile setToEnd.
	].
! !

!SystemDictionary methodsFor: 'sources, change log' stamp: 'dmu 9/7/2010 14:26'!
writeRecentCharacters: nCharacters toFileNamed: aFilename
	"Schedule an editable text view on the last n characters of changes."
	| changes |
	changes _ SourceFiles at: 2.
	changes safelyDo: [
		changes setToEnd; skip: nCharacters negated.
		(FileStream newFileNamed: aFilename) nextPutAll: (changes next: nCharacters); close; open; edit
	]! !

!SystemDictionary methodsFor: 'window preferences' stamp: 'ssa 11/30/2009 17:48'!
recolorWindows
	"Smalltalk recolorWindows"
	"Let the user define the color scheme for all my windows"
	| menu choice color |
	menu _ PopUpMenu labels:'one color for all windows\standard color palette' withCRs.
	choice _ menu startUp.
	choice = 0 ifTrue:[^self].
	choice = 1 ifTrue:[color _ Color fromUser.
		Smalltalk at: #WINDOWCOLORSELECTOR put:[:obj| color]].
	choice = 2 ifTrue:[
		Smalltalk at: #WINDOWCOLORSELECTOR put:[:obj| Preferences windowColorFor: obj class name]].
	self updateAllWindowColors! !

!SystemDictionary methodsFor: 'window preferences' stamp: 'ssa 11/30/2009 17:48'!
updateAllWindowColors
	"Smalltalk updateAllWindowColors"
	
	Cursor wait showWhile:[
		View allSubInstances do:[:v| v backgroundColor: v model defaultBackgroundColor].
		ScheduledControllers unCacheWindows;restore]! !

!SystemNavigation methodsFor: '*Sly' stamp: 'dmu 8/23/2010 15:39'!
parallelAllMethodsWithSourceString: aString matchCase: caseSensitive
	"Answer a SortedCollection of all the methods that contain, in source code, aString as a substring.  Search the class comments also"
	"An experiment -- dmu"

	| list classCount adder sema |
	list _ Set new.
	sema _ Semaphore forMutualExclusion.
	adder _ [ :mrClass :mrSel | sema critical: [list add: ( MethodReference new
											setStandardClass: mrClass
											methodSymbol: mrSel)]].
'Searching all source code...'
displayProgressAt: Sensor cursorPoint
from: 0 to: Smalltalk classNames size
during:
	[:bar | classCount _ 0.
	Smalltalk allClassesDoInParallel:
		[:class | bar value: (classCount _ classCount + 1).
		(Array with: class with: class class) do:
			[:cl | 
				cl selectorsDo: [:sel | 
					((cl sourceCodeAt: sel) findString: aString 
						startingAt: 1 caseSensitive: caseSensitive) > 0 ifTrue: [
							sel == #DoIt ifFalse: [adder copy fixTemps value: cl value: sel]]].
				(cl organization classComment asString findString: aString 
						startingAt: 1 caseSensitive: caseSensitive) > 0 ifTrue: [
							adder copy fixTemps value: cl value: #Comment].
			]]].
	^ list asSortedCollection! !

!TestAsserter methodsFor: 'asserting'!
assert: aBoolean
	aBoolean ifFalse:
		[self logFailure: 'Assertion failed'.
		TestResult failure signal: 'Assertion failed'].! !

!TestAsserter methodsFor: 'asserting'!
assert: aBoolean description: aString
	aBoolean ifFalse:
		[self logFailure: aString.
		TestResult failure signal: aString].! !

!TestAsserter methodsFor: 'asserting'!
assert: aBoolean description: aString resumable: resumableBoolean
	| exception |
	aBoolean ifFalse:
		[self logFailure: aString.
		exception := resumableBoolean
			ifTrue: [TestResult resumableFailure]
			ifFalse: [TestResult failure].
		exception signal: aString].! !

!TestAsserter methodsFor: 'asserting'!
deny: aBoolean
	self assert: aBoolean not.! !

!TestAsserter methodsFor: 'asserting'!
deny: aBoolean description: aString
	self assert: aBoolean not description: aString.! !

!TestAsserter methodsFor: 'asserting'!
deny: aBoolean description: aString resumable: resumableBoolean
	self assert: aBoolean not description: aString resumable: resumableBoolean.! !

!TestAsserter methodsFor: 'asserting'!
should: aBlock raise: anExceptionalEvent 
	self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent).! !

!TestAsserter methodsFor: 'asserting'!
should: aBlock raise: anExceptionalEvent description: aString 
	self
		assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString.! !

!TestAsserter methodsFor: 'asserting'!
shouldnt: aBlock raise: anExceptionalEvent 
	self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not.! !

!TestAsserter methodsFor: 'asserting'!
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	self
		assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
 		description: aString.! !

!TestAsserter methodsFor: 'convenience' stamp: 'nfr 1/3/2010 18:38'!
assert: anObject equals: anotherObject
	self
		assert: anObject = anotherObject
		description: anObject printString , ' is not equal to ' , anotherObject printString.! !

!TestAsserter methodsFor: 'logging'!
logFailure: aString
	self class logFailure: aString.! !

!TestAsserter methodsFor: 'private'!
executeShould: aBlock inScopeOf: anExceptionalEvent
	^[aBlock value.
 	false]
		on: anExceptionalEvent
		do: [:ex | ex sunitExitWith: true]! !

!TestAsserter commentStamp: '<historical>' prior: 0!
I understand methods beginning #assert:... and #deny:... (and my class-side understands #assert:description:).  I am the superclass of TestCase and TestResource and can also be the superclass of any test helper classes you create to factor out test behaviour.  I exist so that test code can be refactored between my subclasses without difficulty.

Send #assert:description: when you want to check for an expected value. For example, you might say
	self assert: socket isOpen description: 'We requested a socket but now it is not open'.
to test whether or not a socket is open at a point in a test.  Use description strings both to give more information about where a test failed in debugger notifiers and logs, and to document the intent of a test.  Other methods include #assert:, #assert:description:resumable:, #deny:, #deny:description:, #deny:description:resumable:, #should:raise:, #should:raise:description:, #shouldnt:raise:, #shouldnt:raise:description:.  All these methods are defined on the superclass, TestAsserter.  (Any convenience assertion methods you create for general use should also be defined in my 'convenience' protocol.)

Override my class-side #isLogging in subclasses to have failed assertion descriptions shown on the Transcript.  To have them appear elsewhere, also override my class-side #failureLog.
!
!TestAsserter class methodsFor: 'asserting'!
assert: aBoolean description: aString
	"Minimal clone of the instance-side assert protocol so that class-side methods can use it."

	aBoolean ifFalse:
		[self logFailure: aString.
		TestResult failure signal: aString].! !

!TestAsserter class methodsFor: 'logging'!
failureLog
	^Transcript! !

!TestAsserter class methodsFor: 'logging'!
isLogging
	"By default, we're not logging failures. Override in subclasses as desired."

	^false! !

!TestAsserter class methodsFor: 'logging'!
logFailure: aString
	self isLogging ifTrue:
		[self failureLog cr; nextPutAll: aString; flush].! !

!TestCase methodsFor: 'accessing'!
resources
	"We give TestCase this instance-side method so that methods polymorphic with TestSuite can be code-identical.  Having this instance-side method also helps when writing tests of resource behaviour. Except for such tests, it is rare to override this method and should not be done without thought.  If there were a good reason why a single test case needed to share tests requiring different resources, it might be legitimate."

	^self class resources! !

!TestCase methodsFor: 'accessing'!
selector
	^testSelector! !

!TestCase methodsFor: 'asserting'!
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

!TestCase methodsFor: 'asserting' stamp: 'md 8/2/2006 11:00'!
assert: aBooleanOrBlock description: aString
	aBooleanOrBlock value ifFalse: [
		self logFailure: aString.
		TestResult failure signal: aString]
			! !

!TestCase methodsFor: 'asserting' stamp: 'md 8/2/2006 11:00'!
assert: aBooleanOrBlock description: aString resumable: resumableBoolean 
	| exception |
	aBooleanOrBlock value
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception signal: aString]
			! !

!TestCase methodsFor: 'asserting' stamp: 'dc 4/2/2007 18:38'!
assert: expected equals: actual
	^ self
		assert: (expected = actual)
		description: (self comparingStringBetween: expected and: actual)
! !

!TestCase methodsFor: 'asserting'!
deny: aBoolean

	self assert: aBoolean not
			! !

!TestCase methodsFor: 'asserting' stamp: 'md 8/2/2006 11:00'!
deny: aBooleanOrBlock description: aString
	self assert: aBooleanOrBlock value not description: aString
			! !

!TestCase methodsFor: 'asserting' stamp: 'md 8/2/2006 11:00'!
deny: aBooleanOrBlock description: aString resumable: resumableBoolean 
	self
		assert: aBooleanOrBlock value not
		description: aString
		resumable: resumableBoolean
			! !

!TestCase methodsFor: 'asserting'!
should: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
			! !

!TestCase methodsFor: 'asserting'!
should: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
			! !

!TestCase methodsFor: 'asserting' stamp: 'nk 5/11/2003 10:32'!
should: aBlock raise: anExceptionalEvent whoseDescriptionDoesNotInclude: subString description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionNotContaining: subString)
		description: aString
! !

!TestCase methodsFor: 'asserting' stamp: 'nk 5/11/2003 10:24'!
should: aBlock raise: anExceptionalEvent whoseDescriptionIncludes: subString description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionContaining: subString)
		description: aString
! !

!TestCase methodsFor: 'asserting'!
shouldnt: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
			! !

!TestCase methodsFor: 'asserting'!
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
			! !

!TestCase methodsFor: 'asserting' stamp: 'nk 5/11/2003 10:34'!
shouldnt: aBlock raise: anExceptionalEvent whoseDescriptionDoesNotInclude: subString description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionNotContaining: subString) not
		description: aString
! !

!TestCase methodsFor: 'asserting' stamp: 'nk 5/11/2003 10:34'!
shouldnt: aBlock raise: anExceptionalEvent whoseDescriptionIncludes: subString description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionContaining: subString) not
		description: aString
! !

!TestCase methodsFor: 'asserting' stamp: 'md 2/22/2006 14:26'!
signalFailure: aString
	TestResult failure signal: aString! !

!TestCase methodsFor: 'dependencies'!
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"! !

!TestCase methodsFor: 'dependencies'!
removeDependentFromHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"! !

!TestCase methodsFor: 'deprecated'!
should: aBlock
	self assert: aBlock value! !

!TestCase methodsFor: 'deprecated'!
should: aBlock description: aString
	self assert: aBlock value description: aString! !

!TestCase methodsFor: 'deprecated'!
shouldnt: aBlock
	self deny: aBlock value! !

!TestCase methodsFor: 'deprecated'!
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString! !

!TestCase methodsFor: 'events'!
announce: anAnnouncementClass
	^ self announce: anAnnouncementClass with: nil! !

!TestCase methodsFor: 'events' stamp: 'tbn 4/26/2011 09:58'!
announce: anAnnouncementClass withResult: result
	| event |
	self shouldAnnounce ifFalse: [ ^ self ].
	
	event := anAnnouncementClass asAnnouncement.
	event testCase: self.
	event testSelector: testSelector.
	event testResult: result.
	self announcer announce: event.! !

!TestCase methodsFor: 'events'!
announcer
	^ self class announcer! !

!TestCase methodsFor: 'events'!
shouldAnnounce
	^ self class shouldAnnounce! !

!TestCase methodsFor: 'extensions' stamp: 'mx 3/20/2006 23:32'!
executeShould: aBlock inScopeOf: anException withExceptionDo: anotherBlock

	^[aBlock value.
 	false] 
		on: anException
		do: [:exception | 
			anotherBlock value: exception.
			exception return: true]! !

!TestCase methodsFor: 'extensions' stamp: 'mx 3/13/2006 23:21'!
fail

	^self assert: false! !

!TestCase methodsFor: 'extensions'!
should: aBlock notTakeMoreThan: aDuration
    "Evaluate aBlock in a forked process and if it takes more than anInteger milliseconds
    to run we terminate the process and report a test failure.  It'' important to
    use the active process for the test failure so that the failure reporting works correctly
    in the context of the exception handlers."

    | evaluated evaluationProcess result delay testProcess |

    evaluated := false.
    delay := Delay forDuration: aDuration.
    testProcess := Processor activeProcess.
    "Create a new process to evaluate aBlock"
    evaluationProcess := [
        result := aBlock value.
        evaluated := true.
        delay unschedule.
        testProcess resume ] forkNamed: 'Process to evaluate should: notTakeMoreThanMilliseconds:'.

    "Wait the milliseconds they asked me to"
    delay wait.
    "After this point either aBlock was evaluated or not..."
    evaluated ifFalse: [
        evaluationProcess terminate.
        self assert: false description: ('Block evaluation took more than the expected <1p>' expandMacrosWith: aDuration)].
   
    ^result! !

!TestCase methodsFor: 'extensions' stamp: 'md 8/2/2006 11:08'!
should: aBlock notTakeMoreThanMilliseconds: anInteger
    "For compatibility with other Smalltalks"

   self should: aBlock notTakeMoreThan: (Duration milliSeconds: anInteger).! !

!TestCase methodsFor: 'extensions' stamp: 'mx 3/20/2006 23:52'!
should: aBlock raise: anException withExceptionDo: anotherBlock 

	^self assert: (self executeShould: aBlock inScopeOf: anException withExceptionDo: anotherBlock)! !

!TestCase methodsFor: 'extensions' stamp: 'mx 3/20/2006 21:29'!
shouldFix: aBlock 

	^self should: aBlock raise: Exception! !

!TestCase methodsFor: 'printing'!
printOn: aStream

	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: testSelector! !

!TestCase methodsFor: 'running'!
debug
	[(self class selector: testSelector) runCase]
		ensure: [TestResource resetResources: self resources]! !

!TestCase methodsFor: 'running' stamp: 'nfr 1/3/2010 18:04'!
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	[semaphore wait.
	TestResource resetResources: self resources] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore! !

!TestCase methodsFor: 'running' stamp: 'md 2/22/2006 14:17'!
failureLog	
	^Transcript

			! !

!TestCase methodsFor: 'running'!
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^false
			! !

!TestCase methodsFor: 'running'!
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
			! !

!TestCase methodsFor: 'running'!
openDebuggerOnFailingTestMethod
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

	self
		halt;
		performTest! !

!TestCase methodsFor: 'running'!
prepareToRunAgain 	

	"Used by the debugger when a test is restarted
	I'm not 'hidding'' possible exceptions because I think it is best to popup a new debugger
	if some one occurs and let the programmer decide what to do - Hernan"
	self 
		tearDown;
		setUp! !

!TestCase methodsFor: 'running'!
run
	| result |
	result := TestResult new.
	[self run: result]
		ensure: [TestResource resetResources: self resources].
	^result! !

!TestCase methodsFor: 'running'!
run: aResult
	aResult runCase: self! !

!TestCase methodsFor: 'running'!
runCase
	self resources do: [:each | each availableFor: self].
	[self setUp.
	self performTest] ensure: [
		self tearDown.
		self cleanUpInstanceVariables]! !

!TestCase methodsFor: 'running'!
runCaseAsFailure: aSemaphore
	[self resources do: [:each | each availableFor: self].
	[self setUp.
	self openDebuggerOnFailingTestMethod] ensure: [self tearDown]]
		ensure: [aSemaphore signal]! !

!TestCase methodsFor: 'running'!
setUp! !

!TestCase methodsFor: 'running'!
tearDown

	! !

!TestCase methodsFor: 'testing'!
expectedFailures
	"| pragmas |
	pragmas := Pragma allNamed: #expectedFailure from: self class to: Object.
	^ pragmas collect: [:each | each method selector  ].
	
	this implementation is far too slow and block the execution of tests since just for printing a test
	it scans all the literal of the system.
	So I reverted the old way of declaring expectedFailures
	"
	
	^ Array new! !

!TestCase methodsFor: 'testing' stamp: 'JF 7/30/2003 13:39'!
shouldPass
	"Unless the selector is in the list we get from #expectedFailures, we expect it to pass"
	^ (self expectedFailures includes: testSelector) not! !

!TestCase methodsFor: 'private'!
cleanUpInstanceVariables
	self class allInstVarNames do: [ :name |
		name = 'testSelector' ifFalse: [
			self instVarNamed: name put: nil ] ]! !

!TestCase methodsFor: 'private' stamp: 'dc 4/2/2007 18:46'!
comparingStringBetween: expected and: actual
	^ String streamContents: [:stream |
		stream
			nextPutAll: 'Expected ';
			nextPutAll: (expected printStringLimitedTo: 10);
			nextPutAll: ' but was ';
			nextPutAll: (actual printStringLimitedTo: 10);
			nextPutAll: '.'
		]! !

!TestCase methodsFor: 'private' stamp: 'md 2/22/2006 14:27'!
executeShould: aBlock inScopeOf: anExceptionalEvent 
	^[aBlock value.
 	false] on: anExceptionalEvent
		do: [:ex | ex return: true]
			! !

!TestCase methodsFor: 'private' stamp: 'md 2/22/2006 14:27'!
executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionContaining: aString
	^[aBlock value.
 	false] on: anExceptionalEvent
		do: [:ex | ex return: (ex description includesSubString: aString) ]
			! !

!TestCase methodsFor: 'private' stamp: 'md 2/22/2006 14:27'!
executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionNotContaining: aString
	^[aBlock value.
 	false] on: anExceptionalEvent
		do: [:ex | ex return: (ex description includesSubString: aString) not ]
			! !

!TestCase methodsFor: 'private'!
performTest
	self perform: testSelector asSymbol! !

!TestCase methodsFor: 'private'!
setTestSelector: aSymbol
	testSelector := aSymbol! !

!TestCase commentStamp: 'nfr 1/3/2010 17:56' prior: 0!
A TestCase is an implementation of the Command pattern to run a test.  TestCase instances are created with the class method #selector:, passing the symbol that names the method to be executed when the test case runs.  Various UIs exist to run these instances and they can also be created and run programmatically.

When you discover a new fixture, subclass TestCase and create a #test... method for the first test.  As that method develops and more #test... methods are added, you will find yourself refactoring temps into instance variables for the objects in the fixture and overriding #setUp to initialize these variables.  As required, override #tearDown to nil references, release objects and deallocate.

See my superclass' comment for assertion and logging information.!
!TestCase class methodsFor: 'accessing' stamp: ' 17/7/10 17:28'!
allTestSelectors
	| answer pivotClass lookupRoot |
	answer := Set withAll: self testSelectors.
	self shouldInheritSelectors
		ifTrue:
			[pivotClass := self.
			lookupRoot := self lookupHierarchyRoot.
			[pivotClass == lookupRoot]
				whileFalse:
					[pivotClass := pivotClass superclass.
					answer addAll: pivotClass testSelectors]].
	^answer asSortedCollection asOrderedCollection! !

!TestCase class methodsFor: 'accessing' stamp: ' 17/7/10 17:28'!
lookupHierarchyRoot
	^TestCase! !

!TestCase class methodsFor: 'accessing'!
resources

	^#()! !

!TestCase class methodsFor: 'accessing' stamp: ' 17/7/10 17:28'!
sunitVersion
	^'4.0'! !

!TestCase class methodsFor: 'accessing'!
testSelectors
	^(self selectors select: [ :each | (each beginsWith: 'test') and: [each numArgs isZero]])! !

!TestCase class methodsFor: 'building suites' stamp: 'lr 3/14/2010 21:13'!
addTestsFor: classNameString toSuite: suite
	| cls |
	cls := Smalltalk globals at: classNameString ifAbsent: [ ^ suite ].
	^ cls isAbstract
		ifTrue: [ 
			cls allSubclasses
				do: [ :each | 
					each isAbstract
						ifFalse: [ each addToSuiteFromSelectors: suite ] ].
			suite ]
		ifFalse: [ cls addToSuiteFromSelectors: suite ]! !

!TestCase class methodsFor: 'building suites' stamp: 'nk 4/21/2002 10:51'!
addToSuite: suite fromMethods: testMethods 
	testMethods do:  [ :selector | 
			suite addTest: (self selector: selector) ].
	^suite! !

!TestCase class methodsFor: 'building suites' stamp: 'nk 4/21/2002 16:37'!
addToSuiteFromSelectors: suite
	^self addToSuite: suite fromMethods: (self shouldInheritSelectors
		ifTrue: [ self allTestSelectors ]
		ifFalse: [self testSelectors ])! !

!TestCase class methodsFor: 'building suites'!
buildSuite
	| suite |
	^self isAbstract
		ifTrue: 
			[suite := self suiteClass named: self name asString.
			self allSubclasses 
				do: [:each | each isAbstract ifFalse: [suite addTest: each buildSuiteFromSelectors]].
			suite]
		ifFalse: [self buildSuiteFromSelectors]! !

!TestCase class methodsFor: 'building suites'!
buildSuiteFromAllSelectors

	^self buildSuiteFromMethods: self allTestSelectors
			! !

!TestCase class methodsFor: 'building suites'!
buildSuiteFromLocalSelectors

	^self buildSuiteFromMethods: self testSelectors
			! !

!TestCase class methodsFor: 'building suites'!
buildSuiteFromMethods: testMethods

	^testMethods
		inject: (self suiteClass named: self name asString)
		into: [:suite :selector |
			suite
				addTest: (self selector: selector);
				yourself]! !

!TestCase class methodsFor: 'building suites' stamp: ' 17/7/10 17:28'!
buildSuiteFromSelectors
	^self buildSuiteFromMethods: self allTestSelectors! !

!TestCase class methodsFor: 'building suites'!
suiteClass
	^TestSuite! !

!TestCase class methodsFor: 'coverage' stamp: 'lr 3/14/2010 21:13'!
coverage
	"returns the coverage determined by a simple static analysis of test coverage 
	made by the receiver on a class that is identified by the name of the receiver.
	We assume that SetTest test Set."

	| cls className |
	(self name endsWith: 'Test')
		ifFalse: [ self error: 'Please, use #coverageForClass: instead' ].
	className := self name copyFrom: 1 to: self name size - 'Test' size.
	cls := Smalltalk globals at: className asSymbol ifAbsent: [ self error: 'Please, use #coverageForClass: instead' ].	"May happen with Transcript"
	cls isBehavior
		ifFalse: [ cls := cls class ].
	^ self coverageForClass: cls! !

!TestCase class methodsFor: 'coverage' stamp: 'ab 12/25/2008 17:20'!
coverageAsString
	| cov className |
	cov := self coverage first asInteger. 
	"coverage already checks that the name is ends with 'Test' and if the class tested exists"
	
	className := self name copyFrom: 1 to: (self name size - 'Test' size).
	^ self name asString, ' covers ', cov asString, '% of ', className.! !

!TestCase class methodsFor: 'coverage' stamp: 'sd 1/28/2009 14:57'!
coverageForClass: cls
	"returns the test coverage of all the methods included inherited ones"
	^ self coverageForClass: cls until: ProtoObject! !

!TestCase class methodsFor: 'coverage' stamp: 'sd 1/28/2009 14:58'!
coverageForClass: cls until: aRootClass
	"returns the test coverage of all the methods included inherited ones but stopping at aRootClass included"
	
	| definedMethods testedMethods untestedMethods |
	definedMethods := cls allSelectorsAboveUntil: aRootClass.
	definedMethods size = 0
		ifTrue: [^ {0. Set new}].
	testedMethods := 
		self methodDictionary values inject: Set new into: 
							[:sums :cm | sums union: cm messages].
	testedMethods := testedMethods reject: [:sel | (definedMethods includes: sel) not].
	untestedMethods := definedMethods select: [:selector | (testedMethods includes: selector) not].
	^ { (testedMethods size * 100 / definedMethods size) asFloat . untestedMethods}
! !

!TestCase class methodsFor: 'coverage' stamp: 'ab 12/25/2008 17:15'!
coveragePercentage
	^ self coverage first! !

!TestCase class methodsFor: 'coverage' stamp: 'lr 3/14/2010 21:13'!
localCoverage
	"returns the coverage determined by a simple static analysis of test coverage 
	made by the receiver on a class that is identified by the name of the receiver.
	We assume that SetTest test Set. The computation of the coverage takes only into
	account the methods defined locally in the tested class. See coverage for a more global 
	coverage"

	| cls className |
	(self name endsWith: 'Test')
		ifFalse: [ self error: 'Please, use #localCoverageForClass: instead' ].
	className := self name copyFrom: 1 to: self name size - 'Test' size.
	cls := Smalltalk globals at: className asSymbol ifAbsent: [ self error: 'Please, use #localCoverageForClass: instead' ].
	cls isBehavior
		ifFalse: [ cls := cls class ].
	^ self localCoverageForClass: cls! !

!TestCase class methodsFor: 'coverage' stamp: 'sd 1/28/2009 15:04'!
localCoverageAsString
	| cov className |
	cov := self localCoverage first asInteger. 
	"coverage already checks that the name is ends with 'Test' and if the class tested exists"
	
	className := self name copyFrom: 1 to: (self name size - 'Test' size).
	^ self name asString, ' covers ', cov asString, '% of ', className.! !

!TestCase class methodsFor: 'coverage' stamp: 'sd 1/28/2009 14:55'!
localCoverageForClass: cls
	
	| definedMethods testedMethods untestedMethods |
	definedMethods := cls selectors.
	"It happens for IdentityBag / IdentityBagTest"
	definedMethods size = 0
		ifTrue: [^ {0. Set new}].

	testedMethods := 
		self methodDictionary values inject: Set new into: 
							[:sums :cm | sums union: cm messages].
					
	"testedMethods contains all the methods send in test methods, which probably contains methods that have nothign to do with collection"
	testedMethods := testedMethods reject: [:sel | (definedMethods includes: sel) not].

	untestedMethods := definedMethods select: [:selector | (testedMethods includes: selector) not].

	^ { (testedMethods size * 100 / definedMethods size) asFloat . untestedMethods}
! !

!TestCase class methodsFor: 'coverage' stamp: 'sd 1/28/2009 14:55'!
localCoveragePercentage
	^ self localCoverage first! !

!TestCase class methodsFor: 'events'!
announcer 
	^ self announcers at: self ifAbsentPut: [ Announcer new ]! !

!TestCase class methodsFor: 'events'!
announcers
	^ Announcers ifNil: [ Announcers := Dictionary new ] ! !

!TestCase class methodsFor: 'events'!
resetAnnouncer
	self announcers removeKey: self ifAbsent: []! !

!TestCase class methodsFor: 'events'!
shouldAnnounce
	^ self announcers includesKey: self! !

!TestCase class methodsFor: 'history'!
generateLastStoredRunMethod

	self shouldGenerateLastStoredRunMethod ifTrue: [
		self class
			compile: (self lastRunMethodNamed: #lastStoredRun)
			classified: 'history' ]! !

!TestCase class methodsFor: 'history'!
history
	^ history ifNil: [ history := self newTestDictionary ]! !

!TestCase class methodsFor: 'history'!
history: aDictionary
	history := aDictionary! !

!TestCase class methodsFor: 'history'!
lastRun
	^ TestResult historyFor: self! !

!TestCase class methodsFor: 'history'!
lastRunMethodNamed: aSelector
	
	^ String streamContents: [:str |
		str nextPutAll: aSelector asString ;cr.
		str tab; nextPutAll: '^ ', (self lastRun) storeString]
! !

!TestCase class methodsFor: 'history'!
lastStoredRun
	^ ((Dictionary new) add: (#failures->#()); add: (#passed->#()); add: (#errors->#()); yourself)! !

!TestCase class methodsFor: 'history'!
newTestDictionary

	^ Dictionary new at: #timeStamp put: DateAndTime now;
		at: #passed put: Set new;
		at: #failures put: Set new;
		at: #errors put: Set new;
		yourself
		! !

!TestCase class methodsFor: 'history'!
resetHistory
	history := nil! !

!TestCase class methodsFor: 'history'!
shouldGenerateLastStoredRunMethod
	| sameRun |
	
	(self class methodDictionary includesKey: #lastStoredRun)
		ifFalse: [^ true].
	sameRun := #(#passed #failures #errors) inject: true into: 
		[ :ok :set | ok and: [(self lastRun at: set) = (self lastStoredRun at: set) ]].
	^ sameRun not
! !

!TestCase class methodsFor: 'initialize - event'!
initialize
	super initialize.
	(SystemChangeNotifier respondsTo: #notify:ofSystemChangesOfItem:using:)
		ifTrue: [
			SystemChangeNotifier uniqueInstance notify: self ofSystemChangesOfItem: #method using: #methodChanged:.
		].
	"STEFAN: Not sure what the implication is of not having the notifications."
		! !

!TestCase class methodsFor: 'initialize - event' stamp: 'al 2/9/2009 20:00'!
methodChanged: anEvent
	"Remove the changed method from the known test results."
	
	| cls sel |
	anEvent item isCompiledMethod ifFalse: [ ^ self ].
	cls := anEvent item methodClass.
	(cls inheritsFrom: TestCase)
		ifFalse: [^ self].
	sel := anEvent item selector.
	(sel beginsWith: 'test')
		ifFalse: [^ self].
	TestResult removeFromTestHistory: sel in: cls.
! !

!TestCase class methodsFor: 'instance creation'!
debug: aSymbol

	^(self selector: aSymbol) debug! !

!TestCase class methodsFor: 'instance creation'!
run: aSymbol

	^(self selector: aSymbol) run! !

!TestCase class methodsFor: 'instance creation'!
selector: aSymbol

	^self new setTestSelector: aSymbol! !

!TestCase class methodsFor: 'instance creation'!
suite

	^self buildSuite! !

!TestCase class methodsFor: 'testing'!
hasMethodBeenRun: aSelector
	^ ((self lastRun at: #errors),
		(self lastRun at: #failures),
		(self lastRun at: #passed))
			includes: aSelector! !

!TestCase class methodsFor: 'testing' stamp: 'md 2/22/2006 14:21'!
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self name = #TestCase
			! !

!TestCase class methodsFor: 'testing'!
isUnitTest
	^true! !

!TestCase class methodsFor: 'testing'!
methodFailed: aSelector
	^ (self lastRun at: #failures) includes: aSelector! !

!TestCase class methodsFor: 'testing'!
methodPassed: aSelector
	^ (self lastRun at: #passed) includes: aSelector! !

!TestCase class methodsFor: 'testing'!
methodProgressed: aSelector
	^ ((self storedMethodRaisedError: aSelector) or: [self storedMethodFailed: aSelector])
		and: [self methodPassed: aSelector]
		! !

!TestCase class methodsFor: 'testing'!
methodRaisedError: aSelector
	^ (self lastRun at: #errors) includes: aSelector! !

!TestCase class methodsFor: 'testing'!
methodRegressed: aSelector
	^ (self storedMethodPassed: aSelector) and: [(self methodFailed: aSelector) or: [self methodRaisedError: aSelector]]! !

!TestCase class methodsFor: 'testing' stamp: ' 17/7/10 17:28'!
shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."
	
	^self ~~ self lookupHierarchyRoot
		and: [self superclass isAbstract or: [self testSelectors isEmpty]]! !

!TestCase class methodsFor: 'testing'!
storedMethodFailed: aSelector
	^ (self lastStoredRun at: #failures) includes: aSelector! !

!TestCase class methodsFor: 'testing'!
storedMethodPassed: aSelector
	^ (self lastStoredRun at: #passed) includes: aSelector! !

!TestCase class methodsFor: 'testing'!
storedMethodRaisedError: aSelector
	^ (self lastStoredRun at: #errors) includes: aSelector! !

!TestCaseAnnouncement methodsFor: 'accessing' stamp: 'tbn 4/26/2011 09:56'!
testCase
        "Returns the test case."
        
        ^testCase! !

!TestCaseAnnouncement methodsFor: 'accessing' stamp: 'tbn 4/26/2011 09:56'!
testCase: aTestCase
        "Sets the test case to the given test case."
        
        testCase := aTestCase! !

!TestCaseAnnouncement methodsFor: 'accessing' stamp: 'tbn 4/26/2011 09:56'!
testResult
        "Returns the test result."
        
        ^testResult! !

!TestCaseAnnouncement methodsFor: 'accessing' stamp: 'tbn 4/26/2011 09:56'!
testResult: aTestResult
        "Sets the test result to the given test result."
        
        testResult := aTestResult! !

!TestCaseAnnouncement methodsFor: 'accessing' stamp: 'tbn 4/26/2011 09:56'!
testSelector
        "Returns the test selector."
        
        ^testSelector! !

!TestCaseAnnouncement methodsFor: 'accessing' stamp: 'tbn 4/26/2011 09:57'!
testSelector: aSymbol
        "Sets the test selector to the given symbol."
        
        testSelector := aSymbol! !

!TestCaseAnnouncement methodsFor: 'testing' stamp: 'tbn 4/26/2011 09:57'!
hasErrors
        "Return true if the test result has errors."
        
        ^testResult hasErrors! !

!TestCaseAnnouncement methodsFor: 'testing' stamp: 'tbn 4/26/2011 09:57'!
hasFailures
        "Return true if the test result has failures."
        
        ^testResult hasFailures! !

!TestCaseAnnouncement methodsFor: 'testing' stamp: 'tbn 4/26/2011 09:58'!
hasPassed
        "Return true if the test has passed."
        
        ^testResult hasPassed! !

!TestCaseAnnouncement commentStamp: 'tbn 4/26/2011 09:54' prior: 0!
This is a common superclass for announcements related to SUnit test cases.

Instance Variables
        testCase:                       <TestCase>
        testResult:                     <TestResult>
        testSelector:           	   <Symbol>

testCase
        - The test case

testResult
        - The result of the test case

testSelector
        - The selector of the test method!
!TestCaseEnded commentStamp: 'tbn 4/26/2011 09:55' prior: 0!
This event is announced when testing a test case ends.!
!TestCaseStarted commentStamp: 'tbn 4/26/2011 09:55' prior: 0!
This event is announced when testing a test case starts.!
!TestCaseTest methodsFor: 'events' stamp: 'jannik.laval 10/1/2010 14:15'!
testAnnouncement
	| collection oldCollection suite unitTest |
	unitTest := ClassFactoryForTestCaseTest.
	collection := OrderedCollection new.
	unitTest resetAnnouncer.
	
	self deny: (unitTest shouldAnnounce).
	self deny: (unitTest new shouldAnnounce).
		
	unitTest announcer on: TestCaseAnnouncement do: [:ann | collection add: ann ].

	self assert: (unitTest shouldAnnounce).
	self assert: (unitTest new shouldAnnounce).

	"We run SUnitTest"
	suite := unitTest buildSuite.
	suite run.

	self assert: (collection size = (suite tests size * 2)).
	self assert: (collection select: [:c | c isKindOf: TestCaseStarted]) size = (collection size / 2).
	self assert: (collection select: [:c | c isKindOf: TestCaseEnded]) size =( collection size / 2).
	self assert: (collection allSatisfy: #hasPassed).
	self deny: (collection anySatisfy: #hasFailures).
	
	oldCollection := collection copy.
	unitTest resetAnnouncer.
	unitTest debug: #testClassCreationInDifferentCategories.
	self assert: (collection = oldCollection)! !

!TestCaseTest methodsFor: 'testing' stamp: 'sm 5/25/2011 01:14'!
expectedFailures
	^ {#testAnnouncement }.! !

!TestCaseTest methodsFor: 'testing' stamp: 'JorgeRessia 3/16/2010 20:57'!
testIsUnitTest

	self assert: TestCase isUnitTest! !

!TestConsoleRunner methodsFor: 'initialization' stamp: 'StefanMarr 7/14/2011 17:18'!
initialize
	super initialize.
	stream := self class defaultOutputTarget! !

!TestConsoleRunner methodsFor: 'initialization'!
initializeOn: aTestSuite
	suite := aTestSuite.
	suitePosition := suiteTime := suiteFailures := suiteErrors := 0! !

!TestConsoleRunner methodsFor: 'running' stamp: 'StefanMarr 7/14/2011 17:26'!
run
	| execBlock |
	execBlock :=  [ [ 
			self setUp.
			suiteTime := [ self runAll ]
				timeToRun ]
					ensure: [ self tearDown.
							self overviewReport. ] ].
	
	(Smalltalk at: #Author ifAbsent: [ 
		execBlock value.
		^ self ])
			uniqueInstance
				ifUnknownAuthorUse: 'TestConsoleRunner'
				during: execBlock.! !

!TestConsoleRunner methodsFor: 'running'!
runAll
	suite tests do: [ :each | each run: self ]! !

!TestConsoleRunner methodsFor: 'running' stamp: 'StefanMarr 7/14/2011 17:27'!
runCase: aTestCase
	| error runtime stack |
	runtime := [
		[	aTestCase announce: TestCaseStarted withResult: self.
		 	aTestCase runCase.
		 	aTestCase announce: TestCaseEnded  withResult: self.
		 	self addPass: aTestCase.] 
		on: Halt , Error, TestFailure, self class failure, self class error
		do: [ :err |
			error := err.
			stack := self stackTraceString: err of: aTestCase.
			err sunitAnnounce: aTestCase toResult: self ]
	] timeToRun.

	self beginTestCase: aTestCase time: runtime.
	
	(error isNil or: [ aTestCase expectedFailures includes: aTestCase selector ]) ifFalse: [
		(error isKindOf: TestFailure)
			ifTrue: [ self writeError: error stack: stack ]
			ifFalse: [ self writeError: error stack: stack ] ].
	self endTestCase! !

!TestConsoleRunner methodsFor: 'running'!
setUp
	stream nextPutAll: 'TestSuite '; nextPutAll: suite name; nextPutAll: ':'; nextPut: Character lf.
	stream nextPutAll: 'Tests: '; print: suite tests size; nextPut: Character lf.
	
	"Initialize the test resources."
	suite resources do: [ :each |
		each isAvailable
			ifFalse: [ each signalInitializationError ] ]! !

!TestConsoleRunner methodsFor: 'running'!
tearDown
	suite resources 
		do: [ :each | each reset ].
		
	stream nextPutAll: 'failures='; print: suiteFailures;
	tab;
	nextPutAll:'errors='; print: suiteErrors;
	tab;
	nextPutAll: 'time='; print: suiteTime / 1000.0;
	nextPut: Character lf.
! !

!TestConsoleRunner methodsFor: 'private'!
beginTestCase: aTestCase time: time
	stream tab; 
	nextPutAll: (aTestCase class category); nextPut: $.;
	nextPutAll: (aTestCase class name); nextPut: $.;
	nextPutAll: (aTestCase selector);
	tab;
	nextPutAll: 'time='; print: time / 1000.0;
	nextPut: Character lf! !

!TestConsoleRunner methodsFor: 'private'!
endTestCase
	stream tab;
	nextPut: Character lf! !

!TestConsoleRunner methodsFor: 'private'!
stackTraceString: err of: aTestCase
	^ String streamContents: [ :str | 
		| context |
		context := err signalerContext.
		[ context isNil or: [ context receiver == aTestCase and: [ context methodSelector == #runCase ] ] ] whileFalse: [
			str print: context; nextPut: Character lf.
			context := context sender ] ] ! !

!TestConsoleRunner methodsFor: 'private'!
writeError: error stack: stack
	suiteErrors := suiteErrors + 1.
	stream tab; tab; 
	nextPutAll: 'Error type='; nextPutAll: (error class name); 
	tab;
	nextPutAll: ' message='; nextPutAll: (error messageText ifNil: [ error description ]);
	nextPut: Character lf;
	nextPutAll: stack; 
	nextPut: Character lf;
	nextPut: Character lf! !

!TestConsoleRunner methodsFor: 'private'!
writeFailure: error stack: stack
	suiteFailures := suiteFailures + 1.
	
	stream tab; tab; 
	nextPutAll: 'Failure type='; nextPutAll: (error class name);
	tab;
	nextPutAll: 'message='; nextPutAll: (error messageText ifNil: [ error description ]);
	nextPut: Character lf;
	nextPutAll: stack;
	nextPut: Character lf;
	nextPut: Character lf! !

!TestConsoleRunner methodsFor: 'reporting' stamp: 'StefanMarr 7/14/2011 17:17'!
overviewReport
	| report results |
	results := self.
	report := stream.  "Old code..."
	
		[report nextPutAll: SystemVersion current version; cr.

		report nextPutAll: 'Time: '; nextPutAll: DateAndTime now asString; cr; cr.

		report nextPutAll: 'Run: '; nextPutAll: results runCount asString; cr.
		report nextPutAll: 'Expected passes: '; nextPutAll: results expectedPassCount asString; cr.
		report nextPutAll: '------------------------------'; cr.
		report nextPutAll: 'Expected failures: '; nextPutAll: results expectedDefectCount asString; cr.
		results expectedDefects do: [:each |
			report tab; nextPutAll: each asString; cr ].
		report nextPutAll: '------------------------------'; cr.
		report nextPutAll: 'Unexpected failures: '; nextPutAll: results unexpectedFailureCount asString; cr.
		results unexpectedFailures do: [:each |
			report tab; nextPutAll: each asString; cr ].
		report nextPutAll: '------------------------------'; cr.
		report nextPutAll: 'Errors: '; nextPutAll: results unexpectedErrors size asString; cr.
		results unexpectedErrors do: [:each |
			report tab; nextPutAll: each asString; cr ].
		report nextPutAll: '------------------------------'; cr.
		report nextPutAll: 'Unexpected passes: '; nextPutAll: results unexpectedPasses size asString; cr.
		report flush.
		results unexpectedPasses do: [:each |
			report tab; nextPutAll: each asString; cr ].
	] on: Error do:  [:e | 
		report cr; nextPutAll: 'INTERNAL ERROR'; cr.
		report nextPutAll: e asString; cr; cr.
		"thisContext stack copy withIndexDo: [:stck :i |
			[report nextPutAll: i asString; space; nextPutAll: stck asString; cr] ifError: []]."
	].
	report flush.! !

!TestConsoleRunner class methodsFor: 'running' stamp: 'sm 5/25/2011 16:05'!
runAllTests
	self runClasses: Smalltalk allClasses named: 'All'.! !

!TestConsoleRunner class methodsFor: 'running'!
runCategories: aCollectionOfStrings
	^ aCollectionOfStrings do: [ :each | self runCategory: each ]! !

!TestConsoleRunner class methodsFor: 'running'!
runCategory: aString
	^ self runClasses: (Smalltalk organization classesInCategory: aString) named: aString! !

!TestConsoleRunner class methodsFor: 'running'!
runClasses: aCollectionOfClasses named: aString
	| suite classes |
	suite := TestSuite named: aString.
	classes := (aCollectionOfClasses
		select: [ :each | (each includesBehavior: TestCase) and: [ each isAbstract not ] ])
			asSortedCollection: [ :a :b | a name <= b name ].
	classes isEmpty
		ifTrue: [ ^ self ].
	classes
		do: [ :each | each addToSuiteFromSelectors: suite ].
	^ self runSuite: suite! !

!TestConsoleRunner class methodsFor: 'running'!
runPackage: aString
	^ self runClasses: (PackageInfo named: aString) classes named: aString! !

!TestConsoleRunner class methodsFor: 'running'!
runPackages: aCollectionOfStrings
	^ aCollectionOfStrings do: [ :each | self runPackage: each ]! !

!TestConsoleRunner class methodsFor: 'running'!
runSuite: aTestSuite
	^ self new 
		initializeOn: aTestSuite; 
		run! !

!TestConsoleRunner class methodsFor: 'defaults' stamp: 'sm 5/25/2011 14:20'!
defaultOutputTarget
	^ DefaultOutputTarget ifNil: [Transcript] ifNotNil: [DefaultOutputTarget]! !

!TestConsoleRunner class methodsFor: 'defaults' stamp: 'sm 5/25/2011 14:21'!
defaultOutputTarget: someStreamishThing
	"The output target should understand some parts of the standard stream protocol.
	 For details, see the actual usage. A Transcript is good, and most streams, too."
	DefaultOutputTarget := someStreamishThing! !

!TestCoverage methodsFor: 'actions' stamp: 'lr 3/30/2009 15:20'!
install
	reference actualClass methodDictionary
		at: reference methodSymbol
		put: self! !

!TestCoverage methodsFor: 'actions' stamp: 'lr 3/30/2009 15:31'!
uninstall
	reference actualClass methodDictionary
		at: reference methodSymbol
		put: method! !

!TestCoverage methodsFor: 'evaluation' stamp: 'lr 3/30/2009 15:32'!
run: aSelector with: anArray in: aReceiver
	self mark; uninstall.
	^ aReceiver withArgs: anArray executeMethod: method! !

!TestCoverage methodsFor: 'initialization' stamp: 'lr 3/30/2009 15:19'!
initializeOn: aMethodReference
	hasRun := false.
	reference := aMethodReference.
	method := reference compiledMethod! !

!TestCoverage methodsFor: 'testing' stamp: 'lr 3/30/2009 15:09'!
hasRun
	^ hasRun! !

!TestCoverage methodsFor: 'private' stamp: 'lr 3/30/2009 20:26'!
doesNotUnderstand: aMessage
	^ method perform: aMessage selector withArguments: aMessage arguments! !

!TestCoverage methodsFor: 'private' stamp: 'lr 4/3/2011 10:59'!
flushCache
	self reference methodSymbol flushCache! !

!TestCoverage methodsFor: 'private' stamp: 'lr 3/30/2009 15:21'!
mark
	hasRun := true! !

!TestCoverage methodsFor: 'private' stamp: 'lr 3/30/2009 15:27'!
reference
	^ reference! !

!TestCoverage commentStamp: 'LaurentLaffont 4/15/2011 20:19' prior: 0!
I wrap a method in order to detect whether it has been called or not. Then I can be used to calculate test coverage for SUnit.!
!TestCoverage class methodsFor: 'instance creation' stamp: 'lr 3/30/2009 15:23'!
on: aMethodReference
	^ self new initializeOn: aMethodReference! !

!TestFailure methodsFor: 'Camp Smalltalk' stamp: ' 17/7/10 17:28'!
sunitAnnounce: aTestCase toResult: aTestResult
	aTestResult addFailure: aTestCase.
	self sunitExitWith: false! !

!TestFailure methodsFor: 'camp smalltalk' stamp: 'ajh 1/24/2003 19:23'!
defaultAction

	Processor activeProcess
		debug: self signalerContext
		title: self description! !

!TestFailure methodsFor: 'camp smalltalk' stamp: 'ajh 2/1/2003 00:58'!
isResumable
	
	^ false! !

!TestFailure commentStamp: '<historical>' prior: 0!
The test framework distinguishes between failures and errors.  A failure is an event whose possibiity is explicitly anticipated and checked for in an assertion, whereas an error is an unanticipated problem like a division by 0 or an index out of bounds.  TestFailure is raised when the boolean parameter of an assert: ... or deny: ... call is the opposite of what the assertion claims.!
!TestResource methodsFor: 'accessing'!
description

	description isNil
		ifTrue: [^''].

	^description! !

!TestResource methodsFor: 'accessing'!
description: aString

	description := aString! !

!TestResource methodsFor: 'accessing'!
name

	name isNil
		ifTrue: [^self printString].

	^name! !

!TestResource methodsFor: 'accessing'!
name: aString

	name := aString! !

!TestResource methodsFor: 'accessing'!
resources
	^self class resources! !

!TestResource methodsFor: 'initialize-release' stamp: ' 17/7/10 17:28'!
initialize
	"This method used to call setUp but now does nothing;  setUp is called by the framework at the appropriate point.  Subclasses may override to set the object to its default state."
	
	! !

!TestResource methodsFor: 'printing'!
printOn: aStream

	aStream nextPutAll: self class printString! !

!TestResource methodsFor: 'running'!
setUp
	"Does nothing. Subclasses should override this to initialize their resource"! !

!TestResource methodsFor: 'running'!
tearDown
	"Does nothing. Subclasses should override this to tear down their resource"! !

!TestResource methodsFor: 'testing'!
isAvailable
	"Override to provide information on the readiness of the resource.  Put state-changing behaviour in setUp and keep this a state-preserving check as far as possible.  Where setUp is guaranteed to provide a valid resource if it completes, there is no need to override this."
	
	^true! !

!TestResource methodsFor: 'testing'!
isUnavailable
	"override to provide information on the
	readiness of the resource"
	
	^self isAvailable not
			! !

!TestResource commentStamp: '<historical>' prior: 0!
Normally a test will set up all the objects it needs and tear them down again after it has run.  This self-containedness makes a test more robust.  Use TestResources only for objects that are needed by several tests and that are too 'expensive' (in time or otherwise) to recreate and destroy for each test.  A viable approach is to develop the code in MyTestCase's #setUp and #tearDown methods, then at some point refactor the code into the #setUp and #tearDown of a TestResource whose class is added to MyTestCase class>>resource method.

TestResource uses the singleton pattern.  A TestResource class will set up a single instance of itself when first requested and tear it down again at the end of TestSuite>>run (or TestCase>>run, >>debug and >>debugAsFailure).  Normally, a TestResource, once setUp, remains active during the running of all remaining tests and is #reset after all tests have run.  For an exception, see subclass CompetingResource in SUnitResourcePatterns.  Users can choose to #reset a resource in the #tearDown of a test that alters it, sacrificing the performance gain of having a single #setUp of the resource for the certainty that other tests using it will not see the alterations.  Generally however, this should be the exception:  if you need to reset the resource for every test that uses it, its code should just be part of your test's #setUp and #tearDown code.

To use, create a subclass of TestResource and override the following:
	- TestCase class>>resources, to return a collection including the TestResource class, for all test case classes that need it
		* a TestCase' resources are set up in the order returned and torn down in the reverse order
	- TestResource class>>resources, if the resource itself always needs some other resource to be present before it can set up
		* a TestResource's resource are set up before it and torn down after it, and are set up in the order returned and torn down in the reverse order
	- TestResource>>setUp and tearDown, to define initial and final behaviour (just like a test)
	- TestResource>>isAvailable, to return true if it is and false if it isn't (the framework calls this after setUp);  ideally, this call should not change the resource' state - that should be done in setUp

TestResource implements the singleton pattern in its class-side #isAvailable and #reset methods.  Do not override these when creating specific resources;  unless you are developing a whole new pattern of use, it will always be correct to override instance-side #setUp, #tearDown and #isAvailable, and dangerous to override class>>isAvailable, class>>isAlreadyAvailable and class>>reset.

Generally, users do not code interactions with a test's resources during the running of a test.  Code that reads a resource' values while leaving its state strictly alone is safe enough.  A test must leave a resource in a clean state:  always use #reset if a test must protect later-running tests from unsafe changes (and review whether in such a case a resource is the right thing to use in the first place).

See my superclass' comment for assertion and logging information.
!
!TestResource class methodsFor: 'accessing' stamp: ' 17/7/10 17:28'!
current
	"This is a lazy accessor:  the assert of self isAvailable does no work unless current isNil.  However this method should normally be sent only to a resource that should already have been made available, e.g. in a test whose test case class has the resource class in its #resources, so should never be able to fail the assert.
	If the intent is indeed to access a possibly-unprepared or reset-in-earlier-test resource lazily, then preface the call of 'MyResource current' with 'MyResource availableFor: self'."
	
	self
		assert: self isAvailable
		description:
			'Sent #current to unavailable resource ' , self name ,
					'.  Add it to test case'' class-side #resources (recommended) or send #availableFor: beforehand'.
	^current! !

!TestResource class methodsFor: 'accessing'!
current: aTestResource

	current := aTestResource
			! !

!TestResource class methodsFor: 'accessing'!
resources
	^#()! !

!TestResource class methodsFor: 'instance creation' stamp: 'nfr 1/3/2010 18:01'!
new
	"Use #current to get the valid current instance.  Use of #new to get an instance (that should never be the current one) could be done in bizarre circumstances, so is not blocked, but will usually be inappropriate."
	
	^super new initialize.! !

!TestResource class methodsFor: 'instance creation'!
reset
	[self isAlreadyAvailable ifTrue: [current tearDown]]
		ensure: [current := nil]! !

!TestResource class methodsFor: 'running' stamp: ' 17/7/10 17:28'!
availableFor: aTestAsserter
	aTestAsserter
		assert: self isAvailable
		description:
			'Unavailable resource ' , self name , ' requested by '
				, aTestAsserter printString! !

!TestResource class methodsFor: 'running' stamp: 'nfr 1/3/2010 18:01'!
resetResources: topLevelResources
	"Reset all imperfectly-set-up resources while gathering the rest for ordered resetting."

	| availableResources |
	availableResources := OrderedCollection new: topLevelResources size.
	topLevelResources
		do: [:each | each resetOrAddResourcesTo: availableResources].
	availableResources reverseDo: [:each | each reset]! !

!TestResource class methodsFor: 'testing' stamp: 'md 2/22/2006 14:21'!
isAbstract
	"Override to true if a TestResource subclass is Abstract and should not have
	TestCase instances built from it"

	^self name = #TestResource
			! !

!TestResource class methodsFor: 'testing'!
isAlreadyAvailable
	^current class == self! !

!TestResource class methodsFor: 'testing'!
isAvailable
	"This is (and must be) a lazy method.  If my current has a value, an attempt to make me available has already been made:  trust its result.  If not, try to make me available."

	current isNil ifTrue: [self makeAvailable].
	^self isAlreadyAvailable! !

!TestResource class methodsFor: 'testing'!
isUnavailable

	^self isAvailable not
			! !

!TestResource class methodsFor: 'private'!
makeAvailable
	"This method must be the _only_ way to set a notNil value for the unique instance (current).  First, obtain a candidate instance and set current to a notNil placeholder (any notNil object not an instance of me would do;  this version uses false).  Next, check any subordinate resources needed by this resource.  Lastly, setUp the candidate and put it in current if it is available, ensuring that it is torn down otherwise."
	
	| candidate |
	current := nil.
	candidate := self new.
	self resources do: [:each | each availableFor: candidate].
	[candidate setUp.
	candidate isAvailable ifTrue: [current := candidate]]
		ensure: [current == candidate ifFalse: [candidate tearDown]]! !

!TestResource class methodsFor: 'private' stamp: 'nfr 1/3/2010 18:00'!
resetOrAddResourcesTo: aCollection
	"Add correctly set-up resources to the collection unless already there. Reset any imperfectly-set-up resources, so current isNil will return true if they are re-encountered via an indirectly self-prerequing resource;  circular references cannot be set up so will never reply true to isAlreadyAvailable, but may have correctly-set-up prereqs to add and/or imperfectly-set-up ones to reset, so do not abort the loop first time round."

	current isNil ifTrue: [^self].
	self isAlreadyAvailable
		ifFalse:
			[self reset.
			self resources do: [:each | each resetOrAddResourcesTo: aCollection]]
		ifTrue:
			[(aCollection includes: self)
				ifFalse:
					[self resources do: [:each | each resetOrAddResourcesTo: aCollection].
					aCollection add: self]]

"The cloned 'self resources do: ...' line in both blocks is, I think, the best way to write this method so that its logic is clear.  The first loop resets this resource immediately, before traversing its resources;  the second traverses before adding"! !

!TestResult methodsFor: 'accessing'!
classesTested
	^ (self tests collect: [ :testCase | testCase class ]) asSet! !

!TestResult methodsFor: 'accessing'!
defects
	^OrderedCollection new
		addAll: self errors;
		addAll: self failures; yourself! !

!TestResult methodsFor: 'accessing'!
errorCount

	^self errors size! !

!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 13:54'!
expectedDefectCount
	^ self expectedDefects size! !

!TestResult methodsFor: 'accessing' stamp: 'md 11/25/2004 16:36'!
expectedDefects
	^ (errors, failures asOrderedCollection) select: [:each | each shouldPass not] ! !

!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 13:54'!
expectedPassCount
	^ self expectedPasses size! !

!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 16:14'!
expectedPasses
	^ passed select: [:each | each shouldPass] ! !

!TestResult methodsFor: 'accessing'!
failureCount

	^self failures size! !

!TestResult methodsFor: 'accessing'!
passedCount

	^self passed size! !

!TestResult methodsFor: 'accessing'!
runCount

	^self passedCount + self failureCount + self errorCount! !

!TestResult methodsFor: 'accessing'!
tests
	^(OrderedCollection new: self runCount)
		addAll: passed;
		addAll: failures;
		addAll: errors;
		yourself! !

!TestResult methodsFor: 'accessing'!
timeStamp
	^ timeStamp! !

!TestResult methodsFor: 'accessing'!
timeStamp: anObject
	timeStamp := anObject! !

!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 13:54'!
unexpectedErrorCount
	^ self unexpectedErrors size! !

!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 16:14'!
unexpectedErrors
	^ errors select: [:each | each shouldPass] ! !

!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 13:54'!
unexpectedFailureCount
	^ self unexpectedFailures size! !

!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 16:14'!
unexpectedFailures
	^ failures select: [:each | each shouldPass] ! !

!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 13:54'!
unexpectedPassCount
	^ self unexpectedPasses size! !

!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 16:14'!
unexpectedPasses
	^ passed select: [:each | each shouldPass not] ! !

!TestResult methodsFor: 'adding'!
addError: aTestCase
	"We cannot use self errors as that incorporates test expectations and so does not return the stored collection."

	^errors add: aTestCase! !

!TestResult methodsFor: 'adding'!
addFailure: aTestCase
	"We cannot use self failures as that incorporates test expectations and so does not return the stored collection."

	^failures add: aTestCase! !

!TestResult methodsFor: 'adding'!
addPass: aTestCase
	"We cannot use self passed as that incorporates test expectations and so does not return the stored collection."

	^passed add: aTestCase! !

!TestResult methodsFor: 'compatibility' stamp: 'JF 7/30/2003 16:09'!
errors
	^ self unexpectedErrors! !

!TestResult methodsFor: 'compatibility' stamp: 'md 11/25/2004 16:23'!
failures
	^ self unexpectedFailures, self unexpectedPasses ! !

!TestResult methodsFor: 'compatibility' stamp: 'JF 7/30/2003 16:08'!
passed
	^ self expectedPasses, self expectedDefects! !

!TestResult methodsFor: 'deprecated' stamp: 'nfr 1/3/2010 17:58'!
correctCount
	"deprecated - use #passedCount"
	
	^self passedCount! !

!TestResult methodsFor: 'diff'!
diff: aTestResult
	"Return a collection that contains differences"
	| passed1Selectors failed1Selectors errors1Selectors passed2Selectors failed2Selectors errors2Selectors |
	passed1Selectors := self passed collect: [:testCase | testCase selector].
	failed1Selectors := self failures collect: [:testCase | testCase selector].
	errors1Selectors := self errors collect: [:testCase | testCase selector].

	passed2Selectors := aTestResult passed collect: [:testCase | testCase selector].
	failed2Selectors := aTestResult failures collect: [:testCase | testCase selector].
	errors2Selectors := aTestResult errors collect: [:testCase | testCase selector].
	
	^ {passed1Selectors copyWithoutAll: passed2Selectors .
		failed1Selectors copyWithoutAll: failed2Selectors .
		errors1Selectors copyWithoutAll: errors2Selectors}! !

!TestResult methodsFor: 'filein/out'!
fileOutOn: aFileStream
	"Write in aFileStream like:
	3 run, 2 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes
	Failures:
	SHParserST80Test>>#testNumbers
	
	Errors:"	
	| printer |
	printer := [:title :testCases | 
				aFileStream cr; nextPutAll: title; cr.
				testCases do: [:aTestCase| 
								aTestCase printOn: aFileStream.
								aFileStream cr]].
				
	self printOn: aFileStream.	
	printer value: 'Failures:' value: self failures.
	printer value: 'Errors:' value: self errors.! !

!TestResult methodsFor: 'history'!
dispatchResultsIntoHistory 

	self classesTested do: 
		[ :testClass | 
		self class
			historyAt: testClass
			put: (self selectResultsForTestCase: testClass) ].
! !

!TestResult methodsFor: 'history'!
selectResultsForTestCase: aTestCaseClass
	| passedSelectors errorsSelectors failuresSelectors |
	passedSelectors := self passed
						select: [:testCase | testCase class == aTestCaseClass ] thenCollect: [:testCase | testCase selector].
	errorsSelectors := self errors 
						select: [:testCase | testCase class == aTestCaseClass ] thenCollect:  [:testCase | testCase selector].
	failuresSelectors := self failures 
						select: [:testCase | testCase class == aTestCaseClass ] thenCollect:  [:testCase | testCase selector].
	
	^ self class newTestDictionary 
		at: #passed put: passedSelectors asSet;
		at: #failures put: failuresSelectors asSet;
		at: #errors put: errorsSelectors asSet;
		yourself
		! !

!TestResult methodsFor: 'history'!
updateResultsInHistory
	
	#(#passed #failures #errors) do: [ :status | 
		(self perform: status) do: [ :testCase | 
			self class updateTestHistoryFor: testCase status: status ] ]! !

!TestResult methodsFor: 'initialization'!
initialize
	super initialize.
	passed := OrderedCollection new.
	failures := Set new.
	errors := OrderedCollection new.
	timeStamp := DateAndTime now! !

!TestResult methodsFor: 'printing'!
printOn: aStream
	aStream
		nextPutAll: self runCount printString;
		nextPutAll: ' run, ';
		nextPutAll: self expectedPassCount printString;
		nextPutAll: ' passes, ';
		nextPutAll: self expectedDefectCount printString;
		nextPutAll:' expected failures, ';
		nextPutAll: self unexpectedFailureCount printString;
		nextPutAll: ' failures, ';
		nextPutAll: self unexpectedErrorCount printString;
		nextPutAll:' errors, ';
		nextPutAll: self unexpectedPassCount printString;
		nextPutAll:' unexpected passes'.! !

!TestResult methodsFor: 'querying'!
isErrorFor: class selector: selector
	^ self errors anySatisfy: [:testCase | testCase class == class and: [testCase selector == selector]]! !

!TestResult methodsFor: 'querying'!
isFailureFor: class selector: selector
	^ self failures anySatisfy: [:testCase | testCase class == class and: [testCase selector == selector]]! !

!TestResult methodsFor: 'querying'!
isPassedFor: class selector: selector
	^ self passed anySatisfy: [:testCase | testCase class == class and: [testCase selector == selector]]! !

!TestResult methodsFor: 'running'!
runCase: aTestCase
	[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCase.
	aTestCase announce: TestCaseEnded  withResult: self.
	self addPass: aTestCase]
		on: self class failure , self class error
		do: [:ex | ex sunitAnnounce: aTestCase toResult: self]! !

!TestResult methodsFor: 'testing'!
hasErrors

	^self errors size > 0! !

!TestResult methodsFor: 'testing'!
hasFailures

	^self failures size > 0! !

!TestResult methodsFor: 'testing'!
hasPassed

	^self hasErrors not and: [self hasFailures not]! !

!TestResult methodsFor: 'testing'!
isError: aTestCase

	^self errors includes: aTestCase! !

!TestResult methodsFor: 'testing'!
isFailure: aTestCase
	^self failures includes: aTestCase! !

!TestResult methodsFor: 'testing'!
isPassed: aTestCase

	^self passed includes: aTestCase! !

!TestResult commentStamp: '<historical>' prior: 0!
This implements the Collecting Parameter pattern for running a bunch of tests.  It holds tests that have run, sorted into the result categories of passed, failures and errors.

TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. TestResult subclasses can  handle multi-threaded tests (see SUnitXProcPatterns) and might record coverage information or send emails when the run completes.
!
!TestResult class methodsFor: 'exceptions'!
error
	^self exError! !

!TestResult class methodsFor: 'exceptions' stamp: 'md 2/22/2006 14:17'!
exError
	^Error
			! !

!TestResult class methodsFor: 'exceptions'!
failure
	^TestFailure! !

!TestResult class methodsFor: 'exceptions'!
resumableFailure
	^ResumableTestFailure! !

!TestResult class methodsFor: 'exceptions' stamp: 'md 2/22/2006 14:26'!
signalErrorWith: aString 
	self error signal: aString
			! !

!TestResult class methodsFor: 'exceptions' stamp: 'md 2/22/2006 14:26'!
signalFailureWith: aString 
	self failure signal: aString
			! !

!TestResult class methodsFor: 'history'!
historyAt: aTestCaseClass
"I will return the last test dictionary for aTestCaseClass. If none found, I will create a new empty one and link it in the history."

	^ aTestCaseClass history ! !

!TestResult class methodsFor: 'history'!
historyAt: aTestCaseClass put: aDictionary
	aTestCaseClass history: aDictionary
	"^ self history at: aTestCaseClass put: aDictionary "! !

!TestResult class methodsFor: 'history'!
historyFor: aTestCaseClass
	"I return the last test dictionary for aTestCaseClass. 
	If none found, I return an empty dictionary but will not link it to the class in the history."
	
	| history |
	history := aTestCaseClass history.
	history ifNil: [ ^ self newTestDictionary ].
	^ history
	
"	^ self history at: aTestCaseClass ifAbsent: [ self newTestDictionary ]"! !

!TestResult class methodsFor: 'history'!
newTestDictionary

	^ Dictionary new at: #timeStamp put: DateAndTime now;
		at: #passed put: Set new;
		at: #failures put: Set new;
		at: #errors put: Set new;
		yourself
		! !

!TestResult class methodsFor: 'history'!
removeFromTestHistory: aSelector in: aTestCaseClass
	| lastRun |
	
	lastRun := self historyFor: aTestCaseClass.
	#(#passed #failures #errors) do:
		[ :set | (lastRun at: set) remove: aSelector ifAbsent: []].
! !

!TestResult class methodsFor: 'history'!
updateTestHistoryFor: aTestCase status: aSymbol
	| cls sel |
	
	cls := aTestCase class.
	sel := aTestCase selector.
	self removeFromTestHistory: sel in: cls.
	((self historyAt: cls) at: aSymbol ) add: sel! !

!TestRunner methodsFor: 'accessing' stamp: 'lr 10/31/2005 15:31'!
baseClass
	^ TestCase! !

!TestRunner methodsFor: 'accessing' stamp: 'lr 11/3/2005 09:37'!
suiteAll
	^ TestSuite new in: [ :suite |
		classesSelected do: [ :each | 
			each isAbstract 
				ifFalse: [ each addToSuiteFromSelectors: suite ] ].
		suite name: (self label: 'Test' forSuite: suite) ].! !

!TestRunner methodsFor: 'accessing' stamp: 'lr 10/27/2005 10:29'!
suiteErrors
	^ TestSuite new in: [ :suite |
		suite 
			addTests: errorList; 
			name: (self label: 'Error' forSuite: suite) ].! !

!TestRunner methodsFor: 'accessing' stamp: 'lr 10/27/2005 10:42'!
suiteFailures
	^ TestSuite new in: [ :suite |
		suite 
			addTests: failedList; 
			name: (self label: 'Failure' forSuite: suite) ].! !

!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:09'!
categoryAt: anIndex
	^ categoriesSelected includes: (categories at: anIndex ifAbsent: [ ^ false ]).! !

!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:51'!
categoryAt: anInteger put: aBoolean
	categoriesSelected := categoriesSelected
		perform: (aBoolean ifTrue: [ #copyWith: ] ifFalse: [ #copyWithout: ])
		with: (categories at: anInteger ifAbsent: [ ^ self ]).
	self changed: #categorySelected; updateClasses.! !

!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:10'!
categoryList
	^ categories! !

!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 11/1/2005 19:25'!
categoryMenu: aMenu
	^ aMenu
		title: 'Categories';
		add: 'Select all' action: #selectAllCategories;
		add: 'Select inversion' action: #selectInverseCategories;
		add: 'Select none' action: #selectNoCategories;
		addLine;
		add: 'Filter...' action: #filterCategories;
		addLine;
		add: 'Refresh' action: #updateCategories;
		yourself.! !

!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:11'!
categorySelected
	^ 0! !

!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:12'!
categorySelected: anInteger
	self changed: #categorySelected.! !

!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 7/4/2009 15:08'!
filterCategories
	| pattern |
	pattern := UIManager default 
		request: 'Pattern to select categories:' 
		initialAnswer: '*'.
	pattern isNil ifTrue: [ ^ self ].
	categoriesSelected := (categories 
		select: [ :each | pattern match: each ]) asSet.
	self changed: #allSelections; changed: #categorySelected; updateClasses! !

!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 7/4/2009 15:08'!
selectAllCategories
	categoriesSelected := categories asSet.
	self changed: #allSelections; changed: #categorySelected; updateClasses! !

!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 7/4/2009 15:08'!
selectInverseCategories
	categoriesSelected := categories asSet 
		removeAll: categoriesSelected;
		yourself.
	self changed: #allSelections; changed: #categorySelected; updateClasses! !

!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 7/4/2009 15:08'!
selectNoCategories
	categoriesSelected := Set new.
	self changed: #allSelections; changed: #categorySelected; updateClasses! !

!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 1/20/2009 14:49'!
browseClass
	(classes at: classIndex ifAbsent: [ ^ self ]) browse! !

!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 10/8/2005 19:58'!
classAt: anInteger
	^ classesSelected includes: (classes at: anInteger ifAbsent: [ ^ false ]).! !

!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 11/21/2005 13:19'!
classAt: anInteger put: aBoolean
	classesSelected := classesSelected
		perform: (aBoolean ifTrue: [ #copyWith: ] ifFalse: [ #copyWithout: ])
		with: (classes at: anInteger ifAbsent: [ ^ self ]).
	self changed: #classSelected; changed: #hasRunnable.! !

!TestRunner methodsFor: 'accessing-classes' stamp: 'nice 1/5/2010 15:59'!
classList
	| offset |
	classes isEmpty ifTrue: [ ^ classes ].
	offset := classes first allSuperclasses size.
	^ classes collect: [ :each | | ident |
		ident := String 
			new: 2 * (0 max: each allSuperclasses size - offset) 
			withAll: $ .
		each isAbstract
			ifFalse: [ ident , each name ]
			ifTrue: [ 
				ident asText , each name asText 
					addAttribute: TextEmphasis italic;
					yourself ] ].! !

!TestRunner methodsFor: 'accessing-classes'!
classMenu: aMenu
	^ aMenu
		title: 'Classes';
		add: 'Browse' action: #browseClass;
		addLine;
		add: 'Select all' action: #selectAllClasses;
		add: 'Select unit tests' action: #selectAllUnitTests;
		add: 'Select subclasses' action: #selectSubclasses;
		add: 'Select inversion' action: #selectInverseClasses;
		add: 'Select none' action: #selectNoClasses;
		addLine;
		add: 'Filter...' action: #filterClasses;
		addLine;
		add: 'Refresh' action: #updateClasses;
		yourself.! !

!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 1/20/2009 14:46'!
classSelected
	^ classIndex! !

!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 1/20/2009 14:48'!
classSelected: anInteger
	classIndex := anInteger.
	self changed: #classSelected! !

!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 7/4/2009 15:10'!
filterClasses
	| pattern |
	pattern := UIManager default 
		request: 'Pattern to select tests:' 
		initialAnswer: '*'.
	pattern isNil ifTrue: [ ^ self ].
	classesSelected := (classes select: [ :each | 
		pattern match: each name ]) asSet.
	self
		changed: #allSelections;
		changed: #classSelected;
		changed: #hasRunnable! !

!TestRunner methodsFor: 'accessing-classes' stamp: 'gvc 7/24/2007 12:01'!
selectAllClasses
	"Fixed to update all selections now that the
	selection invalidation has been optimised."
	
	classesSelected := classes asSet.
	self
		changed: #allSelections;
		changed: #classSelected;
		changed: #hasRunnable! !

!TestRunner methodsFor: 'accessing-classes'!
selectAllUnitTests
	classesSelected := classes asSet select: [ :eachClass | eachClass isUnitTest ].
	self
		changed: #allSelections;
		changed: #classSelected;
		changed: #hasRunnable! !

!TestRunner methodsFor: 'accessing-classes' stamp: 'gvc 7/24/2007 12:01'!
selectInverseClasses
	"Fixed to update all selections now that the
	selection invalidation has been optimised."
	
	classesSelected := classes asSet 
		removeAll: classesSelected;
		yourself.
	self
		changed: #allSelections;
		changed: #classSelected;
		changed: #hasRunnable! !

!TestRunner methodsFor: 'accessing-classes' stamp: 'gvc 7/24/2007 11:59'!
selectNoClasses
	"Fixed to update all selections now that the
	selection invalidation has been optimised."
	
	classesSelected := Set new.
	self
		changed: #allSelections;
		changed: #classSelected;
		changed: #hasRunnable! !

!TestRunner methodsFor: 'accessing-classes' stamp: 'gvc 7/24/2007 12:01'!
selectSubclasses
	"Fixed to update all selections now that the
	selection invalidation has been optimised."
	
	| classesForPackages |
	classesForPackages := self findClassesForCategories: categoriesSelected.	
	classesSelected := (classesSelected gather: [ :class |
		class withAllSubclasses select: [ :each |
			classesForPackages includes: each ] ])
		asSet.
	self
		changed: #allSelections;
		changed: #classSelected;
		changed: #hasRunnable! !

!TestRunner methodsFor: 'accessing-menu'!
errorMenu: aMenu
	"Add the browse item only if an item is selected"

	self statusMenu: aMenu.
	errorSelected ifNotNil: [aMenu add: 'Browse test' action: #browseSelectedErrorTest].
	^aMenu! !

!TestRunner methodsFor: 'accessing-menu'!
failureMenu: aMenu
	"Add the browse item only if an item is selected"
	
	failedSelected ifNotNil: [aMenu add: 'Browse test' action: #browseSelectedFailedTest].
	^ aMenu! !

!TestRunner methodsFor: 'accessing-menu'!
statusMenu: aMenu
	^ aMenu
		add: 'History' action: #showHistoryMenu;
		add: 'Store result as progress reference' action: #storeResultIntoTestCases;
		add: 'Show progress' action: #showProgress; 
		yourself! !

!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/8/2005 22:37'!
errorList
	^ errorList collect: [ :each | each printString ].! !

!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/6/2005 19:46'!
errorSelected
	^ errorList indexOf: errorSelected.! !

!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/27/2005 10:37'!
errorSelected: anInteger
	errorSelected := errorList at: anInteger ifAbsent: nil.
	self changed: #errorSelected.
	errorSelected ifNotNil: [ self debug: errorSelected ].! !

!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/8/2005 22:37'!
failedList
	^ failedList collect: [ :each | each printString ].! !

!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/6/2005 19:47'!
failedSelected
	^ failedList indexOf: failedSelected.! !

!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/6/2005 20:14'!
failedSelected: anInteger
	failedSelected := failedList at: anInteger ifAbsent: nil.
	self changed: #failedSelected.
	failedSelected ifNotNil: [ self debug: failedSelected ].! !

!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/6/2005 15:47'!
result
	^ result! !

!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/8/2005 22:47'!
result: aResult
	result := aResult! !

!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 3/16/2010 19:37'!
statusColor
	result hasErrors 
		ifTrue: [ ^ Color red ].
	result hasFailures 
		ifTrue: [ ^ Color yellow ].
	^ Color green! !

!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/8/2005 22:45'!
statusText
	^ result printString.! !

!TestRunner methodsFor: 'accessing-ui' stamp: 'tbn 7/29/2010 21:17'!
buttons
	^ #(( 'Run Selected' #runAll 'Run all selected tests' #hasRunnable )
		( 'Run Profiled' #runProfiled 'Run tests and profile' #hasRunnable )
		( 'Run Coverage' #runCoverage 'Run test and check code coverage' #hasRunnable )
		( 'Run Failures' #runFailures 'Run all failures' #hasFailures )
		( 'Run Errors' #runErrors 'Run all errors' #hasErrors )
		( 'File out results' #fileOutResults 'File out test results' #hasFailuresOrErrors))! !

!TestRunner methodsFor: 'accessing-ui' stamp: 'lr 10/8/2005 18:39'!
extent
	^ 640 @ 480! !

!TestRunner methodsFor: 'accessing-ui' stamp: 'lr 1/20/2006 13:36'!
label
	^ 'Test Runner' ! !

!TestRunner methodsFor: 'actions' stamp: 'nice 10/20/2009 21:08'!
addDeclaredPackagesUnderTestTo: packages 
	classesSelected do: 
		[ :class | 
		(class class includesSelector: #packageNamesUnderTest) ifTrue: 
			[ class packageNamesUnderTest do: [ :name | packages add: (PackageInfo named: name) ] ] ]! !

!TestRunner methodsFor: 'actions'!
addMethodsUnderTestIn: packages to: methods 
	packages
		do: [:package | package isNil
				ifFalse: [package methods
						do: [:method | ((#(#packageNamesUnderTest #classNamesNotUnderTest ) includes: method methodSymbol)
									or: [method compiledMethod isAbstract
											or: [method compiledMethod refersToLiteral: #ignoreForCoverage]])
								ifFalse: [methods add: method]]]]! !

!TestRunner methodsFor: 'actions'!
collectCoverageFor: methods
	| wrappers suite |
	wrappers := methods collect: [ :each | TestCoverage on: each ].
	suite := self
		reset;
		suiteAll.
	
	[ wrappers do: [ :each | each install ].
	[ self runSuite: suite ] ensure: [ wrappers do: [ :each | each uninstall ] ] ] valueUnpreemptively.
	wrappers := wrappers reject: [ :each | each hasRun ].
	wrappers isEmpty 
		ifTrue: 
			[ UIManager default inform: 'Congratulations. Your tests cover all code under analysis.' ]
		ifFalse: 
			[ MessageSet 
				openMessageList: (wrappers collect: [ :each | each reference ])
				name: 'Not Covered Code (' , (100 - (100 * wrappers size // methods size)) printString , '% Code Coverage)' ].
	self saveResultInHistory! !

!TestRunner methodsFor: 'actions' stamp: 'lr 10/31/2005 17:42'!
debug: aTestCase
	self debugSuite: (TestSuite new
		addTest: aTestCase; 
		yourself).! !

!TestRunner methodsFor: 'actions' stamp: 'lr 10/31/2005 17:01'!
debugSuite: aTestSuite
	self basicRunSuite: aTestSuite do: [ :each | each debug ].! !

!TestRunner methodsFor: 'actions' stamp: 'lr 3/14/2010 21:13'!
excludeClassesNotUnderTestFrom: methods
	classesSelected
		do: [ :class | 
			(class class includesSelector: #classNamesNotUnderTest)
				ifTrue: [ 
					class classNamesNotUnderTest
						do: [ :className | 
							| theClass |
							theClass := Smalltalk globals classNamed: className.
							theClass
								ifNotNil: [ 
									theClass methods do: [ :each | methods remove: each methodReference ifAbsent: [  ] ].
									theClass class methods do: [ :each | methods remove: each methodReference ifAbsent: [  ] ] ] ] ] ]! !

!TestRunner methodsFor: 'actions'!
fileOutResults
	| fileName defaultFilename stream printer |
	"Save current test results into text file."
	"Generate a filename like 'tests_Pharo-1.1-11367-Beta_23_May_2010_9:19:20_am.txt' "
	defaultFilename := 	'tests_',
						SystemVersion current version, 
						'_', 
						(result timeStamp asString copyReplaceAll: ' ' with: '_'),
						'.txt'.
	fileName := UIManager default 
		request: 'Enter the file name' 
		initialAnswer: defaultFilename.
	
	stream := CrLfFileStream newFileNamed: fileName.	
	[result fileOutOn: stream] 
		ensure: [stream close].! !

!TestRunner methodsFor: 'actions'!
promptForPackages
	| packages |
	packages := (PackageOrganizer default packages
				reject: [:package | (package packageName beginsWith: 'Kernel')
						or: [(package packageName beginsWith: 'Collections')
								or: [(package packageName beginsWith: 'Exceptions')
										or: [(package packageName beginsWith: 'SUnit')
												or: [(package packageName beginsWith: 'System')
														or: [package packageName includesSubstring: 'Test' caseSensitive: false]]]]]])
				sort: [:a :b | a packageName < b packageName].
	packages := Array
				with: (UIManager default
						chooseFrom: (packages
								collect: [:package | package packageName])
						values: packages
						title: 'Select Package').
	^ packages! !

!TestRunner methodsFor: 'actions' stamp: 'lr 10/8/2005 22:52'!
reset
	self result: TestResult new; updateResults.! !

!TestRunner methodsFor: 'actions'!
runAll
	self reset; runSuite: self suiteAll.
	self saveResultInHistory! !

!TestRunner methodsFor: 'actions'!
runCoverage
	| packages methods |
	packages := Set new.
	self addDeclaredPackagesUnderTestTo: packages.
	packages isEmpty ifTrue: 
		[ packages := self promptForPackages ].
	methods := OrderedCollection new.
	self 
		addMethodsUnderTestIn: packages
		to: methods.
	self excludeClassesNotUnderTestFrom: methods.
	methods isEmpty ifTrue: 
		[ ^ UIManager default inform: 'No methods found for coverage analysis.' ].
	self collectCoverageFor: methods
! !

!TestRunner methodsFor: 'actions' stamp: 'lr 10/8/2005 23:02'!
runErrors
	self result instVarNamed: 'errors' put: OrderedCollection new.
	self runSuite: self suiteErrors.! !

!TestRunner methodsFor: 'actions' stamp: 'lr 10/27/2005 10:42'!
runFailures
	self result instVarNamed: 'failures' put: Set new.
	self runSuite: self suiteFailures.! !

!TestRunner methodsFor: 'actions' stamp: 'lr 10/31/2005 17:13'!
runProfiled
	MessageTally spyOn: [ self runAll ].! !

!TestRunner methodsFor: 'actions' stamp: 'lr 3/30/2009 14:50'!
runSuite: aTestSuite
	self basicRunSuite: aTestSuite do: [ :each | self runTest: each ].
	self updateResults

! !

!TestRunner methodsFor: 'actions' stamp: 'lr 11/3/2005 09:15'!
runTest: aTestCase
	aTestCase run: result.
	self updateStatus: true.! !

!TestRunner methodsFor: 'browsing'!
browseSelectedErrorTest

	errorSelected ifNil: [^self].
	self browseSelectedTest: errorSelected! !

!TestRunner methodsFor: 'browsing'!
browseSelectedFailedTest

	failedSelected ifNil: [^self].
	self browseSelectedTest: failedSelected! !

!TestRunner methodsFor: 'browsing'!
browseSelectedTest: aTest

	Browser fullOnClass: aTest class selector: aTest selector! !

!TestRunner methodsFor: 'building' stamp: 'tbn 7/29/2010 21:16'!
buildButtonsWith: aBuilder
	^ aBuilder pluggablePanelSpec new
		model: self;
		layout: #horizontal;
		children: (self buttons collect: [ :each |
			aBuilder pluggableButtonSpec new
				model: self; 
				label: each first;
				action: each second;
				help: each third;
				enabled: (each at: 4);
				yourself ]);
		yourself.! !

!TestRunner methodsFor: 'building' stamp: 'lr 10/31/2005 15:12'!
buildCategoriesWith: aBuilder
	^ aBuilder pluggableMultiSelectionListSpec new
		model: self;
		list: #categoryList;
		menu: #categoryMenu:;
		getIndex: #categorySelected;
		setIndex: #categorySelected:;
		getSelectionList: #categoryAt:;
		setSelectionList: #categoryAt:put:;
		yourself.! !

!TestRunner methodsFor: 'building' stamp: 'lr 10/17/2005 09:13'!
buildClassesWith: aBuilder
	^ aBuilder pluggableMultiSelectionListSpec new
		model: self;
		list: #classList;
		menu: #classMenu:;
		getIndex: #classSelected;
		setIndex: #classSelected:;
		getSelectionList: #classAt:;
		setSelectionList: #classAt:put:;
		yourself.! !

!TestRunner methodsFor: 'building' stamp: 'lr 10/21/2008 18:04'!
buildErrorListWith: aBuilder
	^ aBuilder pluggableListSpec new
		model: self;
		name: 'Error List';
		list: #errorList; 
		menu: #errorMenu:;
		getIndex: #errorSelected; 
		setIndex: #errorSelected:;
		yourself.! !

!TestRunner methodsFor: 'building' stamp: 'lr 10/21/2008 18:04'!
buildFailureListWith: aBuilder
	^ aBuilder pluggableListSpec new
		model: self;
		name: 'Failure List';
		list: #failedList; 
		menu: #failureMenu:;
		getIndex: #failedSelected; 
		setIndex: #failedSelected:;
		yourself.! !

!TestRunner methodsFor: 'building' stamp: 'lr 10/21/2008 18:05'!
buildStatusWith: aBuilder
	^ aBuilder pluggableInputFieldSpec new
		model: self;
		menu: #statusMenu:;
		color: #statusColor;
		getText: #statusText;
		yourself.! !

!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:45'!
buildWith: aBuilder
	| window |
	window := aBuilder pluggableWindowSpec new
		model: self; label: self label; extent: self extent;
		children: (OrderedCollection new 
			add: ((self buildCategoriesWith: aBuilder)
				frame: self categoriesFrame;
				yourself);
			add: ((self buildClassesWith: aBuilder)
				frame: self classesFrame;
				yourself);
			add: ((self buildStatusWith: aBuilder)
				frame: self statusFrame;
				yourself);
			add: ((self buildFailureListWith: aBuilder)
				frame: self failureListFrame;
				yourself);
			add: ((self buildErrorListWith: aBuilder)
				frame: self errorListFrame;
				yourself);
			add: ((self buildButtonsWith: aBuilder)
				frame: self buttonsFrame;
				yourself);
			yourself);
		yourself.
	^ aBuilder build: window.! !

!TestRunner methodsFor: 'building'!
buttonHeight
	^ self theme buttonMinHeight + 25! !

!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:45'!
buttonsFrame
	^LayoutFrame new
		leftFraction: 0 offset: 0;
		topFraction: 1 offset: self buttonHeight negated;
		rightFraction: 1 offset: 0;
		bottomFraction: 1 offset: 0! !

!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:48'!
categoriesFrame
	^LayoutFrame new
		leftFraction: 0 offset: 0;
		topFraction: 0 offset: 0;
		rightFraction: 0.25 offset: 0;
		bottomFraction: 1 offset: self buttonHeight negated + 4! !

!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:48'!
classesFrame
	^LayoutFrame new
		leftFraction: 0.25 offset: 0;
		topFraction: 0 offset: 0;
		rightFraction: 0.5 offset: 0;
		bottomFraction: 1 offset: self buttonHeight negated + 4! !

!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:49'!
errorListFrame
	^LayoutFrame new
		leftFraction: 0.5 offset: 0;
		topFraction: 0.5 offset: 0;
		rightFraction: 1 offset: 0;
		bottomFraction: 1 offset: self buttonHeight negated + 4! !

!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:43'!
failureListFrame
	^LayoutFrame new
		leftFraction: 0.5 offset: 0;
		topFraction: 0 offset: self statusHeight;
		rightFraction: 1 offset: 0;
		bottomFraction: 0.5 offset: 0! !

!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:41'!
statusFrame
	^LayoutFrame new
		leftFraction: 0.5 offset: 0;
		topFraction: 0 offset: 0;
		rightFraction: 1 offset: 0;
		bottomFraction: 0 offset: self statusHeight! !

!TestRunner methodsFor: 'building'!
statusHeight
	^ self theme textFont height * 2 + 5! !

!TestRunner methodsFor: 'history saving'!
hasProgress

	result classesTested do: [:cls |
		(cls class methodDictionary includesKey: #lastStoredRun)
			ifTrue: [^ true]].
	^ false! !

!TestRunner methodsFor: 'history saving'!
hasResults

	^ result notNil! !

!TestRunner methodsFor: 'history saving'!
historyMenuList
	^ {'** save current result **'}, (self previousRun collect: [:ts | ts printString])! !

!TestRunner methodsFor: 'history saving'!
previousRun

	^ previousRun ifNil: [ previousRun := OrderedCollection new ]! !

!TestRunner methodsFor: 'history saving'!
saveResultInHistory
	result dispatchResultsIntoHistory! !

!TestRunner methodsFor: 'history saving'!
showDiffWith: aTestResult
	| string diff |

	diff := result diff: aTestResult.
	string := String streamContents: [:str|
		str nextPutAll: '----------------'; cr.
		str nextPutAll: 'Diff between current result with: ', aTestResult asString; cr.
		str nextPutAll: 'New passed: '.
		diff first do: [:s| str nextPutAll: s printString, ' '].
		str cr.
		str nextPutAll: 'New failures: '.
		diff second do: [:s| str nextPutAll: s printString, ' '].
		str cr.
		
		str nextPutAll: 'New errors: '.
		diff third do: [:s| str nextPutAll: s printString, ' '].
		str cr].
	
	Workspace new contents: string; openLabel: 'SUnit Progress'
	! !

!TestRunner methodsFor: 'history saving'!
showHistoryMenu
	| selectionIndex selectedPreviousResult actionIndex |
	selectionIndex := UIManager default chooseFrom: self historyMenuList title: 'History:'.

	"We pressed outside the menu"
	selectionIndex isZero ifTrue: [ ^ self ]. 				

	"save current result is selected"
	selectionIndex = 1 ifTrue: [ self previousRun addFirst: result. ^ self ]. 			

	selectedPreviousResult := self previousRun at: (selectionIndex - 1).
 	actionIndex := (UIManager default chooseFrom: #('delete' 'show diff')  title:  'Action:').
	actionIndex = 1 ifTrue: [ self previousRun remove: selectedPreviousResult. ^ self ].
	actionIndex = 2 ifTrue: [ self showDiffWith: selectedPreviousResult].	! !

!TestRunner methodsFor: 'history saving' stamp: 'nice 1/5/2010 15:59'!
showProgress
	| testCaseClasses d string |
	testCaseClasses := (self suiteAll tests collect: [:testCase | testCase class]) asSet.
	
	"At the end of the algorithm, d will contains all the diff between what was saved and the current result"
	d := Dictionary new.
	d at: #passed put: OrderedCollection new.
	d at: #failures put: OrderedCollection new.
	d at: #errors put: OrderedCollection new.

	testCaseClasses do: [ :cls | | t |
		(cls class methodDict includesKey: #lastStoredRun)
			ifTrue: [t := cls lastStoredRun.
					(t at: #passed) do: [:s | 	
											(result isErrorFor: cls selector: s)
												ifTrue: [(d at: #errors) add: {cls . s}].
											(result isFailureFor: cls selector: s)
												ifTrue: [(d at: #failures) add: {cls . s}]  ].
											
					(t at: #failures) do: [:s | (result isPassedFor: cls selector: s)
												ifTrue: [(d at: #passed) add: {cls . s}].
											(result isErrorFor: cls selector: s)
												ifTrue: [(d at: #errors) add: {cls . s}]].
											
					(t at: #errors) do: [:s | 	(result isPassedFor: cls selector: s)
												ifTrue: [(d at: #passed) add: {cls . s}].
											(result isFailureFor: cls selector: s)
												ifTrue: [(d at: #failures) add: {cls . s}]]]].
		
			
	string := String streamContents: [:str|
		str nextPutAll: '----------------'; cr.
		str nextPutAll: 'Diff between current result and saved result'; cr.
		str nextPutAll: 'New passed: '.
		(d at: #passed) do: [:s| str nextPutAll: s printString, ' '].
		str cr.
		str nextPutAll: 'New failures: '.
		(d at: #failures) do: [:s| str nextPutAll: s printString, ' '].
		str cr.
		
		str nextPutAll: 'New errors: '.
		(d at: #errors) do: [:s| str nextPutAll: s printString, ' '].
		str cr].
	
	Workspace new contents: string; openLabel: 'SUnit Progress' string.

	! !

!TestRunner methodsFor: 'history saving'!
storeResultIntoTestCases

	result classesTested do: [:testCaseCls | testCaseCls generateLastStoredRunMethod ]
! !

!TestRunner methodsFor: 'initialization' stamp: 'lr 3/22/2006 19:36'!
initialize
	super initialize.
	failedList := errorList := Array new.
	SystemChangeNotifier uniqueInstance 
		notify: self ofSystemChangesOfItem: #class change: #Added using: #update;
		notify: self ofSystemChangesOfItem: #category change: #Added using: #update;
		notify: self ofSystemChangesOfItem: #class change: #Removed using: #update;
		notify: self ofSystemChangesOfItem: #category change: #Removed using: #update;
		notify: self ofSystemChangesOfItem: #class change: #Renamed using: #update;
		notify: self ofSystemChangesOfItem: #category change: #Renamed using: #update;
		notify: self ofSystemChangesOfItem: #class change: #Recategorized using: #update;
		notify: self ofSystemChangesOfItem: #category change: #Recategorized using: #update.
	self update; reset! !

!TestRunner methodsFor: 'processing' stamp: 'lr 10/31/2005 17:43'!
basicRunSuite: aTestSuite do: aBlock
	self basicSetUpSuite: aTestSuite.
	[ aTestSuite name isEmptyOrNil
		ifTrue: [ aTestSuite tests do: aBlock ]
		ifFalse: [ aTestSuite tests do: aBlock displayingProgress: aTestSuite name ] ]
			ensure: [ self basicTearDownSuite: aTestSuite ].
	! !

!TestRunner methodsFor: 'processing' stamp: 'lr 10/27/2005 10:04'!
basicSetUpSuite: aTestSuite
	aTestSuite resources do: [ :each |
		each isAvailable
			ifFalse: [ each signalInitializationError ] ].! !

!TestRunner methodsFor: 'processing' stamp: 'lr 10/27/2005 10:04'!
basicTearDownSuite: aTestSuite
	aTestSuite resources do: [ :each | each reset ].! !

!TestRunner methodsFor: 'testing' stamp: 'lr 11/21/2005 13:19'!
hasErrors
	^ result hasErrors.! !

!TestRunner methodsFor: 'testing' stamp: 'lr 11/21/2005 13:19'!
hasFailures
	^ result hasFailures.! !

!TestRunner methodsFor: 'testing'!
hasFailuresOrErrors
	^ result hasFailures | result hasErrors.! !

!TestRunner methodsFor: 'testing' stamp: 'lr 11/21/2005 13:19'!
hasRunnable
	^ classesSelected notEmpty.! !

!TestRunner methodsFor: 'theme'!
theme
	"Answer the ui theme that provides controls."

	^UITheme current! !

!TestRunner methodsFor: 'updating' stamp: 'lr 3/22/2006 19:35'!
update
	self updateCategories; updateClasses! !

!TestRunner methodsFor: 'updating' stamp: 'lr 10/31/2005 15:45'!
updateCategories
	categories := self findCategories.
	categoriesSelected := categoriesSelected isNil
		ifTrue: [ Set new ]
		ifFalse: [
			categoriesSelected
				select: [ :each | categories includes: each ] ].
	self changed: #categoryList; changed: #categorySelected.! !

!TestRunner methodsFor: 'updating' stamp: 'lr 1/20/2009 14:48'!
updateClasses
	| classesForCategories |
	classesForCategories := self findClassesForCategories: categoriesSelected.
	classes := classesForCategories asArray
		sort: [ :a :b | self sortClass: a before: b ].
	classIndex := 0.
	classesSelected := classesSelected isNil
		ifTrue: [ classesForCategories ]
		ifFalse: [ 
			classesSelected
				select: [ :each | classesForCategories includes: each ] ].
	self changed: #classList; changed: #classSelected; changed: #hasRunnable.! !

!TestRunner methodsFor: 'updating'!
updateResults
	"<lint: #expect rule: #guardingClause>"
	"<lint: #expect rule: #longMethods>"

	self updateStatus: false.
	failedList size = result failures size ifFalse: [
		failedList := result failures asArray
			sort: [ :a :b | a printString <= b printString ].
		failedSelected := nil.
		self 
			changed: #failedList; 
			changed: #failedSelected;
			changed: #hasFailures;
			changed: #hasProgress;
			changed: #hasFailuresOrErrors  ].
	errorList size = result errors size ifFalse: [
		errorList := result errors asArray
			sort: [ :a :b | a printString <= b printString ].
		errorSelected := nil.
		self 
			changed: #errorList; 
			changed: #errorSelected;
			changed: #hasErrors;
			changed: #hasProgress;
			changed: #hasFailuresOrErrors  ].! !

!TestRunner methodsFor: 'updating' stamp: 'lr 11/3/2005 09:28'!
updateStatus: aBoolean
	"Update the status display, at most once a second if aBoolean is true."

	(aBoolean and: [ lastUpdate = Time totalSeconds ])
		ifTrue: [ ^ self ].
	self changed: #statusText; changed: #statusColor.
	lastUpdate := Time totalSeconds.! !

!TestRunner methodsFor: 'utilities'!
findCategories
	| visible |
	visible := Set new.
	self baseClass withAllSubclassesDo: [ :each |
		each category ifNotNil: [
			visible add: each category ] ].
	^ Array streamContents: [ :stream |
		Smalltalk organization categories do: [ :each |
			(visible includes: each)
				ifTrue: [ stream nextPut: each ] ] ].! !

!TestRunner methodsFor: 'utilities' stamp: 'lr 3/14/2010 21:13'!
findClassesForCategories: aCollection
	| items |
	aCollection isEmpty
		ifTrue: [ ^ self baseClass withAllSubclasses asSet ].
	items := aCollection
		gather: [ :category | 
			((Smalltalk organization listAtCategoryNamed: category) collect: [ :each | Smalltalk globals at: each ])
				select: [ :each | each includesBehavior: self baseClass ] ].
	^ items asSet! !

!TestRunner methodsFor: 'utilities' stamp: 'lr 10/10/2005 08:43'!
sortClass: aFirstClass before: aSecondClass
	| first second |
	first := aFirstClass withAllSuperclasses reversed.
	second := aSecondClass withAllSuperclasses reversed.
	1 to: (first size min: second size) do: [ :index | 
		(first at: index) == (second at: index)
			ifFalse: [ ^ (first at: index) name <= (second at: index) name ] ].
	^ second includes: aFirstClass.! !

!TestRunner methodsFor: 'private' stamp: 'lr 3/14/2010 21:13'!
browserEnvironment
	^ Smalltalk globals classNamed: #BrowserEnvironment! !

!TestRunner methodsFor: 'private' stamp: 'lr 10/27/2005 10:32'!
label: aString forSuite: aTestSuite
	^ String streamContents: [ :stream |
		stream nextPutAll: 'Running '; print: aTestSuite tests size; space; nextPutAll: aString.
		aTestSuite tests size > 1 ifTrue: [ stream nextPut: $s ] ]. ! !

!TestRunner methodsFor: 'private' stamp: 'lr 12/21/2005 10:39'!
perform: selector orSendTo: otherTarget
	"<lint: #expect rule: #badMessage rational: 'this is a common morphic pattern'>"
	
	^ (self respondsTo: selector)
		ifTrue: [ self perform: selector ]
		ifFalse: [ super perform: selector orSendTo: otherTarget ].! !

!TestRunner methodsFor: 'private' stamp: 'lr 3/22/2006 19:26'!
windowIsClosing
	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self! !

!TestRunner commentStamp: '<historical>' prior: 0!
"<lint: #ignore rule: #classNotReferenced rational: 'this view is only accessed from menus'>

!
!TestRunner class methodsFor: 'initialization'!
registerAsDefaultTestRunner
	TestRunnerBrowser default: self.! !

!TestRunner class methodsFor: 'instance-creation' stamp: 'KR 4/28/2006 21:07'!
build
	^ ToolBuilder build: self new.! !

!TestRunner class methodsFor: 'instance-creation' stamp: 'lr 10/8/2005 18:35'!
open
	^ ToolBuilder open: self new.! !

!TestRunner class methodsFor: 'window color'!
patchworkUIThemeColor
	"Answer a default color for UI themes that make use of different colors for Browser, MessageList etc..."

	^ Color brown whiter! !

!TestSuite methodsFor: 'accessing'!
addTest: aTest
	self tests add: aTest! !

!TestSuite methodsFor: 'accessing'!
addTests: aCollection 
	aCollection do: [:eachTest | self addTest: eachTest]! !

!TestSuite methodsFor: 'accessing'!
defaultResources
	^self tests
		inject: OrderedCollection new
		into:
			[:coll :testCase |
			testCase resources do:
				[:each |
				(coll includes: each) ifFalse: [coll add: each]].
			coll]! !

!TestSuite methodsFor: 'accessing'!
name

	^name! !

!TestSuite methodsFor: 'accessing'!
name: aString

	name := aString! !

!TestSuite methodsFor: 'accessing'!
resources
	resources isNil ifTrue: [resources := self defaultResources].
	^resources! !

!TestSuite methodsFor: 'accessing'!
resources: someOrderedTestResourceClasses
	"The parameter should understand reverseDo: and should not contain duplicates."

	resources := someOrderedTestResourceClasses! !

!TestSuite methodsFor: 'accessing'!
tests
	tests isNil ifTrue: [tests := OrderedCollection new].
	^tests! !

!TestSuite methodsFor: 'dependencies' stamp: 'md 2/22/2006 14:24'!
addDependentToHierachy: anObject
	self addDependent: anObject.
	self tests do: [ :each | each addDependentToHierachy: anObject]
			! !

!TestSuite methodsFor: 'dependencies' stamp: 'md 2/22/2006 14:24'!
removeDependentFromHierachy: anObject
	self removeDependent: anObject.
	self tests do: [ :each | each removeDependentFromHierachy: anObject]
			! !

!TestSuite methodsFor: 'running'!
resourceClass

	^TestResource! !

!TestSuite methodsFor: 'running'!
resultClass

	^ TestResult! !

!TestSuite methodsFor: 'running'!
run
	| result |
	result := self resultClass new.
	[self run: result]
		ensure: [self resourceClass resetResources: self resources].
	^result! !

!TestSuite methodsFor: 'running'!
run: aResult 
	self tests do: [:each | 
		self changed: each.
		each run: aResult].
			! !

!TestSuite commentStamp: '<historical>' prior: 0!
This is a Composite of Tests, either TestCases or other TestSuites. The top-level protocol is #run.  This creates aTestResult and sends
	self run: aTestResult.
then ensures that any TestResources made available during the run are reset.  These, and the dependencies protocol, are common between this and TestCase.!
!TestSuite class methodsFor: 'instance creation'!
named: aString

	^self new
		name: aString;
		yourself! !

!Text methodsFor: 'converting' stamp: 'ssa 1/20/2010 10:35'!
asParagraphWithStyle: aTextStyle
	"Answer a Paragraph whose text is the receiver."

	^Paragraph withText: self style: aTextStyle! !

!Text methodsFor: 'emphasis' stamp: 'ssa 11/24/2009 19:00'!
bold
	"Force this whole text to be bold."
	string size = 0 ifTrue: [^self].
	self makeBoldFrom: 1 to: string size! !

!Text methodsFor: 'emphasis' stamp: 'ssa 8/22/2009 17:47'!
emphasizeFrom: start to: stop with: emphasis 
	"Set the emphasis for characters in the interval start-stop."

	runs _ 
		runs
			copyReplaceFrom: start
			to: stop
			with: (RunArray new: stop - start + 1 withAll: emphasis)! !

!Text methodsFor: 'emphasis' stamp: 'ssa 11/24/2009 19:01'!
italic
	"Force this whole text to be italic."
	string size = 0 ifTrue: [^self].
	self makeItalicFrom: 1 to: string size! !

!Text methodsFor: 'emphasis' stamp: 'ssa 11/24/2009 19:01'!
makeItalicFrom: start to: stop

	^ self addAttribute: TextEmphasis italic from: start to: stop! !

!Text methodsFor: 'emphasis' stamp: 'ssa 11/27/2009 01:23'!
makeUnderlineFrom: start to: stop

	^ self addAttribute: TextEmphasis underline from: start to: stop! !

!Text methodsFor: 'emphasis' stamp: 'ssa 11/24/2009 19:03'!
makeUnderlinedFrom: start to: stop

	^ self addAttribute: TextEmphasis underlined from: start to: stop! !

!Text methodsFor: 'emphasis' stamp: 'ssa 11/27/2009 01:23'!
underline 
	"Force this whole text to be underline."
	string size = 0 ifTrue: [^self].
	self makeUnderlineFrom: 1 to: string size! !

!Text methodsFor: 'emphasis' stamp: 'ssa 11/24/2009 19:03'!
underlined
	"Force this whole text to be underlined."
	string size = 0 ifTrue: [^self].
	self makeUnderlinedFrom: 1 to: string size! !

!Text methodsFor: 'attributes' stamp: 'ssa 11/27/2009 01:09'!
font: aFont
	self addAttribute: (TextFontReference toFont: aFont)! !

!Text methodsFor: 'attributes' stamp: 'ssa 11/27/2009 01:28'!
fontName: fname pointSize: ptsize
	"  ('Hello World' asText fontName: #Accuny pointSize: 24) asParagraph display"
	| style sizes findex font availableSize |
	style _ TextStyle named:fname.
	sizes _ TextStyle fontPointSizesFor: fname.
	availableSize _ sizes detect:[:each| each >= ptsize] ifNone:[sizes last].
	findex _ sizes indexOf: availableSize.
	font _ style fontAt:findex.
	self font: font 
	
"Accuat  #(18 )
Accujen  #(9 10 12 14 18 24 )
Accula  #(12 24 )
Accumon  #(9 10 12 )
Accuny  #(9 10 12 14 18 24 )
Accusf  #(18 )
Accushi  #(12 )
Accuve  #(12 14 )
Atlanta  #(11 22 )
DefaultFixedTextStyle  #(11 22 )
DefaultTextStyle  #(9 10 12 14 18 24 )"! !

!Text methodsFor: 'attributes' stamp: 'ssa 11/27/2009 00:56'!
fontNumber: anInteger

	self addAttribute: (TextFontChange fontNumber:anInteger)! !

!TextBlockDoIt methodsFor: 'accessing' stamp: 'ssa 9/15/2009 09:37'!
actionBlock
	"Answer the value of actionBlock"

	actionBlock isNil ifTrue:[self actionBlock: [self notify:'default action block']].
	^ actionBlock! !

!TextBlockDoIt methodsFor: 'accessing' stamp: 'ssa 9/15/2009 09:36'!
actionBlock: anObject
	"Set the value of actionBlock"

	actionBlock _ anObject! !

!TextBlockDoIt methodsFor: 'activating' stamp: 'ssa 9/15/2009 09:38'!
actOnClickFor: anObject
	
	self actionBlock value.
	^true! !

!TextStyle class methodsFor: 'user interface' stamp: 'ssa 9/4/2009 21:20'!
mvcPromptForFont: aPrompt 
	"MVC Only!! prompt for a font and if one is provided, send it to aTarget using a message with selector aSelector."
	| aMenu aChoice aStyle namesAndSizes |
	"TextStyle mvcPromptForFont: 'Choose system font style' "
	aMenu _ CustomMenu new.
	self actualTextStyles keys do:
		[:styleName |
			aMenu add: styleName action: styleName].
	aChoice _ aMenu startUpWithCaption: aPrompt.
	aChoice ifNil: [^ self].
	aMenu _ CustomMenu new.
	aStyle _ self named: aChoice.
	(namesAndSizes _ aStyle fontNamesWithPointSizes) do:
		[:aString | aMenu add: aString action: aString].
	aChoice _ aMenu startUpWithCaption: nil.
	aChoice ifNil: [^ self].
	^aStyle fontAt: (namesAndSizes indexOf: aChoice).
	! !

!TextStyle class methodsFor: 'user interface' stamp: 'ssa 9/4/2009 21:11'!
mvcPromptForStyle: aPrompt andSendTo: aTarget withSelector: aSelector
	"MVC Only!! prompt for a font and if one is provided, send it to aTarget using a message with selector aSelector."
	| aMenu aChoice aStyle namesAndSizes aFont |
	"TextStyle mvcPromptForFont: 'Choose system font style' andSendTo: TextStyle withSelector: #setSystemFontTo:"
	aMenu _ CustomMenu new.
	self actualTextStyles keys do:
		[:styleName |
			aMenu add: styleName action: styleName].
	aChoice _ aMenu startUpWithCaption: aPrompt.
	aChoice ifNil: [^ self].
	aMenu _ CustomMenu new.
	aStyle _ self named: aChoice.
	(namesAndSizes _ aStyle fontNamesWithPointSizes) do:
		[:aString | aMenu add: aString action: aString].
	aChoice _ aMenu startUpWithCaption: nil.
	aChoice ifNil: [^ self].
	aTarget perform: aSelector with: aStyle! !

!Time class methodsFor: '*SMark-squeak protocol' stamp: 'sm 5/25/2011 14:26'!
milliseconds: currentTime since: lastTime
	"Answer the elapsed time since last recorded in milliseconds.
	Compensate for rollover."

	| delta |
	delta := currentTime - lastTime.
	^ delta < 0
		ifTrue: [SmallInteger maxVal + delta]
		ifFalse: [delta]
! !

!TranscriptStream methodsFor: 'initialization' stamp: 'ssa 9/3/2008 11:13'!
openLabel: aString 
	"Open a window on this transcriptStream"

	| topView codeView |

	topView _ (StandardSystemView new) model: self.
	topView borderWidth: 1.
	topView label: aString.
	topView minimumSize: 100 @ 50.

	codeView _ PluggableTextView on: self text: nil accept: nil
					readSelection: nil menu: #codePaneMenu:shifted:.
	codeView window: (0@0 extent: 200@200).
	topView addSubView: codeView.
	topView controller open! !

!TranscriptStream methodsFor: '*Ly' stamp: 'ssa 7/16/2010 17:06'!
nextPutAll: stuff
	self showInConsole ifTrue:[stuff printConsole].
	super nextPutAll: stuff.
! !

!TranscriptStream methodsFor: '*Ly' stamp: 'dmu 3/22/2010 02:58'!
resetSemaphore
	AccessSema signal! !

!TranscriptStream methodsFor: '*RVMBootstrap' stamp: 'ssa 3/24/2010 14:03'!
showInConsole

	^self class showInConsole! !

!TranscriptStream methodsFor: '*RVMBootstrap' stamp: 'ssa 3/24/2010 14:04'!
showInConsole: aBoolean

	^self class showInConsole: aBoolean! !

!TranscriptStream methodsFor: '*RVMBootstrap' stamp: 'ssa 7/5/2010 13:02'!
showInConsoleSwitch
	"Transcript showInConsoleSwitch demo"
	^RVMCheckBoxView on: nil label: 'Show Transcript in Console' 
						checkState: [Transcript showInConsole] 
						whenChecked: [Transcript showInConsole: true] 
						whenUnchecked: [Transcript showInConsole: false].! !

!TranscriptStream methodsFor: '*RVMBootstrap' stamp: 'ssa 3/24/2010 14:04'!
toggleShowInConsole

	self class toggleShowInConsole! !

!TranscriptStream methodsFor: '*RVM' stamp: 'StefanMarr 7/14/2011 17:44'!
nextPut: chr
	"Evil hack for some more platform independence...."
	chr = Character lf ifTrue: [ super nextPut: Character cr.]
					ifFalse: [super nextPut: chr ].! !

!TranscriptStream class methodsFor: '*RVMBootstrap' stamp: 'ssa 3/24/2010 13:58'!
showInConsole
	"A flag to support mirroring the transcript in the RVM console"
	ShowInConsole isNil ifTrue:[ShowInConsole _ false].
	^ShowInConsole! !

!TranscriptStream class methodsFor: '*RVMBootstrap' stamp: 'ssa 3/24/2010 13:58'!
showInConsole: aBoolean
	"A flag to support mirroring the transcript in the RVM console"
	ShowInConsole _ aBoolean! !

!TranscriptStream class methodsFor: '*RVMBootstrap' stamp: 'ssa 3/24/2010 13:59'!
toggleShowInConsole

	self showInConsole: self showInConsole not! !

!Transcripter methodsFor: 'command line' stamp: 'ssa 7/7/2010 19:30'!
readEvalPrint
	| line okToRevert |
	Sensor flushKeyboard.
	okToRevert _ true.
	[#('quit' 'exit' 'done' 'restart' 'refresh' 'revert') includes: (line _ self request: '>') ]
		whileFalse:
		[line = 'refresh'
			ifTrue:[ScheduledControllers restore halt]
			ifFalse:[line = 'restart'
				ifTrue:[ProcessorScheduler removeAllPossible]
				ifFalse:[line = 'revert'
					ifTrue: [okToRevert
						ifTrue: [Utilities revertLastMethodSubmission.
							self cr; show: 'reverted: ' , Utilities mostRecentlySubmittedMessage.
							okToRevert _ false]
					ifFalse: [self cr; show: 'Only one level of revert currently supported']]
			ifFalse: [self cr; show: ([Compiler evaluate: line] ifError: [:err :ex | err])]]]]! !

!Transcripter class methodsFor: 'utilities' stamp: 'ssa 6/11/2010 13:29'!
emergencyEvaluator
	(Transcripter newInFrame: (0@0 corner: 320@200))
		show: 'Type ''revert'' to revert your last method change.
Type ''restart'' to restart the processor scheduler.
Type ''refresh'' to refresh the display.
Type ''exit'' to exit the emergency evaluator.';
		readEvalPrint! !

!TransportFormat methodsFor: 'transporter' stamp: 'ads 12/23/2010 13:47'!
transporter
	^ transporter! !

!TransportFormat methodsFor: 'transporter' stamp: 'ads 12/23/2010 13:47'!
transporter: t
	transporter := t.! !

!TransportFormat methodsFor: 'root directory' stamp: 'ads 1/6/2011 13:13'!
createRoot
	self rootDirectory: ( self createDir: self rootName in: transporter baseDirectory mustBeNew: true )! !

!TransportFormat methodsFor: 'root directory' stamp: 'dmu 8/23/2010 14:04'!
rootDirectory
	"Answer the value of rootDirectory"

	rootDirectory isNil ifTrue:[self rootDirectory: nil].
	^ rootDirectory! !

!TransportFormat methodsFor: 'root directory'!
rootDirectory: anObject
	"Set the value of rootDirectory"

	rootDirectory := anObject! !

!TransportFormat methodsFor: 'root directory' stamp: 'dmu 8/23/2010 14:00'!
rootName
	"Answer the value of rootName"

	rootName isNil ifTrue:[self rootName: 'root'].
	^ rootName! !

!TransportFormat methodsFor: 'root directory'!
rootName: anObject
	"Set the value of rootName"

	rootName := anObject! !

!TransportFormat methodsFor: 'directories' stamp: 'dmu 8/23/2010 14:35'!
classCategoryDirFor: cat
	^ self createDir: cat in: self rootDirectory mustBeNew: false! !

!TransportFormat methodsFor: 'directories'!
createDir: leafName in: parentDir mustBeNew: mustBeNew
	| d validLeafName |
	validLeafName := self validNameForDir: leafName in: parentDir.
	leafName asString = validLeafName ifFalse: [Transcript show: 'Warning: renamed directory ', leafName asString, ' to ', validLeafName; cr].
	d := parentDir directoryNamed: validLeafName.
	(mustBeNew and: [d exists]) ifTrue: [| oldDirName oldDir |
		oldDirName := validLeafName, '.old'.
		oldDir := parentDir directoryNamed: oldDirName.
		oldDir exists ifTrue: [oldDir recursiveDelete].
		Transcript show: d fullName, ' already exists. Renaming it to ', oldDirName; cr.
		parentDir rename: validLeafName toBe: oldDirName.
		d exists ifTrue: [self error: 'Assertion failure; the directory should not exist anymore, we just tried to rename it.'].
	].
	d exists ifFalse: [d assureExistence].
	^ d
! !

!TransportFormat methodsFor: 'directories' stamp: 'ads 12/3/2010 12:04'!
validNameForDir:  leafName in: parentDir
	"MacOS doesn't like slashes in directory names. -- Adam"
	^ leafName asString replaceAll: $/ with: $-! !

!TransportFormat methodsFor: 'saving' stamp: 'ads 1/6/2011 13:14'!
savePackage: p
	self createRoot.
	self saveScriptForLoadingPackageBackIn: p.
	self saveAllClassesForPackage: p.
	self saveAllExtensionMethodsForPackage: p.! !

!TransportFormat methodsFor: 'saving methods' stamp: 'ads 12/10/2010 12:26'!
saveAllExtensionMethodsForPackage: p
	self subclassResponsibility! !

!TransportFormat methodsFor: 'saving classes' stamp: 'ads 12/14/2010 14:14'!
saveAllClassesForPackage: p
	p classes asArray
		do: [:cls | self saveClass: cls forPackage: p]
		displayingProgress: 'Saving ', p name, ' classes'.
! !

!TransportFormat methodsFor: 'saving classes' stamp: 'ads 12/2/2010 15:24'!
saveClass: cls forPackage: p
	self subclassResponsibility! !

!TransportFormat methodsFor: 'loading'!
classesInOrderForLoading: p
	| extensionClassNames extensionClasses coreClasses coreClassNames |
	"Gotta sort them to make sure superclassOrder: always puts them in canonical order."
	coreClassNames := (p classes collect: [:cls | cls theNonMetaClass name]) asSet asArray sort.
	extensionClassNames := (p extensionClasses collect: [:cls | cls theNonMetaClass name]) asSet asArray sort.
	coreClasses := coreClassNames collect: [:n | Smalltalk classNamed: n].
	extensionClasses := extensionClassNames collect: [:n | Smalltalk classNamed: n].
	^ self transporter fiddleWithClassLoadingOrder: extensionClasses, (ChangeSet superclassOrder: coreClasses)! !

!TransportFormat methodsFor: 'loading' stamp: 'ads 12/10/2010 12:27'!
saveScriptForLoadingPackageBackIn: p
	self subclassResponsibility! !

!TransportFormat methodsFor: 'preamble and postscript' stamp: 'ads 12/14/2010 12:15'!
postscriptBlock
	^ postscriptBlock! !

!TransportFormat methodsFor: 'preamble and postscript' stamp: 'ads 12/14/2010 12:15'!
postscriptBlock: aBlock
	postscriptBlock := aBlock.! !

!TransportFormat methodsFor: 'preamble and postscript' stamp: 'ads 12/10/2010 12:39'!
preambleBlock
	^ preambleBlock! !

!TransportFormat methodsFor: 'preamble and postscript' stamp: 'ads 12/10/2010 12:39'!
preambleBlock: aBlock
	preambleBlock := aBlock.! !

!Transporter methodsFor: 'accessing' stamp: 'ads 1/4/2011 15:56'!
baseDirectory
	^ baseDirectory ifNil: [FileDirectory default]! !

!Transporter methodsFor: 'accessing' stamp: 'ads 1/4/2011 15:56'!
baseDirectory: aDirectory
	baseDirectory := aDirectory.! !

!Transporter methodsFor: 'accessing' stamp: 'ads 12/10/2010 11:54'!
package
	^ package! !

!Transporter methodsFor: 'accessing'!
package: anObject
	package := anObject! !

!Transporter methodsFor: 'accessing' stamp: 'ads 12/14/2010 12:30'!
postscriptBlock
	^ postscriptBlock! !

!Transporter methodsFor: 'accessing' stamp: 'ads 12/14/2010 12:31'!
postscriptBlock: aBlock
	postscriptBlock := aBlock.! !

!Transporter methodsFor: 'accessing' stamp: 'ads 12/14/2010 12:31'!
preambleBlock
	^ preambleBlock! !

!Transporter methodsFor: 'accessing' stamp: 'ads 12/14/2010 12:31'!
preambleBlock: aBlock
	preambleBlock := aBlock.! !

!Transporter methodsFor: 'accessing' stamp: 'sm 7/8/2011 23:14'!
subTransporters: anArrayOfTransporters
	subTransporters := anArrayOfTransporters! !

!Transporter methodsFor: 'accessing' stamp: 'ads 12/10/2010 11:54'!
team
	^ team! !

!Transporter methodsFor: 'accessing' stamp: 'ads 12/10/2010 11:54'!
team: anObject
	team _ anObject! !

!Transporter methodsFor: 'accessing' stamp: 'ads 12/10/2010 12:08'!
transportFormatClass
	^ transportFormatClass ifNil: [OneFilePerClass]! !

!Transporter methodsFor: 'accessing' stamp: 'ads 12/10/2010 12:08'!
transportFormatClass: anObject
	transportFormatClass _ anObject! !

!Transporter methodsFor: 'reverting' stamp: 'ads 12/10/2010 13:04'!
revert
	self team revertPackage: self package.! !

!Transporter methodsFor: 'loading' stamp: 'ads 12/23/2010 13:50'!
fiddleWithClassLoadingOrder: classes
	"Can be overridden by children who need special ordering."
	^ classes! !

!Transporter methodsFor: 'saving' stamp: 'ads 12/23/2010 13:48'!
createTransportFormat
	^ self transportFormatClass new
		transporter: self;
		rootName: self package name;
		preambleBlock: self preambleBlock;
		postscriptBlock: self postscriptBlock;
		yourself! !

!Transporter methodsFor: 'saving' stamp: 'sm 7/8/2011 23:13'!
save
	self willAllChangesInCurrentChangeSetBeSaved ifFalse: [
		(PopUpMenu confirm: 'There are changes in the current changeset that will not be saved.' trueChoice: 'Save anyway!!' falseChoice: 'Cancel the save, show me what''s changed') ifFalse: [
			ChangeSorter new showChangeSet: ChangeSet current; open.
			^ self.
		].
	].
	self createTransportFormat savePackage: self package.
	self saveSubTransporters.! !

!Transporter methodsFor: 'saving' stamp: 'sm 7/8/2011 23:13'!
saveNoPopup
	self willAllChangesInCurrentChangeSetBeSaved ifFalse: [
		Transcript show: 'Not all changes in current ChangeSet will be saved'; cr.
	].
	self createTransportFormat savePackage: self package.
	self saveSubTransporters.! !

!Transporter methodsFor: 'saving' stamp: 'sm 7/8/2011 23:15'!
saveSubTransporters
	subTransporters ifNotNil: [
		subTransporters do: [:trsp | trsp saveNoPopup ]].! !

!Transporter methodsFor: 'changes' stamp: 'ads 1/26/2011 14:23'!
willAllChangesInCurrentChangeSetBeSaved
	^ ChangeSet current changedPackages allSatisfy: [:p | self package includesPackage: p]! !

!Transporter methodsFor: 'searching' stamp: 'ads 12/10/2010 12:12'!
findMethodsWrittenByThisTeamButNotIncludedInPackage
	^ self team findMethodsWrittenByThisTeamButNotIncludedInPackage: self package, (PackageInfo named: 'Transporter')! !

!Transporter class methodsFor: 'as yet unclassified' stamp: 'sm 3/10/2011 17:43'!
findAllMethodChangedByTeamButNotTransported
	"Transporter findAllMethodChangedByTeamButNotTransported"
	
	"Find all changes in the system that were done by a team member 
	 but are not yet included in any of the Transporter packages/definitions"
	| transportersByName teams packages changedMethods systemCats tricky |
	transportersByName := self getAllTransporters.

	"next: get all teams and categories"
	teams := OrderedCollection new.
	systemCats := OrderedCollection new.
	packages := nil.
	transportersByName valuesDo: [:trns | 
		trns team ifNotNil: [teams add: (trns team)].
		systemCats addAll: trns package systemCategories.
		
		packages 
			ifNil: [packages := trns package.]
			ifNotNil: [packages := packages, trns package.]
	].

	tricky := self constructTrickySet.
	
	changedMethods := Set new.
	((Smalltalk 
		allClasses reject: [:cls | systemCats includes: cls category]) 
			gather: [:cls| {cls. cls class}]) 
		do: [:cls |
			cls organization allMethodSelectors do: [:sel | 
				| mr crs |
				mr := MethodReference new setStandardClass: cls methodSymbol: sel.
				crs := mr changeRecords.
				crs isEmpty ifFalse: [
					teams do: [:team |
						(team didProjectMemberCreateChangeRecord: crs first) ifTrue: [
							(packages isYourClassExtension: mr category) ifFalse: [
								(tricky includes: (((cls name asString), '>>', sel asString) asSymbol)) ifFalse: [
									changedMethods add: mr.
								].
							].
						].
					].
				].
			].
		].
	^ changedMethods asArray! !

!Transporter class methodsFor: 'as yet unclassified' stamp: 'ads 1/26/2011 13:26'!
nonCategoryBasedPackages
	"Not sure what would be the right way to do this. -- Adam, Jan. 2011"
	^ PackageWhoseContentsMustBeTransportedInOrder allSubclasses collect: [:c | c new]! !

!Transporter class methodsFor: 'private' stamp: 'sm 3/10/2011 16:54'!
classAndOrMethodAsUniqueSymbole: anArray
	anArray size = 1 
		ifTrue:  [^ (anArray at: 1) asSymbol ]
		ifFalse: [^  ((anArray at: 1), '>>', (anArray at: 2)) asSymbol ].! !

!Transporter class methodsFor: 'private' stamp: 'sm 3/10/2011 17:31'!
constructTrickySet
	"Transporter constructTrickySet"
	"Creates a set with symboles for all tricky elements"
	| result |
	
	result := Set new. 
	
	self getAllTrickyDefinitions do: [:def |
		| uniqueSymbol |
		uniqueSymbol := self classAndOrMethodAsUniqueSymbole: def.
		(result includes: uniqueSymbol) ifTrue: [Transcript show: 'Multiple includes of ', uniqueSymbol asString.].
		result add: uniqueSymbol.
	].

	^ result! !

!Transporter class methodsFor: 'private' stamp: 'sm 3/10/2011 16:49'!
constructTrickySet: transportersByName
	"Creates a set with symboles for all tricky elements"
	| result |
	
	result := Set new. 
	
	transportersByName valuesDo: [:trans |
		trans trickyModificationsThatNeedToBeDoneInOrder do: [:trickyElem |
			result add: (self classAndOrMethodAsUniqueSymbole: trickyElem )
		].
	].! !

!Transporter class methodsFor: 'transporter' stamp: 'StefanMarr 7/14/2011 13:11'!
fileOutPackage: aPackageName
	(Transporter forPackage: (PackageInfo named: aPackageName)) saveNoPopup.! !

!Transporter class methodsFor: 'transporter' stamp: 'ads 12/14/2010 12:26'!
forEntireImage
	^ self forPackage: CompositePackageInfo forEntireImage! !

!Transporter class methodsFor: 'transporter' stamp: 'ads 12/14/2010 12:25'!
forPackage: p
	^ self new
		package: p;
		yourself! !

!Transporter class methodsFor: 'transporter' stamp: 'sm 3/10/2011 15:34'!
getAllTransporters
	"Identify all transporters based on #transportersForFileOutMenu"
	| transportersByName |
	transportersByName _ Dictionary new.
	Smalltalk allClassesDo: [:class |
		(class respondsTo: #transportersForFileOutMenu) ifTrue: [
			class transportersForFileOutMenu do: [:transporter |
				transportersByName at: transporter package name put: transporter.
			].
		].
	].
	^ transportersByName.! !

!Transporter class methodsFor: 'transporter' stamp: 'sm 4/22/2011 00:06'!
getAllTrickyDefinitions
	"Transporter getAllTrickyDefinitions"
	"Identify all tricky definitions based on #trickyModificationsThatNeedToBeDoneInOrder"
	| tricky |
	tricky _ OrderedCollection new.
	Smalltalk allClassesDo: [:class |
		(class canUnderstand: #trickyModificationsThatNeedToBeDoneInOrder) ifTrue: [
			| modifications |
			modifications := class new trickyModificationsThatNeedToBeDoneInOrder.
			modifications ifNotNil: [
				tricky addAll: modifications.
			].
		].
	].
	^ tricky.! !

!Transporter class methodsFor: 'transporter' stamp: 'sm 5/24/2011 23:27'!
loadPackage: aPackageName
	"This is a convenience method to not require to remember how to file in stuff.
	 It just uses the package name and the implemented convention to guess the file and load it."
	
	| stream chgSetName aNewChangeSet cls |
	stream := FileStream fileNamed: aPackageName, '/', aPackageName,'.st'.
	chgSetName := ChangeSet uniqueNameLike: stream localName sansPeriodSuffix.
	
	cls := (ChangeSet respondsTo: #newChangesFromStream:named:) ifTrue: [ChangeSet] ifFalse: [ChangeSorter].
	
	aNewChangeSet := cls	newChangesFromStream: stream
						named: chgSetName.
		
	aNewChangeSet
		ifNotNil: [ChangeSorter open model showChangeSet: aNewChangeSet]! !

!Transporter class methodsFor: 'transporter' stamp: 'ads 1/3/2011 17:41'!
transportersForFileOutMenu
	^ {
		Transporter forPackage: (PackageInfo named: 'Transporter')
	}! !

!True methodsFor: 'debugging' stamp: 'ssa 3/11/2010 11:54'!
haltIfTrue

	self halt! !

!True class methodsFor: '*RVM-Archiving'!
dearchiveFrom: aStream

	aStream storeObject: true.
	^true! !

!UndefinedObject methodsFor: '*RVM-Archiving'!
archiveOn: aStream
	aStream
		storeClass: self class! !

!UndefinedObject class methodsFor: 'instance creation'!
dearchiveFrom: aStream
	^nil! !

!UnhandledError methodsFor: 'priv handling' stamp: 'dmu 11/25/2008 00:25'!
devDefaultAction

	Processor thisProcess
		debug: exception signalerContext
		title: exception description! !

!UpdateImage class methodsFor: 'script entry'!
run: args
	"The loading needs to be done after everything in startup has been done.
	 Otherwise the snaphost routine gets confused.
	 Thus, we do that ourselfs."
		
	ScriptStarter quitVMAfterScriptExecution: false.

	self fileInAllRenaissanceCode.
	
	ScriptStarter quitVMAfterScriptExecution: false.
! !

!UpdateImage class methodsFor: 'fileIn script'!
fileInAllRenaissanceCode
	"Create an up-to-date image"
	Transcript show: 'Save as updated.image.'; cr.
	
	SmalltalkImage current saveAs: 'updated-tmp.image'.

	Transcript show: 'File in code.'; cr.
	(FileStream readOnlyFileNamed: 'FileInAllRenaissanceCode.st') fileIn.
	
	Transcript show: 'Done filing in code. Now Save and Quit.'; cr.

	SmalltalkImage current saveAs: 'updated.image'.	
	SmalltalkImage current closeSourceFiles.
	Smalltalk snapshot: true andQuit: true.! !

!Utilities class methodsFor: 'miscellaneous' stamp: 'ssa 1/21/2010 12:17'!
exploreViewFromUser
	ScheduledControllers screenController exploreViewFromUser! !

!Utilities class methodsFor: 'user interface' stamp: 'ssa 9/3/2008 11:13'!
informUserDuring: aBlock
	"Display a message above (or below if insufficient room) the cursor during execution of the given block."
	"Utilities informUserDuring:[:bar|
		#(one two three) do:[:info|
			bar value: info.
			(Delay forSeconds: 1) wait]]"
	aBlock value:[:string| Transcript cr; show: string]! !

!Utilities class methodsFor: 'finding pointers' stamp: 'ar 7/16/2005 19:56'!
pointersTo: anObject
	"Find all occurrences in the system of pointers to the argument anObject."
	"(Utilities pointersTo: Browser) inspect."
	^ self pointersTo: anObject except: #()
! !

!Utilities class methodsFor: 'finding pointers' stamp: 'dmu 3/23/2010 12:31'!
pointersTo: anObject except: objectsToExclude 
	"Find all occurrences in the system of pointers to the argument
	anObject. Remove objects in the exclusion list from the
	results. "
	| results anObj |
	Transcript cr; show: 'Calling garbageCollect from pointersTo:except:'.
	Smalltalk garbageCollect.
	"big collection shouldn't grow, so it's contents array is always the same"
	results := OrderedCollection new: 1000.
	"allObjectsDo: is expanded inline to keep spurious
	method and block contexts out of the results"
	anObj := self someObject.
	[0 == anObj] whileFalse: [
		anObj isInMemory ifTrue: [
			(anObj pointsTo: anObject) ifTrue: [
				"exclude the results collector and contexts in call chain"
				(anObj ~~ results collector 
					and: [anObj ~~ objectsToExclude
					and: [anObj ~~ thisContext
					and: [anObj ~~ thisContext sender
					and: [anObj ~~ thisContext sender sender]]]])
						ifTrue: [results add: anObj]]].
		anObj := anObj nextObject].
	objectsToExclude do: [:obj | results removeAllSuchThat: [:el | el == obj]].
	^ results asArray! !

!Utilities class methodsFor: 'finding pointers' stamp: 'ar 7/16/2005 19:56'!
pointersToItem: index of: anArray
	"Find all occurrences in the system of pointers to the given element of the given array. This is useful for tracing up a pointer chain from an inspector on the results of a previous call of pointersTo:. To find out who points to the second element of the results, one would evaluate:

	Utilities pointersToItem: 2 of: self

in the inspector."
	^ self pointersTo: (anArray at: index) except: (Array with: anArray)! !

!VersionsBrowser methodsFor: 'init & update' stamp: 'dmu 9/7/2010 14:26'!
scanVersionsOf: method class: class meta: meta category: category selector: selector
	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp |
	selectorOfMethod _ selector.
	currentCompiledMethod _ method.
	classOfMethod _ meta ifTrue: [class class] ifFalse: [class].
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	self addedChangeRecord ifNotNilDo: [ :change |
		self addItem: change text: ('{1} (in {2})' translated format: { change stamp. change fileName }) ].
	listIndex _ 0.
	position _ method filePosition.
	sourceFilesCopy _ SourceFiles collect:
		[:x | x isNil ifTrue: [ nil ]
				ifFalse: [x readOnlyCopy]].
	method fileIndex == 0 ifTrue: [^ nil].
	file _ sourceFilesCopy at: method fileIndex.
	[position notNil & file notNil]
		whileTrue:
		[file position: (0 max: position-150).  "Skip back to before the preamble"
		[file position < (position-1)]  "then pick it up from the front"
			whileTrue: [preamble _ file nextChunk].

		"Preamble is likely a linked method preamble, if we're in
			a changes file (not the sources file).  Try to parse it
			for prior source position and file index"
		prevPos _ nil.
		stamp _ ''.
		(preamble findString: 'methodsFor:' startingAt: 1) > 0
			ifTrue: [tokens _ Scanner new scanTokens: preamble]
			ifFalse: [tokens _ Array new  "ie cant be back ref"].
		((tokens size between: 7 and: 8)
			and: [(tokens at: tokens size-5) = #methodsFor:])
			ifTrue:
				[(tokens at: tokens size-3) = #stamp:
				ifTrue: ["New format gives change stamp and unified prior pointer"
						stamp _ tokens at: tokens size-2.
						prevPos _ tokens last.
						prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: prevPos.
						prevPos _ sourceFilesCopy filePositionFromSourcePointer: prevPos]
				ifFalse: ["Old format gives no stamp; prior pointer in two parts"
						prevPos _ tokens at: tokens size-2.
						prevFileIndex _ tokens last].
				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos _ nil]].
		((tokens size between: 5 and: 6)
			and: [(tokens at: tokens size-3) = #methodsFor:])
			ifTrue:
				[(tokens at: tokens size-1) = #stamp:
				ifTrue: ["New format gives change stamp and unified prior pointer"
						stamp _ tokens at: tokens size]].
 		self addItem:
				(ChangeRecord new file: file position: position type: #method
						class: class name category: category meta: meta stamp: stamp)
			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.
		position _ prevPos.
		prevPos notNil ifTrue:
			[file _ sourceFilesCopy at: prevFileIndex]].
	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].
	listSelections _ Array new: list size withAll: false! !

!View methodsFor: 'initialize-release' stamp: 'ssa 11/30/2009 17:50'!
setDefaultBackgroundColor

	self backgroundColor: self model defaultBackgroundColor! !

!View methodsFor: 'testing' stamp: 'ssa 1/1/1970 00:19'!
isRVMView

	^false! !

!View methodsFor: 'subView access' stamp: 'ssa 1/1/1970 12:58'!
allSubViews
	"Answer the receiver's collection of subViews and their subViews recursively."

	| all |
	all _ OrderedCollection new.
	all addAll: self subViews.
	self subViews do:[:sub| all addAll: sub allSubViews].
	^all! !

!View methodsFor: 'subView access' stamp: 'ssa 10/19/2008 00:00'!
subViewsSatisfying: aBlock
	"Return the subviews that satisfy aBlock, or #() if none does.  1/31/96 sw"

	^ subViews select: [:aView | aBlock value: aView]! !

!View methodsFor: 'lock access'!
unlock
        "Unlock the receiver and all of its subViews (see View|isUnlocked). This 
        has the effect of forcing the display transformation (see 
        View|displayTransformation) and inset display box (see 
        View|insetDisplayBox) of the receiver and all its subViews to be 
        recomputed the next time they are referenced. The locking and 
        unlocking of a View is handled automatically by the internal methods of 
        the View, but can also be done explicitly if desired."
        "Added a guard clause to protect against empty subview collections.  This is one reason why lazy initialization and consistent use of accessor methods is better than direct access.  - ssa 2/27/98 11:26"

        self isUnlocked ifTrue: [^self].
        displayTransformation _ nil.
        insetDisplayBox _ nil.
        subViews isNil ifFalse:[subViews do: [:aSubView | aSubView unlock]]! !

!View methodsFor: 'subView inserting' stamp: 'ssa 9/13/2008 16:54'!
addSubView: aSubView above: lowerView
	"Adds aView (see View|addSubView:) so that it lies above topView."
	"ssa - added a hack to allow nil lowerView"

	lowerView isNil
		ifTrue:[self addSubView: aSubView]
		ifFalse:[self addSubView: aSubView
					align: aSubView viewport bottomLeft
					with: lowerView viewport topLeft]! !

!View methodsFor: 'subView inserting' stamp: 'ssa 9/13/2008 16:55'!
addSubView: aSubView below: lowerView
	"Add the argument, aSubView, (see View|addSubView:) so that it lies 
	below the view, topView."
	"ssa - added a hack to allow nil lowerView"

	lowerView isNil
		ifTrue:[self addSubView: aSubView]
		ifFalse:[self addSubView: aSubView
					align: aSubView viewport topLeft
					with: lowerView viewport bottomLeft]! !

!View methodsFor: 'subView inserting' stamp: 'ssa 8/15/2008 17:31'!
addSubView: aView in: aRelativeRectangle borderWidth: width
	"ssa - added for compatibility."
 
	"Make 'aView' into a subview. Use 'aRelativeRectangle' and the 
	super view's window to compute (1) a viewport within the 
	superview for 'aView' and (2) the window extent for 'aView'. Note: 
	defining the windowing transformation and deriving the viewport is 
	logically equivalent but does not seem to be easily done"

	| subViewPort myWindow myExtent myOrigin |
	self addSubView: aView ifCyclic: [self error: 'cycle in subView structure.'].
	aView borderWidth: width.
	myWindow _ self window.
	myExtent _ myWindow extent.
	myOrigin _ myWindow origin.
	subViewPort _ myExtent * aRelativeRectangle origin + myOrigin 
						corner: myExtent * aRelativeRectangle corner + myOrigin.
	aView window: aView window viewport: subViewPort
! !

!View methodsFor: 'subView inserting' stamp: 'ssa 9/13/2008 16:55'!
addSubView: aSubView toLeftOf: rightView
	"Adds aView (see addSubView:) so that it lies to the right of rightView."

	"ssa - added a hack to allow nil rightView"

	rightView isNil
		ifTrue:[self addSubView: aSubView]
		ifFalse:[self addSubView: aSubView
					align: aSubView viewport topRight
					with:  rightView viewport topLeft]! !

!View methodsFor: 'subView inserting' stamp: 'ssa 9/13/2008 16:56'!
addSubView: aSubView toRightOf: leftView
	"Add the argument, aSubView, (see View|addSubView:) so that it lies to 
	the right of the view, leftView."

	"ssa - added a hack to allow nil leftView"

	leftView isNil
		ifTrue:[self addSubView: aSubView]
		ifFalse:[self addSubView: aSubView
					align: aSubView viewport topLeft
					with: leftView viewport topRight]! !

!View methodsFor: 'miscellaneous' stamp: 'ssa 10/8/2008 17:54'!
stretchFrame: newFrameBlock startingWith: startFrame 
	"Track the outline of a newFrame as long as mouse drags it.
	Maintain max and min constraints throughout the drag"
	| frame newFrame click delay |
	delay _ Delay forMilliseconds: 10.
	frame _ startFrame origin extent: ((startFrame extent min: self maximumSize)
											max: self minimumSize).
	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.
	click _ false.
	[click and: [Sensor noButtonPressed]] whileFalse: 
		["delay wait."
		click _ click | Sensor anyButtonPressed.
		newFrame _ newFrameBlock value: frame.
		newFrame _ newFrame topLeft extent: ((newFrame extent min: self maximumSize)
											max: self minimumSize).
		newFrame = frame ifFalse:
			[Display border: frame width: 2 rule: Form reverse fillColor: Color gray.
			Display border: newFrame width: 2 rule: Form reverse fillColor: Color gray.
			frame _ newFrame]].
	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.
	^ frame! !

!View methodsFor: 'demonstrating' stamp: 'ssa 11/27/2008 10:05'!
demo
	"Add me to a system view and open me on the desktop"
	self demoSized: self minimumSize! !

!View methodsFor: 'demonstrating' stamp: 'ssa 11/27/2008 10:05'!
demoSized: anExtent
	"Add me to a system view and open me on the desktop"
	| topView  |
	topView := StandardSystemView new.
	topView borderWidth:1.
	topView minimumSize: anExtent.
	topView addSubView: self .
	topView label: self class name,' demo'.
	topView controller open! !

!View methodsFor: 'accessing' stamp: 'ssa 3/12/2010 10:12'!
borderColor
	"Answer the value of borderColor"

	borderColor isNil ifTrue:[self borderColor: self foregroundColor].
	^ borderColor! !

!View methodsFor: 'accessing' stamp: 'ssa 3/12/2010 10:12'!
borderColor: anObject
	"Set the value of borderColor"

	borderColor _ anObject! !

!View methodsFor: 'accessing' stamp: 'ssa 3/12/2010 10:12'!
boundingBox: anObject
	"Set the value of boundingBox"

	boundingBox _ anObject! !

!View methodsFor: 'accessing' stamp: 'ssa 3/12/2010 10:12'!
displayTransformation: anObject
	"Set the value of displayTransformation"

	displayTransformation _ anObject! !

!View methodsFor: 'accessing' stamp: 'ssa 3/12/2010 10:12'!
insetDisplayBox: anObject
	"Set the value of insetDisplayBox"

	insetDisplayBox _ anObject! !

!View methodsFor: 'accessing' stamp: 'ssa 3/12/2010 10:12'!
insideColor
	"Answer the value of insideColor"

	insideColor isNil ifTrue:[self insideColor: nil].
	^ insideColor! !

!View methodsFor: 'accessing' stamp: 'ssa 3/12/2010 10:12'!
subViews: anObject
	"Set the value of subViews"

	subViews _ anObject! !

!View methodsFor: 'accessing' stamp: 'ssa 3/12/2010 10:12'!
viewport: anObject
	"Set the value of viewport"

	viewport _ anObject! !

!View methodsFor: '*Ly experiments' stamp: 'ssa 3/12/2010 17:52'!
moveBy: delta
	"Move me delta left  in my superView"
	| scaledDelta |
	scaledDelta _ self viewport width / self insetDisplayBox width * delta.
	self transformUsing:[:ovp| ovp moveBy: scaledDelta]! !

!View methodsFor: '*Ly experiments' stamp: 'ssa 3/12/2010 17:54'!
moveDown
	"Move me 10 pixels down  in my superView"
	self moveBy:(0@10)! !

!View methodsFor: '*Ly experiments' stamp: 'ssa 3/12/2010 16:50'!
moveFrom: oldBox
	"Move me to ensure I refect my window/viewport"

	self uncacheBits.
	self displayEmphasized.
	self moved.  "In case its model wishes to take note."
	(oldBox areasOutside: self windowBox) do:
		[:rect | ScheduledControllers restore: rect]! !

!View methodsFor: '*Ly experiments' stamp: 'ssa 3/12/2010 17:54'!
moveLeft
	"Move me 10 pixels left  in my superView"
	self moveBy:(-10@0)! !

!View methodsFor: '*Ly experiments' stamp: 'ssa 3/12/2010 17:54'!
moveRight
	"Move me 10 pixels right  in my superView"
	self moveBy:(10@0)! !

!View methodsFor: '*Ly experiments' stamp: 'ssa 3/12/2010 17:54'!
moveUp
	"Move me 10 pixels up  in my superView"
	self moveBy:(0 @ -10)! !

!View methodsFor: '*Ly experiments' stamp: 'ssa 3/12/2010 16:55'!
narrower
	"Make me 5% narrower in my superView"
	self transformUsing:[:ovp| ovp expandBy:(ovp width*0.05)negated@0]! !

!View methodsFor: '*Ly experiments' stamp: 'ssa 3/12/2010 16:57'!
shorter
	"Make me 5% shorter in my superView"
	self transformUsing:[:ovp| ovp expandBy:0@(ovp height*0.05)negated]! !

!View methodsFor: '*Ly experiments' stamp: 'ssa 3/12/2010 16:57'!
taller
	"Make me 5% taller in my superView"
	self transformUsing:[:ovp| ovp expandBy:0@(ovp height*0.05)]! !

!View methodsFor: '*Ly experiments' stamp: 'ssa 3/12/2010 17:43'!
transformUsing: aBlock
	"self transformUsing: [:oldViewport |  ...return new viewport... ]  "
	"Change my viewport and update me on the display"
	| ovp nvp ow |
	ovp _ self viewport.
	ow _ self getWindow.
	nvp _ aBlock value:ovp.
	self window: self window viewport: nvp.
	self moveFrom: ow.
	self unlock.! !

!View methodsFor: '*Ly experiments' stamp: 'ssa 3/12/2010 16:55'!
wider
	"Make me 5% wider in my superView"
	self transformUsing:[:ovp| ovp expandBy:(ovp width*0.05)@0]! !

!View methodsFor: '*Interface-MSWLook'!
percentContentVisible
        "Answer the percent of my content that is visible.  ssa 12/5/97 15:37"

        ^self visibleContentHeight / self totalContentHeight! !

!View methodsFor: '*Interface-MSWLook'!
percentPrecedingContent
        "Answer the percent of my content that not visible since it has been scrolled of the top of the screen.  ssa 12/5/97 15:37"

        ^0.0! !

!View methodsFor: '*Interface-MSWLook'!
percentPreceedingContent
        "Answer the percent of my content that not visible since it has been scrolled of the top of the screen.  ssa 12/5/97 15:37"

        ^0.0! !

!View methodsFor: '*Interface-MSWLook'!
percentVisibleContent
        "Answer the percent of my content that is visible.  ssa 12/5/97 15:37"

        ^self totalContentHeight = 0
                ifTrue:[0.0]
                ifFalse:[self visibleContentHeight / self totalContentHeight]! !

!View methodsFor: '*Interface-MSWLook'!
totalContentHeight
        "Answer the height of my content, visible or not.  ssa 12/5/97 15:04"

        ^100 / self unitContentHeight! !

!View methodsFor: '*Interface-MSWLook'!
unitContentHeight
        "Answer the unit height of my content.  ssa 12/5/97 15:04"

        ^10.0! !

!View methodsFor: '*Interface-MSWLook'!
visibleContentHeight
        "Answer the height of my visible content.  ssa 12/5/97 15:04"

        ^100 / self unitContentHeight! !

!WeakArray class methodsFor: 'private' stamp: 'sm 2/24/2011 16:41'!
restartFinalizationProcess
	"kill any old process, just in case"
	FinalizationProcess
		ifNotNil: [FinalizationProcess terminate.
			FinalizationProcess := nil].

	"Check if Finalization is supported by this VM"
	IsFinalizationSupported := nil.
	self isFinalizationSupported
		ifFalse: [^ self].

	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.
	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].
	FinalizationLock := Semaphore forMutualExclusion.
	FinalizationProcess := [self finalizationProcess]
		forkAt: Processor userInterruptPriority.
	FinalizationProcess name: 'WeakArray Finalization'.
! !

!Workspace methodsFor: 'menu commands' stamp: 'ssa 9/3/2008 10:48'!
addModelItemsToWindowMenu: aMenu
	"Add model-related items to the supplied window menu"

	aMenu addLine.
	aMenu add: 'save contents to file...' target: self action: #saveContentsInFile.
	aMenu addLine.
! !

!WriteStream methodsFor: '*SMark-printing' stamp: 'sm 5/25/2011 14:30'!
<< aCollection
	"we want a readable version of nextPutAll however it may be difficult to fully recreate nextPutAll:
	for all the different types of stream. Rather then simply send to nextPutAll:
	we handle the String (or ByteArray) argument
	as fast as possible - the rest we delegate to putOn: This means that we handle single characters and bytes 
	whereas nextPutAll: is only for sequencable collections.
	.
	Note this may not work in every case that nextPutAll: does subject to extensive testing, 
	but it should work in the important cases"

	| newEnd |
	collection class == aCollection class ifFalse:
		[ aCollection putOn: self. ^ self ].

	newEnd := position + aCollection size.
	newEnd > writeLimit ifTrue:
		[self growTo: newEnd + 10].

	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.
	position := newEnd.

! !
----STARTUP----#(14 August 2011 7:18:54 pm) as /Users/smarr/Projects/PhD/IBM/renaissance-image.git/awards-release.image!condenseChanges		"Move all the changes onto a compacted sources file."	"Smalltalk condenseChanges!----QUIT----#(14 August 2011 7:19:37 pm) awards-release.image priorSource: 1985396!

----STARTUP----#(15 August 2011 2:33:57 pm) as /Users/smarr/Projects/PhD/IBM/github-master/vm/src/from_squeak/iOS/vm/iPhone/iPhone.image!


----QUIT----#(15 August 2011 2:34:20 pm) iPhone.image priorSource: 1985621!

----STARTUP----#(15 August 2011 2:34:28 pm) as /Users/smarr/Projects/PhD/IBM/github-master/vm/src/from_squeak/iOS/vm/iPhone/iPhone.image!


----QUIT----#(15 August 2011 2:34:50 pm) iPhone.image priorSource: 1985846!

----STARTUP----#(15 August 2011 2:42:33 pm) as /Users/smarr/Projects/PhD/IBM/github-master/vm/src/from_squeak/iOS/vm/iPhone/iPhone.image!


"To activate the VM Monitors, enable Sampling in the RVM dashboard to the left"

"Our canonical demo is a simulation of birds flying on the screen"
[Sly3Boids new run] fork.

"To stop them, deactivate Keep SlyBoids Flying in the dashboard to the left"

"A brief introduction to Sly"

"numbers and squaredNumbers are ensembles, denoted with the % sign. Sending a message to it will cause all members to evaluate the message"
numbers := Sly3Ensemble withMembersFrom: {1. 2. 3. 4. 5}.
squaredNumbers := numbers squared. "->  %{1. 4. 9. 16. 25. } "
RVMOperations coreCount!
!RVMMonitor class methodsFor: 'user interface' stamp: 'sm 8/15/2011 14:50' prior: 34661352!
dashboard
	"RVMMonitor dashboard      "   
	| topView samplingCheck turboCheck gcButton benchButton subViewCount sampleButton clearSamplesButton forgetButton shuffle56Button shuffle4Button multistripButton systemAspectsButton coreAspectsButton inspectSampleButton testAspectCheck spiderButton bytesUsedsSpiderButton delayTimingCheck recordingOptionsButton allToReadMostlyButton printAllHeapsButton printExecutionTraceButton printStackButton gridButton stripButton scanButton outlierButton locateClassesButton locatorButton locators4Button heartbeat spread56Button runningProcessesButton |
	topView := RVMStandardSystemView new  .
	topView borderWidth:1. 
	samplingCheck _ RVMCheckBoxView on: self label: 'Sampling' checkState: [self sampling] whenChecked: [self startSampling] whenUnchecked: [self stopSampling] monitor: true.
	turboCheck _ RVMCheckBoxView on: self label: 'Turbo' checkState: [self turboSampling] whenChecked: [self turboOn] whenUnchecked: [self turboOff] monitor: true.
	testAspectCheck _ RVMCheckBoxView on: self label: 'Test Aspects' checkState: [self showTestAspects] whenChecked: [self showTestAspects:true] whenUnchecked: [self showTestAspects:false] monitor: true.
	delayTimingCheck _ RVMCheckBoxView on: self label: 'Short Delay' checkState: [self delayTiming = #short] whenChecked: [self useShortDelay] whenUnchecked: [self useNormalDelay] monitor: true.
	heartbeat _ RVMCheckBoxView on: self label: 'Heartbeat' checkState: [self showHeartbeat] whenChecked: [self startHeartbeat] whenUnchecked: [self stopHeartbeat] monitor: true.
	sampleButton _ RVMButtonView label:'Take Sample' action:[RVMMonitor getSample; informListeners].
	inspectSampleButton _ RVMButtonView label:'Inspect Sample' action:[Transcript show: 'CoreCount: ', (RVMOperations coreCount) asString . RVMMonitor lastSample inspect].
	clearSamplesButton _ RVMButtonView label:'Clear Samples' action:[RVMMonitor clearSamples].
	recordingOptionsButton _ RVMButtonView label:'Recording Options' action:[RVMMonitor recordingControls].
	forgetButton _ RVMButtonView label:'Forget Listeners' action:[RVMMonitor forgetListeners].
	gcButton _ RVMButtonView label:'GC' action:[Transcript cr show:'GC: ',Smalltalk garbageCollect printString].
	spread56Button _ RVMButtonView label:'Spread 56' action:[RVMOperations spreadFrom: 0 to: 55  moveRWtoRM: true moveRMtoRW: false].
	shuffle56Button _ RVMButtonView label:'Shuffle:56' action:[RVMOperations shuffle:56].
	shuffle4Button _ RVMButtonView label:'Shuffle:4' action:[RVMOperations shuffle:4].
	allToReadMostlyButton _ RVMButtonView label:'All->readMostly' action:[RVMOperations moveAllToReadMostlyHeaps].
	printAllHeapsButton _ RVMButtonView label:'Print BytesUsed' action:[RVMOperations printAllHeapsBytesUsed].
	printExecutionTraceButton _ RVMButtonView label:'Print Trace' action:[RVMOperations printExecutionTrace].
	printStackButton _ RVMButtonView label:'Print Stack' action:[RVMOperations printStack].
	gridButton _ self relAbsButtonLabeled:'Tile Grid...' 
					relAction:[RVMTileGridView example]
					absAction:[RVMTileGridScalerView example].
	stripButton _ self relAbsButtonLabeled:'Tile Strip...' 
					relAction:[RVMTileStripChartView example]
					absAction:[RVMTileStripChartScalerView example].
	scanButton _ self relAbsButtonLabeled:'Tile Scan...' 
					relAction:[RVMScanningStripChartView example]
					absAction:[RVMAbsScanningStripChartView example].
	multistripButton _ RVMButtonView label:'Multi Strip' action:[RVMCoreAspectTrace exampleView1].
	systemAspectsButton _ RVMButtonView label:'System Aspects' action:[RVMAspectTrace monitorAllSystemAspects].
	coreAspectsButton _ RVMButtonView label:'Core Aspects' action:[RVMCoreAspectTrace monitorAllCoreAspectsForCoreFromUser].
	runningProcessesButton _  RVMButtonView label:'Running Processes' action:[RVMAspectTrace exampleView8].
		spiderButton _ RVMButtonView label:'Kiviat' action:[RVMMultiKiviatView exampleBytecodesAndProcessesRunning].
	bytesUsedsSpiderButton _ RVMButtonView label:'heap size Kiviat' action:[RVMMultiKiviatView exampleBytesUsedTrioCommonPinned].
	outlierButton _ RVMButtonView label:'Outlier...' action:[RVMMonitor outlierFromUser].
	locateClassesButton _ RVMButtonView label:'Class Locator' action:[RVMGroupLocatorView openOn: Smalltalk objectsSource:#allClasses labeled:'All Classes'].
	locatorButton _ RVMButtonView label:'Group Locator' action:[RVMGroupLocatorView openWithSourceEditorOn: nil objectsSource:[Array allInstances]].
	locators4Button _ RVMButtonView label:'4 Group Locator' action:[RVMMultiGroupLocatorView openOn: nil sources: {[String allInstances]. [Collection withAllSubclasses]. [Object withAllSubclasses]. [View allSubInstances]} colors: nil].
	benchButton _ RVMButtonView label:'testCompiler' action:[Cursor wait showWhile:[RVMExperiment testCompiler]].
	
	topView addSubView: samplingCheck.
	topView addSubView:  turboCheck below:  samplingCheck.
	topView addSubView:  testAspectCheck below:  turboCheck.
	topView addSubView:  delayTimingCheck below:  testAspectCheck.
	topView addSubView:  heartbeat below:  delayTimingCheck.
	topView addSubView:  sampleButton below:  heartbeat.
	topView addSubView:  inspectSampleButton below:  sampleButton.
	topView addSubView:  clearSamplesButton below:  inspectSampleButton.
	topView addSubView:  recordingOptionsButton below:  clearSamplesButton.
	topView addSubView:  forgetButton below:  recordingOptionsButton.
	topView addSubView:  gcButton below:  forgetButton.
	topView addSubView:  spread56Button below:  gcButton.
	topView addSubView:  shuffle56Button below:  spread56Button.
	topView addSubView:  shuffle4Button below:  shuffle56Button.
 	topView addSubView:  allToReadMostlyButton below:  shuffle4Button.
	topView addSubView:  printAllHeapsButton below:  allToReadMostlyButton.
	topView addSubView:  printExecutionTraceButton below: printAllHeapsButton.
	topView addSubView:  printStackButton below: printExecutionTraceButton.
	topView addSubView:  gridButton below: printStackButton.
	topView addSubView:  stripButton below: gridButton.
	topView addSubView:  scanButton below: stripButton.
	topView addSubView:  multistripButton below: scanButton.
	topView addSubView:  systemAspectsButton below: multistripButton.
	topView addSubView:  coreAspectsButton below: systemAspectsButton.
	topView addSubView: runningProcessesButton below: coreAspectsButton.
	topView addSubView:  spiderButton below: runningProcessesButton.
	topView addSubView:  bytesUsedsSpiderButton below: spiderButton.
	topView addSubView:  outlierButton below: bytesUsedsSpiderButton.
	topView addSubView:  locateClassesButton below: outlierButton.
	topView addSubView:  locatorButton below: locateClassesButton.
	topView addSubView:  locators4Button below: locatorButton.
	topView addSubView:  benchButton below: locators4Button.
	topView label: 'RVM'.
	RVMMonitor forgetAll: topView allSubViews.
	RVMMonitor forget: topView.
	subViewCount _ topView subViews size.
	topView minimumSize: 120@(subViewCount*27).
	topView maximumSize: topView minimumSize.
	topView controller open! !

----QUIT----#(15 August 2011 2:50:42 pm) iPhone.image priorSource: 1986063!